<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tipos de Datos Genéricos - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html" class="active"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="tipos-de-datos-genéricos"><a class="header" href="#tipos-de-datos-genéricos">Tipos de datos genéricos</a></h2>
<p>Podemos usar genéricos para crear definiciones para elementos como firmas de
funciones o estructuras, que luego podemos usar con muchos tipos de datos
concretos diferentes. Primero veamos cómo definir funciones, estructuras,
enumeraciones y métodos usando genéricos. Luego discutiremos cómo los
genéricos afectan el rendimiento del código.</p>
<h3 id="en-definiciones-de-funciones"><a class="header" href="#en-definiciones-de-funciones">En Definiciones de funciones</a></h3>
<p>Al definir una función que usa genéricos, colocamos los genéricos en la firma
de la función en la que normalmente especificamos los tipos de datos de los
parámetros y el valor de retorno. Hacerlo hace que nuestro código sea más
flexible y proporciona más funcionalidad a los llamantes de nuestra función a
la vez que evita la duplicación de código.</p>
<p>Continuando con nuestra función <code>largest</code>, el Listado 10-4 muestra dos
funciones que encuentran el valor más grande en un <em>slice</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">   assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Listado 10-4: dos funciones que difieren solo en sus
nombres y los tipos en sus firmas</span></p>
<p>La función <code>largest_i32</code> es la que extrajimos en el Listado 10-3 que
encuentra el <code>i32</code> más grande en una porción. La función <code>largest_char</code>
encuentra el <code>char</code> más grande en una porción. Los cuerpos de función tienen
el mismo código, así que eliminemos la duplicación introduciendo un parámetro
de tipo genérico en una sola función.</p>
<p>Para parametrizar los tipos en la nueva función que definiremos, necesitamos
nombrar el parámetro tipo, tal como lo hacemos para los parámetros de valor
de una función. Puede usar cualquier identificador como nombre de parámetro
de tipo. Pero usaremos <code>T</code> porque, por convención, los nombres de los
parámetros en Rust son cortos, a menudo solo una letra, y la convención de
nombres de Rust es CamelCase. Abreviatura de &quot;tipo&quot;, <code>T</code> es la opción
predeterminada de la mayoría de los programadores de Rust.</p>
<p>Cuando usamos un parámetro en el cuerpo de la función, tenemos que declarar
el nombre del parámetro en la firma para que el compilador sepa lo que
significa ese nombre. De forma similar, cuando usamos un nombre de parámetro
de tipo en una firma de función, tenemos que declarar el nombre del parámetro
de tipo antes de usarlo. Para definir la función genérica <code>largest</code>,
coloque declaraciones de nombre de tipo dentro de corchetes angulares,<code>&lt;&gt;</code>,
entre el nombre de la función y la lista de parámetros, como esta:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Leemos esta definición como: la función <code>largest</code> es genérica sobre algún
tipo <code>T</code>. Esta función tiene un parámetro llamado <code>list</code>, que es un segmento
de valores de tipo <code>T</code>. La función <code>largest</code> devolverá un valor del mismo
tipo <code>T</code>.</p>
<p>El listado 10-5 muestra la definición de función &quot;más grande&quot; combinada que
utiliza el tipo de datos genéricos en su firma. La lista también muestra cómo
podemos llamar a la función con una porción de valores <code>i32</code> o <code>char</code>. Tenga
en cuenta que este código aún no se compilará, pero lo solucionaremos más
adelante en este capítulo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listado 10-5: Una definición de la función <code>largest</code>
que usa parámetros de tipo genérico pero aún no compila</span></p>
<p>Si compilamos este código ahora, obtendremos este error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>La nota menciona <code>std::cmp::PartialOrd</code>, que es un <em>trait</em>. Hablaremos sobre
los <em>trait</em> en la siguiente sección. Por ahora, este error indica que el
cuerpo de <code>largest</code> no funcionará para todos los tipos posibles que <code>T</code>
podría ser. Como queremos comparar valores del tipo <code>T</code> en el cuerpo, solo
podemos usar tipos cuyos valores se puedan ordenar. Para permitir las
comparaciones, la biblioteca estándar tiene el <em>trait</em> <code>std::cmp::PartialOrd</code>
que puede implementar en los tipos (consulte el Apéndice C para obtener más
información sobre este <em>trait</em>). Aprenderá cómo especificar que un tipo
genérico tiene un <em>trait</em> particular en la sección “Límites de
características”, pero primero exploremos otras maneras de usar parámetros
genéricos de tipo.</p>
<h3 id="en-las-definiciones-de-struct"><a class="header" href="#en-las-definiciones-de-struct">En las definiciones de <em>Struct</em></a></h3>
<p>También podemos definir estructuras para usar un parámetro de tipo genérico
en uno o más campos usando la sintaxis <code>&lt;&gt;</code>. El Listado 10-6 muestra cómo
definir una estructura <code>Point &lt;T&gt;</code> para contener valores de coordenadas <code>x</code>
y <code>y</code> de cualquier tipo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: Una estructura <code>Point &lt;T&gt;</code> que contiene los valores <code>x</code> y <code>y</code> de tipo <code>T</code></span></p>
<p>La sintaxis para usar genéricos en las definiciones de estructuras es similar a la utilizada en las definiciones de funciones. Primero, declaramos el nombre del parámetro tipo dentro de corchetes angulares justo después del nombre de la estructura. Entonces podemos usar el tipo genérico en la definición de estructura donde especificaríamos tipos de datos concretos.</p>
<p>Tenga en cuenta que debido a que hemos usado solo un tipo genérico para definir <code>Point &lt;T&gt;</code>, esta definición dice que la estructura <code>Point &lt;T&gt;</code> es genérica sobre algún tipo <code>T</code>, y los campos <code>x</code> y <code>y</code> son <em>ambos</em> del mismo tipo, cualquiera que sea ese tipo. Si creamos una instancia de un <code>Punto &lt;T&gt;</code> que tiene valores de diferentes tipos, como en el Listado 10-7, nuestro código no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listado 10-7: Los campos <code>x</code> y <code>y</code> deben ser del mismo
tipo porque ambos tienen el mismo tipo de datos genéricos <code>T</code>.</span></p>
<p>En este ejemplo, cuando asignamos el valor entero 5 a <code>x</code>, dejamos que el
compilador sepa que el tipo genérico <code>T</code> será un entero para esta instancia
de <code>Point &lt;T&gt;</code>. Luego, cuando especifiquemos 4.0 para <code>y</code>, que hemos definido
para que tenga el mismo tipo que <code>x</code>, obtendremos un error de desajuste de
tipo como este:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p>Para definir una estructura <code>Point</code> donde <code>x</code> y <code>y</code> son ambos genéricos pero
podrían tener diferentes tipos, podemos usar múltiples parámetros genéricos
de tipo. Por ejemplo, en el listado 10-8, podemos cambiar la definición de
<code>Point</code> para que sea genérica sobre los tipos<code> T</code> y <code>U</code> donde <code>x</code> es de tipo
<code>T</code> y <code>y</code> es de tipo <code>U</code> .</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listado 10-8: Un <code>Point &lt;T, U&gt;</code> genérico sobre dos
tipos para que <code>x</code> y <code>y</code> puedan ser valores de diferentes tipos</span></p>
<p>¡Ahora todas las instancias de <code>Point</code> se muestran permitidas! Puede usar
tantos parámetros de tipo genérico como desee en una definición, pero usar
más de unos pocos hace que su código sea difícil de leer. Cuando necesite
muchos tipos genéricos en su código, podría indicar que su código necesita
una reestructuración en piezas más pequeñas.</p>
<h3 id="en-enum-definiciones"><a class="header" href="#en-enum-definiciones">En Enum Definiciones</a></h3>
<p>Como hicimos con las estructuras, podemos definir las enumeraciones para
mantener los tipos de datos genéricos en sus variantes. Echemos otro vistazo
a la enumeración <code>Opción &lt;T&gt;</code> que proporciona la biblioteca estándar, que
usamos en el Capítulo 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta definición ahora debería tener más sentido para usted. Como puede ver,
<code>Option &lt;T&gt;</code> es una enumeración que es genérica sobre el tipo <code>T</code> y tiene dos
variantes: <code>Some</code>, que contiene un valor de tipo <code>T</code>, y una <code>None</code> variante
que no tiene ningún valor. Al utilizar la enumeración <code>Opción &lt;T&gt;</code>, podemos
expresar el concepto abstracto de tener un valor opcional, y como
<code>Opción &lt;T&gt;</code> es genérico, podemos usar esta abstracción sin importar el tipo
de valor opcional.</p>
<p>Los <em>enums</em> también pueden usar múltiples tipos genéricos. La definición de
la enumeración <code>Result</code> que utilizamos en el Capítulo 9 es un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>La enumeración <code>Result</code> es genérica sobre dos tipos, <code>T</code> y <code>E</code>, y tiene dos
variantes: <code>Ok</code>, que contiene un valor de tipo <code>T</code>, y <code>Err</code>, que contiene un
valor de tipo <code>E</code>. Esta definición hace que sea conveniente usar la
enumeración <code>Result</code> en cualquier lugar donde tengamos una operación que
pueda tener éxito (devuelva un valor de algún tipo <code>T</code>) o que falle
(devuelva un error de algún tipo <code>E</code>). De hecho, esto es lo que usamos para
abrir un archivo en el Listado 9-3, donde <code>T</code> se completó con el tipo
<code>std::fs::File</code> cuando el archivo se abrió correctamente y <code>E</code> se completó
con el tipo <code>std::io::Error</code> cuando hubo problemas al abrir el archivo.</p>
<p>Cuando reconoce situaciones en su código con múltiples definiciones <em>struct</em>
o <em>enum</em> que difieren solo en los tipos de los valores que contienen, puede
evitar la duplicación mediante el uso de tipos genéricos.</p>
<h3 id="en-definiciones-de-métodos"><a class="header" href="#en-definiciones-de-métodos">En definiciones de métodos</a></h3>
<p>Podemos implementar métodos en estructuras y enumeraciones (como lo hicimos
en el Capítulo 5) y también usar tipos genéricos en sus definiciones. El
Listado 10-9 muestra la estructura <code>Point &lt;T&gt;</code> que definimos en el Listado
10-6 con un método llamado <code>x</code> implementado en él.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listado 10-9: Implementando un método llamado <code>x</code> en la
estructura <code>Point &lt;T&gt;</code> que devolverá una referencia al campo <code>x</code> de tipo
<code>T</code></span></p>
<p>Aquí, hemos definido un método llamado <code>x</code> en <code>Point &lt;T&gt;</code> que devuelve una
referencia a los datos en el campo <code>x</code>.</p>
<p>Tenga en cuenta que tenemos que declarar <code>T</code> justo después de <code>impl</code> para que
podamos usarlo para especificar que estamos implementando métodos en el tipo
<code>Point &lt;T&gt;</code>. Al declarar <code>T</code> como un tipo genérico después de <code>impl</code>, Rust
puede identificar que el tipo en los paréntesis angulares en <code>Point</code> es un
tipo genérico en lugar de un tipo concreto.</p>
<p>Podríamos, por ejemplo, implementar métodos solo en instancias <code>Point &lt;f32&gt;</code>
en lugar de en instancias <code>Point &lt;T&gt;</code> con cualquier tipo genérico. En el
listado 10-10 usamos el tipo concreto <code>f32</code>, lo que significa que no
declaramos ningún tipo después de <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-10: Un bloque <code>impl</code> que solo se aplica a
una estructura con un tipo concreto para el parámetro de tipo
genérico <code>T</code></span></p>
<p>Este código significa que el tipo <code>Point &lt;f32&gt;</code> tendrá un método llamado
<code>distance_from_origin</code> y otras instancias de <code>Point &lt;T&gt;</code> donde <code>T</code> no es del
tipo <code>f32</code> no tendrá este método definido. El método mide qué tan lejos está
nuestro punto del punto en coordenadas (0.0, 0.0) y utiliza operaciones
matemáticas que están disponibles solo para tipos de coma flotante.</p>
<p>Los parámetros de tipo genérico en una definición de estructura no son
siempre los mismos que los que usa en las firmas de métodos de esa
estructura. Por ejemplo, el Listado 10-11 define el método <code>mixup</code> en la
estructura <code>Point &lt;T, U&gt;</code> del Listado 10-8. El método toma otro <code>Point</code> como
parámetro, que puede tener diferentes tipos que el <code>self</code> <code>Point</code> al que
llamamos <code>mixup</code>. El método crea una nueva instancia <code>Point</code> con el valor <code>x</code>
del <code>self</code> <code>Point</code> (de tipo <code>T</code>) y el valor <code>y</code> del <code>Point</code> pasado (de tipo <code>W</code>)</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listado 10-11: un método que usa diferentes tipos
genéricos que la definición de su estructura</span></p>
<p>En <code>main</code>, hemos definido un <code>Point</code> que tiene un <code>i32</code> para <code>x</code> (con valor
<code>5</code>) y un <code>f64</code> para <code>y</code> (con valor <code>10.4</code>). La variable <code>p2</code> es una
estructura <code>Point</code> que tiene un <em>string slice</em> para <code>x</code> (con valor <code>&quot;Hello&quot;</code>)
y <code>char</code> para <code>y</code> (con valor <code>c</code>). Llamar <code>mixup</code> en <code>p1</code> con el argumento
<code>p2</code> nos da <code>p3</code>, que tendrá un <code>i32</code> para <code>x</code>, porque <code>x</code> viene de <code>p1</code>. La
variable <code>p3</code> tendrá un <code>char</code> para <code>y</code>, porque <code>y</code> viene de <code>p2</code>. La llamada
a la macro <code>println!</code> Imprimirá <code>p3.x = 5, p3.y = c</code>.</p>
<p>El propósito de este ejemplo es demostrar una situación en la que algunos
parámetros genéricos se declaran con <code>impl</code> y algunos se declaran con la
definición del método. Aquí, los parámetros genéricos <code>T</code> y <code>U</code> se declaran
después de <code>impl</code>, porque van con la definición de estructura. Los parámetros
genéricos <code>V</code> y <code>W</code> se declaran después de <code>fn mixup</code>, porque solo son
relevantes para el método.</p>
<h3 id="rendimiento-del-código-usando-genéricos"><a class="header" href="#rendimiento-del-código-usando-genéricos">Rendimiento del código usando genéricos</a></h3>
<p>Es posible que se pregunte si hay un costo de tiempo de ejecución cuando usa
parámetros de tipo genérico. La buena noticia es que Rust implementa los
genéricos de tal manera que su código no se ralentiza con los tipos genéricos
más que con los tipos concretos.</p>
<p>Rust logra esto realizando la monomorfización del código que usa genéricos en
tiempo de compilación. <em>Monomorphization</em> es el proceso de convertir código
genérico en código específico completando los tipos concretos que se utilizan
cuando se compilan.</p>
<p>En este proceso, el compilador hace lo contrario de los pasos que usamos para
crear la función genérica en el Listado 10-5: el compilador observa todos los
lugares donde se llama el código genérico y genera código para los tipos
concretos con los que se llama el código genérico.</p>
<p>Veamos cómo funciona esto con un ejemplo que usa la enumeración <code>Option &lt;T&gt;</code>
de la biblioteca estándar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Cuando Rust compila este código, realiza la monomorfización. Durante ese
proceso, el compilador lee los valores que se han utilizado en las instancias
<code>Option &lt;T&gt;</code> e identifica dos tipos de <code>Option &lt;T&gt;</code>: uno es <code>i32</code> y el otro
es <code>f64</code>. Como tal, expande la definición genérica de <code>Opción &lt;T&gt;</code> en
<code>Opción_i32</code> y <code>Opción_f64</code>, reemplazando así la definición genérica por las
específicas.</p>
<p>La versión monomorfizada del código tiene el siguiente aspecto. La
<code>Opción &lt;T&gt;</code> genérica se reemplaza por las definiciones específicas creadas
por el compilador:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Debido a que Rust compila código genérico en código que especifica el tipo en
cada instancia, no pagamos costo de tiempo de ejecución por el uso de
genéricos. Cuando el código se ejecuta, funciona igual que si hubiéramos
duplicado cada definición a mano. El proceso de monomorfización hace que los
genéricos de Rust sean extremadamente eficientes en tiempo de ejecución.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
