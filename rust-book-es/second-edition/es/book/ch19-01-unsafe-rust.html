<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust en Modo Inseguro - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html" class="active"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Funciones Avanzadas y Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Pakabras Clave</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Características más Recientes</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="unsafe-inseguro-rust"><a class="header" href="#unsafe-inseguro-rust"><em>Unsafe</em> (<em>inseguro</em>) Rust</a></h2>
<p>Todo el código que hemos discutido hasta ahora ha tenido las garantías de
seguridad de la memoria de Rust aplicadas en tiempo de compilación. Sin
embargo, Rust tiene un segundo lenguaje oculto dentro que no impone estas
garantías de seguridad de la memoria: se llama <em>Rust inseguro</em>
(<em>unsafe Rust</em>) y funciona igual que el Rust normal, pero nos da superpoderes
adicionales.</p>
<p>Rust inseguro existe porque, por naturaleza, el análisis estático es
conservador. Cuando el compilador intenta determinar si el código mantiene o
no las garantías, es mejor que rechace algunos programas válidos en lugar de
aceptar algunos programas no válidos. Aunque el código podría estar bien, por
lo que Rust puede decir, ¡no lo es!. En estos casos, puede usar un código
inseguro para decirle al compilador: “Créame, sé lo que estoy haciendo”. Lo
malo es que lo usa bajo su propio riesgo: si utiliza el código inseguro
incorrectamente, pueden ocurrir problemas debido a la inseguridad de la
memoria, como la desreferenciación de punteros nulos.</p>
<p>Otra razón por la que Rust tiene un alter ego inseguro es que el hardware
subyacente de la computadora es inherentemente inseguro. Si Rust no le
permitió hacer operaciones inseguras, no podría hacer ciertas tareas. Rust
debe permitirle realizar una programación de sistemas de bajo nivel, como
interactuar directamente con el sistema operativo o incluso escribir su
propio sistema operativo. Trabajar con sistemas de programación de bajo nivel
es uno de los objetivos del lenguaje. Exploremos qué podemos hacer con Rust
inseguro y cómo hacerlo.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>Para cambiar a Rust inseguro, use la palabra clave <code>unsafe</code> y luego comience
un nuevo bloque que contenga el código inseguro. Puedes tomar cuatro acciones
en Rust inseguro, llamadas <em>unsafe superpowers</em>, que no puedes usar en Rust seguro. Esos <em>Superpowers</em> incluyen la capacidad de:</p>
<ul>
<li>Desreferenciar un <em>raw pointer</em></li>
<li>Llamar a una función o método inseguro</li>
<li>Accede o modifica una variable estática mutable</li>
<li>Implementar un <em>trait</em> inseguro</li>
</ul>
<p>Es importante comprender que <code>unsafe</code> no apaga el comprobador de préstamos ni
desactiva ninguna otra de las verificaciones de seguridad de Rust: si utiliza
una referencia en un código inseguro, seguirá siendo revisado. La palabra
clave <code>unsafe</code> solo le da acceso a estas cuatro características que el
compilador no verifica para la seguridad de la memoria. Todavía obtendrá un
cierto grado de seguridad dentro de un bloque inseguro.</p>
<p>Además, <code>unsafe</code> no significa que el código dentro del bloque sea
necesariamente peligroso o que definitivamente tenga problemas de seguridad
en la memoria: la intención es que, como programador, se asegure de que el
código dentro de un bloque <code>unsafe</code> acceda a la memoria de una manera válida.</p>
<p>Las personas son falibles y se producirán errores, pero al requerir que estas
cuatro operaciones inseguras estén dentro de bloques anotados con <code>unsafe</code>,
sabrá que cualquier error relacionado con la seguridad de la memoria debe
estar dentro de un bloque <code>unsafe</code>. Mantenga los bloques <code>unsafe</code> pequeños;
Estarás agradecido más tarde cuando investigue errores de memoria.</p>
<p>Para aislar el código inseguro tanto como sea posible, es mejor incluir el
código no seguro dentro de una abstracción segura y proporcionar una API
segura, que veremos más adelante en el capítulo cuando examinemos funciones y
métodos inseguros. Partes de la biblioteca estándar se implementan como
abstracciones seguras sobre el código inseguro que se ha auditado. Envolver
el código no seguro en una abstracción segura evita que los usos de
<code>unsafe</code> se filtren en todos los lugares donde usted o sus usuarios puedan
querer usar la funcionalidad implementada con el código <code>unsafe</code>, porque usar
una abstracción segura es seguro.</p>
<p>Miremos cada una de las cuatro <em>superpowers unsafe</em> a su vez. También veremos
algunas abstracciones que proporcionan una interfaz segura para el código
inseguro.</p>
<h3 id="desreferenciar-un-raw-pointer"><a class="header" href="#desreferenciar-un-raw-pointer">Desreferenciar un <em>Raw Pointer</em></a></h3>
<p>En el Capítulo 4, en la sección “<em>Dangling</em> que cuelgan”, mencionamos que el
compilador asegura que las referencias siempre son válidas. <em>Unsafe</em> Rust
tiene dos nuevos tipos llamados <em>raw pointers</em> que son similares a las
referencias. Al igual que con las referencias, los punteros crudos pueden ser
inmutables o mutables y se escriben como <code>*const T</code> y <code>*mut T</code>,
respectivamente. El asterisco no es el operador de desreferencia; es parte
del nombre del tipo. En el contexto de los punteros sin formato,
<em>inmutables</em> significa que el puntero no puede asignarse directamente después
de haber sido desreferenciados.</p>
<p>A diferencia de las referencias y los punteros inteligentes, los punteros sin
formato:</p>
<ul>
<li>Se les permite ignorar las reglas de préstamo al tener punteros inmutables
y mutables o múltiples punteros mutables en la misma ubicación</li>
<li>No se garantiza que apunte a la memoria válida</li>
<li>Pueden ser nulos</li>
<li>No implemente ninguna limpieza automática</li>
</ul>
<p>Al optar por evitar que Rust haga cumplir estas garantías, puede renunciar a
la seguridad garantizada a cambio de un mayor rendimiento o la capacidad de
interactuar con otro lenguaje o hardware donde las garantías de Rust no se
apliquen.</p>
<p>El listado 19-1 muestra cómo crear un <em>raw pointer</em> inmutable y mutable a
partir de las referencias.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-1: Creación de <em>raw pointers</em> a partir de
referencias</span></p>
<p>Tenga en cuenta que no incluimos la palabra clave <code>unsafe</code> en este código.
Podemos crear <em>raw pointers</em> en código seguro; simplemente no podemos
desreferenciar <em>raw pointers</em> fuera de un bloque <code>unsafe</code>, como verán en un
momento.</p>
<p>Hemos creado <em>raw pointers</em> utilizando <code>as</code> para convertir una referencia
inmutable y mutable en sus correspondientes tipos de <em>raw pointers</em>. Debido a
que los creamos directamente a partir de referencias que se garantiza que son
válidas, sabemos que estos <em>raw pointers</em> particulares son válidos, pero no
podemos hacer esa suposición sobre cualquier <em>raw pointers</em>.</p>
<p>A continuación, crearemos un <em>raw pointers</em> cuya validez no podemos estar tan
seguros. El Listado 19-2 muestra cómo crear un <em>raw pointers</em> a una ubicación
arbitraria en la memoria. Intentar usar memoria arbitraria no está definido:
puede haber datos en esa dirección o puede que no, el compilador podría
optimizar el código para que no haya acceso a la memoria, o el programa
podría generar un error con un error de segmentación. Por lo general, no hay
una buena razón para escribir código como este, pero es posible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let address = 0x012345usize;
let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-2: Creación de un <em>raw pointer</em> a una
dirección de memoria arbitraria</span></p>
<p>Recuerde que podemos crear <em>raw pointers</em> en código seguro, pero no podemos
<em>desreferenciar</em>, <em>raw pointers</em> y leer los datos que se apuntan. En el
listado 19-3, usamos el operador de desreferencia <code>*</code> en un <em>raw pointers</em>
que requiere un bloque <code>unsafe</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-3: Cómo desreferenciar <em>raw pointers</em>
dentro de un bloque <code>unsafe</code></span></p>
<p>Crear un puntero no hace daño; solo cuando tratamos de acceder al valor que
señala, podríamos terminar lidiando con un valor no válido.</p>
<p>Tenga en cuenta también que en el listado 19-1 y 19-3, creamos <em>raw pointers</em> <code>*const i32</code> y <code>*mut i32</code> que apuntaban a la misma ubicación de memoria,
donde <code>num</code> está almacenado. Si en lugar de eso intentamos crear una
referencia inmutable y mutable a <code>num</code>, el código no se habría compilado
porque las reglas de propiedad de Rust no permiten una referencia mutable al
mismo tiempo que cualquier referencia inmutable. Con los <em>raw pointers</em>,
podemos crear un puntero mutable y un puntero inmutable en la misma ubicación
y cambiar los datos a través del puntero mutable, lo que podría crear una
carrera de datos. ¡Tenga cuidado!</p>
<p>Con todos estos peligros, ¿por qué usaría <em>raw pointers</em>?. Un caso de uso
importante es cuando se interactúa con el código C, como verá en la siguiente
sección, “Llamar a una función o método inseguro”. Otro caso es cuando se
crean abstracciones seguras que el verificador de préstamos no entiende.
Introduciremos funciones inseguras y luego veremos un ejemplo de abstracción
segura que usa código inseguro.</p>
<h3 id="llamar-a-una-función-o-método-inseguro"><a class="header" href="#llamar-a-una-función-o-método-inseguro">Llamar a una función o método inseguro</a></h3>
<p>El segundo tipo de operación que requiere un bloque inseguro es llamadas a
funciones inseguras. Las funciones y métodos inseguros se ven exactamente
como las funciones y los métodos normales, pero tienen un <code>unsafe</code> adicional
antes del resto de la definición. La palabra clave <code>unsafe</code> en este contexto
indica que la función tiene requisitos que debemos mantener cuando llamamos a
esta función, porque Rust no puede garantizar que cumplamos con estos
requisitos. Al llamar a una función insegura dentro de un bloque <code>unsafe</code>,
estamos diciendo que hemos leído la documentación de esta función y asumimos
la responsabilidad de mantener los contratos de la función.</p>
<p>Aquí hay una función insegura llamada <code>dangerous</code> que no hace nada en su
cuerpo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}

unsafe {
    dangerous();
}
<span class="boring">}
</span></code></pre></pre>
<p>Debemos llamar a la función <code>dangerous</code> dentro de un bloque <code>unsafe</code>
separado. Si tratamos de llamar <code>dangerous</code> sin el bloque <code>unsafe</code>,
obtendremos un error:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>Al insertar el bloque <code>unsafe</code> en nuestra llamada a <code>dangerous</code>, le estamos
diciendo a Rust que hemos leído la documentación de la función, que sabemos
cómo usarla correctamente y que hemos verificado que estamos cumpliendo el
contrato. de la función.</p>
<p>Los cuerpos de funciones inseguras son efectivamente bloques <code>unsafe</code>, por lo
que para realizar otras operaciones inseguras dentro de una función insegura,
no es necesario agregar otro bloque <code>unsafe</code>.</p>
<h4 id="creando-una-abstracción-segura-sobre-un-código-inseguro"><a class="header" href="#creando-una-abstracción-segura-sobre-un-código-inseguro">Creando una abstracción segura sobre un código inseguro</a></h4>
<p>El hecho de que una función contenga un código inseguro no significa que
tengamos que marcar toda la función como insegura. De hecho, envolver código
inseguro en una función segura es una abstracción común. Como ejemplo,
estudiemos una función de la biblioteca estándar, <code>split_at_mut</code>, que
requiere algún código inseguro y explore cómo podemos implementarlo. Este
método seguro se define en porciones mutables: toma una porción y la
convierte en dos dividiendo la porción en el índice dado como argumento. El
listado 19-4 muestra cómo usar <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-4: Uso de la función segura
<code>split_at_mut</code></span></p>
<p>No podemos implementar esta función usando solo Rust seguro. Un intento puede
parecerse al Listado 19-5, que no se compilará. Para simplificar,
implementaremos <code>split_at_mut</code> como una función en lugar de un método y solo
para segmentos de valores <code>i32</code> en lugar de para un tipo genérico <code>T</code>.</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">Listado 19-5: Un intento de implementación de
<code>split_at_mut</code> usando solo Rust seguro</span></p>
<p>Esta función primero obtiene la longitud total del <em>slice</em>. Luego afirma que
el índice dado como parámetro está dentro del <em>slice</em> al verificar si es
menor o igual a la longitud. La afirmación significa que si pasamos un índice
que es mayor que el índice para dividir el <em>slice</em>, la función entrará en
pánico antes de intentar usar ese índice.</p>
<p>Luego devolvemos dos <em>slice</em> mutables en una tupla: una desde el inicio del
<em>slice</em> original al índice <code>mid</code> y otra desde <code>mid</code> hasta el final del
<em>slice</em>.</p>
<p>Cuando intentemos compilar el código en el listado 19-5, obtendremos un error.</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>El comprobador de préstamos de Rust no puede entender que estamos tomando
prestadas partes diferentes del <em>slice</em>; solo sabe que tomamos prestado del misma <em>slice</em> dos veces. Pedir prestado diferentes partes de un <em>slice</em> es
fundamentalmente correcto porque los dos <em>slice</em> no se superponen, pero Rust
no es lo suficientemente inteligente como para saberlo. Cuando sabemos que el
código está bien, pero Rust no, es hora de buscar un código inseguro.</p>
<p>El Listado 19-6 muestra cómo utilizar un bloque <code>unsafe</code>, un <em>raw pointer</em> y
algunas llamadas a funciones inseguras para hacer que la implementación de
<code>split_at_mut</code> funcione.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-6: Usar código inseguro en la implementación
de la función <code>split_at_mut</code></span></p>
<p>Recuerde de la sección “Tipo de <em>Slice</em>” en el Capítulo 4 que los <em>slices</em>
son un puntero a algunos datos y la longitud del <em>slices</em>. Utilizamos el
método <code>len</code> para obtener la longitud de un <em>slices</em> y el método <code>as_mut_ptr</code>
para acceder al puntero sin formato de un <em>slices</em>. En este caso, como
tenemos un <em>slices</em> mutable a valores <code>i32</code>, <code>as_mut_ptr</code> devuelve un puntero
sin formato con el tipo <code>*mut i32</code>, que hemos almacenado en la variable <code>ptr</code>.</p>
<p>Mantenemos la afirmación de que el índice <code>mid</code> está dentro del <em>slices</em>.
Luego llegamos al código inseguro: la función <code>slice::from_raw_parts_mut</code>
toma un puntero sin formato y una longitud, y crea un <em>slices</em>. Usamos esta
función para crear un <em>slices</em> que comienza desde <code>ptr</code> y es <code>mid</code> largo.
Luego llamamos al método <code>offset</code> en <code>ptr</code> con <code>mid</code> como argumento para
obtener un puntero sin formato que comience en <code>mid</code>, y creamos un <em>slices</em>
usando ese puntero y el número restante de elementos después de <code>mid</code> como la
longitud.</p>
<p>La función <code>slice::from_raw_parts_mut</code> no es segura porque toma un puntero
sin formato y debe confiar en que este puntero es válido. El método <code>offset</code>
en punteros sin formato también es inseguro, porque debe confiar en que la
ubicación del desplazamiento también es un puntero válido. Por lo tanto,
tuvimos que poner un bloque <code>unsafe</code> alrededor de nuestras llamadas a
<code>slice::from_raw_parts_mut</code> y <code>offset</code> para que pudiéramos llamarlas. Al
observar el código y al agregar la afirmación de que <code>mid</code> debe ser menor o
igual que <code>len</code>, podemos decir que todos los <em>raw pointers</em> utilizados dentro
del bloque <code>unsafe</code> serán punteros válidos para los datos dentro del
<em>slice</em>. Este es un uso aceptable y apropiado de <code>unsafe</code>.</p>
<p>Tenga en cuenta que no necesitamos marcar la función <code>split_at_mut</code>
resultante como <code>unsafe</code>, y podemos llamar a esta función desde Rust seguro.
Hemos creado una abstracción segura del código inseguro con una
implementación de la función que usa el código <code>unsafe</code> de forma segura, ya
que solo crea punteros válidos a partir de los datos a los que tiene acceso
esta función.</p>
<p>Por el contrario, el uso de <code>slice::from_raw_parts_mut</code> en el Listado 19-7
probablemente se bloquee cuando se use el <em>slice</em>. Este código toma una
ubicación de memoria arbitraria y crea un <em>slice</em> de 10.000 elementos de
longitud.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-7: Crear un <em>slice</em> desde una ubicación de
memoria arbitraria</span></p>
<p>No poseemos la memoria en esta ubicación arbitraria, y no hay garantía de que
el <em>slice</em> que crea este código contenga valores <code>i32</code> válidos. Intentar
utilizar el <code>slice</code> como si fuera un <em>slice</em> válido da como resultado un
comportamiento indefinido.</p>
<h4 id="uso-de-funciones-extern-para-llamar-al-código-externo"><a class="header" href="#uso-de-funciones-extern-para-llamar-al-código-externo">Uso de funciones <code>extern</code> para llamar al código externo</a></h4>
<p>A veces, su código Rust podría necesitar interactuar con código escrito en
otro lenguaje. Para esto, Rust tiene una palabra clave, <code>extern</code>, que
facilita la creación y el uso de una <em>Foreign Function Interface (FFI)</em>. Un
FFI es una forma para que un lenguaje de programación defina funciones y
habilite un lenguaje de programación diferente (extranjero) para llamar a
esas funciones.</p>
<p>El listado 19-8 muestra cómo configurar una integración con la función <code>abs</code>
de la biblioteca estándar C. Las funciones declaradas dentro de bloques
<code>extern</code> siempre son inseguras para llamar desde el código Rust. La razón es
que otros lenguajes no hacen cumplir las reglas y garantías de Rust, y Rust
no puede verificarlos, por lo que la responsabilidad recae en el programador
para garantizar la seguridad.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Listado 19-8: Declarar y llamar a una función <code>extern</code>
definida en otro lenguaje</span></p>
<p>Dentro del bloque <code>extern&quot; C &quot;</code>, enumeramos los nombres y firmas de funciones
externas de otro lenguaje que queremos llamar. La parte <code>&quot;C&quot;</code> define qué
<em>application binary interface (ABI)</em> (<em>interfaz binaria de aplicación (ABI)</em>)
utiliza la función externa: el ABI define cómo llamar a la función en el
nivel de ensamblaje. El <code>&quot;C&quot;</code> ABI es el más común y sigue el ABI del lenguaje
de programación C.</p>
<blockquote>
<h4 id="llamar-a-funciones-de-rust-desde-otros-lenguajes"><a class="header" href="#llamar-a-funciones-de-rust-desde-otros-lenguajes">Llamar a funciones de Rust desde otros lenguajes</a></h4>
<p>También podemos usar <code>extern</code> para crear una interfaz que permita a otros
lenguajes llamar a las funciones de Rust. En lugar de un bloque <code>extern</code>,
agregamos la palabra clave <code>extern</code> y especificamos el ABI para usar justo
antes de la palabra clave <code>fn</code>. También necesitamos agregar una anotación
<code>#[no_mangle]</code> para decirle al compilador de Rust que no modifique el nombre
de esta función. <em>Mangling</em> es cuando un compilador cambia el nombre al que
hemos asignado una función por un nombre diferente que contiene más
información para que otras partes del proceso de compilación lo consuman,
pero es menos legible para el ser humano. Cada compilador de lenguaje de
programación manipula los nombres de forma ligeramente diferente, por lo
que para que una función Rust sea reconocible por otros lenguajes, debemos
deshabilitar el nombre del compilador Rust.</p>
<p>En el siguiente ejemplo, hacemos que la función <code>call_from_c</code> sea accesible
desde el código C, después de compilarla en una biblioteca compartida y
vincularla desde C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este uso de <code>extern</code> no requiere <code>unsafe</code>.</p>
</blockquote>
<h3 id="acceder-o-modificar-una-variable-estática-mutable"><a class="header" href="#acceder-o-modificar-una-variable-estática-mutable">Acceder o modificar una variable estática mutable</a></h3>
<p>Hasta ahora, no hemos hablado sobre <em>variables globales</em>, que Rust sí admite,
pero puede ser problemático con las reglas de propiedad de Rust. Si dos hilos
están accediendo a la misma variable global mutable, puede causar una carrera
de datos.</p>
<p>En Rust, las variables globales se llaman <em>variables estáticas</em>. El listado
19-9 muestra una declaración de ejemplo y el uso de una variable estática con
un <em>string slice</em> como un valor.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listado 19-9: Definición y uso de una variable estática
inmutable</span></p>
<p>Las variables estáticas son similares a las constantes, que discutimos en la
sección “Diferencias entre variables y constantes” en el Capítulo 3. Los
nombres de las variables estáticas están en <code>SCREAMING_SNAKE_CASE</code> por
convención, y debemos <em>anotar</em> el tipo de la variable, que es <code>&amp;'static str</code>
en este ejemplo. Las variables estáticas solo pueden almacenar referencias
con el <em>lifetime</em> <code>'static</code>, lo que significa que el compilador de Rust puede
calcular la duración; no necesitamos anotarlo explícitamente. El acceso a una
variable estática inmutable es seguro.</p>
<p>Las constantes y las variables estáticas inmutables pueden parecer similares,
pero una diferencia sutil es que los valores en una variable estática tienen
una dirección fija en la memoria. El uso del valor siempre tendrá acceso a
los mismos datos. Las constantes, por otro lado, pueden duplicar sus datos
siempre que se utilicen.</p>
<p>Otra diferencia entre las constantes y las variables estáticas es que las
variables estáticas pueden ser mutables. El acceso y la modificación de
variables estáticas mutables es <em>inseguro</em>. El listado 19-10 muestra cómo
declarar, acceder y modificar una variable estática mutable llamada <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 19-10: leer o escribir en una variable estática
mutable es inseguro</span></p>
<p>Al igual que con las variables regulares, especificamos la mutabilidad usando
la palabra clave <code>mut</code>. Cualquier código que lea o escriba de <code>COUNTER</code> debe
estar dentro de un bloque <code>unsafe</code>. Este código compila e imprime
<code>COUNTER: 3</code> como se esperaría porque tiene un solo hilo. Tener múltiples
hilos de acceso <code>COUNTER</code> probablemente resultaría en carreras de datos.</p>
<p>Con los datos mutables que son accesibles a nivel mundial, es difícil
garantizar que no haya carreras de datos, razón por la cual Rust considera
que las variables estáticas mutables no son seguras. Siempre que sea posible,
es preferible utilizar las técnicas de concurrencia y <em>thread-safe smart
pointers</em> que discutimos en el Capítulo 16, de modo que el compilador
compruebe que los datos a los que se accede desde diferentes subprocesos se
realizan de forma segura.</p>
<h3 id="implementando-un-trait-inseguro"><a class="header" href="#implementando-un-trait-inseguro">Implementando un <em>Trait</em> Inseguro</a></h3>
<p>La acción final que solo funciona con <code>unsafe</code> está implementando un <em>trait</em>
inseguro. Un <em>trait</em> no es seguro cuando al menos uno de sus métodos tiene
alguna invariante que el compilador no puede verificar. Podemos declarar que
un <em>trait</em> es <code>unsafe</code> añadiendo la palabra clave <code>unsafe</code> antes de <code>trait</code> y
marcando la implementación del <code>trait</code> como <code>unsafe</code> también, como se muestra
en el Listado 19-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-11: Definición e implementación de un <em>trait</em>
inseguro</span></p>
<p>Al utilizar <code>unsafe impl</code>, prometemos que mantendremos las invariantes que el
compilador no puede verificar.</p>
<p>Como ejemplo, recuerde los <em>trait</em> del marcador <code>Sync</code> y <code>Send</code> que
discutimos en la sección “Concurrencia extensible con los <em>Traits</em><code>Sync</code> y
<code>Send</code>” en el Capítulo 16: el compilador implementa estos <em>trait</em>
automáticamente si nuestros tipos están compuestos completamente de los tipos
<code>Send</code> y <code>Sync</code>. Si implementamos un tipo que contiene un tipo que no es
<code>Send</code> o <code>Sync</code>, como <em>raw pointers</em>, y queremos marcar ese tipo como <code>Send</code>
o <code>Sync</code>, debemos usar <code>unsafe</code>. Rust no puede verificar que nuestro tipo
mantenga las garantías de que puede enviarse de manera segura a través de
hilos o acceder desde múltiples hilos; por lo tanto, necesitamos hacer esos
controles manualmente e indicar como tal con <code>unsafe</code>.</p>
<h3 id="cuándo-usar-el-código-no-seguro"><a class="header" href="#cuándo-usar-el-código-no-seguro">Cuándo usar el código no seguro</a></h3>
<p>Usar <code>unsafe</code> para tomar una de las cuatro acciones (<em>superpoderes</em>)
(<em>superpowers</em>) que acabamos de discutir no es incorrecto o incluso
desaprobado. Pero es más complicado obtener el código <code>unsafe</code> correcto
porque el compilador no puede ayudar a mantener la seguridad de la memoria.
Cuando tiene una razón para usar el código <code>unsafe</code>, puede hacerlo, y tener
la anotación <code>unsafe</code> explícita hace que sea más fácil rastrear el origen de
los problemas si ocurren.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-02-advanced-lifetimes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-02-advanced-lifetimes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
