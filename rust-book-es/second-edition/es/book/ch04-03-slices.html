<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Segmentos (Slices) - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="el-tipo-slice-segmento"><a class="header" href="#el-tipo-slice-segmento">El Tipo Slice (Segmento)</a></h2>
<p>Los <em>Slices</em> le permiten hacer referencia a un secuencia contigua de elementos en una colección en lugar de toda la colección. Un <em>Slice</em> es una especie de referencia, por lo que no tiene la propiedad.</p>
<p>He aquí un pequeño problema de programación: escriba una función que tome una cadena (<em>string</em>) de palabras (separadas por espacios) y devuelva la primera palabra que encuentre en ese <em>string</em>. Si la función no encuentra un espacio en el <em>string</em>, todo el <em>string</em> debe ser una palabra, por lo que se debe devolver el <em>string</em> completo. </p>
<p>Analicemos cómo escribiríamos la firma de esta función sin usar <em>Slices</em>, para entender el problema que luego resolverán los <em>Slices</em>:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>La función <code>first_word</code> tiene un <code>&amp;String</code> como parámetro. No queremos la <em>propiedad</em>, así que eso está bien. Pero, ¿qué deberíamos devolver? Realmente no tenemos una forma de hablar sobre <em>parte</em> de un <em>string</em>. Sin embargo, podríamos devolver el índice del final de la palabra, indicado por un espacio. Probemos eso, como se muestra en el Listado 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 4-7: La función <code>first_word</code> que devuelve un valor de índice de byte en el parámetro <code>String</code></span></p>
<p>Debido a que necesitamos recorrer el <code>String</code> elemento por elemento y comprobar si un valor es un espacio, convertiremos nuestro <code>String</code> a un array de bytes utilizando el método <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>A continuación, creamos un iterador sobre el array de bytes utilizando el método <code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Analizaremos iteradores con más detalle en el <a href="ch13-02-iterators.html">Capítulo 13</a>. Por ahora, sepa que <code>iter</code> es un método que devuelve cada elemento de una colección y que <code>enumerate</code> adapta el resultado de <code>iter</code> y en su lugar devuelve cada elemento como parte de una tupla. El primer elemento de la tupla devuelta de <code>enumerate</code> es el índice, y el segundo elemento es una referencia al elemento. Esto es un poco más conveniente que calcular el índice nosotros mismos.</p>
<p>Debido a que el método <code>enumerate</code> devuelve una tupla, podemos usar patrones
para desestructurar esa tupla. Hablaremos más sobre los patrones en el <a href="ch06-02-match.html">Capítulo 6</a>. En el bucle <code>for</code>, especificamos un patrón que tiene <code>i</code> para el
índice en la tupla y <code>&amp;item</code> para el byte simple en la tupla. Como de <code>.iter().enumerate()</code> obtenemos una referencia al elemento, usamos <code>&amp;</code> en el patrón.</p>
<p>Dentro del bucle <code>for</code>, buscamos el byte que representa el espacio usando la sintaxis
literal de byte. Si encontramos un espacio, devolvemos la posición. De lo contrario,
devolvemos la longitud del <em>string</em> usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">   let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">   for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Ahora tenemos una forma de averiguar el índice del final de la primera palabra en el <em>string</em>,
pero hay un problema. Estamos devolviendo un <code>usize</code> por sí solo, pero es un número
significativo sólo en el contexto de <code>&amp;String</code>. En otras palabras, como es un valor separado de
<code>String</code>, no hay garantía de que siga siendo válido en el futuro. Considere el programa en
el Listado 4-8 que usa la función <code>first_word</code> del Listado 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word obtendrá el valor 5

    s.clear(); // esto vacía el String, haciéndolo igual a &quot;&quot;

    // word todavía tiene el valor 5 aquí, pero no hay más un string con el que podamos
    // usar significativamente el valor 5. ¡word ahora es totalmente inválido!
}
</code></pre></pre>
<p><span class="caption">Listing 4-8: Almacenar el resultado de llamar a la función <code>first_word</code>
y luego cambiar el contenido de <code>String</code></span></p>
<p>Este programa compila sin ningún error y también lo haría si usáramos <code>word</code> después de llamar a <code>s.clear()</code>. Debido a que <code>word</code> no está conectado en absoluto al estado de <code>s</code>, <code>word</code> todavía contiene el valor <code>5</code>. Podríamos usar ese valor <code>5</code> con la variable <code>s</code> para intentar extraer la primera palabra, pero esto sería un error porque el contenido de <code>s</code> ha cambiado desde que guardamos <code>5</code> en <code>word</code>.</p>
<p>Tener que preocuparse de que el índice en <code>word</code> esté fuera de sincronía con los
datos en <code>s</code> es tedioso y propenso a errores. La gestión de estos índices es aún
más frágil si escribimos una función <code>second_word</code>. Su firma debería verse así:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Ahora estamos rastreando un índice de inicio <em>y</em> uno final, y tenemos
aún más valores que se calcularon a partir de datos en un estado particular,
pero que no están vinculados a ese estado en absoluto. Ahora tenemos tres variables
no relacionadas flotando alrededor que deben mantenerse sincronizadas.</p>
<p>Afortunadamente, Rust tiene una solución a este problema: <em>string slices</em> (segmentos de cadenas).</p>
<h3 id="string-slices-segmentos-de-cadenas"><a class="header" href="#string-slices-segmentos-de-cadenas">String Slices (Segmentos de Cadenas)</a></h3>
<p>Un <em>string slice</em> es una referencia a parte de un <code>String</code>, y se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>En lugar de una referencia a todo el <code>String</code>, <code>hello</code> es una referencia a una parte del <code>String</code>, especificado en el agregado extra <code>[0..5]</code>. Creamos segmentos usando un rango entre corchetes especificando <code>[índice_inicial..índice_final]</code>, donde el <code>índice_inicial</code> es la primera posición en el segmento y el <code>índice_final</code> es uno más que la última posición en el segmento. Internamente, la estructura de datos del segmento almacena la posición inicial y la longitud del segmento, que corresponde al <code>índice_final</code> menos el <code>índice_inicial</code>. Entonces, en el caso de <code>let world = &amp;s[6..11];</code>, <code>world</code> sería un segmento que contiene un puntero al byte con índice 6 de <code>s</code>, con un valor de longitud 5.</p>
<p>La figura 4-6 muestra esto en un diagrama.</p>
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-6: <em>string slice</em> refiriéndose a parte de un
<code>String</code></span></p>
<p>Con la sintaxis de rango <code>..</code> de Rust, si desea comenzar en el primer índice (cero),
puede omitir el valor antes de los dos puntos. En otras palabras, estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello&quot;);

    let slice = &amp;s[0..2];
    let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>De la misma manera, si su segmento incluye el último byte del <code>String</code>, puede omitir el
número final. Eso significa que estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello&quot;);

    let len = s.len();

    let slice = &amp;s[3..len];
    let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>También puede omitir ambos valores para tomar un segmento de la cadena completa.
Entonces estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello&quot;);

    let len = s.len();

    let slice = &amp;s[0..len];
    let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Nota: Los índices de rango de <em>string slice</em> deben darse en límites válidos de caracteres UTF-8. Si intenta crear un <em>string slice</em> en el medio de un caracter multibyte, su programa se cerrará con un error. A los efectos de introducir <em>string slices</em>, estamos asumiendo sólo ASCII en esta sección. Una discusión más detallada del manejo de UTF-8 se encuentra en la sección <a href="ch08-02-strings.html">“Almacenamiento de texto codificado en UTF-8 con Strings”</a> del Capítulo 8.</p>
</blockquote>
<p>Con toda esta información en mente, reescribamos <code>first_word</code> para devolver un
<em>slice</em>. El tipo indicado para “string slice” se escribe como <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Obtenemos el índice para el final de la palabra de la misma manera que lo hicimos en el Listado 4-7, buscando la primera aparición de un espacio. Cuando encontramos un espacio, devolvemos un <em>string slice</em> usando el inicio del <em>string</em> y el índice del espacio como los índices inicial y final.</p>
<p>Ahora, cuando llamamos a <code>first_word</code>, obtenemos un valor único que está vinculado a los datos subyacentes. El valor se compone de una referencia al punto inicial del segmento (<em>slice</em>) y el número de elementos en ese segmento.</p>
<p>Devolver un segmento también funcionaría para una función <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Ahora tenemos una API sencilla que es mucho más difícil de estropear, porque el compilador se asegurará de que las referencias a <code>String</code> sigan siendo válidas. ¿Recuerda el error en el programa del Listado 4-8, cuando obtuvimos el índice al final de la primera palabra pero luego borramos el <em>string</em>, por lo que nuestro índice no era válido? Ese código era lógicamente incorrecto pero no mostraba ningún error inmediato. Los problemas aparecerían más adelante si siguiéramos intentando usar el índice de la primera palabra con un <em>string</em> vaciado. Los <em>slices</em> hacen que este error sea imposible y nos avisan que tenemos un problema con nuestro código mucho antes. El uso de la versión <em>slice</em> de <code>first_word</code> generará un error en tiempo de compilación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>Aquí está el error del compilador:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Recuerde de las reglas de préstamo que: si tenemos una referencia inmutable a algo, no podemos tener también una referencia mutable. Debido a que <code>clear</code> necesita truncar el <code>String</code>, necesita obtener una referencia mutable. El <code>println!</code> después de la llamada a <code>clear</code> usa la referencia en <code>word</code>, por lo que la referencia inmutable aún debe estar activa en ese punto. Rust no permite que la referencia mutable en <code>clear</code> y la referencia inmutable en <code>word</code> existan al mismo tiempo, y la compilación falla. ¡Rust no solo ha hecho que nuestra API sea más fácil de usar, sino que también ha eliminado toda una clase de errores en el momento de la compilación!</p>
<h4 id="string-literales-son-slices"><a class="header" href="#string-literales-son-slices">String Literales son Slices</a></h4>
<p>Recordemos que hablamos sobre <em>string literales</em> (<em>cadenas literales</em>) que se almacenan dentro del binario. Ahora que sabemos acerca de <em>slices</em>, podemos entender correctamente los <em>string literales</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>El tipo de <code>s</code> aquí es <code>&amp;str</code>: es un <em>slice</em> que apunta a ese punto específico del
binario. Esta es también la razón por la cual los <em>string literales</em> son inmutables;
<code>&amp;str</code> es una referencia inmutable.</p>
<h4 id="string-slices-como-parámetros"><a class="header" href="#string-slices-como-parámetros">String Slices como Parámetros</a></h4>
<p>Saber que podemos tomar segmentos de valores literales y valores <code>String</code> nos lleva
a una mejora más en <code>first_word</code>, y esa es su firma:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Un <em>Rustáceo</em> más experimentado escribiría la firma que se muestra en el Listado 4-9 porque nos permite usar la misma función tanto en los valores <code>&amp;String</code> como en los valores <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 4-9: Mejorando la función <code>first_word</code> usando un <em>slice string</em>
para el tipo del parámetro <code>s</code></span></p>
<p>Si tenemos un <em>string slice</em>, podemos pasarlo directamente. Si tenemos un <code>String</code>, podemos pasar un <em>slice</em> de <code>String</code> o una referencia a <code>String</code>. Esta flexibilidad aprovecha la <em>&quot;deref coercions&quot;</em>, una característica que cubriremos en la sección <a href="ch15-02-deref.html#implicaciones-deref-impl%C3%ADcitas-con-funciones-y-m%C3%A9todos">&quot;Deref Coercions Implícitas con Funciones y Métodos&quot;</a> del Capítulo 15. Definir una función que toma un <em>string slice</em> en lugar de una referencia a un <code>String</code> hace que nuestra API sea más general y útil sin perder ninguna funcionalidad:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` funciona en segmentos de `String`s, ya sean parciales o completos
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    
    // `first_word` también funciona en referencias a `String`s, las cuales son 
    // el equivalente a porciones completas de `String`s
    let word = first_word(&amp;my_string);

    // Asignamos una cadena literal 
    let my_string_literal = &quot;hello world&quot;;

    // `first_word` funciona en &quot;segmentos&quot; de &quot;cadenas literales&quot;, 
    // ya sean parciales o completos
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Debido a que las &quot;cadenas literales&quot; *ya son* &quot;segmentos de cadena&quot;, 
    // esto también funciona, ¡sin la sintaxis de &quot;slice [..]&quot;!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3 id="otros-slices"><a class="header" href="#otros-slices">Otros Slices</a></h3>
<p>String slices, como puedes imaginar, son específicas de los <em>strings</em>. Pero también hay un tipo de <em>slice</em> más general. Considera este array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Del mismo modo que podríamos querer referirnos a una parte de un <em>string</em>, es posible que deseemos referirnos a parte de un array. Lo haríamos así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Este <em>slice</em> tiene el tipo <code>&amp;[i32]</code>. Funciona de la misma manera que los <em>string slices</em>,
almacenando una referencia al primer elemento y una longitud. Utilizará este tipo de <em>slices</em> para todo tipo de otras colecciones. Discutiremos sobre estas colecciones en detalle cuando hablemos de vectores en el Capítulo 8.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>Los conceptos de <em>ownership</em> (propiedad), <em>borrowing</em> (préstamo) y <em>slices</em> (segmentos) garantizan la seguridad de la memoria en los programas de Rust en tiempo de compilación. El lenguaje Rust le permite controlar el uso de la memoria de la misma manera que otros lenguajes de programación de sistemas, pero hacer que el propietario de los datos limpie automáticamente esos datos cuando el propietario se sale del <em>scope</em> (alcance) significa que no tiene que escribir y depurar código adicional para obtener este control.</p>
<p>La propiedad afecta el funcionamiento de muchas otras partes de Rust, por lo que hablaremos
más de estos conceptos a lo largo del resto del libro. Pasemos al Capítulo 5 y veamos cómo
agrupar piezas de datos en un <code>struct</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
