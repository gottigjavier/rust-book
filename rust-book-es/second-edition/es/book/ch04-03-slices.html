<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Partes (Slices) - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> Partes (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis de lo Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Haciendo Referencia a Nombres en Distintos Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Trait: Acceso a los Datos a través de una Referencia</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Funciones Avanzadas y Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Pakabras Clave</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Características más Recientes</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="el-tipo-slice"><a class="header" href="#el-tipo-slice">El tipo Slice</a></h2>
<p>Otro tipo de datos que no tiene propiedad es el <em>slice</em>. Las divisiones le
permiten hacer referencia a una secuencia contigua de elementos en una
colección en lugar de a toda la colección.</p>
<p>Aquí hay un pequeño problema de programación: escriba una función que toma
una cadena y devuelve la primera palabra que encuentra en esa cadena. Si la
función no encuentra un espacio en la cadena, toda la cadena debe ser una
palabra, por lo que se debe devolver toda la cadena.</p>
<p>Pensemos en la firma de esta función:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta función, <code>first_word</code>, tiene un <code>&amp;String</code> como parámetro. No queremos
ser propietarios (<em>ownership</em>), así que está bien. Pero, ¿qué deberíamos devolver?
Realmente no tenemos una forma de hablar sobre <em>parte</em> de una cadena. Sin embargo,
podríamos devolver el índice del final de la palabra. Probemos eso, como se
muestra en el Listado 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-7: La función <code>first_word</code> que devuelve un valor de
índice de bytes en el parámetro <code>String</code></span></p>
<p>Debido a que necesitamos pasar por el elemento <code>String</code> por elemento y
comprobar si un valor es un espacio, convertiremos nuestro <code>String</code>
a una matriz de bytes utilizando el método <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>A continuación, creamos un iterador sobre la matriz de bytes utilizando el método <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Analizaremos iteradores con más detalle en el Capítulo 13. Por ahora, sepa
que <code>iter</code> es un método que devuelve cada elemento de una colección y que
<code>enumerate</code> ajusta el resultado de <code>iter</code> y devuelve cada elemento como
parte de un tupla en su lugar. El primer elemento de la tupla devuelta de
<code>enumerate</code> es el índice, y el segundo elemento es una referencia al elemento.
Esto es un poco más conveniente que calcular el índice nosotros mismos.</p>
<p>Debido a que el método <code>enumerate</code> devuelve una tupla, podemos usar patrones
para desestructurar esa tupla, al igual que en cualquier otro lugar en Rust.
Entonces en el ciclo <code>for</code>, especificamos un patrón que tiene <code>i</code> para el
índice en la tupla y <code>&amp;item</code> para el byte simple en la tupla. Como obtenemos
una referencia al elemento de <code>.iter (). Enumerate ()</code>, usamos <code>&amp;</code> en el patrón.</p>
<p>Dentro del bucle <code>for</code>, buscamos el byte que representa el espacio usando la sintaxis
literal de byte. Si encontramos un espacio, devolvemos la posición. De lo contrario,
devolvemos la longitud de la cadena usando <code>s.len ()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}

s.len()
</code></pre>
<p>Ahora tenemos una forma de averiguar el índice del final de la primera palabra en la cadena,
pero hay un problema. Estamos devolviendo un <code>usize</code> por sí mismo, pero es solo un número
significativo en el contexto de <code>&amp;String</code>. En otras palabras, como es un valor separado del
<code>String</code>, no hay garantía de que siga siendo válido en el futuro. Considere el programa en
el Listado 4-8 que usa la función <code>first_word</code> del Listado 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // palabra obtendrá el valor 5

    s.clear(); // esto vacía el String, haciéndolo igual a &quot;&quot;

    // la palabra todavía tiene el valor 5 aquí, pero no hay más string
    // con las que podamos usar significativamente el valor 5. ¡la palabra ahora es totalmente inválida!
}
</code></pre></pre>
<p><span class="caption">Listing 4-8: Almacenar el resultado de llamar a la función <code>first_word</code>
y luego cambiar el contenido de <code>String</code></span></p>
<p>Este programa compila sin ningún error y también lo haría si usáramos <code>word</code>
después de llamar a <code>s.clear ()</code>. Debido a que <code>word</code> no está conectado al estado
de <code>s</code> en absoluto, <code>word</code> todavía contiene el valor <code>5</code>. Podríamos usar ese valor
<code>5</code> con la variable <code>s</code> para intentar extraer la primera palabra, pero esto sería un
error porque el contenido de <code>s</code> ha cambiado desde que guardamos <code>5</code> en <code>word</code>.</p>
<p>¡Tener que preocuparse de que el índice en <code>word</code> esté fuera de sincronía con los
datos en <code>s</code> es tedioso y propenso a errores! La gestión de estos índices es aún
más frágil si escribimos una función <code>second_word</code>. Su firma debería verse así:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Ahora estamos rastreando un índice de inicio <em>y</em> final, y tenemos
aún más valores que se calcularon a partir de datos en un estado particular,
pero que no están vinculados a ese estado en absoluto. Ahora tenemos tres variables
no relacionadas flotando alrededor que deben mantenerse sincronizadas.</p>
<p>Afortunadamente, Rust tiene una solución a este problema: string slices.</p>
<h3 id="string-slices"><a class="header" href="#string-slices">String Slices</a></h3>
<p>Un <em>string slice</em> es una referencia a parte de un <code>String</code>, y se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>Esto es similar a tomar una referencia a todo el <code>String</code> pero con el bit
adicional <code>[0..5] </code>. En lugar de una referencia a todo el <code>String</code>, es una
referencia a una parte del <code>String</code>. La sintaxis <code>start..end</code> es un rango
que comienza en <code>start</code> y continúa hasta, pero sin incluir, <code>end</code>.</p>
<p>Podemos crear sectores utilizando un rango entre paréntesis especificando
<code>[starting_index..ending_index]</code>, donde <code>starting_index</code> es la primera posición
en el sector y <code>ending_index</code> es uno más que la última posición del sector.
Internamente, la estructura de datos de corte almacena la posición de inicio
y la longitud de la división, que corresponde a <code>índice_determinado</code>
menos <code>índice_inicio</code>. Entonces, en el caso de <code>let world = &amp; s [6..11];</code>,
<code>world</code> sería una porción que contiene un puntero al sexto byte de <code>s</code>
con un valor de longitud de 5.</p>
<p>La figura 4-6 muestra esto en un diagrama.</p>
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-6: String slice refiriéndose a parte de un
<code>String</code></span></p>
<p>Con la sintaxis del rango <code>..</code> de Rust, si desea comenzar en el primer índice (cero),
puede soltar el valor antes de los dos períodos. En otras palabras, estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>De la misma manera, si su segmento incluye el último byte de <code>String</code>, puede soltar el
número final. Eso significa que estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>También puede soltar ambos valores para tomar una porción de la cadena completa.
Entonces estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Nota: Los índices de rango de <em>String slice</em> deben ocurrir en límites de
caracteres UTF-8 válidos. Si intenta crear un segmento de cadena en el medio
de un carácter multibyte, su programa saldrá con un error. A los efectos de la
introducción de segmentos de cadena, asumimos ASCII solo en esta sección;
una discusión más completa del manejo de UTF-8 se encuentra en la sección
“Almacenamiento de texto codificado en UTF-8 con Strings” del Capítulo 8.</p>
</blockquote>
<p>Con toda esta información en mente, reescribamos <code>first_word</code> para devolver un
slice. El tipo que significa “string slice” se escribe como <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<p>Obtenemos el índice para el final de la palabra de la misma manera que lo
hicimos en el Listado 4-7, al buscar la primera aparición de un espacio.
Cuando encontramos un espacio, devolvemos un segmento de cadena usando el
inicio de la cadena y el índice del espacio como los índices inicial y final.</p>
<p>Ahora cuando llamamos a <code>first_word</code>, recuperamos un único valor que está
vinculado a los datos subyacentes. El valor se compone de una referencia al
punto inicial de la división y la cantidad de elementos en la división.</p>
<p>Devolver un segmento también funcionaría para una función <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Ahora tenemos una API directa que es mucho más difícil de desordenar, porque el
compilador asegurará que las referencias en <code>String</code> sigan siendo válidas.
¿Recuerdas el error en el programa en el listado 4-8, cuando obtuvimos el índice
al final de la primera palabra pero luego borramos la cadena para que nuestro índice
no fuera válido? Ese código era lógicamente incorrecto pero no mostró ningún error
inmediato. Los problemas aparecerían más adelante si seguimos intentando usar el
primer índice de palabras con una cadena vacía. Las rebanadas hacen que este error
sea imposible y háganos saber que tenemos un problema con nuestro código mucho antes.
El uso de la versión de corte de <code>first_word</code> arrojará un error en tiempo de compilación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!
}
</code></pre>
<p>Aquí está el error del compilador:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = first_word(&amp;s);
  |                            - immutable borrow occurs here
5 |
6 |     s.clear(); // error!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Recuerde de las reglas de préstamo que si tenemos una referencia inmutable a algo,
tampoco podemos tomar una referencia mutable. Como <code>clear</code> necesita truncar el <code>String</code>,
intenta tomar una referencia mutable, que falla. Rust no solo ha hecho que nuestra API
sea más fácil de usar, ¡sino que también ha eliminado toda una clase de errores en
tiempo de compilación!</p>
<h4 id="string-literals-are-slices"><a class="header" href="#string-literals-are-slices">String Literals Are Slices</a></h4>
<p>Recordemos que hablamos sobre <em>string</em> literales que se almacenan dentro
del binario. Ahora que sabemos acerca de las divisiones, podemos entender
correctamente los <em>string</em> literales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>El tipo de <code>s</code> aquí es <code>&amp;str</code>: es un <em>slice</em> que apunta a ese punto específico del
binario. Esta es también la razón por la cual los literales de <em>string</em> son inmutables;
<code>&amp;str</code> es una referencia inmutable.</p>
<h4 id="string-slices-como-parámetros"><a class="header" href="#string-slices-como-parámetros">String Slices como parámetros</a></h4>
<p>Saber que puedes tomar porciones de literales y valores de <code>String</code> nos lleva
a una mejora más en <code>first_word</code>, y esa es su firma:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Un <em>Rustacean</em> más experimentado escribiría la firma que se muestra en el Listado 4-9
porque nos permite utilizar la misma función en los valores de <code>String</code> y <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p><span class="caption">Listing 4-9: Mejorando la función <code>first_word</code> usando un <em>slice string</em>
para el tipo del parámetro <code>s</code></span></p>
<p>Si tenemos un <em>string slice</em>, podemos pasarlo directamente. Si tenemos un <code>String</code>,
podemos pasar una porción del <code>String</code> entero. Definir una función para tomar un segmento
de cadena en lugar de una referencia a un <code>String</code> hace que nuestra API sea más general y
útil sin perder ninguna funcionalidad:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3 id="otros-slices"><a class="header" href="#otros-slices">Otros Slices</a></h3>
<p>String slices, como puedes imaginar, son específicas de los <em>strings</em>.
Pero hay un tipo de <em>slice</em> más general, también. Considera esta matriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Del mismo modo que podríamos querer referirnos a una parte de un <em>string</em>,
es posible que deseemos referirnos a parte de una matriz. Lo haríamos así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>Este <em>slice</em> tiene el tipo <code>&amp;[i32]</code>. Funciona de la misma manera que los <em>string slices</em>,
almacenando una referencia al primer elemento y una longitud. Utilizará este
tipo de <em>slices</em> para todo tipo de otras colecciones. Hablaremos de estas colecciones en detalle
cuando hablemos de vectores en el Capítulo 8.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>Los conceptos de propiedad (<em>ownership</em>), endeudamiento (<em>borrowing</em>) y slices garantizan
la seguridad de la memoria en los programas de Rust en tiempo de compilación.
El lenguaje Rust le permite controlar el uso de la memoria de la misma manera que otros
lenguajes de programación de sistemas, pero que el propietario de los datos limpie automáticamente
esos datos cuando el propietario se sale del alcance significa que no tiene que escribir
y depurar código adicional para obtener este control</p>
<p>La propiedad afecta el funcionamiento de muchas otras partes de Rust, por lo que hablaremos
de estos conceptos más a lo largo del resto del libro. Pasemos al Capítulo 5 y veamos cómo
agrupar piezas de datos en un <code>struct</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
