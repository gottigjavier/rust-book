<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traits: Definición del Comportamiento Compartido - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="traits-definición-de-comportamiento-compartido"><a class="header" href="#traits-definición-de-comportamiento-compartido">Traits: Definición de comportamiento compartido</a></h2>
<p>Un <em>trait</em> le dice al compilador Rust acerca de la funcionalidad que un tipo
en particular tiene y puede compartir con otros tipos. Podemos usar <em>trait</em>
para definir el comportamiento compartido de una manera abstracta. Podemos
usar límites de <em>trait</em> para especificar que un genérico puede ser de
cualquier tipo que tenga cierto comportamiento.</p>
<blockquote>
<p>Nota: Los <em>trait</em> son similares a una característica a menudo llamada
<em>interfaces</em> en otros lenguaje, aunque con algunas diferencias.</p>
</blockquote>
<h3 id="definiendo-un-trait"><a class="header" href="#definiendo-un-trait">Definiendo un Trait</a></h3>
<p>El comportamiento de un tipo consiste en los métodos que podemos invocar en
ese tipo. Los diferentes tipos comparten el mismo comportamiento si podemos
llamar a los mismos métodos en todos esos tipos. Las definiciones de <em>trait</em>
son una forma de agrupar las firmas de métodos para definir un conjunto de
comportamientos necesarios para lograr algún propósito.</p>
<p>Por ejemplo, supongamos que tenemos estructuras múltiples que contienen
varios tipos y cantidades de texto: una estructura <code>NewsArticle</code> que contiene
una historia de noticias presentada en una ubicación particular y un <code>Tweet</code>
que puede tener como máximo 280 caracteres junto con metadatos que indican si
fue un nuevo tweet, un retweet o una respuesta a otro tweet.</p>
<p>Queremos crear una biblioteca de agregadores de medios que pueda mostrar
resúmenes de datos que podrían almacenarse en una instancia de <code>NewsArticle</code>
o <code>Tweet</code>. Para hacer esto, necesitamos un resumen de cada tipo, y
necesitamos solicitar ese resumen llamando a un método <code>summarize</code> en una
instancia. El listado 10-12 muestra la definición de un <em>trait</em> <code>Summary</code> que
expresa este comportamiento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-12: Un <em>trait</em> <code>Resumen</code> que consiste en el comportamiento proporcionado por un método <code>summarize</code></span></p>
<p>Aquí, declaramos un <em>trait</em> usando la palabra clave <code>trait</code> y luego el nombre
del <em>trait</em>, que es <code>Summary</code>en este caso. Dentro de las llaves, declaramos
las firmas de métodos que describen los comportamientos de los tipos que
implementan este <em>trait</em>, que en este caso es
<code>fn summarize(&amp; self) -&gt; String</code>.</p>
<p>Después de la firma del método, en lugar de proporcionar una implementación
entre llaves, usamos un punto y coma. Cada tipo que implementa este <em>trait</em>
debe proporcionar su propio comportamiento personalizado para el cuerpo del
método. El compilador hará cumplir que cualquier tipo que tenga el <em>trait</em>
<code>Summary</code>tendrá el método <code>summarize</code> definido con esta firma exactamente.</p>
<p>Un <em>trait</em> puede tener múltiples métodos en su cuerpo: las firmas del método
se enumeran una por línea y cada línea termina en punto y coma.</p>
<h3 id="implementando-un-rasgo-en-un-tipo"><a class="header" href="#implementando-un-rasgo-en-un-tipo">Implementando un rasgo en un tipo</a></h3>
<p>Ahora que hemos definido el comportamiento deseado utilizando el <em>trait</em> <code>Summary</code>, podemos implementarlo en los tipos en nuestro agregador de medios.
El listado 10-13 muestra una implementación del <em>trait</em> <code>Summary</code> en la
estructura <code>NewsArticle</code> que usa el título, el autor y la ubicación para
crear el valor de retorno de <code>summarize</code>. Para la estructura <code>Tweet</code>,
definimos <code>summarize</code> como el nombre de usuario seguido por el texto completo
del tweet, suponiendo que el contenido del tweet ya está limitado a 280
caracteres.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-13: Implementando el <em>trait</em> <code>Summary</code> en los
tipos <code>NewsArticle</code> y <code>Tweet</code></span></p>
<p>La implementación de un <em>trait</em> en un tipo es similar a la implementación de
métodos regulares. La diferencia es que después de <code>impl</code>, ponemos el nombre
del <em>trait</em> que queremos implementar, luego usamos la palabra clave <code>for</code>, y
luego especificamos el nombre del tipo para el cual queremos implementar el
<em>trait</em>. Dentro del bloque <code>impl</code>, ponemos las firmas de método que ha
definido la definición de <em>trait</em>. En lugar de agregar un punto y coma
después de cada firma, usamos llaves y completamos el cuerpo del método
con el comportamiento específico que queremos que tengan los métodos del
<em>trait</em> para el tipo particular.</p>
<p>Después de implementar el <em>trait</em>, podemos llamar a los métodos en instancias
de <code>NewsArticle</code> y <code>Tweet</code> de la misma manera que llamamos a los métodos
regulares, como este:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>Este código imprime <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Tenga en cuenta que porque definimos el <em>trait</em> <code>Summary</code> y el <code>NewsArticle</code>
y tipos de <code>Tweet</code> en la misma <em>lib.rs</em> en el Listado 10-13, todos están en
el mismo alcance. Digamos que esto <em>lib.rs</em> es para un <em>create</em> que hemos llamado <code>aggregator</code> y alguien más quiere usar la funcionalidad de nuestro
<em>crate</em> para implementar el <code>Summary</code> <em>trait</em> en una estructura definida
dentro del alcance de su biblioteca. Tendrían que importar el <em>trait</em> en su alcance primero. Lo harían especificando
<code>use aggregator::Summary;</code>, que luego le permitiría implementar <code>Summary</code> para
su tipo. El <em>trait</em> <code>Summary</code> también necesitaría ser un <em>trait</em> público para
otra <em>create</em> para implementarlo, que es porque ponemos la palabra clave <code>pub</code>
antes de <em>trait</em> en el Listado 10-12.</p>
<p>Una restricción a tener en cuenta con las implementaciones de <em>traits</em> es que
podemos implementar un <em>trait</em> en un tipo solo si el <em>trait</em> o el tipo es
local para nuestro <em>crate</em>. Por ejemplo, podemos implementar <em>traits</em> de la biblioteca estándar como <code>Display</code> en un tipo personalizado como <code>Tweet</code> como
parte de nuestra funcionalidad <code>aggregator</code>, porque el tipo <code>Tweet</code> es local
a nuestro <em>crate</em> <code>aggregator</code>. También podemos implementar <code>Summary</code> en
<code>Vec &lt;T&gt;</code> en nuestro <em>crate</em> <code>aggregator</code>, porque el <em>trait</em> <code>Summary</code> es
local para nuestro <em>crate</em> <code>aggregator</code>.</p>
<p>Pero no podemos implementar <em>traits</em> externos en tipos externos. Por ejemplo,
no podemos implementar el <em>trait</em> <code>Display</code> en <code>Vec &lt;T&gt;</code> dentro de nuestro
<em>crate</em> <code>aggregator</code>, porque <code>Display</code> y<code> Vec &lt;T&gt;</code> están definidos en la
biblioteca estándar y no son local a nuestro <em>crate</em> <code>agregador</code> Esta
restricción es parte de una propiedad de programas llamados <em>coherencia</em>, y
más específicamente, la <em>regla huérfana</em>, llamada así porque el tipo
principal no está presente. Esta regla asegura que el código de otras
personas no puede romper su código y viceversa. Sin la regla, dos <em>crates</em>
podrían implementar el mismo <em>trait</em> para el mismo tipo, y Rust no sabría qué
implementación usar.</p>
<h3 id="implementaciones-predeterminadas"><a class="header" href="#implementaciones-predeterminadas">Implementaciones predeterminadas</a></h3>
<p>A veces es útil tener un comportamiento predeterminado para algunos o todos
los métodos en un <em>trait</em> en lugar de requerir implementaciones para todos
los métodos en cada tipo. Luego, a medida que implementamos el <em>trait</em> en un
tipo particular, podemos mantener o anular el comportamiento predeterminado
de cada método.</p>
<p>El Listado 10-14 muestra cómo especificar un <em>string</em> predeterminada para el
método <code>summarize</code> del <em>trait</em> <code>Summary</code> en lugar de solo definir la firma
del método, como hicimos en el Listado 10-12.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-14: Definición de un <em>trait</em> <code>Summary</code> con una implementación predeterminada del método <code>summarize</code></span></p>
<p>Para usar una implementación predeterminada para resumir instancias de
<code>NewsArticle</code> en lugar de definir una implementación personalizada,
especificamos un bloque <code>impl</code> vacío con <code>impl Summary for NewsArticle {}</code>.</p>
<p>Aunque ya no estamos definiendo el método <code>summarize</code> en <code>NewsArticle</code>
directamente, hemos proporcionado una implementación predeterminada y
especificamos que <code>NewsArticle</code> implementa el <em>trai</em> <code>Summary</code>. Como
resultado, todavía podemos llamar al método <code>summarize</code> en una instancia de
<code>NewsArticle</code>, así:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summarize());
</code></pre>
<p>Este código imprime <code>New article available! (Read more...)</code>.</p>
<p>Crear una implementación predeterminada para <code>summarize</code> no requiere que
cambiemos nada sobre la implementación de <code>Summary</code> en <code>Tweet</code> en el Listado
10-13. La razón es que la sintaxis para anular una implementación
predeterminada es la misma que la sintaxis para implementar un método de
<em>trait</em> que no tiene una implementación predeterminada.</p>
<p>Las implementaciones predeterminadas pueden llamar a otros métodos en el
mismo <em>trait</em>, incluso si esos otros métodos no tienen una implementación
predeterminada. De esta forma, un <em>trait</em> puede proporcionar una gran
cantidad de funcionalidades útiles y solo requiere que los implementadores
especifiquen una pequeña parte de él. Por ejemplo, podríamos definir el
<em>trait</em> <code>Summary</code> para tener un método <code>summarize_author</code> cuya implementación
es necesaria, y luego definir un método <code>summarize</code> que tenga una
implementación predeterminada que llame al método <code>summarize_author</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para usar esta versión de <code>Summary</code>, solo necesitamos definir
<code>summarize_author</code> cuando implementamos el <em>trait</em> en un tipo:</p>
<pre><code class="language-rust ignore">impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Después de definir <code>summarize_author</code>, podemos llamar <code>summarize</code> en las
instancias de la estructura <code>Tweet</code>, y la implementación predeterminada de
<code>summarize</code> llamará a la definición de <code>summarize_author</code> que hemos
proporcionado. Debido a que hemos implementado <code>summarize_author</code>, el
<em>trait</em> <code>Summary</code> nos ha dado el comportamiento del método <code>summarize</code> sin
necesidad de escribir más código.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>Este código imprime <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Tenga en cuenta que no es posible llamar a la implementación predeterminada
desde una implementación principal de ese mismo método.</p>
<h3 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h3>
<p>Ahora que sabe cómo definir <em>trait</em> e implementar esos <em>traits</em> en los tipos,
podemos explorar cómo usar los <em>traits</em> con los parámetros de tipo genérico.
Podemos usar <em>trait bounds</em> para restringir los tipos genéricos para
garantizar que el tipo se limitará a aquellos que implementan un <em>trait</em> y
comportamiento particular.</p>
<p>Por ejemplo, en el listado 10-13, implementamos el <em>trait</em> <code>Summary</code> en los
tipos <code>NewsArticle</code> y <code>Tweet</code>. Podemos definir una función <code>notify</code> que llama
al método <code>summarize</code> en su parámetro <code>item</code>, que es del tipo genérico <code>T</code>.
Para poder llamar <code>summarize</code> on <code>item</code> sin recibir un error que nos diga que
el tipo genérico <code>T</code> no implementa el método <code>summarize</code>, podemos usar
límites de <em>traits</em> en <code>T</code> para especificar ese <code>item</code> debe ser de un tipo
que implemente el <em>trait</em> <code>Summary</code>:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Colocamos límites de <em>trait</em> con la declaración del parámetro de tipo
genérico, después de dos puntos y dentro de corchetes angulares. Debido a la
característica de límite en <code>T</code>, podemos llamar a <code>notify</code> y pasar cualquier
instancia de <code>NewsArticle</code> o <code>Tweet</code>. El código que llama a la función con
cualquier otro tipo, como un <code>String</code> o un <code>i32</code>, no compilará, porque esos
tipos no implementan <code>Summary</code>.</p>
<p>Podemos especificar múltiples límites de <em>trait</em> en un tipo genérico usando
la sintaxis <code>+</code>. Por ejemplo, para usar el formato de visualización en el
tipo <code>T</code> en una función así como en el método <code>summarize</code>, podemos usar
<code>T: Summary + Display</code> para decir <code>T</code> puede ser cualquier tipo que implemente
<code>Summary</code> y <code>Display</code>.</p>
<p>Sin embargo, hay desventajas al uso de demasiados límites de <em>trait</em>. Cada
genérico tiene sus propios límites de <em>trait</em>, por lo que las funciones con
múltiples parámetros de tipo genérico pueden tener mucha información de
límite de caracteres entre el nombre de una función y su lista de parámetros,
lo que hace que la firma de la función sea difícil de leer. Por esta razón,
Rust tiene una sintaxis alternativa para especificar límites de <em>trait</em>
dentro de una cláusula <code>where</code> después de la firma de la función. Entonces,
en lugar de escribir esto:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>podemos usar una cláusula <code>where</code>, como esta:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>La firma de esta función es menos desordenada porque el nombre de la función,
la lista de parámetros y el tipo de retorno están muy juntos, de forma
similar a una función sin muchos límites de caracteres.</p>
<h3 id="reparar-la-función-largest-con-límites-de-trait"><a class="header" href="#reparar-la-función-largest-con-límites-de-trait">Reparar la función <code>largest</code> con límites de <em>Trait</em></a></h3>
<p>Ahora que sabe cómo especificar el comportamiento que desea usar utilizando
los límites del parámetro de tipo genérico, regresemos al Listado 10-5 para
corregir la definición de la función <code>largest</code> que usa un parámetro de
tipo genérico. La última vez que intentamos ejecutar ese código, recibimos
este error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>En el cuerpo de <code>largest</code> queríamos comparar dos valores de tipo <code>T</code> usando
el operador mayor que (<code>&gt;</code>). Debido a que ese operador se define como un
método predeterminado en el <em>trait</em> de la biblioteca estándar
<code>std::cmp::PartialOrd</code>, necesitamos especificar <code>PartialOrd</code> en los límites
de <em>trait</em> para <code>T</code>, de modo que la función <code>largest</code> puede funcionar en
sectores de cualquier tipo que podamos comparar no necesitamos traer
<code>PartialOrd</code> al alcance porque está en el preludio. Cambie la firma de
<code>largest</code> para que se vea así:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Esta vez, cuando compilamos el código, obtenemos un conjunto diferente de errores:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>La línea clave en este error es
<code>cannot move out of type [T], a non-copy slice</code>. Con nuestras versiones no
genéricas de la función <code>largest</code>, solo intentábamos encontrar el <code>i32</code> o
<code>char</code> más grande. Como se estudió en la sección “Datos apilados solo: copia”
en el Capítulo 4, los tipos como <code>i32</code> y <code>char</code> que tienen un tamaño conocido
se pueden almacenar en la pila (<em>stack</em>), por lo que implementan el <em>trait</em>
<code>Copy</code>. Pero cuando hicimos genérica la función <code>largest</code>, se hizo posible
que el parámetro <code>list</code> tuviera tipos que no implementan el <em>trait</em> <code>Copy</code>.
En consecuencia, no podríamos mover el valor fuera de <code>list[0]</code> y dentro de
la variable <code>largest</code>, lo que daría como resultado este error.</p>
<p>Para llamar a este código solo con aquellos tipos que implementan el <em>trait</em>
<code>Copy</code>, podemos agregar <code>Copy</code> a los límites de <em>trait</em> de <code>T</code>! El Listado
10-15 muestra el código completo de una función genérica <code>largest</code> que se
compilará siempre que los tipos de los valores en la porción que pasamos a la
función implementen los <em>trait</em> <code>PartialOrd</code> <em>y</em> <code>Copy</code>, como <code>i32</code> y <code>char</code>
hacen.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listing 10-15: Una definición trabajando de la función <code>largest</code> que funciona en cualquier tipo genérico que implemente los <em>traits</em> <code>PartialOrd</code> y <code>Copy</code></span></p>
<p>Si no queremos restringir la función <code>largest</code> a los tipos que implementan el
<em>trait</em> <code>Copy</code>, podríamos especificar que <code>T</code> tenga <em>trait bound</em> <code>Clone</code> en
lugar de <code>Copy</code>. Entonces podríamos clonar cada valor en el <em>slice</em> cuando
queremos que la función <code>largest</code> tenga propiedad. Usar la función <code>clone</code>
significa que potencialmente estamos haciendo más asignaciones de <em>heap</em> en
el caso de tipos que poseen datos de montículo (<em>heap</em>) como <code>String</code>, y las
asignaciones de <em>heap</em> pueden ser lentas si estamos trabajando con grandes
cantidades de datos.</p>
<p>Otra forma en que podríamos implementar <code>largest</code> es que la función devuelva
una referencia a un valor <code>T</code> en el <em>slice</em>. Si cambiamos el tipo de retorno
a <code>&amp; T</code> en lugar de <code>T</code>, cambiando así el cuerpo de la función para devolver
una referencia, no necesitaríamos los límites <em>trait</em> (<em>trait bounds</em>)
<code>Clone</code> o <code>Copy</code> y podríamos evitar las asignaciones de <em>heap</em>. ¡Intente implementar estas soluciones alternativas por su cuenta!</p>
<h3 id="usar-límites-de-trait-trait-bounds-para-implementar-métodos-condicionalmente"><a class="header" href="#usar-límites-de-trait-trait-bounds-para-implementar-métodos-condicionalmente">Usar límites de <em>trait</em> (<em>Trait Bounds</em>) para implementar métodos condicionalmente</a></h3>
<p>Al usar un <em>trait</em> vinculado con un bloque <code>impl</code> que usa parámetros de tipo
genérico, podemos implementar métodos condicionalmente para tipos que
implementan los <em>traits</em> especificados. Por ejemplo, el tipo <code>Pair &lt;T&gt;</code> en el
Listado 10-16 siempre implementa la función <code>new</code>. Pero <code>Pair &lt;T&gt;</code> solo
implementa el método <code>cmp_display</code> si su tipo interno <code>T</code> implementa el
<em>trait</em> <code>PartialOrd</code> que permite la comparación <em>y</em> el <em>trait</em> <code>Display</code> que
permite la impresión.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-16: Implementar métodos condicionalmente en
un tipo genérico dependiendo de los <em>trait bounds</em></span></p>
<p>También podemos implementar condicionalmente un <em>trait</em> para cualquier tipo
que implemente otro <em>trait</em>. Las implementaciones de un <em>trait</em> en cualquier
tipo que satisfaga los límites de <em>traits</em> se denominan
<em>blanket implementations</em> (<em>implementaciones generales</em>) y se usan ampliamente en la biblioteca estándar de Rust. Por
ejemplo, la biblioteca estándar implementa el <em>trait</em> <code>ToString</code> en cualquier
tipo que implemente el <em>trait</em> <code>Display</code>. El bloque <code>impl</code> en la biblioteca
estándar se ve similar a este código:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Debido a que la biblioteca estándar tiene esta implementación general,
podemos llamar al método <code>to_string</code> definido por el <em>trait</em> <code>ToString</code> en
cualquier tipo que implemente el <em>trait</em> <code>Display</code>. Por ejemplo, podemos
convertir enteros en sus correspondientes valores <code>String</code> como este porque
los enteros implementan <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Las implementaciones generales aparecen en la documentación del <em>trait</em> en la sección “Implementadores”.</p>
<p><em>Traits</em> and <em>trait bounds</em> nos permiten escribir código que usa parámetros
de tipo genérico para reducir la duplicación pero también especifica al
compilador que queremos que el tipo genérico tenga un comportamiento
particular. El compilador puede usar la información de <em>trait bound</em> para
verificar que todos los tipos concretos utilizados con nuestro código
proporcionen el comportamiento correcto. En lenguajes tipados dinámicamente,
obtendríamos un error en el tiempo de ejecución si llamamos a un método en un
tipo que el tipo no implementó. Pero Rust mueve estos errores en tiempo de
compilación, por lo que nos vemos obligados a solucionar los problemas antes
de que nuestro código pueda ejecutarse. Además, no tenemos que escribir
código que verifique el comportamiento en el tiempo de ejecución porque ya lo
hemos comprobado en tiempo de compilación. Al hacerlo, mejora el rendimiento
sin tener que renunciar a la flexibilidad de los genéricos.</p>
<p>Otro tipo de genérico que ya hemos estado usando se llama <em>lifetimes</em>. En
lugar de garantizar que un tipo tenga el comportamiento que queremos, los
tiempos de vida (<em>lifetimes</em>) garantizan que las referencias sean válidas siempre que lo necesitemos. Veamos cómo <em>lifetimes</em> hacen eso.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
