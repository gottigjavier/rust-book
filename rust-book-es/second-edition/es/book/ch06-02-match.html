<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>El Operador de Estructuras de Control match - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html" class="active"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="el-operador-de-flujo-de-control-match"><a class="header" href="#el-operador-de-flujo-de-control-match">El operador de flujo de control <code>match</code></a></h2>
<p>Rust tiene un operador de flujo de control extremadamente poderoso llamado <code>match</code>
que le permite comparar un valor con una serie de patrones y luego ejecutar el código
según el patrón que coincida. Los patrones pueden estar formados por valores literales,
nombres de variables, comodines y muchas otras cosas; El Capítulo 18 cubre todos los diferentes
tipos de patrones y lo que hacen. El poder de <code>match</code> proviene de la expresividad de
los patrones y del hecho de que el compilador confirma que se manejan todos los casos posibles.</p>
<p>Piense en una expresión de <code>match</code> como una máquina clasificadora de monedas: las monedas se
deslizan por una pista con orificios de diferentes tamaños a lo largo de ella, y cada moneda
cae por el primer orificio que encuentra que encaja. De la misma manera, los valores pasan
por cada patrón en una coincidencia <code>match</code>, y en el primer patrón en el que el valor encaje,
el valor cae en el bloque de código asociado para ser utilizado durante la ejecución.</p>
<p>¡Debido a que acabamos de mencionar monedas, utilicémoslas como ejemplo usando <code>match</code>!
Podemos escribir una función que puede tomar una moneda desconocida de los Estados Unidos y,
de manera similar a la máquina de conteo, determinar qué moneda es y devolvera su valor en
centavos, como se muestra aquí en el Listado 6-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-3: Un enum y una expresión de <code>match</code> que
tiene las variantes de la enumeración como sus patrones</span></p>
<p>Vamos a desglosar el <code>match</code> en la función <code>value_in_cents</code>. Primero, listamos
la palabra clave <code>match</code> seguida de una expresión, que en este caso es el valor
<code>coin</code>. Esto parece muy similar a una expresión utilizada con <code>if</code>, pero hay una
gran diferencia: con <code>if</code>, la expresión necesita devolver un valor booleano, pero
aquí, puede ser de cualquier tipo. El tipo de <code>coin</code> en este ejemplo es el <em>enum</em> de
<code>coin</code> que definimos en la línea 1.</p>
<p>A continuación están los brazos del <code>match</code>. Un brazo tiene dos partes: un patrón y algo de código.
El primer brazo aquí tiene un patrón que es el valor <code>Coin::Penny</code> y luego el <code>=&gt; </code>
operador que separa el patrón y el código para ejecutar. El código en este caso
es solo el valor <code>1</code>. Cada brazo está separado del siguiente con una coma.</p>
<p>Cuando se ejecuta la expresión <code>match</code>, compara el valor resultante contra
el patrón de cada brazo, en orden. Si un patrón coincide con el valor, el código
asociado con ese patrón se ejecuta. Si ese patrón no coincide con el
valor, la ejecución continúa al siguiente brazo, al igual que en una máquina
clasificadora de monedas. Podemos tener tantas brazos como necesitemos:
en el Listado 6-3, nuestro <code>match</code> tiene cuatro brazos.</p>
<p>El código asociado con cada brazo es una expresión, y el valor resultante de
la expresión en el brazo correspondiente es el valor que se devuelve para el
expresión completa del <code>match</code>.</p>
<p>Las llaves normalmente no se usan si el código del <em>match</em> es corto, ya que
en el listado 6-3 donde cada brazo simplemente devuelve un valor. Si quieres ejecutar múltiples
líneas de código en un brazo de coincidencia, puede usar llaves. Por ejemplo, el
siguiente código imprimirá “Lucky penny!” cada vez que se llame al método con
un <code>Coin::Penny</code> pero aún devolvería el último valor del bloque, <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="patrones-que-se-unen-a-los-valores"><a class="header" href="#patrones-que-se-unen-a-los-valores">Patrones que se unen a los valores</a></h3>
<p>Otra característica útil de los brazos del <em>match</em> es que pueden unirse a las partes
de los valores que coinciden con el patrón. Así es como podemos extraer valores de las variantes <em>enum</em>.</p>
<p>Como ejemplo, cambiemos una de nuestras variantes <em>enum</em> para contener datos dentro de ella.
De 1999 a 2008, los Estados Unidos acuñaron cuartos con diferentes diseños para cada uno de
los 50 estados en un lado. Ninguna otra moneda tiene diseños de estado, por lo que solo
los cuartos tienen este valor adicional. Podemos agregar esta información a nuestro <code>enum</code>
cambiando la variante <code>Quarter</code> para incluir un valor <code>UsState</code> almacenado dentro de él,
lo que hemos hecho aquí en el Listado 6-4.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-4: Una enumeración de <code>Coin</code> en la cual la variante <code>Quarter</code>
también tiene un valor <code>UsState</code></span></p>
<p>Imaginemos que un amigo nuestro está tratando de reunir los 50 <em>Quarters</em> (<em>cuartos)</em> estatales.
Mientras clasificamos nuestro cambio suelto por tipo de moneda, también llamaremos el nombre
del estado asociado con cada <em>quarter</em>, por lo que si es uno que nuestro amigo no tiene,
pueden agregarlo a su colección.</p>
<p>En la expresión de coincidencia para este código, agregamos una variable llamada <code>state</code> al
patrón que coincide con los valores de la variante<code> Coin::Quarter</code>. Cuando coincide un <code>Coin::Quarter</code>,
la variable <code>state</code> se vinculará al valor del estado de ese <em>quarter</em>. 
Entonces podemos usar <code>state</code> en el código para ese brazo, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Si tuviéramos que llamar a <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>,
<code>coin</code> sería <code>Coin::Quarter(UsState::Alaska)</code>. Cuando comparamos ese valor
con cada uno de los brazos de coincidencia, ninguno de ellos coincide hasta
que llegamos a <code>Coin::Quarter(state)</code>. En ese punto, el enlace para <code>state</code>
será el valor <code>UsState::Alaska</code>. Entonces podemos usar ese enlace en la expresión
<code>println!</code>, Obteniendo así el valor de estado interno de la variante <em>enum</em>
<code>Coin</code> para <code>Quarter</code>.</p>
<h3 id="emparejando-con-optiont"><a class="header" href="#emparejando-con-optiont">Emparejando con <code>Option&lt;T&gt;</code></a></h3>
<p>En la sección anterior, queríamos obtener el valor interno de <code>T</code> fuera del caso <code>Some</code>
cuando usamos <code>Option &lt;T&gt;</code>; también podemos manejar <code>Option &lt;T&gt;</code> usando <code>match</code> como
lo hicimos con la enumeración <code>Coin</code>! En lugar de comparar monedas, compararemos
las variantes de <code>Option &lt;T&gt;</code>, pero la forma en que funciona la expresión <code>match</code>
sigue siendo la misma.</p>
<p>Digamos que queremos escribir una función que tenga una <code>Opción &lt;i32&gt;</code> y, si hay un
valor dentro, agrega 1 a ese valor. Si no hay un valor dentro, la función debe devolver
el valor <code>None</code> y no intentar realizar ninguna operación.</p>
<p>Esta función es muy fácil de escribir, gracias a <code>match</code>, y se verá como el Listado 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-5: Una función que usa una expresión <code>match</code> en un <code>Option &lt;i32&gt;</code></span></p>
<p>Examinemos la primera ejecución de <code>plus_one</code> con más detalle. Cuando llamamos a <code>plus_one(five)</code>,
la variable <code>x</code> en el cuerpo de <code>plus_one</code> tendrá el valor <code>Some(5)</code>. Luego lo
comparamos con cada brazo del <em>match</em>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>El valor <code>Some(5)</code> no coincide con el patrón <code>None</code>, por lo que continuamos al siguiente brazo.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>¿<code>Some(5)</code> coincide con <code>Some(i)</code>? Porque sí lo hace! Tenemos la misma variante.
El <code>i</code> se une al valor contenido en <code>Some</code>, entonces <code>i</code> toma el valor <code>5</code>.
El código en el brazo de coincidencia se ejecuta luego, por lo que agregamos 1 al
valor de <code>i</code> y creamos un nuevo valor <code>Some</code> con nuestro total de '6' dentro.</p>
<p>Ahora consideremos la segunda llamada de <code>plus_one</code> en el Listado 6-5,
donde <code>x</code> es <code>None</code>. Ingresamos al <code>match</code> y lo comparamos con el primer brazo.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>¡Coincide! No hay ningún valor para agregar, por lo que el programa se detiene y
devuelve el valor <code>None</code> en el lado derecho de <code>=&gt;</code>. Debido a que el primer brazo
coincide, no se comparan otros brazos.</p>
<p>Combinar <code>match</code> y <em>enums</em> es útil en muchas situaciones. Verá este patrón mucho
en el código Rust: <code>match</code> contra una enumeración, enlazará una variable a los datos
internos y luego ejecutará el código en función de ello. Es un poco complicado al
principio, pero una vez que se acostumbre, deseará tenerlo en todos los lenguajes.
Es constantemente un favorito del usuario.</p>
<h3 id="matches-are-exhaustive"><a class="header" href="#matches-are-exhaustive">Matches Are Exhaustive</a></h3>
<p>Hay otro aspecto de <code>match</code> que debemos discutir. Considere esta versión de
nuestra función <code>plus_one</code> que tiene un error y no compilará:</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>No manejamos el caso <code>None</code>, por lo que este código provocará un error.
Afortunadamente, es un error que Rust sabe atrapar. Si tratamos de compilar
este código, obtendremos este error:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>¡Rust sabe que no cubrimos todos los casos posibles e incluso sabemos qué patrón
olvidamos! Las coincidencias en Rust son <em>exhaustivas</em>: debemos agotar todas las
posibilidades para que el código sea válido. Especialmente en el caso de <code>Option &lt;T&gt;</code>,
cuando Rust evita que olvidemos manejar explícitamente el caso <code>None</code>,
nos protege de asumir que tenemos un valor cuando podríamos tener nulo, y
así cometer el error billonario Discutido antes.</p>
<h3 id="the-_-placeholder"><a class="header" href="#the-_-placeholder">The <code>_</code> Placeholder</a></h3>
<p>Rust también tiene un patrón que podemos usar cuando no queremos enumerar todos
los valores posibles. Por ejemplo, un <code>u8</code> puede tener valores válidos de 0 a 255.
Si solo nos importan los valores 1, 3, 5 y 7, no queremos tener que enumerar
0, 2, 4, 6, 8, 9 hasta 255. Afortunadamente, no es necesario: podemos usar el
patrón especial <code>_</code> en su lugar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>El patrón <code>_</code> coincidirá con cualquier valor. Al ponerlo después de nuestros otros
brazos, el <code>_</code> coincidirá con todos los casos posibles que no se hayan especificado
antes. El <code>()</code> es solo el valor unitario, por lo que no sucederá nada en el caso <code>_</code>.
Como resultado, podemos decir que no queremos hacer nada para todos los valores posibles
que no enumeramos antes del marcador de posición <code>_</code>.</p>
<p>Sin embargo, la expresión <code>match</code> puede ser un poco prolija en una situación en la
que solo nos importa <em>uno</em> de los casos. Para esta situación, Rust proporciona <code>if let</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
