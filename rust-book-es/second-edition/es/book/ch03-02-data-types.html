<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tipos de Datos - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Funciones Avanzadas y Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Pakabras Clave</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Características más Recientes</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de Datos</a></h2>
<p>Cada valor en Rust es de un determinado tipo de datos, lo que le dice a Rust qué tipo de datos se especifica para que sepa cómo trabajar con esos datos. Veremos dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<p>Tenga en cuenta que Rust es un lenguaje <em>estáticamente tipado</em>, lo que
significa que debe conocer los tipos de todas las variables en tiempo de
compilación. El compilador generalmente puede inferir qué tipo queremos usar
en función del valor y cómo lo usamos. En los casos en que son posibles
muchos tipos, como cuando convertimos un <code>String</code> a un tipo numérico usando
<code>parse</code> en la sección <a href="ch02-00-guessing-game-tutorial.html#comparando-la-conjetura-con-el-n%C3%BAmero-secreto">“Comparando la conjetura con el número secreto”</a> en el
Capítulo 2, debemos agregar una <em>anotación de tipo</em> (<em>type annotation</em>), como esta :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Si no agregamos la anotación de tipo <code>:u32</code> antes, Rust mostrará el siguiente error, lo que significa que el compilador necesita más información de parte nuestra para saber qué tipo queremos usar:</p>
<pre><code class="language-text">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>Verá anotaciones de tipo diferentes para otros tipos de datos.</p>
<h3 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos Escalares</a></h3>
<p>Un tipo <em>escalar</em> representa un solo valor. Rust tiene cuatro tipos escalares
básicos: enteros, números de punto flotante, booleanos y caracteres. Puede
reconocer estos de otros lenguajes de programación. Veamos cómo funcionan en
Rust.</p>
<h4 id="tipos-enteros-integer"><a class="header" href="#tipos-enteros-integer">Tipos <em>Enteros</em> (<em>Integer</em>)</a></h4>
<p>Un <em>entero</em> es un número sin un componente fraccionario. Usamos un tipo entero
en el Capítulo 2, el tipo <code>u32</code>. Esta declaración de tipo indica que el valor
con el que está asociado debe ser un entero sin signo (los tipos enteros con
signo comienzan con <code>i</code>, en lugar de <code>u</code>) que ocupan 32 bits de espacio. La
Tabla 3-1 muestra los tipos enteros incorporados en Rust. Podemos usar cualquiera de estas variantes para declarar el tipo de un valor entero.</p>
<p><span class="caption">Tabla 3-1: Tipos enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Cada variante puede ser &quot;con signo&quot; o &quot;sin signo&quot; y tiene un tamaño explícito. <em>Con signo</em> y <em>sin signo</em> se refieren a si es posible que el número sea negativo; en otras palabras, si el número debe tener un signo con él (<em>Signed</em>) o si solo será positivo y, por lo tanto, puede representarse sin signo (<em>Unsigned</em>). Es como escribir números en un papel: cuando el signo importa, un número se muestra con un signo más o un signo menos; sin embargo, cuando es seguro asumir que el número es positivo, se muestra <em>sin signo</em>. Los números <em>con signo</em> se almacenan usando la representación <a href="https://es.wikipedia.org/wiki/Complemento_a_dos">complemento a dos</a>.</p>
<p>Cada variante <em>con signo</em> puede almacenar números de -(2<sup>n - 1</sup>) a
2<sup>n - 1</sup> - 1 inclusive, donde <em>n</em> es el número de bits que utiliza la
variante. Entonces, un <code>i8</code> puede almacenar números de -(2<sup>7</sup>) a
2<sup>7</sup> - 1, lo que equivale de -128 a 127. Las variantes <em>sin signo</em>
pueden almacenar números de 0 al 2<sup>n</sup> - 1, por lo que un <code>u8</code> puede
almacenar números de 0 a 2<sup>8</sup> - 1, es decir, de 0 a 255.</p>
<p>Además, los tipos <code>isize</code> y <code>usize</code> dependen del tipo de computadora en la que
se ejecute el programa: 64 bits si está en una arquitectura de 64 bits y 32
bits si está en una arquitectura de 32 bits.</p>
<p>Puede escribir literales enteros en cualquiera de las formas que se muestran en la tabla 3-2. Tenga en cuenta que los literales numéricos que pueden ser varios tipos numéricos permiten un sufijo de tipo, como <code>57u8</code>, para designar el tipo. Los literales numéricos también pueden usar <code>_</code> como separador visual para que el número sea más fácil de leer, como <code>1_000</code>, que tendrá el mismo valor que si hubiera especificado <code>1000</code>.</p>
<p><span class="caption">Tabla 3-2: Literales enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Entonces, ¿cómo saber qué tipo de número entero usar? Si no está seguro, los valores predeterminados de Rust generalmente son buenas opciones. El tipo predeterminado para enteros es <code>i32</code>. La situación principal en la que usaría <code>isize</code> o <code>usize</code> es al indexar algún tipo de colección.</p>
<blockquote>
<p><strong>Desbordamiento de Enteros</strong></p>
<p>Digamos que tiene una variable de tipo <code>u8</code> que puede contener valores entre 0 y 255. 
Si intenta cambiar la variable a un valor fuera de ese rango, como como 256, ocurrirá un <em>desbordamiento de enteros</em>, lo que puede resultar en uno de dos comportamientos.</p>
<p>Cuando está compilando en modo de depuración, Rust incluye verificaciones de desbordamiento de enteros que hacen que su programa entre en <em>pánico</em> en tiempo de ejecución si ocurre este comportamiento. Rust usa el término entrar en pánico cuando un programa se cierra por un error. Discutiremos los <em>pánicos</em> con más profundidad en la sección <a href="ch09-01-unrecoverable-errors-with-panic.html">&quot;Errores Irrecuperables con panic!”</a> del capítulo 9.</p>
<p>Cuando esté compilando en modo de lanzamiento con la bandera <code>--release</code>, Rust no incluye comprobaciones de desbordamiento de enteros que causen pánico. En cambio, si se produce un desbordamiento, Rust realiza el ajuste de complemento a dos. En resumen, los valores mayores que el valor máximo que el tipo puede contener &quot;ajustan&quot; al mínimo de los valores que el tipo puede contener. En el caso de un <code>u8</code>, el valor 256 se convierte en 0, el valor 257 se convierte en 1, y así sucesivamente. El programa no entrará en pánico, pero la variable tendrá un valor que probablemente no sea el que esperaba tener. Confiar en el comportamiento de ajuste del desbordamiento de enteros se considera un error.</p>
<p>Para manejar explícitamente la posibilidad de desbordamiento, puede usar estas familias de métodos proporcionadas por la biblioteca estándar para tipos numéricos primitivos:</p>
<ul>
<li>Restrinja en todos los modos con los métodos <code>wrapping_*</code>, tales como <code>wrapping_add</code></li>
<li>Devuelva el valor <code>None</code> si hay desbordamiento con los métodos <code>checked_*</code></li>
<li>Devuelva el valor y un booleano que indica si hubo desbordamiento con los métodos <code>overflowing_*</code></li>
<li>Sature en los valores mínimo o máximo del valor con métodos <code>saturating_*</code></li>
</ul>
</blockquote>
<h4 id="tipos-de-punto-flotante"><a class="header" href="#tipos-de-punto-flotante">Tipos de Punto Flotante</a></h4>
<p>Rust también tiene dos tipos primitivos para <em>números de punto flotante</em>, que
son números con cifras decimales. Los tipos de punto flotante de Rust son
<code>f32</code> y <code>f64</code>, que son de 32 bits y 64 bits de tamaño, respectivamente. El
tipo predeterminado es <code>f64</code> porque en las CPU modernas se trata con más o menos la
misma velocidad que <code>f32</code>, pero es capaz de obtener más precisión. Todos los tipos de punto flotante son <em>con signo</em>.</p>
<p>Aquí hay un ejemplo que muestra los números de punto flotante en acción:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Los números de punto flotante se representan según el estándar IEEE-754. El
tipo <code>f32</code> es un <em>float</em> de precisión simple, y <code>f64</code> tiene doble precisión.</p>
<h4 id="operaciones-numéricas"><a class="header" href="#operaciones-numéricas">Operaciones Numéricas</a></h4>
<p>Rust soporta las operaciones matemáticas básicas que esperaría para todos los
tipos de números: adición, sustracción, multiplicación, división y residuo (resto de la división entera). La división de enteros se redondea al entero inferior más próximo. El siguiente código muestra cómo usaría cada uno en una declaración <code>let</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Cada expresión en estas declaraciones usa un operador matemático y la evalúa a un
solo valor, que luego se vincula a una variable. El <a href="appendix-02-operators.html">Apéndice B</a> contiene una lista de todos los operadores que Rust proporciona.</p>
<h4 id="el-tipo-booleano-boolean"><a class="header" href="#el-tipo-booleano-boolean">El Tipo <em>Booleano</em> (<em>Boolean</em>)</a></h4>
<p>Como en la mayoría de los demás lenguajes de programación, un tipo <em>booleano</em> en Rust tiene dos valores posibles: <code>true</code> y <code>false</code>. Los booleanos tienen un tamaño de un byte. El tipo <em>booleano</em> en Rust se especifica con <code>bool</code>. Por ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // con &quot;anotación de tipo&quot; explícita
}
</code></pre></pre>
<p>La forma principal de usar valores <em>booleanos</em> es mediante condicionales, como una expresión <code>if</code>. Cubriremos cómo funcionan las expresiones <code>if</code> en Rust en la sección <a href="ch03-05-control-flow.html">“Estructuras de Control”</a>.</p>
<h4 id="el-tipo-caracter"><a class="header" href="#el-tipo-caracter">El Tipo Caracter</a></h4>
<p>El tipo <code>char</code> de Rust es el tipo alfabético más primitivo del lenguaje. Aquí hay algunos ejemplos de cómo declarar valores <code>char</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // con &quot;anotación de tipo&quot; explícita
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Tenga en cuenta que el literal <code>char</code> se especifica con comillas simples, a diferencia de los literales <em>strings</em>, que usan comillas dobles. El tipo <code>char</code> de Rust tiene un tamaño de cuatro bytes y representa un valor escalar Unicode, lo que significa que puede representar mucho más que solo ASCII. Letras acentuadas; caracteres chinos, japoneses y coreanos; emoji; y los <em>espacios de ancho cero</em> son todos valores <code>char</code> válidos en Rust. Los valores escalares Unicode van desde <code>U + 0000</code> a <code>U + D7FF</code> y <code>U + E000</code> a <code>U + 10FFFF</code> inclusive. Sin embargo, un “caracter” no es realmente un concepto en Unicode, por lo que su intuición humana para lo que es un “caracter” puede no coincidir con lo que es un <code>char</code> en Rust. Discutiremos este tema en detalle en <a href="ch08-02-strings.html">“Almacenamiento de texto codificado en UTF-8 con Strings”</a> en el Capítulo 8.</p>
<h3 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos Compuestos</a></h3>
<p><em>Los tipos compuestos</em> pueden agrupar múltiples valores en un tipo. Rust tiene
dos tipos de compuestos primitivos: tuplas y arrays.</p>
<h4 id="el-tipo-tupla-tuple"><a class="header" href="#el-tipo-tupla-tuple">El tipo <em>Tupla</em> (<em>Tuple</em>)</a></h4>
<p>Una tupla es una forma general de agrupar juntos un número de valores con una variedad de tipos dentro de un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, no pueden crecer ni encogerse de tamaño.</p>
<p>Creamos una tupla escribiendo una lista de valores separados por comas dentro de un paréntesis. Cada posición en la tupla tiene un tipo, y los tipos de los diferentes valores en la tupla no tienen que ser iguales. Agregamos anotaciones de tipo opcionales en este ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>La variable <code>tup</code> se vincula a la tupla completa, porque una tupla se considera un
solo elemento compuesto. Para obtener los valores individuales de una tupla,
podemos usar la coincidencia de patrones para desestructurar un valor de tupla
como este:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>Este programa crea primero una tupla y la vincula a la variable <code>tup</code>. Luego
usa un patrón con <code>let</code> para tomar <code>tup</code> y convertirlo en tres variables
separadas, <code>x</code>, <code>y</code>, y <code>z</code>. Esto se llama <em>desestructuración</em>, porque divide
la tupla individual en tres partes. Finalmente, el programa imprime el valor
de <code>y</code>, que es <code>6.4</code>.</p>
<p>También podemos acceder a un elemento de tupla directamente usando un punto (<code>.</code>) seguido del índice del valor al que queremos acceder. Por ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Este programa crea la tupla, <code>x</code>, y luego crea nuevas variables para cada
elemento usando su índice. Como con la mayoría de los lenguajes de
programación, el primer índice en una tupla es 0.</p>
<p>La tupla sin ningún valor tiene un nombre especial: <em>unidad</em>. Este valor y su correspondiente tipo se escriben <code>()</code> y representan un valor vacío o un tipo de retorno vacío. Las expresiones devuelven implícitamente el valor <em>unidad</em> si no devuelven cualquier otro valor. </p>
<h4 id="el-tipo-array-arreglo-o-matriz"><a class="header" href="#el-tipo-array-arreglo-o-matriz">El tipo <em>Array</em> (<em>Arreglo o Matriz</em>)</a></h4>
<p>Otra forma de tener una colección de valores múltiples es con un <em>Array</em>. A diferencia de una tupla, cada elemento de un <em>array</em> debe tener el mismo tipo. A diferencia de algunos otros lenguajes, los <em>arrays</em> en Rust tienen una longitud fija: una vez declarados, no pueden crecer o reducirse de tamaño.</p>
<p>En Rust, los valores en un <em>array</em> se escriben como una lista separada por comas, entre corchetes:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Los arrays son útiles cuando quiere que sus datos se asignen en el <em>Stack</em> en
lugar de en el <em>Heap</em> (discutiremos más sobre <em>Stack</em> y <em>Heap</em> en el
<a href="ch04-01-what-is-ownership.html#la-pila-stack-y-el-mont%C3%ADculo-heap">Capítulo 4</a>) o cuando quiera asegurarse de tener siempre una cantidad fija de elementos. Sin embargo, un array no es tan flexible como el tipo vector. Un vector es un tipo de colección similar provisto por la biblioteca estándar <em>que</em> puede crecer o reducir su tamaño. Si no está seguro de utilizar un
array o un vector, probablemente debería usar un vector. El <a href="ch08-01-vectors.html">Capítulo 8</a>
discute los vectores con más detalle.</p>
<p>Sin embargo, los arrays son más útiles cuando sabe que no será necesario cambiar la cantidad de elementos. Por ejemplo, si estuviera usando los nombres de los meses en un programa, probablemente usaría un array en lugar de un vector porque sabe que siempre contendrá 12 elementos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Escriba el tipo de un array usando corchetes con el tipo de cada elemento, un punto y coma, y luego la cantidad de elementos en la matriz, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Aquí, <code>i32</code> es el tipo de cada elemento. Después del punto y coma, el número <code>5</code> indica que el array contiene cinco elementos.</p>
<p>También puede inicializar un array para que contenga el mismo valor para cada elemento especificando entre corchetes: el valor inicial, seguido de un punto y coma, y luego la longitud del array, como se muestra aquí:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>El array llamado <code>a</code> contendrá 5 elementos que se inicalizarán en el valor <code>3</code>. Esto es lo mismo que escribir <code>let a = [3, 3, 3, 3, 3];</code> pero de una manera más concisa.</p>
<h5 id="acceso-a-los-elementos-del-array"><a class="header" href="#acceso-a-los-elementos-del-array">Acceso a los Elementos del Array</a></h5>
<p>Un array es un fragmento único de memoria, de tamaño fijo conocido, que se puede asignar al <em>Stack</em>. Puede acceder a los elementos de un array mediante la indexación, así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>En este ejemplo, la variable llamada <code>first</code> obtendrá el valor <code>1</code>, porque ese
es el valor en el índice <code>[0]</code> del array. La variable llamada <code>second</code>
obtendrá el valor <code>2</code> del índice <code>[1]</code> del array.</p>
<h5 id="acceso-a-elementos-no-válidos-de-un-array"><a class="header" href="#acceso-a-elementos-no-válidos-de-un-array">Acceso a Elementos no válidos de un Array</a></h5>
<p>Veamos qué sucede si intenta acceder a un elemento de un array que está más allá del final del array. Supongamos que ejecuta este código, similar al juego de adivinanzas del Capítulo 2, para obtener del usuario un índice del array: </p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}
</code></pre>
<p>Este código se compila correctamente. Si ejecuta este código usando <code>cargo run</code> e ingresa 0, 1, 2, 3 o 4, el programa imprimirá el valor correspondiente a ese índice en el array. Si, en cambio, ingresa un número de índice después del final del array, como <code>10</code>, verá un resultado como este: </p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>El programa resultó en un <em>error en tiempo de ejecución</em> al momento de usar un valor no válido en la operación de indexación. El programa salió con un mensaje de error y no ejecutó la declaración final <code>println!</code>. Cuando intenta acceder a un elemento utilizando la indexación, Rust comprobará que el índice que ha especificado es menor que la longitud del array. Si el índice es mayor o igual que la longitud, Rust entrará en pánico. Esta verificación tiene que ocurrir en tiempo de ejecución, especialmente en este caso, porque el compilador no puede saber qué valor ingresará un usuario cuando se ejecute el código más tarde.</p>
<p>Este es un ejemplo de los principios de seguridad de la memoria de Rust en acción. En muchos lenguajes de bajo nivel, este tipo de verificación no se realiza, y cuando proporciona un índice incorrecto, se puede acceder a memoria no válida. Rust le protege contra este tipo de error al salir inmediatamente en lugar de permitir el acceso a la memoria y continuar. El Capítulo 9 analiza más sobre el manejo de errores de Rust y cómo puede escribir un código legible y seguro que no entre en pánico ni permita el acceso no válido a la memoria.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
