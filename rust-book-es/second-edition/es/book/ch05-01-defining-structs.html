<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Definiendo e Instanciando Structs - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html" class="active"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="definir-e-instanciar-structs"><a class="header" href="#definir-e-instanciar-structs">Definir e Instanciar <em>Structs</em></a></h2>
<p>Los <em>structs</em> son similares a las tuplas, discutidas en la sección <a href="ch03-02-data-types.html#el-tipo-tupla-tuple">&quot;El Tipo Tupla&quot;</a>, en el sentido de que ambos contienen múltiples valores relacionados. Al igual que las tuplas, las piezas de un <em>struct</em> pueden ser de diferentes tipos. A diferencia de las tuplas, en un <em>struct</em> nombrará cada dato para que quede claro lo que significan los valores. Agregar estos nombres significa que los <em>structs</em> son más flexibles que las tuplas: no tiene que confiar en el orden de los datos para especificar o acceder a los valores de una instancia.</p>
<p>Para definir un <em>struct</em>, ingresamos la palabra clave <code>struct</code> y nombramos el
<em>struct</em> completo. El nombre de un <em>struct</em> debe describir el significado de
las piezas de datos que se agrupan. Luego, dentro de las llaves, definimos los nombres
y tipos de los datos, que llamamos <em>campos</em>. Por ejemplo, el Listado 5-1 muestra
un <em>struct</em> que almacena información sobre una cuenta de usuario.</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 5-1: Definición del <em>struct</em> <code>User</code></span></p>
<p>Para usar un <em>struct</em> después de haberlo definido, creamos una <em>instancia</em> de ese <em>struct</em> especificando valores concretos para cada uno de los campos. Creamos una instancia indicando el nombre del <em>struct</em> y luego agregamos llaves que contienen pares <em>(clave: valor)</em> <code>key: value</code>, donde las claves son los nombres de los campos y los valores son los datos que queremos almacenar en esos campos. No tenemos que especificar los campos en el mismo orden en que los declaramos en el <em>struct</em>. En otras palabras, la definición de un <em>struct</em> es como una plantilla general para el tipo, y las instancias completan esa plantilla con datos particulares para crear valores de ese tipo. Por ejemplo, podemos declarar un usuario particular como se muestra en el Listado 5-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-2: Creando una instancia del <em>struct</em> <code>User</code></span></p>
<p>Para obtener un valor específico de un <em>struct</em>, usamos la notación de punto. Por ejemplo, para acceder a la dirección de correo electrónico de este usuario, usamos <code>user1.email</code>. Si la instancia es mutable, podemos cambiar un valor usando la notación de punto y la asignación en un campo particular. El listado 5-3 muestra cómo cambiar el valor en el campo <code>email</code> de una instancia <code>User</code> mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 5-3: Cambiar el valor en el campo <code>email</code> de una instancia <code>User</code></span></p>
<p>Tenga en cuenta que toda la instancia debe ser mutable; Rust no nos permite marcar solo ciertos campos como mutables. Al igual que con cualquier expresión, podemos construir una nueva instancia del <em>struct</em> como la última expresión en el cuerpo de la función para devolver implícitamente esa nueva instancia.</p>
<p>El listado 5-4 muestra una función <code>build_user</code> que devuelve una instancia <code>User</code> con el correo electrónico y el nombre de usuario dados. El campo <code>active</code> obtiene el valor de <code>true</code>, y <code>sign_in_count</code> obtiene un valor de <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-4: Una función <code>build_user</code> que toma un correo electrónico y un nombre de usuario y devuelve una instancia <code>User</code></span></p>
<p>Tiene sentido nombrar los parámetros de la función con el mismo nombre que los campos del <em>struct</em>, pero tener que repetir los nombres y variables de campo <code>email</code> y<code> username</code> es un poco tedioso. Si el <em>struct</em> tuviera más campos, repetir cada nombre sería aún más molesto. Afortunadamente, ¡hay una abreviatura conveniente!</p>
<h3 id="uso-de-field-init-shorthand"><a class="header" href="#uso-de-field-init-shorthand">Uso de <em>Field Init Shorthand</em></a></h3>
<p>Debido a que los nombres de los parámetros y los nombres de los campos del <em>struct</em> son
exactamente los mismos en el Listado 5-4, podemos usar la sintaxis <em>field init shorthand</em> (<em>abreviación de inicio de campo</em>) para reescribir <code>build_user</code> y así se comporte exactamente igual pero no tenga la repetición <code>email</code> y <code>username</code>, como se muestra en el Listado 5-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-5: Una función <code>build_user</code> que usa <em>field init shorthand</em> porque los parámetros<code> email</code> y <code>username</code> tienen el mismo nombre que los campos struct</span></p>
<p>Aquí, estamos creando una nueva instancia del <em>struct</em> <code>User</code>, que tiene un campo llamado <code>email</code>. Queremos establecer el valor del campo <code>email</code> al valor en el parámetro <code>email</code> de la función <code>build_user</code>. Debido a que el campo <code>email</code> y el parámetro <code>email</code> tienen el mismo nombre, solo necesitamos escribir <code>email</code> en lugar de <code>email: email</code>.</p>
<h3 id="crear-instancias-desde-otras-instancias-con-la-sintaxis-de-actualización-de-struct"><a class="header" href="#crear-instancias-desde-otras-instancias-con-la-sintaxis-de-actualización-de-struct">Crear Instancias desde Otras Instancias con la Sintaxis de Actualización de Struct</a></h3>
<p>A menudo es útil crear una nueva instancia de un <em>struct</em> que utiliza la mayoría de los valores de una instancia anterior, pero cambia algunos. Pude hacer esto usando <em>struct update syntax</em> (sintaxis de actualización de struct).</p>
<p>Primero, en el Listado 5-6 mostramos cómo crear una nueva instancia <code>User</code> en <code>user2</code>
normalmente, sin la sintaxis de actualización. Establecemos un nuevo valor para <code>email</code> pero para los demás campos usamos los mismos valores de <code>user1</code> que creamos en el Listado 5-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre></pre>
<p><span class="caption">Listing 5-6: Creando una nueva instancia de <code>User</code> usando valores de <code>user1</code></span></p>
<p>Usando <em>struct update syntax</em>, podemos lograr el mismo efecto con menos código, como se muestra en el listado 5-7. La sintaxis <code>..</code> especifica que los campos restantes no establecidos explícitamente deben tener el mismo valor que los campos en la instancia dada.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}
</code></pre></pre>
<p><span class="caption">Listing 5-7: Usar <em>struct update syntax</em> para establecer el nuevo
valor de <code>email</code> para una instancia <code>User</code>, pero usar el resto de los valores de los campos de la instancia desde la variable <code>user1</code></span></p>
<p>El código del Listado 5-7 también crea una instancia en <code>user2</code> que tiene un valor diferente para <code>email</code>, pero tiene los mismos valores para los campos <code>username</code>, <code>active</code> y <code>sign_in_count</code> de <code>user1</code>. La línea <code>..user1</code> debe ser la última para especificar que los campos restantes deben obtener sus valores de los campos correspondientes en <code>user1</code>, pero podemos optar por especificar valores para tantos campos como queramos en cualquier orden, independientemente del orden de los campos en la definición de la estructura.</p>
<p>Tenga en cuenta que <em>struct update syntax</em> usa <code>=</code> como una asignación; esto se debe a que mueve los datos, tal como vimos en la sección <a href="ch04-01-what-is-ownership.html#formas-en-que-interact%C3%BAan-las-variables-y-los-datos-mover">“Formas en que Interactúan las Variables y los Datos: mover”</a>. En este ejemplo, ya no podemos usar <code>user1</code> después de crear <code>user2</code> porque el <code>String</code> en el campo <code>username</code> de <code>user1</code> se movió a <code>user2</code>. Si le hubiéramos dado a <code>user2</code> nuevos valores <code>String</code> para <code>email</code> y <code>username</code> y, por lo tanto, solo usáramos los valores <code>active</code> y <code>sign_in_count</code> de <code>user1</code>, entonces <code>user1</code> seguiría siendo válido después de crear <code>user2</code>. Los tipos de <code>active</code> y <code>sign_in_count</code> son tipos que implementan el <em>trait</em> Copiar, por lo que se aplicaría el comportamiento que discutimos en la sección <a href="ch04-01-what-is-ownership.html#datos-de-s%C3%B3lo-pila-copiar">&quot;Datos de Sólo-Pila: Copiar&quot;</a>.</p>
<h3 id="usar-tuple-structs-sin-campos-nombrados-para-crear-diferentes-tipos"><a class="header" href="#usar-tuple-structs-sin-campos-nombrados-para-crear-diferentes-tipos">Usar <em>Tuple Structs</em> sin Campos Nombrados para Crear Diferentes Tipos</a></h3>
<p>Rust también admite estructuras que se parecen a las tuplas, llamadas <em>tuple structs</em> (<em>estructuras de tupla</em>). Las <em>tuple structs</em> tienen el significado adicional que proporciona el nombre del <em>struct</em>, pero no tienen nombres asociados con sus campos; más bien, solo tienen los tipos de los campos. Las <em>tuple structs</em> son útiles cuando se quiere dar un nombre a la tupla completa y hacer que la tupla sea un tipo diferente de otras tuplas, y cuando nombrar cada campo como en un <em>struct</em> regular sería detallado o redundante.</p>
<p>Para definir una <em>tuple struct</em>, comience con la palabra clave <code>struct</code> y el nombre del <em>struct</em> seguido de los tipos en la tupla. Por ejemplo, aquí hay definiciones y usos de dos <em>tuple structs</em> denominadas <code>Color</code> y <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<p>Tenga en cuenta que los valores <code>black</code> y <code>origin</code> son de tipos diferentes, porque son instancias de diferentes <em>tuple structs</em>. Cada <em>struct</em> que define es de su propio tipo, aunque los campos dentro del <em>struct</em> tienen los mismos tipos. Por ejemplo, una función que toma un parámetro de tipo <code>Color</code> no puede tomar un <code>Point</code> como argumento, aunque ambos tipos están compuestos por tres valores <code>i32</code>. Por otro lado, las instancias de <em>tuple struct</em> son similares a las tuplas en el sentido de que puede desestructurarlas en sus piezas individuales, y puede usar un <code>.</code> seguido del índice para acceder a un valor individual.</p>
<h3 id="unit-like-structs-structs-sin-ningún-campo"><a class="header" href="#unit-like-structs-structs-sin-ningún-campo"><em>Unit-Like Structs</em>. Structs sin Ningún Campo</a></h3>
<p>¡También puede definir <em>structs</em> que no tienen ningún campo! Estos se denominan <em>unit-like structs</em> (<em>estructuras similares a unidades</em>) porque se comportan de manera similar a (), el tipo <em>unit</em> (<em>unidad</em>) que mencionamos al final de la sección <a href="ch03-02-data-types.html#el-tipo-tupla-tuple">&quot;El Tipo Tupla&quot;</a>. Los <em>unit-like structs</em> pueden ser útiles cuando necesita implementar un <em>trait</em> en algún tipo pero no tiene ningún dato que desee almacenar en el tipo en sí. Hablaremos de los <em>traits</em><sup class="footnote-reference"><a href="#1">1</a></sup> en el Capítulo 10. Aquí hay un ejemplo de cómo declarar e instanciar un <em>unit struct</em> <em>(estructura unidad)</em> llamado <code>AlwaysEqual</code>:</p>
<pre><code class="language-rust ignore">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre>
<p>Para definir <code>AlwaysEqual</code>, usamos la palabra clave <code>struct</code>, el nombre que queremos, luego un punto y coma. ¡No hay necesidad de corchetes o paréntesis! Entonces podemos obtener una instancia de <code>AlwaysEqual</code> en la variable <code>subject</code> de una manera similar: usando el nombre que definimos, sin corchetes ni paréntesis. Imagine que más adelante implementaremos un comportamiento para este tipo, de modo que cada instancia de <code>AlwaysEqual</code> siempre sea igual a cada instancia de cualquier otro tipo, tal vez para tener un resultado conocido con fines de prueba. ¡No necesitaríamos ningún dato para implementar ese comportamiento! Verá en el Capítulo 10 cómo definir <em>traits</em> e implementarlos en cualquier tipo, incluidas las <em>unit-like structs</em>.</p>
<blockquote>
<h3 id="propiedad-de-los-datos-de-un-struct"><a class="header" href="#propiedad-de-los-datos-de-un-struct">Propiedad de los Datos de un Struct</a></h3>
<p>En la definición del <em>struct</em> <code>User</code> en el listado 5-1, utilizamos el tipo
<code>String</code> para la propiedad en lugar del tipo <em>string slice</em> <code>&amp;str</code>. Esta es
una elección deliberada porque queremos que cada instancia de este
<em>struct</em> sea propietaria de todos sus datos y que los datos sean
válidos mientras el <em>struct</em> completo sea válido.</p>
<p>Es posible que los <em>structs</em> almacenen referencias a datos que son propiedad
de otra cosa, pero para hacerlo se requiere el uso de <em>lifetimes</em>, una
característica de Rust que discutiremos en el Capítulo 10. Lifetimes
garantiza que los datos a los que hace referencia un <em>struct</em> son
válidos mientras el <em>struct</em> lo sea. Digamos que intenta almacenar
una referencia en un <em>struct</em> sin especificar <em>lifetimes</em>, como esta, que
no funcionará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>El compilador se quejará de que necesita especificadores <em>lifetime</em>:</p>
<pre><code class="language-text">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>En el Capítulo 10, discutiremos cómo solucionar estos errores para que pueda
almacenar referencias en <em>structs</em>, pero por ahora, corregiremos errores como
estos utilizando tipos propios como <code>String</code> en lugar de referencias como <code>&amp;str</code>.</p>
</blockquote>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> <small>Nota del traductor: por el momento, puede asemejar los <em>traits</em> a lo que son las <em>intefaces</em> en otros lenguajes, aunque luego se verán las diferencias.</small></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
