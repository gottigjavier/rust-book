<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defining and Instantiating Structs - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References & Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html" class="active"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Referring to Names in Different Modules</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; Points to Data on the Heap and Has a Known Size</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects that Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions & Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning our Single Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="definir-e-instanciar-structs"><a class="header" href="#definir-e-instanciar-structs">Definir e Instanciar <em>Structs</em></a></h2>
<p>Los <em>structs</em> son similares a las <em>tuples</em>, que se discutieron en el Capítulo 3.
Al igual que las <em>tuples</em>, las piezas de un <em>structs</em> pueden ser de tipos diferentes.
A diferencia de las <em>tuples</em>, nombrará cada dato para que quede claro lo que significan
los valores. Como resultado de estos nombres, los <em>structs</em> son más flexibles que las
<em>tuples</em>: no tiene que depender del orden de los datos para especificar o acceder a
los valores de una instancia.</p>
<p>Para definir un <em>structs</em>, ingresamos la palabra clave <code>struct</code> y nombramos el
<em>structs</em> completa. El nombre de un <em>structs</em> debe describir el significado de
las piezas de datos que se agrupan. Luego, dentro de las llaves, definimos los nombres
y tipos de los datos, que llamamos <em>campos</em>. Por ejemplo, el Listado 5-1 muestra
un <em>structs</em> que almacena información sobre una cuenta de usuario.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-1: Definición del <em>struct</em> <code>User</code></span></p>
<p>Para usar un <em>struct</em> después de haberlo definido, creamos una <em>instancia</em>
de ese <em>struct</em> especificando valores concretos para cada uno de los campos.
Creamos una instancia indicando el nombre del <em>struct</em> y luego agregamos
llaves que contienen pares <code>key: value</code>, donde las claves son los nombres de los
campos y los valores son los datos que queremos almacenar en esos campos. No
tenemos que especificar los campos en el mismo orden en que los declaramos en
el <em>struct</em>. En otras palabras, la definición de un <em>structs</em> es como una plantilla
general para el tipo, y las instancias completan esa plantilla con datos particulares
para crear valores del tipo. Por ejemplo, podemos declarar un usuario particular
como se muestra en el Listado 5-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-2: Creando una instancia de <code>User</code>
struct</span></p>
<p>Para obtener un valor específico de un <em>struct</em>, podemos usar la notación de
puntos. Si quisiéramos solo la dirección de correo electrónico de este usuario,
podríamos usar <code>user1.email</code> donde quisiéramos utilizar este valor. Si la instancia
es mutable, podemos cambiar un valor usando la notación de puntos y la asignación
en un campo particular. El listado 5-3 muestra cómo cambiar el valor en el campo
<code>email</code> de una instancia <code>User</code> mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-3: Cambiar el valor en el campo <code>email</code> de una instancia <code>User</code></span></p>
<p>Tenga en cuenta que toda la instancia debe ser mutable; Rust no nos permite
marcar solo ciertos campos como mutables. Al igual que con cualquier expresión,
podemos construir una nueva instancia del <em>struct</em> como la última expresión
en el cuerpo de la función para devolver implícitamente esa nueva instancia.</p>
<p>El listado 5-4 muestra una función <code>build_user</code> que devuelve una instancia <code>User</code>
con el correo electrónico y el nombre de usuario dados. El campo <code>activo</code> obtiene
el valor de <code>true</code>, y <code>sign_in_count</code> obtiene un valor de <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-4: Una función <code>build_user</code> que toma un correo electrónico y un nombre de usuario y devuelve una instancia <code>User</code></span></p>
<p>Tiene sentido nombrar los parámetros de la función con el mismo nombre que
los campos de un <em>struct</em>, pero tener que repetir los nombres y variables de
campo <code>email</code> y<code> username</code> es un poco tedioso. Si el <em>struct</em> tuviera más
campos, repetir cada nombre sería aún más molesto. Afortunadamente,
¡hay una taquigrafía conveniente!</p>
<h3 id="uso-de-la-abreviatura-field-init-cuando-las-variables-y-los-campos-tienen-el-mismo-nombre"><a class="header" href="#uso-de-la-abreviatura-field-init-cuando-las-variables-y-los-campos-tienen-el-mismo-nombre">Uso de la abreviatura <em>Field Init</em> cuando las variables y los campos tienen el mismo nombre</a></h3>
<p>Debido a que los nombres de los parámetros y los nombres de los campos <em>struct</em> son
exactamente los mismos en el Listado 5-4, podemos usar la sintaxis <em>field init shorthand</em>
para reescribir <code>build_user</code> para que se comporte exactamente igual pero no tenga la repetición
<code>email</code> y <code>username</code>, como se muestra en el Listado 5-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-5: Una función <code>build_user</code> que usa <em>field init shorthand</em>
porque los parámetros<code> email</code> y <code>username</code> tienen el mismo nombre
que los campos struct</span></p>
<p>Aquí, estamos creando una nueva instancia de la estructura (<em>struct</em>) <code>User</code>, que tiene un campo
llamado <code>email</code>. Queremos establecer el valor del campo <code>email</code> al valor en el parámetro
<code>email</code> de la función <code>build_user</code>. Debido a que el campo <code>email</code> y el parámetro <code>email</code>
tienen el mismo nombre, solo necesitamos escribir <code>email</code> en lugar de <code>email: email</code>.</p>
<h3 id="crear-instancias-desde-otras-instancias-con-la-sintaxis-de-actualización-de-struct"><a class="header" href="#crear-instancias-desde-otras-instancias-con-la-sintaxis-de-actualización-de-struct">Crear instancias desde otras instancias con la sintaxis de actualización de Struct</a></h3>
<p>A menudo es útil crear una nueva instancia de una estructura que utiliza la mayoría de
los valores de una instancia anterior, pero cambia algunos. Harás esto usando
<em>struct update syntax</em>.</p>
<p>Primero, el Listado 5-6 muestra cómo creamos una nueva instancia <code>User</code> en <code>user2</code>
sin la sintaxis de actualización. Establecimos nuevos valores para <code>email</code> y <code>username</code>
pero de lo contrario usamos los mismos valores de <code>user1</code> que creamos en el Listado 5-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let user1 = User {
</span><span class="boring">    email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">    username: String::from(&quot;someusername123&quot;),
</span><span class="boring">    active: true,
</span><span class="boring">    sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-6: Creando una nueva instancia de <code>User</code>
usando algunos de los valores de <code>user1</code></span></p>
<p>Usando la sintaxis de actualización de <em>struct</em>, podemos lograr el mismo efecto
con menos código, como se muestra en el listado 5-7. La sintaxis <code>..</code> especifica
que los campos restantes no configurados explícitamente deben tener el mismo valor
que los campos en la instancia dada.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let user1 = User {
</span><span class="boring">    email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">    username: String::from(&quot;someusername123&quot;),
</span><span class="boring">    active: true,
</span><span class="boring">    sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-7: Usar <em>struct update syntax</em> para establecer nuevos
valores de <code>email</code> y <code>username</code> para una instancia <code>User</code>, pero use el resto de los
valores de los campos de la instancia en la variable <code>user1</code></span></p>
<p>El código en el Listado 5-7 también crea una instancia en <code>user2</code> que tiene un valor
diferente para <code>email</code> y <code>username</code> pero tiene los mismos valores para los campos
<code>active</code> y <code>sign_in_count</code> de <code>user1</code>.</p>
<h3 id="usar-tuple-structs-sin-campos-con-nombre-para-crear-diferentes-tipos"><a class="header" href="#usar-tuple-structs-sin-campos-con-nombre-para-crear-diferentes-tipos">Usar <em>Tuple Structs</em> sin campos con nombre para crear diferentes tipos</a></h3>
<p>También puede definir estructuras que se parecen a las tuplas, llamadas
<em>tuple
structs</em> (<em>estructuras de tupla</em>). Las estructuras Tupla tienen el significado añadido que
proporciona el nombre de la estructura, pero no tienen nombres asociados con sus
campos; más bien, solo tienen los tipos de los campos. Las estructuras Tupla son
útiles cuando se quiere dar un nombre a la tupla completa y hacer que la tupla sea
un tipo diferente que otras tuplas, y nombrar cada campo como en una estructura
regular sería detallado o redundante.</p>
<p>Para definir una estructura de tupla, comience con la palabra clave <code>struct</code> y
el nombre de la estructura seguido de los tipos en la tupla. Por ejemplo, aquí
hay definiciones y usos de dos estructuras de tupla denominadas <code>Color</code> y <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>Tenga en cuenta que los valores <code>black</code> y <code>origin</code> son de tipos diferentes,
porque son instancias de diferentes estructuras de tupla. Cada estructura que
define es de su propio tipo, aunque los campos dentro de la estructura tienen
los mismos tipos. Por ejemplo, una función que toma un parámetro de tipo <code>Color</code>
no puede tomar un <code>Point</code> como argumento, aunque ambos tipos están compuestos
por tres valores <code>i32</code>. De lo contrario, las instancias de tupla struct se
comportan como tuplas: puede desestructurarlas en sus piezas individuales,
puede usar un <code>.</code> seguido del índice para acceder a un valor individual,
y así sucesivamente.</p>
<h3 id="unit-like-estructura-sin-ningún-campo"><a class="header" href="#unit-like-estructura-sin-ningún-campo"><em>Unit-Like</em> Estructura sin ningún campo</a></h3>
<p>¡También puedes definir estructuras que no tienen ningún campo! Estos se denominan
<em>unit-like structs</em> porque se comportan de manera similar a <code>()</code>,
el tipo de unidad. <em>Unit-like structs</em> pueden ser útiles en situaciones en
las que necesita implementar un rasgo en algún tipo pero no tiene ningún dato que desee
almacenar en el tipo mismo. Discutiremos los rasgos en el Capítulo 10.</p>
<blockquote>
<h3 id="ownership-of-struct-data"><a class="header" href="#ownership-of-struct-data">Ownership of Struct Data</a></h3>
<p>En la definición de estructura <code>User</code> en el listado 5-1, utilizamos el tipo
<code>String</code> propiedad en lugar del tipo de sección de cadena <code>&amp;str</code>. Esta es
una elección deliberada porque queremos que las instancias de esta
estructura sean propietarias de todos sus datos y que los datos sean
válidos mientras toda la estructura sea válida.</p>
<p>Es posible que las estructuras almacenen referencias a datos propiedad
de otra cosa, pero para hacerlo se requiere el uso de <em>lifetimes</em>, una
característica de Rust que discutiremos en el Capítulo 10. Lifetimes
garantiza que los datos a los que hace referencia una estructura son
válidos para siempre que la estructura sea Digamos que intenta almacenar
una referencia en una estructura sin especificar vidas, como esta, que
no funcionará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>El compilador se quejará de que necesita especificadores <em>lifetime</em>:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>En el Capítulo 10, discutiremos cómo solucionar estos errores para que pueda
almacenar referencias en estructuras, pero por ahora, corregiremos errores como
estos utilizando tipos propios como <code>String</code> en lugar de referencias como <code>&amp;str</code>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
