<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Graceful Shutdown and Cleanup - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References & Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Referring to Names in Different Modules</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; Points to Data on the Heap and Has a Known Size</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects that Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions & Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning our Single Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html" class="active"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="elegante-shutdown-y-cleanup"><a class="header" href="#elegante-shutdown-y-cleanup">Elegante <em>Shutdown</em> y <em>Cleanup</em></a></h2>
<p>El código en el listado 20-21 responde a las solicitudes de forma asincrónica
mediante el uso de un <em>thread pool</em>, como pretendíamos. Recibimos algunas
advertencias sobre los campos <code>workers</code>, <code>id</code>, y <code>thread</code> que no estamos
usando de manera directa que nos recuerda que no estamos limpiando nada.
Cuando utilizamos el método menos elegante
<span class="keystroke">ctrl-c</span> para detener el hilo principal, todos
los demás hilos también se detienen inmediatamente, incluso si están en medio
de atender una solicitud.</p>
<p>Ahora implementaremos el <em>trait</em> <code>Drop</code> para llamar <code>join</code> en cada uno de los
<em>threads</em> en el <em>pool</em> para que puedan finalizar las solicitudes en las que
están trabajando antes de cerrar. Luego implementaremos una forma de decirle
a los hilos que deben dejar de aceptar nuevas solicitudes y cerrar. Para ver
este código en acción, modificaremos nuestro servidor para que acepte solo
dos solicitudes antes de cerrar correctamente su <em>thread pool</em>.</p>
<h3 id="implementando-el-trait-drop-en-threadpool"><a class="header" href="#implementando-el-trait-drop-en-threadpool">Implementando el <em>Trait</em> <code>Drop</code> en <code>ThreadPool</code></a></h3>
<p>Comencemos implementando <code>Drop</code> en nuestro <em>thread pool</em>. Cuando se abandona
el <em>pool</em>, nuestros hilos deben unirse para asegurarse de que terminen su
trabajo. El listado 20-23 muestra un primer intento de implementación de un
<code>Drop</code>; este código aún no funcionará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-23: Unirse a cada subproceso cuando el
<em>thread pool</em> se sale del alcance</span></p>
<p>Primero, recorremos cada uno de los <em>thread pool</em> de <code>workers</code>. Usamos
<code>&amp;mut</code> para esto porque <code>self</code> es una referencia mutable, y también
necesitamos poder mutar <code>worker</code>. Para cada <em>worker</em>, imprimimos un mensaje
que dice que este <em>worker</em> en particular se está cerrando, y luego llamamos
<code>join</code> en el hilo de ese <em>worker</em>. Si la llamada a <code>join</code> falla, usamos
<code>unwrap</code> para hacer que Rust se inunde y entrar en un apagado desvergonzado.</p>
<p>Aquí está el error que obtenemos cuando compilamos este código:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>El error nos dice que no podemos llamar <code>join</code> porque solo tenemos un
préstamo mutable de cada <code>worker</code> y <code>join</code> toma posesión de su argumento.
Para resolver este problema, debemos mover el hilo de la instancia <code>Worker</code>
que posee <code>thread</code> para que <code>join</code> pueda consumir el hilo. Hicimos esto en el
Listado 17-15: si <code>Worker</code> tiene una <code>Option&lt;thread::JoinHandle&lt;()&gt;</code> en su
lugar, podemos llamar al método <code>take</code> en <code>Option</code> para mover el valor de la
variante <code>Some</code> y dejar un una variante <code>None</code> en su lugar. En otras palabras
un <code>Worker</code> que se ejecuta tendrá una variante <code>Some</code> en <code>thread</code>, y cuando
queremos limpiar un <code>Worker</code>, reemplazaremos <code>Some</code> por <code>None</code> de modo que el
<code>Worker</code> no tenga un hilo para ejecutar.</p>
<p>Entonces sabemos que queremos actualizar la definición de <code>Worker</code> de esta
manera:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora apoyémonos en el compilador para encontrar los otros lugares que
necesitan cambiar. Al revisar este código, obtenemos dos errores:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>Vamos a abordar el segundo error, que apunta al código al final de
<code>Worker::new</code>; necesitamos envolver el valor <code>thread</code> en <code>Some</code> cuando
creamos un nuevo <code>Worker</code>. Realice los siguientes cambios para corregir este
error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>El primer error está en nuestra implementación <code>Drop</code>. Anteriormente
mencionamos que teníamos la intención de llamar a <code>take</code> en el valor
<code>Option</code> para mover <code>thread</code> de <code>worker</code>. Los siguientes cambios lo harán:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>Como se discutió en el Capítulo 17, el método <code>take</code> en <code>Option</code> saca la
variante <code>Some</code> y deja <code>None</code> en su lugar. Estamos usando <code>if let</code> para
desestructurar el <code>Some</code> y obtener el hilo; entonces llamamos <code>join</code> en el
hilo. Si el hilo de un <em>worker</em> ya es <code>None</code>, sabemos que el <em>worker</em> ya ha
limpiado el hilo, por lo que no ocurre nada en ese caso.</p>
<h3 id="señalización-a-los-threads--para-dejar-de-escuchar-jobs"><a class="header" href="#señalización-a-los-threads--para-dejar-de-escuchar-jobs">Señalización a los <em>Threads</em>  para dejar de escuchar <em>Jobs</em></a></h3>
<p>Con todos los cambios que hemos realizado, nuestro código se compila sin
advertencias. Pero la mala noticia es que este código aún no funciona como
queremos. La clave es la lógica en los <em>closures</em> ejecutados por los hilos de
las instancias <code>Worker</code>: en este momento, llamamos <code>join</code>, pero eso no
cerrará los hilos porque <code>loop</code> siempre buscan <em>jobs</em>. Si intentamos soltar
nuestro <code>ThreadPool</code> con nuestra implementación actual de <code>drop</code>, el hilo
principal se bloqueará para siempre esperando a que termine el primer hilo.</p>
<p>Para solucionar este problema, modificaremos los hilos para que escuchen la
ejecución de <code>Job</code> o una señal de que deben dejar de escuchar y salir del
ciclo infinito. En lugar de instancias <code>Job</code>, nuestro canal enviará una de
estas dos variantes <em>enum</em>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Job;
</span>enum Message {
    NewJob(Job),
    Terminate,
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta enumeración <code>Message</code> será una variante <code>NewJob</code> que contiene el <code>Job</code>
que debe ejecutar el hilo, o será una variante <code>Terminate</code> que hará que el
hilo salga de su ciclo y se detenga.</p>
<p>Necesitamos ajustar el canal para usar valores de tipo <code>Mensaje</code> en lugar de
escribir <code>Job</code>, como se muestra en el Listado 20-24.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-24: Enviar y recibir valores <code>Message</code> y
salir del bucle si un <code>Worker</code> recibe <code>Message::Terminate</code></span></p>
<p>Para incorporar el <em>enum</em> <code>Message</code>, necesitamos cambiar <code>Job</code> a <code>Message</code> en
dos lugares: la definición de <code>ThreadPool</code> y la firma de <code>Worker::new</code>. El
método <code>execute</code> de <code>ThreadPool</code> necesita enviar <em>jobs wrapped</em> envueltos en
la variante <code>Message::NewJob</code>. Luego, en <code>Worker::new</code> donde se recibe un
<code>Message</code> desde el canal, el trabajo será procesado si se recibe la variante
<code>NewJob</code>, y el hilo se saldrá del ciclo si la variante <code>Terminate</code> es
recibida.</p>
<p>Con estos cambios, el código se compilará y continuará funcionando de la
misma forma que lo hizo después del Listado 20-21. Pero recibiremos una
advertencia porque no estamos creando ningún mensaje de la variedad
<code>Terminate</code>. Arreglemos esta advertencia cambiando nuestra implementación
<code>Drop</code> para que se vea como el Listado 20-25.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-25: Enviar <code>Message::Terminate</code> a los
<em>workers</em> antes de llamar <code>join</code> en cada hilo de <em>worker</em></span></p>
<p>Ahora estamos iterando sobre los <em>workers</em> dos veces: una para enviar un
mansaje <code>Terminate</code> para cada <em>worker</em> y una vez para llamar <code>join</code> en el
hilo de cada <em>worker</em>. Si nosotros intentado enviar un mensaje y
<code>join</code> inmediatamente en el mismo ciclo, no pudimos
garantizar que el <em>worker</em> en la iteración actual sea el que obtenga el
mensaje del canal</p>
<p>Para comprender mejor por qué necesitamos dos bucles separados, imagine un
escenario con dos <em>workers</em>, si usamos un solo ciclo para iterar a través de
cada <em>worker</em>, en la primera iteración, un mensaje de finalización se enviará
por el canal y el <code>join</code> llamado en el hilo del primer <em>worker</em>. Si ese
primer <em>worker</em> estaba ocupado procesando una solicitud en ese momento, el
segundo <em>worker</em> tomaría el mensaje de terminación del canal y se apagaría.
Nos quedaríamos esperando que el primer <em>worker</em> cerrara, pero nunca lo haría
porque el segundo hilo recogió el mensaje de terminación. ¡Punto muerto!</p>
<p>Para evitar este escenario, primero colocamos todos nuestros mensajes
<code>Terminate</code> en el canal en un bucle; luego unimos todos los hilos en otro
ciclo. Cada <em>worker</em> dejará de recibir solicitudes en el canal una vez que
reciba un mensaje de terminación. Por lo tanto, podemos estar seguros de que
si enviamos la misma cantidad de mensajes de terminación porque hay <em>workers</em>
cada <em>worker</em> recibirá un mensaje de terminación antes de que se llame a
<code>join</code> en su hilo.</p>
<p>Para ver este código en acción, modifiquemos <code>main</code> para aceptar solo dos
solicitudes antes de cerrar con gracia el servidor, como se muestra en el
Listado 20-26.</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<p><span class="caption">Listado 20-26: Apague el servidor después de atender
dos solicitudes saliendo del ciclo</span></p>
<p>No querrías que un servidor web del mundo real se apagara después de servir
solo dos solicitudes. Este código solo demuestra que el cierre y la limpieza
elegantes funcionan correctamente.</p>
<p>El método <code>take</code> se define en el <em>trait</em> <code>Iterator</code> y limita la iteración a
los dos primeros elementos como máximo. El <code>ThreadPool</code> saldrá del alcance a
final de <code>main</code>, y se ejecutará la implementación <code>drop</code>.</p>
<p>Inicie el servidor con <code>cargo run</code>, y realice tres solicitudes. La tercera
solicitud debería generar un error, y en su terminal debería ver un resultado
similar al siguiente:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Es posible que vea un pedido diferente de <em>workers</em> y mensajes impresos.
Podemos ver cómo funciona este código a partir de los mensajes: los
<em>workers</em> 0 y 3 obtuvieron las dos primeras solicitudes y luego, en la
tercera solicitud, el servidor dejó de aceptar las conexiones. Cuando e
<code>ThreadPool</code> sale del ámbito de aplicación al final de <code>main</code>, su
implementación <code>Drop</code> entra en acción y el <em>pool</em> ordena a todos los
<em>workers</em> que finalicen. Cada uno de los <em>workers</em> imprime un mensaje cuando
ven el mensaje de terminación, y luego el <em>thread pool</em> llama a <code>join</code> para
cerrar cada <em>worker thread</em>.</p>
<p>Observe un aspecto interesante de esta ejecución en particular: el
<code>ThreadPool</code> envió los mensajes de terminación al canal, y antes de que
cualquier <em>worker</em> recibiera los mensajes, intentamos unirnos al <em>worker</em> 0.
El <em>worker</em> 0 aún no había recibido el mensaje de terminación, por lo que el
hilo principal bloqueado esperando que el <em>worker</em> 0 termine. Mientras tanto,
cada uno de los workers recibió los mensajes de terminación. Cuando el
<em>worker</em> 0 finalizó, el hilo principal esperó a que el resto de los workers
terminara. En ese momento, todos habían recibido el mensaje de terminación y
pudieron cerrar.</p>
<p>¡Felicidades! Ya hemos completado nuestro proyecto; tenemos un servidor web
básico que usa un <em>thread pool</em> para responder de forma asincrónica. Podemos
realizar un cierre elegante del servidor, que limpia todos los hilos del
<em>pool</em>.</p>
<p>Aquí está el código completo para referencia:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>¡Podríamos hacer más aquí! Si desea continuar mejorando este proyecto, aquí
hay algunas ideas:</p>
<ul>
<li>Agregue más documentación a <code>ThreadPool</code> y sus métodos públicos.</li>
<li>Agregar pruebas de la funcionalidad de la biblioteca.</li>
<li>Cambie las llamadas a <code>unwrap</code> para un manejo de errores más robusto.</li>
<li>Use <code>ThreadPool</code> para realizar alguna tarea que no sea servir solicitudes
web.</li>
<li>Encuentra un <em>crate</em> de <em>thread pool</em> en <em>https://crates.io/</em> e implemente
un servidor web similar utilizando el <em>crate</em> en su lugar. Luego, compare su
API y su robustez con el <em>thread pool</em> que implementamos.</li>
</ul>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>¡Bien hecho! ¡Has llegado al final del libro! Queremos agradecerle por
unirse a nosotros en esta gira de Rust. Ahora está listo para implementar sus
propios proyectos de Rust y ayudar con los proyectos de otras personas. Tenga
en cuenta que hay una comunidad acogedora de otros <em>Rustaceans</em>
que les encantaría ayudarlo con cualquier desafío que encuentre en su viaje en
Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-multithreaded.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="appendix-00.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-multithreaded.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="appendix-00.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
