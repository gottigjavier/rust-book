<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paso de Mensajes - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html" class="active"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="uso-message-passing-para-transferir-datos-entre-hilos"><a class="header" href="#uso-message-passing-para-transferir-datos-entre-hilos">Uso <em>Message Passing</em> para transferir datos entre hilos</a></h2>
<p>Un enfoque cada vez más popular para garantizar la concurrencia segura es
<em>message passing</em>, donde los hilos o actores se comunican enviándose mensajes
que contienen datos. Aquí está la idea en un lema de
<a href="http://golang.org/doc/effective_go.html">the Go language documentation</a>:  &quot;Do not communicate by sharing memory; instead, share memory by communicating&quot;.</p>
<p>Una herramienta importante que Rust tiene para lograr la concurrencia deenvío de mensajes es el <em>channel</em>, un concepto de programación que la biblioteca
estándar de Rust proporciona implementación de. Puedes imaginar un canal en
la programación como algo así como un canal de agua, como un arroyo o un río.
Si pones algo así como pato de goma o barco en una corriente, viajará río
abajo hasta el final de la camino acuático.</p>
<p>Un canal en programación tiene dos mitades: un transmisor y un receptor. los
La mitad del transmisor es la ubicación aguas arriba donde se colocan patos
de goma en el río, y la mitad del receptor es donde el pato de goma termina
río abajo. Uno parte de su código llama métodos en el transmisor con los
datos que desea enviar, y otra parte verifica el destinatario para los
mensajes que llegan. Se dice que el canal está <em>cerrado</em> si la mitad del transmisor o del receptor está caído.</p>
<p>Aquí, trabajaremos en un programa que tiene un hilo para generar valores y
enviarlos por un canal, y otro hilo que recibirá los valores y
imprimirlos. Vamos a enviar valores simples entre hilos usando un canal
para ilustrar la característica. Una vez que esté familiarizado con la
técnica, podría usa canales para implementar un sistema de chat o un sistema
donde se realizan muchos subprocesos partes de un cálculo y enviar las partes
a un hilo que agrega el resultados.</p>
<p>Primero, en el listado 16-6, crearemos un canal pero no haremos nada con él.
Tenga en cuenta que esto aún no se compilará porque Rust no puede decir qué
tipo de valores quiero enviar por el canal.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
<span class="boring">    tx.send(()).unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">Listado 16-6: Creando un canal y asignando las dos
mitades a <code>tx</code> y <code>rx</code></span></p>
<p>Creamos un nuevo canal usando la función <code>mpsc::channel</code>; <code>mpsc</code> significa
<em>productor múltiple, consumidor único</em>
(<em>multiple producer, single consumer</em>). En resumen, la forma en que la
biblioteca estándar de Rust implementa canales significa que un canal puede
tener múltiples <em>envíos</em> finales que producen valores pero solo un
<em>receptor</em> final que consume esos valores. Imagina que varias corrientes
fluyen juntas en un gran río: todo lo que se envíe a través de cualquiera de
las corrientes terminará en un río al final. Comenzaremos con un solo
productor por ahora, pero agregaremos varios productores cuando este ejemplo
funcione.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>La función <code>mpsc::channel</code> devuelve una tupla, cuyo primer elemento es el
extremo que envía y el segundo elemento es el extremo receptor. Las
abreviaturas <code>tx</code> y <code>rx</code> se usan tradicionalmente en muchos campos para
<em>transmisor</em> y <em>receptor</em> respectivamente, por lo que nombramos nuestras
variables como tales para indicar cada extremo. Estamos usando una
declaración <code>let</code> con un patrón que destruye las tuplas; discutiremos el uso
de patrones en sentencias <code>let</code> y la desestructuración en el Capítulo 18.
Usar una declaración <code>let</code> de esta manera es un enfoque conveniente para
extraer las piezas de la tupla devuelta por <code>mpsc::channel</code>.</p>
<p>Movamos el extremo transmisor a un hilo generado y hagamos que envíe una
cadena para que el hilo engendrado se comunique con el hilo principal, como
se muestra en el Listado 16-7. Esto es como poner un pato de goma en el río
río arriba o enviar un mensaje de chat de un hilo a otro.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Listado 16-7: Mover <code>tx</code> a un hilo generado y enviar
“hi”</span></p>
<p>De nuevo, estamos usando <code>thread::spawn</code> para crear un nuevo hilo y luego
usando <code>move</code> para mover <code>tx</code> al <em>closure</em> para que el hilo generado tenga
<code>tx</code>. El subproceso generado necesita poseer el extremo de transmisión del
canal para poder enviar mensajes a través del canal.</p>
<p>El extremo transmisor tiene un método de <code>send</code> que toma el valor que
queremos enviar. El método <code>send</code> devuelve un tipo <code>Result &lt;T, E&gt;</code>, por lo
que si el extremo receptor ya se ha eliminado y no hay ningún lugar para
enviar un valor, la operación de envío devolverá un error. En este ejemplo,
llamamos <code>unwrap</code> al pánico en caso de error. Pero en una aplicación real, lo
manejaríamos correctamente: regrese al Capítulo 9 para revisar estrategias
para el manejo correcto de errores.</p>
<p>En el listado 16-8, obtendremos el valor del extremo receptor del canal en el
hilo principal. Esto es como recuperar el pato de goma del agua al final del
río o como recibir un mensaje de chat.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Listado 16-8: Recibir el valor “hi” en el hilo
principal e imprimirlo</span></p>
<p>El extremo receptor de un canal tiene dos métodos útiles: <code>recv</code> y
<code>try_recv</code>. Estamos usando <code>recv</code>, abreviatura de <em>receive</em>, que bloqueará la
ejecución del hilo principal y esperará hasta que se envíe un valor por el
canal. Una vez que se envía un valor, <code>recv</code> lo devolverá en un
<code>Result &lt;T, E&gt;</code>. Cuando el extremo emisor del canal se cierra, <code>recv</code>
devolverá un error para indicar que no vendrán más valores.</p>
<p>El método <code>try_recv</code> no bloquea, sino que devuelve inmediatamente un
<code>Result &lt;T, E&gt;</code>: un valor <code>Ok</code> que contiene un mensaje si hay uno disponible
y un valor <code>Err</code> si no hay ningún mensaje esta vez. El uso de <code>try_recv</code> es
útil si este hilo tiene otro trabajo pendiente mientras se esperan mensajes:
podríamos escribir un ciclo que llame <code>try_recv</code> de vez en cuando, maneje un
mensaje si hay uno disponible y haga otro trabajo por un tiempo hasta que
vuelva a verificar.</p>
<p>Hemos usado <code>recv</code> en este ejemplo por simplicidad; no tenemos otro trabajo
para el hilo principal que no sea esperar mensajes, por lo que es apropiado
bloquear el hilo principal.</p>
<p>Cuando ejecutamos el código en el listado 16-8, veremos el valor impreso
desde el hilo principal:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>¡Perfecto!</p>
<h3 id="canales-y-transferencia-de-propiedad"><a class="header" href="#canales-y-transferencia-de-propiedad">Canales y transferencia de propiedad</a></h3>
<p>Las reglas de <em>propiedad</em> (<em>ownership</em>) juegan un papel vital en el envío de
mensajes porque lo ayudan a escribir código seguro y simultáneo. La
prevención de errores en la programación concurrente es la ventaja de pensar
sobre la propiedad en todos sus programas de Rust. Hagamos un experimento
para mostrar cómo los canales y la propiedad trabajan juntos para evitar
problemas: trataremos de usar un valor <code>val</code> en el hilo generado <em>después</em> de
que lo hayamos enviado por el canal. Intente compilar el código en el listado
16-9 para ver por qué este código no está permitido:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Listado 16-9: Intentando usar <code>val</code> después de enviarlo
por el canal</span></p>
<p>Aquí, tratamos de imprimir <code>val</code> después de enviarlo por el canal a través
de <code>tx.send</code>. Permitir esto sería una mala idea: una vez que el valor ha sido
enviado a otro hilo, ese hilo podría modificarlo o soltarlo antes de intentar
usar el valor nuevamente. Potencialmente, las modificaciones del otro
subproceso podrían causar errores o resultados inesperados debido a datos
inconsistentes o inexistentes. Sin embargo, Rust nos da un error si tratamos
de compilar el código en el Listado 16-9:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<p>Nuestro error de concurrencia ha causado un error de tiempo de compilación.
La función <code>send</code> toma posesión de su parámetro, y cuando se mueve el valor,
el receptor se apropia de él. Esto nos impide volver a usar accidentalmente
el valor después de enviarlo; el sistema de propiedad comprueba que todo está
bien.</p>
<h3 id="enviar-múltiples-valores-y-ver-el-receptor-esperando"><a class="header" href="#enviar-múltiples-valores-y-ver-el-receptor-esperando">Enviar múltiples valores y ver el receptor esperando</a></h3>
<p>El código en el listado 16-8 se compiló y ejecutó, pero no nos mostró
claramente que dos hilos separados estaban hablando entre sí a través del
canal. En el listado 16-10 hicimos algunas modificaciones que demostrarán que
el código en el listado 16-8 se está ejecutando simultáneamente: el hilo
generado ahora enviará múltiples mensajes y se detendrá por un segundo entre
cada mensaje.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 16-10: Envío de mensajes múltiples y pausas
entre cada uno</span></p>
<p>Esta vez, el hilo generado tiene un vector de <em>strings</em> que queremos enviar
al hilo principal. Realizamos iteraciones sobre ellos, enviando cada uno
individualmente, y hacemos una pausa entre cada uno llamando a la función
<code>thread::sleep</code> con un valor <code>Duration</code> de 1 segundo.</p>
<p>En el hilo principal, no estamos llamando a la función <code>recv</code> explícitamente
más: en su lugar, estamos tratando <code>rx</code> como un iterador. Para cada valor
recibido, lo estamos imprimiendo. Cuando el canal está cerrado, la iteración
finalizará.</p>
<p>Al ejecutar el código en el listado 16-10, debería ver el siguiente resultado
con una pausa de 1 segundo entre cada línea:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Debido a que no tenemos ningún código que haga una pausa o se retrase en el
ciclo <code>for</code> en el hilo principal, podemos decir que el hilo principal está
esperando recibir los valores del hilo generado.</p>
<h3 id="creando-múltiples-productores-clonando-el-transmisor"><a class="header" href="#creando-múltiples-productores-clonando-el-transmisor">Creando múltiples productores clonando el transmisor</a></h3>
<p>Anteriormente mencionamos que <code>mpsc</code> era un acrónimo de
<em>productor múltiple, consumidor único</em>
(<em>multiple producer, single consumer</em>). Pongamos <code>mpsc</code> para usar y expandir
el código en el Listado 16-10 para crear múltiples hilos que envíen valores
al mismo receptor. Podemos hacerlo clonando la mitad transmisora del canal,
como se muestra en el listado 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 16-11: Envío de múltiples mensajes de múltiples
productores</span></p>
<p>Esta vez, antes de crear el primer hilo generado, llamamos <code>clone</code> en el
extremo de envío del canal. Esto nos dará un nuevo identificador de envío que
podemos pasar al primer hilo generado. Pasamos el final de envío original del
canal a un segundo hilo generado. Esto nos da dos hilos, cada uno enviando
mensajes diferentes al extremo receptor del canal.</p>
<p>Cuando ejecuta el código, su resultado debería verse más o menos así:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Puede ver los valores en otro orden; depende de tu sistema. Esto es lo que
hace que la concurrencia sea interesante y difícil. Si experimentas con
<code>thread::sleep</code>, dándole varios valores en los diferentes hilos, cada
ejecución será más no determinista y creará resultados diferentes cada vez.</p>
<p>Ahora que hemos analizado cómo funcionan los canales, veamos un método
diferente de concurrencia.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-01-threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch16-03-shared-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-01-threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch16-03-shared-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
