<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Strings - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Cómo Trabajan las Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Partes (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis de lo Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Haciendo Referencia a Nombres en Distintos Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html" class="active"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Trait: Acceso a los Datos a través de una Referencia</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Funciones Avanzadas y Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Pakabras Clave</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Características más Recientes</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="almacenamiento-de-texto-codificado-en-utf-8-con-strings"><a class="header" href="#almacenamiento-de-texto-codificado-en-utf-8-con-strings">Almacenamiento de texto codificado en UTF-8 con <em>Strings</em></a></h2>
<p>Hablamos sobre <em>strings</em> de caracteres en el Capítulo 4, pero las veremos con
más profundidad ahora. Los nuevos Rustaceans comúnmente se atascan en los
<em>strings</em> por una combinación de tres razones: la propensión de Rust a
exponer posibles errores, los <em>strings</em> son una estructura de datos más
complicada de lo que muchos programadores les dan crédito, y UTF-8. Estos
factores se combinan de una manera que puede parecer difícil cuando proviene
de otros lenguajes de programación.</p>
<p>Es útil analizar los <em>strings</em> en el contexto de las colecciones porque los
<em>strings</em> se implementan como una colección de bytes, además de algunos
métodos para proporcionar una funcionalidad útil cuando esos bytes se
interpretan como texto. En esta sección, hablaremos sobre las operaciones en
<code>String</code> que tiene cada tipo de colección, como crear, actualizar y leer.
También discutiremos las formas en que <code>String</code> es diferente de las otras
colecciones, es decir, cómo la indexación en un <code>String</code> se complica por las
diferencias entre la forma en que las personas y las computadoras interpretan
los datos de <code>String</code>.</p>
<h3 id="qué-es-un-string"><a class="header" href="#qué-es-un-string">¿Qué es un <em>String</em>?</a></h3>
<p>Primero definiremos lo que queremos decir con el término <em>string</em>. Rust solo
tiene un tipo de <em>string</em> en el nucleo del lenguaje, que es el segmento de
<em>string</em> <code>str</code> que se ve generalmente en su forma prestada <code>&amp; str</code>. En el
Capítulo 4, hablamos sobre <em>string slices</em>, que son referencias a algunos
datos de <em>string</em> codificados en UTF-8 almacenados en otro lugar. <em>String</em>
literales, por ejemplo, se almacenan en la salida binaria del programa y son
por lo tanto, secciones de <em>string</em>.</p>
<p>El tipo <code>String</code>, proporcionado por la biblioteca estándar de Rust en lugar de
codificado en el lenguaje central, es un código UTF-8 creable, mutable, de
propiedad, tipo de <em>string</em> codificado. Cuando los Rustaceos se refieren a
<em>string</em> en Rust, generalmente se refieren a lo tipos <code>String</code> y los <em>string
slice</em> <code>&amp;str</code>, no solo uno de esos tipos.
Aunque esta sección trata principalmente sobre <code>String</code>, ambos tipos se usan
mucho en la biblioteca estándar de Rust, y tanto <code>String</code> como las <em>string
slice</em> están codificadas en UTF-8.</p>
<p>La biblioteca estándar de Rust también incluye varios otros tipos de <em>string</em>,como <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, y <code>CStr</code>. Los <em>library crates</em> pueden
proporcionar incluso más opciones para almacenar datos de <em>string</em>. ¿Ve cómo todos esos nombres terminan en <code>String</code> o <code>Str</code>? Se refieren a variantes
propias y prestadas, al igual que el tipo <code>String</code> y <code>str</code> que has visto
anteriormente. Estos tipos de <em>string</em> pueden almacenar texto en diferentes
codificaciones o ser representado en la memoria de una manera diferente, por
ejemplo. No discutiremos estos otros tipos de <em>string</em> en este capítulo; ver
su documentación API para obtener más información sobre cómo usarlos y cuándo
es cada uno apropiado.</p>
<h3 id="creando-un-nuevo-string"><a class="header" href="#creando-un-nuevo-string">Creando un nuevo <em>string</em></a></h3>
<p>Muchas de las mismas operaciones disponibles con <code>Vec &lt;T&gt;</code> están disponibles con <code>String</code> también, comenzando con la función <code>new</code> para crear una <em>string</em> que se muestra en el Listado 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-11: Creando un nuevo <code>String</code> vacío </span></p>
<p>Esta línea crea un nuevo <em>string</em> vacío llamado <code>s</code>, en el que luego podemos
cargar datos. A menudo, tendremos algunos datos iniciales con los que
queremos comenzar el <em>string</em>. Para eso, usamos el método <code>to_string</code>, que
está disponible en cualquier tipo que implemente el <em>trait</em> <code>Display</code>, como
lo hacen los literales <em>string</em>. El Listado 8-12 muestra dos ejemplos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = &quot;initial contents&quot;;

let s = data.to_string();

// el método también funciona en un literal directamente:
let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-12: Usando el método <code>to_string</code> para crear
un <code>String</code> a partir de un <em>string</em> literal </span></p>
<p>Este código crea un <em>string</em> que contiene <code>initial contents</code>.</p>
<p>También podemos usar la función <code>String::from</code> para crear un <code>String</code> a
partir de un <em>string</em> literal. El código en el Listado 8-13 es equivalente al
código del Listado 8-12 que usa <code>to_string</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-13: Usando la función <code>String::from</code> para
crear un <code>String</code> a partir de un <em>string</em> literal</span></p>
<p>Como los <em>string</em> se utilizan para muchas cosas, podemos usar muchas API
genéricas diferentes para <em>string</em>, lo que nos brinda muchas opciones.
Algunos de ellos pueden parecer redundantes, ¡pero todos tienen su lugar! En
este caso, <code>String::from</code> y <code>to_string</code> hacen lo mismo, por lo que eligir uno u otro es una cuestión de estilo.</p>
<p>Recuerde que los <em>string</em> están codificadas en UTF-8, por lo que podemos
incluir cualquier información codificada correctamente en ellas, como se
muestra en el Listado 8-14.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-14: Almacenando de saludos en diferentes
idiomas en <em>string</em></span></p>
<p>Todos estos son valores válidos de <code>String</code>.</p>
<h3 id="actualizar-un-string"><a class="header" href="#actualizar-un-string">Actualizar un <em>String</em></a></h3>
<p>Un <code>String</code> puede crecer en tamaño y su contenido puede cambiar, al igual que
el contenido de un <code>Vec &lt;T&gt;</code>, si inserta más datos en él. Además, puede usar
convenientemente el operador <code>+</code> o la macro <code>format!</code> Para concatenar los
valores <code>String</code>.</p>
<h4 id="añadiendo-a-un-string-con-push_str-y-push"><a class="header" href="#añadiendo-a-un-string-con-push_str-y-push">Añadiendo a un <em>String</em> con <code>push_str</code> y <code>push</code></a></h4>
<p>Podemos hacer crecer un <code>String</code> utilizando el método <code>push_str</code> para añadir
un segmento de <em>string</em>, como se muestra en el Listado 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-15: Agregar un segmento de <em>string</em> a un
<code>String</code> usando el método <code>push_str</code></span></p>
<p>Después de estas dos líneas, <code>s</code> contendrá <code>foobar</code>. El método <code>push_str</code>
toma un segmento de un <em>string</em> porque no necesariamente queremos tomar
posesión del parámetro. Por ejemplo, el código en el Listado 8-16 muestra que
sería desafortunado si no pudiéramos usar <code>s2</code> después de agregar sus
contenidos a <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-16: Usando un segmento de <em>string</em> después de
añadir su contenido a un <code>String</code></span></p>
<p>Si el método <code>push_str</code> se apropiara de <code>s2</code>, no podríamos imprimir su valor
en la última línea. Sin embargo, este código funciona como esperábamos.</p>
<p>El método <code>push</code> toma un solo carácter como parámetro y lo agrega a <code>String</code>.
El Listado 8-17 muestra un código que agrega la letra <em>l</em> a un <code>String</code>
utilizando el método <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-17: Agregar un carácter a un valor <code>String</code>
con <code>push</code></span></p>
<p>Como resultado de este código, <code>s</code> contendrá <code>lol</code>.</p>
<h4 id="concatenación-con-el-operador--o-la-macro-format"><a class="header" href="#concatenación-con-el-operador--o-la-macro-format">Concatenación con el operador <code>+</code> o la Macro <code>format!</code></a></h4>
<p>A menudo, querrás combinar dos <em>string</em> existentes. Una forma es usar el operador <code>+</code>, como se muestra en el Listado 8-18.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // nota s1 se ha movido aquí y ya no se puede usar
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-18: Usando el operador <code>+</code> para combinar dos
valores <code>String</code> en un nuevo valor 'String`</span></p>
<p>El <em>string</em> <code>s3</code> contendrá <code>Hello, world!</code> como resultado de este código. El
motivo <code>s1</code> ya no es válido después de la adición y el motivo por el que
usamos una referencia a <code>s2</code> tiene que ver con la firma del método que se
llama cuando usamos el operador <code>+</code>. El operador <code>+</code> usa el método <code>add</code>,
cuya firma se ve más o menos así:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta no es la firma exacta que está en la biblioteca estándar: en la
biblioteca estándar, <code>add</code> se define usando genéricos. Aquí, estamos viendo
la firma de <code>add</code> con tipos de concreto sustituidos por los genéricos, que es
lo que sucede cuando llamamos a este método con valores <code>String</code>.
Discutiremos los genéricos en el Capítulo 10. Esta firma nos da las pistas
que necesitamos para comprender las partes difíciles del operador <code>+</code>.</p>
<p>Primero, <code>s2</code> tiene un <code>&amp;</code>, lo que significa que estamos agregando una
<em>referencia</em> de el segundo <em>string</em> a la primera <em>string</em> debido al parámetro <code>s</code>
en la función <code>add</code>: solo podemos agregar un <code>&amp; str</code>a un <code>String</code>; no podemos
agregar dos valores <code>String</code> juntos. Pero espera, el tipo de <code>&amp;s2</code> es
<code>&amp; String</code>, no <code>&amp;str</code>, como se especifica en el segundo parámetro para <code>add</code>. Entonces, ¿por qué compila el Listado 8-18?</p>
<p>La razón por la que podemos usar <code>&amp;s2</code> en la llamada a <code>add</code> es que el
compilador puede <em>forzar</em> el argumento <code>&amp;String</code> en un <code>&amp;str</code>. Cuando
llamamos al método <code>add</code>, Rust usa una coerción <em>deref</em>, que aquí convierte
<code>&amp;s2</code> en <code>&amp;s2[..]</code>. Analizaremos la coerción de <em>deref</em> con más profundidad
en el Capítulo 15. Como <code>add</code> no toma posesión del parámetro <code>s</code>, <code>s2</code>
seguirá siendo un <code>String</code> válido después de esta operación.</p>
<p>En segundo lugar, podemos ver en la firma que <code>add</code> toma posesión de <code>self</code>,
porque <code>self</code> <em>no</em> tiene un <code>&amp;</code>. Esto significa que <code>s1</code> en el Listado 8-18
se moverá a la llamada <code>add</code> y ya no será válido después de eso. Entonces,
aunque <code>let s3 = s1 + &amp;s2;</code> parece que copiará ambos <em>strings</em> y creará una
nueva, esta declaración toma posesión de <code>s1</code>, agrega una copia del contenido
de <code>s2</code>, y luego devuelve la propiedad de el resultado. En otras palabras,parece que está haciendo muchas copias pero no lo está; la implementación es más eficiente que la copia.</p>
<p>Si necesitamos concatenar varias <em>strings</em>, el comportamiento del operador <code>+</code>
se vuelve difícil de manejar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>En este punto, <code>s</code> será <code>tic-tac-toe</code>. Con todos los caracteres <code>+</code> y <code>&quot;</code>,
es difícil ver qué está sucediendo. Para una combinación de <em>string</em> más
complicada, podemos usar la macro <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Este código también establece <code>s</code> en <code>tic-tac-toe</code>. La macro <code>format!</code>
funciona de la misma manera que <code>println!</code>, pero en lugar de imprimir la
salida a la pantalla, devuelve un <code>String</code> con los contenidos. La versión del
código que utiliza <code>format!</code> es mucho más fácil de leer y no toma posesión de
ninguno de sus parámetros.</p>
<h3 id="indexación-en-strings"><a class="header" href="#indexación-en-strings">Indexación en <em>Strings</em></a></h3>
<p>En muchos otros lenguajes de programación, el acceso a caracteres
individuales en un <em>string</em> haciendo referencia a ellos por índice es una
operación válida y común. Sin embargo, si intenta acceder a partes de un
<code>String</code> usando la sintaxis de indexación en Rust, obtendrá un error.
Considere el código inválido en el Listado 8-19.</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p><span class="caption">Listing 8-19: Intentando utilizar la sintaxis de indexación con un String</span></p>
<p>Este código dará como resultado el siguiente error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>El error y la nota cuentan la historia: los <em>string</em> de Rust no son
compatibles con la indexación. ¿Pero por qué no? Para responder a esa
pregunta, debemos analizar cómo Rust almacena <em>strings</em>en la memoria.</p>
<h4 id="representación-interna"><a class="header" href="#representación-interna">Representación interna</a></h4>
<p>Un <code>String</code> es un contenedor sobre un <code>Vec &lt;u8&gt;</code>. Veamos algunas de nuestros
<em>string</em> de ejemplo UTF-8 codificadas correctamente del Listado 8-14. Primero
este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Hola&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<p>En este caso, <code>len</code> será 4, lo que significa que el vector que almacena el
<em>string</em> “Hola” tiene 4 bytes de longitud. Cada una de estas letras toma 1
byte cuando está codificada en UTF-8. Pero, ¿qué pasa con la siguiente línea?
(Tenga en cuenta que este <em>string</em> comienza con la letra cirílica mayúscula Ze,
no el número árabe 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Здравствуйте&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<p>Si se pregunta, cuán largo es el <em>string</em>, podría decir 12. Sin embargo,la respuesta de Rust es 24: ese es el número de bytes que se necesita para
codificar &quot;Здравствуйте&quot; en UTF-8, ya que cada valor escalar Unicode toma 2
bytes de almacenamiento. Por lo tanto, un índice en los bytes del <em>string</em> no
siempre se correlacionará con un valor escalar Unicode válido. Para demostrar,considere este código de Rust no válido:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>¿Cuál debería ser el valor de <code>answer</code>? ¿Debería ser <code>З</code>, la primera letra?
Cuando está codificado en UTF-8, el primer byte de <code>З</code> es <code>208</code> y el segundo
es <code>151</code>, por lo que <code>answer</code> debería ser <code>208</code>, pero <code>208</code> no es un carácter
válido por sí mismo. Devolver <code>208</code> probablemente no sea lo que un usuario
desearía si pidieran la primera letra de este <em>string</em>; sin embargo, esos son
los únicos datos que -Rust tiene un índice de bytes 0-. Los usuarios
generalmente no desean que se devuelva el valor del byte, incluso si el
<em>string</em> solo contiene letras latinas: si <code>&amp;&quot;hello&quot;[0]</code> eran códigos válidos
que devolvían el valor de byte, devolvería <code>104</code>, no <code>h</code>. Para evitar
devolver un valor inesperado y causar errores que podrían no descubrirse de
inmediato, Rust no compila este código en absoluto y evita malos entendidos
al principio del proceso de desarrollo.</p>
<h4 id="bytes-y-valores-escalares-y-clusters-de-grafema-oh-mi"><a class="header" href="#bytes-y-valores-escalares-y-clusters-de-grafema-oh-mi">¡Bytes y valores escalares y clusters de Grafema! ¡Oh mi!</a></h4>
<p>Otro punto acerca de UTF-8 es que en realidad hay tres formas relevantes de
mirar los <em>string</em> desde la perspectiva de Rust: como bytes, valores
escalares y clusters de grafemas (lo más parecido a lo que llamaríamos
<em>letras</em>).</p>
<p>Si miramos la palabra Hindi &quot;नमस्ते&quot; escrita en la secuencia de comandos
Devanagari, se almacena como un vector de valores 'u8` que se ve así:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Eso es 18 bytes y es la forma en que las computadoras finalmente almacenan
estos datos. Si los vemos como valores escalares Unicode, que son el tipo
<code>char</code> de Rust, esos bytes se ven así:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Aquí hay seis valores <code>char</code>, pero el cuarto y el sexto no son letras: son
diacríticos que no tienen sentido por sí mismos. Finalmente, si los vemos
como grupos de grafemas, obtendríamos lo que una persona llamaría las cuatro
letras que componen la palabra hindi:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust proporciona diferentes formas de interpretar los datos de <em>string</em> sin
formato que almacenan las computadoras para que cada programa pueda elegir la
interpretación que necesita, sin importar en qué idioma humano se encuentren
los datos.</p>
<p>Una razón final por la que Rust no nos permite indexar en un <code>String</code> para
obtener un carácter es que las operaciones de indexación siempre toman un
tiempo constante (O (1)). Pero no es posible garantizar ese rendimiento con
un <code>String</code>, porque Rust tendría que recorrer el contenido desde el principio
hasta el índice para determinar cuántos caracteres válidos había.</p>
<h3 id="cortando-strings"><a class="header" href="#cortando-strings">Cortando <em>Strings</em></a></h3>
<p>La indexación en un <em>string</em> a menudo es una mala idea porque no está claro
cuál debería ser el tipo de devolución de la operación de indexación de
<em>string</em>: un valor de byte, un carácter, un clúster de grafemas o un segmento
de <em>string</em>. Por lo tanto, Rust le pide que sea más específico si realmente
necesita usar índices para crear secciones de <em>string</em> (<em>string slices</em>).
Para ser más específico en su indexación e indicar que desea un segmento de
<em>string</em> (<em>string slices</em>), en lugar de indexar usando <code>[]</code> con un solo
número, puede usar <code>[]</code> con un rango para crear un segmento de <em>string</em>
(<em>string slices</em>) que contenga bytes particulares:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Aquí, <code>s</code> será un <code>&amp; str</code> que contiene los primeros 4 bytes del <em>string</em>.
Anteriormente, mencionamos que cada uno de estos caracteres tenía 2 bytes, lo
que significa que <code>s</code> será <code>Зд</code>.</p>
<p>¿Qué pasaría si usáramos <code>&amp;hello[0..1]</code>? La respuesta: Rust entraría en
pánico en tiempo de ejecución de la misma manera que si se accede a un índice
no válido en un vector:</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
</code></pre>
<p>Debe usar rangos para crear secciones de <em>string</em> con precaución, ya que al hacerlo puede bloquear su programa.</p>
<h3 id="métodos-para-iterar-sobre-strings"><a class="header" href="#métodos-para-iterar-sobre-strings">Métodos para iterar sobre <em>Strings</em></a></h3>
<p>Afortunadamente, puede acceder a elementos en un <em>string</em> de otras maneras.</p>
<p>Si necesita realizar operaciones en valores escalares Unicode individuales,
la mejor manera de hacerlo es usar el método <code>chars</code>. Llamar <code>chars</code> en“नमस्ते” se separa y devuelve seis valores de tipo <code>char</code>, y puede iterar sobre el resultado para acceder a cada elemento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimirá lo siguiente:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>El método <code>bytes</code> devuelve cada byte sin formato, que podría ser apropiado
para su dominio:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimirá los 18 bytes que componen este <code>String</code>:</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<p>Pero asegúrese de recordar que los valores escalares Unicode válidos pueden
estar formados por más de 1 byte.</p>
<p>Obtener clústeres de grafema a partir de <em>strings</em>es complejo, por lo que la
biblioteca estándar no proporciona esta funcionalidad. Los <em>Crates</em> están
disponibles en <a href="https://crates.io">crates.io</a> si esta es la funcionalidad que
necesita.</p>
<h3 id="los-strings-no-son-tan-simples"><a class="header" href="#los-strings-no-son-tan-simples">Los <em>Strings</em> no son tan simples</a></h3>
<p>Para resumir, los <em>string</em> son complicados. Diferentes lenguajes de
programación toman diferentes decisiones sobre cómo presentar esta
complejidad al programador. Rust ha elegido hacer que el manejo correcto de
los datos de <code>String</code> sea el comportamiento predeterminado de todos los
programas de Rust, lo que significa que los programadores tienen que pensar
más en manejar los datos de UTF-8 por adelantado. Este <em>trade-off</em> expone más
de la complejidad de los <em>string</em> de lo que es evidente en otros lenguajes de
programación, pero evita que tenga que manejar errores que involucren
caracteres no ASCII más adelante en su ciclo de vida de desarrollo.</p>
<p>Cambiemos a algo un poco menos complejo: ¡<em>hash maps</em>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
