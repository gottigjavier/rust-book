<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What is Ownership? - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References & Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Referring to Names in Different Modules</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; Points to Data on the Heap and Has a Known Size</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects that Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions & Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning our Single Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="qué-es-la-propiedad-ownership"><a class="header" href="#qué-es-la-propiedad-ownership">¿Qué es la propiedad (Ownership)?</a></h2>
<p>La característica central de Rust es <em>ownership</em> (<em>propiedad</em>). Aunque la característica es directa
para explicar, tiene profundas implicaciones para el resto del lenguaje.</p>
<p>Todos los programas tienen que administrar la forma en que usan la memoria de una
computadora mientras se ejecuta. Algunos lenguajes tienen <em>recolección de basura</em>,
<em>recolector de basura</em>, que constantemente busca memoria que ya no se usa cuando el
programa se ejecuta; en otros lenguajes, el programador debe explícitamente asignar
y libera la memoria. Rust utiliza un tercer enfoque: la memoria se gestiona a través
de un sistema de propiedad con un conjunto de reglas que el compilador verifica en
tiempo de compilación. Ninguna de las características de propiedad ralentiza su programa
mientras está en funcionamiento.</p>
<p>Como la propiedad es un concepto nuevo para muchos programadores, lleva tiempo
acostumbrarse a ella. La buena noticia es que cuanto más experimentado te vuelves con Rust
y las reglas del sistema de propiedad (<em>ownership</em>), más podrá, naturalmente,
desarrollar código que sea seguro y eficiente. ¡Síguelo!</p>
<p>Cuando comprenda la propiedad, tendrá una base sólida para la comprensión
las características que hacen que Rust sea único. En este capítulo, aprenderá la propiedad
trabajando a través de algunos ejemplos que se centran en una estructura de datos muy común:
<em>strings</em>.</p>
<blockquote>
<h3 id="la-pila-stack-y-el-montículo-heap"><a class="header" href="#la-pila-stack-y-el-montículo-heap">La pila (<em>Stack</em>) y el montículo (<em>Heap</em>).</a></h3>
</blockquote>
<blockquote>
<p>En muchos lenguajes de programación, no tiene que pensar en el <em>Stack</em> y
el <em>Heap</em> muy a menudo. Pero en un lenguaje de programación de sistemas como Rust, ya sea
que un valor está en el <em>Stack</em> o el <em>Heap</em> tiene más de un efecto sobre cómo el lenguaje
se comporta y por qué tiene que tomar ciertas decisiones. Partes de la propiedad
se describirá en relación con el <em>Stack</em> y el <em>Heap</em> más adelante en este capítulo, por lo que
aquí hay una breve explicación en preparada.</p>
<p>Tanto la pila como el montículo son partes de la memoria que está disponible para usar en su código
en tiempo de ejecución, pero están estructurados de diferentes maneras. El <em>stack</em> almacena los
valores en el orden en que los obtiene y elimina los valores en el orden opuesto.
Esto se conoce como <em>last in, first out</em>, <em>LIFO</em>, (último en entrar, primero en salir). Piensa en una pila de platos: cuando
agregas más platos, los pones encima de la pila, y cuando necesitas un
plato, tomas uno de la parte superior. Agregar o quitar platos del medio o
¡abajo no funcionaría tan bien! Agregar datos se llama <em>pushing onto the stack</em> (empujando hacia la pila),
y eliminar datos se llama <em>popping off the stack</em> (saliendo de la pila).</p>
<p>La pila es rápida debido a la forma en que accede a los datos: nunca tiene que
buscar un lugar para poner nuevos datos o un lugar para obtener datos porque eso
el lugar siempre es la parte superior. Otra propiedad que hace que la pila sea rápida es que
todos los datos en la pila deben tomar un tamaño conocido y fijo.</p>
<p>Los datos con un tamaño desconocido en el momento de la compilación o un tamaño que podría cambiar pueden ser
almacenado en el <em>Heap</em> en su lugar. El <em>Heap</em> está menos organizado: cuando pones datos en
el <em>Heap</em>, pides una cierta cantidad de espacio. El sistema operativo encuentra
un lugar vacío en algún lugar del <em>Heap</em> que sea lo suficientemente grande, lo marca como que esta en uso,
y devuelve un <em>puntero</em>, que es la dirección de esa ubicación. Este
proceso se llama <em>allocating on the heap</em> (<em>asignando en el montículo</em>), a veces abreviado como solo
“allocating”. No se considera asignar valores al <em>stack</em>.
Debido a que el puntero es de un tamaño conocido y fijo, puede almacenar el puntero en el <em>stack</em>, pero cuando quiere los datos reales, debe seguir el puntero.</p>
<p>Piense en sentarse en un restaurante. Cuando ingresas, indicas la cantidad de
personas de tu grupo, y el personal encuentra una mesa vacía que se adapta a todos
y te lleva allí. Si alguien en su grupo llega tarde, pueden preguntar dónde
has estado sentado para encontrarte.</p>
<p>Acceder a los datos en el <em>Heap</em> es más lento que acceder a los datos en el <em>stack</em> porque
tienes que seguir un puntero para llegar allí. Los procesadores contemporáneos son más rápidos
si saltan menos en la memoria. Continuando con la analogía, considera un camarero
en un restaurante que recibe pedidos de muchas mesas. Es más eficiente obtener
todos los pedidos en una mesa antes de pasar a la siguiente mesa. Tomando una orden de la mesa A, luego una
orden de la mesa B, luego una de la mesa A otra vez, y
entonces uno más de la mesa B sería un proceso mucho más lento. Por la misma razón, un procesador puede
hacer su trabajo mejor si funciona con datos que están cerca de otros datos (como en el <em>stack</em>) en lugar de
estar más lejos (como puede ser en el <em>heap</em>). Asignar una gran cantidad de espacio en el <em>heap</em> también
puede llevar tiempo.</p>
<p>Cuando su código llama a una función, los valores pasan a la función
(incluidos, potencialmente, punteros a los datos en el montículo) y la función de
las variables locales se insertan en la pila. Cuando la función termina, aquellos
los valores se eliminan de la pila.</p>
<p>Hacer un seguimiento de qué partes del código están usando qué datos en el montículo,
minimizar la cantidad de datos duplicados en el montículo y limpiar sin usar
los datos en el montículo para que no te quedes sin espacio son todos los problemas que aborda la
<em>propiedad dirección</em> (<em>ownership addresses</em>). Una vez que comprenda la propiedad, no tendrá que pensar en la
pila y el montículo con frecuencia, pero sabiendo que la gestión de los datos del montículo es por qué
la propiedad existe puede ayudar a explicar por qué funciona de la manera en que funciona.</p>
</blockquote>
<h3 id="reglas-de-propiedad-ownership"><a class="header" href="#reglas-de-propiedad-ownership">Reglas de propiedad (<em>Ownership</em>)</a></h3>
<p>Primero, echemos un vistazo a las reglas de propiedad. Tenga en cuenta estas reglas cuando trabaje a través de los ejemplos que los ilustran:</p>
<ul>
<li>Cada valor en Rust tiene una variable que se llama <em>owner</em>.</li>
<li>Solo puede haber un propietario a la vez.</li>
<li>Cuando el propietario sale del alcance, el valor se eliminará.</li>
</ul>
<h3 id="alcance-variable-scope"><a class="header" href="#alcance-variable-scope">Alcance variable (<em>Scope</em>)</a></h3>
<p>Ya revisamos un ejemplo de un programa de Rust en el Capítulo 2. Ahora
que hemos pasado la sintaxis básica, no incluiremos todo el código <code>fn main () {</code> en ejemplos, así que si estás siguiendo, tendrás que poner los siguientes ejemplos dentro de una función <code>main</code> de forma manual. Como resultado, nuestros ejemplos serán una un poco más conciso, dejándonos enfocarnos en los detalles reales en lugar de código repetitivo.</p>
<p>Como primer ejemplo de propiedad, veremos el <em>scope</em> de algunas variables. Un <em>scope</em> es el rango dentro de un programa para el cual un artículo es válido. Digamos que tenemos una variable que se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>La variable <code>s</code> se refiere a una <em>string</em> literal, donde el valor del <em>string</em> es
codificado en el texto de nuestro programa. La variable es válida desde el punto en el
que se declara hasta el final del <em>scope</em> actual. El listado 4-1 tiene comentarios
anotando donde la variable <code>s</code> es válida.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s no es válido aquí, aún no está declarada
    let s = &quot;hello&quot;;   // s es válido a partir de este punto

    // hacer cosas con s
}                      // este alcance ha terminado, y s ya no es válido
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-1: Una variable y el alcance en el que es válida</span></p>
<p>En otras palabras, hay dos puntos importantes en el tiempo aquí:</p>
<ul>
<li>Cuando <code>s</code> entra en el <em>scope</em>, es válido.</li>
<li>Sigue siendo válido hasta que se sale <em>scope</em>.</li>
</ul>
<p>En este punto, la relación entre los ámbitos y cuándo las variables son válidas es similar a la de otros lenguajes de programación. Ahora construiremos sobre esta comprensión introduciendo el tipo <code>String</code>.</p>
<h3 id="el-tipo-string"><a class="header" href="#el-tipo-string">El tipo <code>String</code></a></h3>
<p>Para ilustrar las reglas de propiedad (<em>ownership</em>), necesitamos un tipo de datos que sea más complejo que los que cubrimos en la sección &quot;Tipos de datos&quot; del Capítulo 3. Los tipos cubiertos anteriormente están todos almacenados en la pila (<em>stack</em>) y salieron de la pila (<em>stack</em>) cuando
su alcance ha terminado, pero queremos ver los datos que se almacenan en el montículo (<em>heap</em>) y explora cómo Rust sabe cuándo limpiar esos datos.</p>
<p>Usaremos <code>String</code> como ejemplo aquí y nos concentraremos en las partes de <code>String</code> que se relacionan con la propiedad. Estos aspectos también se aplican a otros tipos de datos complejos provisto por la biblioteca estándar (<em>std</em>) y que usted crea. Estudiaremos el tipo <code>String</code> con más profundidad en el Capítulo 8.</p>
<p>Ya vimos <em>string</em> literales, donde un valor de <em>string</em> está codificado en nuestro programa. Los literales de <em>string</em> son convenientes, pero no son adecuados para toda situación en la cual podemos querer usar texto. Una razón es que son inmutable. Otra es que no todos los valores de <em>string</em> se pueden conocer cuando escribimos nuestro código: por ejemplo, ¿qué sucede si queremos tomar la entrada del usuario y almacenarla? por
estas situaciones, Rust tiene un segundo tipo de <em>string</em>, <code>String</code>. Este tipo es asignado en el montículo (<em>heap</em>) y como tal es capaz de almacenar una cantidad de texto que es desconocido para nosotros en tiempo de compilación. Puede crear un <code>String</code> a partir de un literal de <em>string</em>
usando la función <code>from</code>, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Los dos puntos dobles (<code>::</code>) es un operador que nos permite el espacio de nombres
(<em>namespace</em>) esta función particular <code>from</code> bajo el tipo <code>String</code> en lugar de utilizar
algún tipo de nombre como <code>string_from</code>. Estudiaremos esta sintaxis más en la sección
“Método Sintaxis” del Capítulo 5 y cuando hablamos de espacios de nombres con módulos en
&quot;Definiciones de módulos&quot; en el Capítulo 7.</p>
<p>Este tipo de <em>string</em>, <em>pueden</em> mutar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() agrega un literal a un String

println!(&quot;{}&quot;, s);      // Esto imprimirá `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>Entonces, ¿cuál es la diferencia aquí? ¿Por qué <code>String</code> puede mutarse pero los literales no?
La diferencia es cómo estos dos tipos lidian con la memoria</p>
<h3 id="memoria-y-asignación"><a class="header" href="#memoria-y-asignación">Memoria y Asignación</a></h3>
<p>En el caso de un <em>string</em> literal, conocemos el contenido en tiempo de compilación, por lo que el texto está codificado directamente en el ejecutable final. Esta es la razón por la que los <em>string</em> literales son rápidos y eficientes. Pero estas propiedades solo provienen de la inmutabilidad del literal del <em>string</em>. Desafortunadamente, no podemos poner una burbuja de memoria en el binario por cada fragmento de texto cuyo tamaño se desconoce en el momento de la compilación y cuyo tamaño podría cambiar mientras se ejecuta el programa.</p>
<p>Con el tipo <code>String</code>, para admitir un fragmento de texto mutable y creíble,
necesitamos asignar una cantidad de memoria en el montículo, desconocida en tiempo de compilación, para contener los contenidos. Esto significa:</p>
<ul>
<li>La memoria debe solicitarse desde el sistema operativo en tiempo de ejecución.</li>
<li>Necesitamos una forma de devolver esta memoria al sistema operativo cuando hayamos terminado con nuestro <code>String</code>.</li>
</ul>
<p>Esa primera parte la hacemos nosotros: cuando llamamos a <code>String::from</code>, su implementación solicita la memoria que necesita. Esto es bastante universal en los lenguajes de programación.</p>
<p>Sin embargo, la segunda parte es diferente. En lenguajes con un <em>recolector de basura (GC)</em>, el GC realiza un seguimiento y limpia la memoria que ya no se usa, y no necesitamos pensar en ello. Sin un GC, es nuestra responsabilidad identificar cuándo ya no se usa la memoria y llamar al código para devolverla explícitamente, tal como lo hicimos para solicitarlo. Hacer esto correctamente ha sido históricamente un problema de programación difícil. Si lo olvidamos, perderemos la memoria. Si lo hacemos demasiado pronto, tendremos una variable inválida. Si lo hacemos dos veces, también es un error.
Necesitamos emparejar exactamente un <code>allocate</code> con exactamente un <code>free</code>.</p>
<p>Rust toma una ruta diferente: la memoria se devuelve automáticamente una vez que la variable que lo posee queda fuera del alcance. Aquí hay una versión de nuestro ejemplo de alcance del Listado 4-1 usando un <code>String</code> en lugar de un literal de <em>string</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s es válido a partir de este punto

    // hacer cosas con s
}                                  // este alcance ha terminado, y s ya no es válido
<span class="boring">}
</span></code></pre></pre>
<p>Aquí hay un punto natural en el que podemos devolver la memoria que nuestro <code>String</code> necesita para el sistema operativo: cuando <code>s</code> sale del alcance. Cuando una variable se sale del alcance, Rust llama a una función especial para nosotros. Esta función se llama <code>drop</code>, y es donde el autor de <code>String</code> puede poner el código para devolver la memoria. Rust llama <code>drop</code> automáticamente al cierre de la llave.</p>
<blockquote>
<p>Nota: En C ++, este patrón de desasignación de recursos al final de la vida útil de un elemento se denomina a veces <em>Resource Acquisition Is Initialization (RAII)</em> (<em>Inicialización de adquisición de recursos (RAII)</em>).
La función <code>drop</code> en Rust le resultará familiar si ha utilizado patrones RAII.</p>
</blockquote>
<p>Este patrón tiene un profundo impacto en la forma en que se escribe el código de Rust. Puede parecer simple en este momento, pero el comportamiento del código puede ser
inesperado en situaciones más complicadas cuando queremos que múltiples variables usen
los datos que hemos asignado en el montículo (<em>heap</em>). Exploremos algunas de esas
situaciones ahora.</p>
<h4 id="ways-variables-and-data-interact-move"><a class="header" href="#ways-variables-and-data-interact-move">Ways Variables and Data Interact: Move</a></h4>
<p>Múltiples variables pueden interactuar con los mismos datos de diferentes maneras en Rust.
Veamos un ejemplo usando un número entero en el Listado 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-2: Asignando el valor entero de la variable <code>x</code> a <code>y</code></span></p>
<p>Probablemente podamos adivinar qué está haciendo esto: “vincula el valor <code>5</code> a <code>x</code>; luego haga una copia del valor en <code>x</code> y agréguela a <code>y</code>.” Ahora tenemos dos variables,<code>x</code> e <code>y</code>, y ambas son <code>5</code>. De hecho, esto es lo que está sucediendo, porque los enteros son valores simples con un tamaño conocido y fijo, y estos dos valores <code>5</code> se insertan en la pila (<em>stack</em>).</p>
<p>Ahora veamos la versión <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Esto se ve muy similar al código anterior, por lo que podemos suponer que la forma en que funciona sería la misma: es decir, la segunda línea haría una copia del valor en <code>s1</code> y lo vincularía a <code>s2</code>. Pero esto no es exactamente lo que sucede.</p>
<p>Eche un vistazo a la Figura 4-1 para ver lo que está sucediendo con <code>String</code> debajo de las sábanas. Una <code>String</code> se compone de tres partes, que se muestran a la izquierda: un puntero a la memoria que contiene el contenido del <em>string</em>, una longitud y una capacidad. Este grupo de datos se almacena en la pila (<em>stack</em>). A la derecha está la memoria en el montículo <em>(heap</em>) que contiene los contenidos.</p>
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-1: Representación en memoria de un <code>String</code>
sosteniendo el valor <code>&quot;hello&quot;</code> bound to <code>s1</code></span></p>
<p>La longitud es la cantidad de memoria, en bytes, que está usando el contenido de <code>String</code>.
La capacidad es la cantidad total de memoria, en bytes, que el <code>String</code> recibió del sistema
operativo. La diferencia entre la duración y la capacidad importa, pero no en este contexto,
por lo que, por ahora, está bien ignorar la capacidad.</p>
<p>Cuando asignamos <code>s1</code> a <code>s2</code>, los datos de <code>String</code> se copian, lo que significa que copiamos
el puntero, la longitud y la capacidad que están en la pila (<em>stack</em>). No copiamos los datos
en el montículo (<em>heap</em>) al que se refiere el puntero. En otras palabras, la representación de
datos en la memoria se parece a la Figura 4-2.</p>
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-2: Representación en memoria de la variable <code>s2</code>
que tiene una copia del puntero, longitud y capacidad de <code>s1</code></span></p>
<p>La representación * no * se parece a la Figura 4-3, que es como se vería la memoria
si Rust copiara también los datos del montículo. Si Rust hiciera esto, la operación <code>s2 = s1</code>
podría ser muy costosa en términos de rendimiento en tiempo de ejecución si los datos
en el montículo fueran grandes.</p>
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-3: Otra posibilidad para qué <code>s2 = s1</code>
podría hacer si Rust copiara los datos del montículo (<em>heap</em>) también</span></p>
<p>Anteriormente, dijimos que cuando una variable queda fuera del alcance, Rust
llama automáticamente a la función <code>drop</code> y limpia la memoria del montículo para esa variable.
Pero la Figura 4-2 muestra ambos punteros de datos apuntando a la misma ubicación.
Esto es un problema: cuando <code>s2</code> y <code>s1</code> salen del alcance, ambos intentarán liberar la misma memoria.
Esto se conoce como un <em>double free</em> error y es uno de los errores de seguridad de memoria
que mencionamos anteriormente. Liberar la memoria dos veces puede provocar daños en la memoria,
lo que puede generar vulnerabilidades de seguridad.</p>
<p>Para garantizar la seguridad de la memoria, hay un detalle más de lo que sucede en esta
situación en Rust. En lugar de intentar copiar la memoria asignada, Rust considera que
<code>s1</code> ya no es válido y, por lo tanto, Rust no necesita liberar nada cuando <code>s1</code> sale del alcance.
Echa un vistazo a lo que sucede cuando tratas de usar <code>s1</code> después de crear <code>s2</code>; no funcionará:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>Recibirá un error como este porque Rust le impide usar la referencia invalidada:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>Si ha escuchado los términos <em>shallow copy</em> (<em>copia superficial</em>) y <em>deep copy</em> (<em>copia profunda</em>)
mientras trabaja con otros lenguajes, el concepto de copiar el puntero, la longitud y la capacidad
sin copiar los datos probablemente suene como una copia superficial. Pero debido a que Rust
también invalida la primera variable, en lugar de llamarse una copia superficial, se la
conoce como <em>mover</em>. En este ejemplo, diríamos que <code>s1</code> se <em>movió</em> a <code>s2</code>. Entonces,
lo que realmente sucede se muestra en la Figura 4-4.</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-4: La representación en memoria después de <code>s1</code> ha sido invalidada</span></p>
<p>¡Eso resuelve nuestro problema! Con solo <code>s2</code> válido, cuando salga del alcance, solo
liberará la memoria y terminaremos.</p>
<p>Además, hay una opción de diseño implícita: Rust nunca creará automáticamente copias “profundas”
de sus datos. Por lo tanto, se puede suponer que cualquier copiado <em>automático</em> es económico en
términos de rendimiento en tiempo de ejecución.</p>
<h4 id="ways-variables-and-data-interact-clone"><a class="header" href="#ways-variables-and-data-interact-clone">Ways Variables and Data Interact: Clone</a></h4>
<p>Si <em>hacemos</em> queremos copiar profundamente los datos del montículo (<em>heap</em>) de <code>String</code>,
no solo los datos de la pila (<em>stack</em>), podemos usar un método común llamado <code>clone</code>.
Estudiaremos la sintaxis del método en el Capítulo 5, pero dado que los métodos son
una característica común en muchos lenguajes de programación, probablemente ya los haya visto antes.</p>
<p>Aquí hay un ejemplo del método <code>clone</code> en acción:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Esto funciona bien y produce explícitamente el comportamiento que se muestra en
la Figura 4-3, donde los datos del montículo <em>no</em> se copian.</p>
<p>Cuando ves una llamada a <code>clone</code>, sabes que se está ejecutando algún código
arbitrario y que el código puede ser costoso. Es un indicador visual de que
algo diferente está sucediendo.</p>
<h4 id="stack-only-data-copy"><a class="header" href="#stack-only-data-copy">Stack-Only Data: Copy</a></h4>
<p>Hay otra arruga de la que aún no hemos hablado. Este código que usa números enteros,
parte del cual se mostró en el Listado 4-2, funciona y es válido:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Pero este código parece contradecir lo que acabamos de aprender: no tenemos una llamada a
<code>clon</code>, pero<code> x</code> sigue siendo válida y no se movió a <code>y</code>.</p>
<p>La razón es que los tipos como los enteros que tienen un tamaño conocido en el momento
de la compilación se almacenan completamente en la pila, por lo que las copias de los
valores reales son rápidos de realizar. Eso significa que no hay ninguna razón por la que
quisiéramos evitar que <code>x</code> sea válida después de que creamos la variable<code> y</code>. En otras
palabras, aquí no hay diferencia entre la copia profunda y la poco profunda, por lo que
llamar <code>clon</code> no haría nada diferente de la copia superficial normal y podemos omitirlo.</p>
<p>Rust tiene una anotación especial llamada el <em>trait</em> <code>Copy</code> que podemos colocar en
tipos como enteros que están almacenados en la pila (hablaremos más sobre los rasgos en el Capítulo 10).
Si un tipo tiene el <em>trait</em> <code>Copy</code>, una variable más vieja todavía se puede usar después de la asignación.
Rust no nos permitirá anotar un tipo con el <em>trait</em> <code>Copy</code> si el tipo, o cualquiera de sus partes,
ha implementado el <em>trait</em> <code>Drop</code>. Si el tipo necesita que ocurra algo especial cuando el
valor se sale del alcance y agregamos la anotación <code>Copy</code> a ese tipo, obtendremos un error
en tiempo de compilación. Para obtener información sobre cómo agregar la anotación <code>Copy</code>
a su tipo, consulte “Rasgos derivables” en el Apéndice C.</p>
<p>Entonces, ¿qué tipos son <code>Copy</code>? Puede verificar la documentación del tipo dado para asegurarse,
pero como regla general, cualquier grupo de valores escalares simples puede ser <code>Copy</code>, y
nada que requiera asignación o es alguna forma de recurso es <code>Copy</code>. Estos son algunos de los
tipos que son <code>Copiar</code>:</p>
<ul>
<li>Todos los tipos de enteros, como <code>u32</code>.</li>
<li>El tipo booleano, <code>bool</code>, con los valores <code>true</code> y <code>false</code>.</li>
<li>Todos los tipos de punto flotante, como <code>f64</code>.</li>
<li>El tipo de carácter, <code>char</code>.</li>
<li>Tuplas, pero solo si contienen tipos que también son <code>Copy</code>. Por ejemplo,
<code>(i32, i32)</code> que son <code>Copy</code>, pero <code>(i32, String)</code> no lo son.</li>
</ul>
<h3 id="propiedad-y-funciones"><a class="header" href="#propiedad-y-funciones">Propiedad y funciones</a></h3>
<p>La semántica para pasar un valor a una función es similar a la de establecer
un valor para una variable. Pasar una variable a una función se moverá o copiará,
tal como lo hace la asignación. El listado 4-3 tiene un ejemplo con algunas anotaciones
que muestran dónde las variables entran y salen del alcance (<em>scope</em>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s entra en el alcance

    takes_ownership(s);             // s's el valor se mueve a la función ...
                                    // ... y entonces ya no es válido aquí

    let x = 5;                      // x entra en el alcance

    makes_copy(x);                  // x se movería a la función,
                                    // pero i32 es Copy, así que está bien todavía
                                    // use x después

} // Aquí, x sale del alcance, luego s. Pero como el valor de s se movió, nada
  // sucede de manera especial.

fn takes_ownership(some_string: String) { // some_string entra en el alcance
    println!(&quot;{}&quot;, some_string);
} // Aquí, some_string sale del alcance y se llama `drop`. La memoria de
  // respaldo se libera.

fn makes_copy(some_integer: i32) { // some_integer entra en el alcance
    println!(&quot;{}&quot;, some_integer);
} // Aquí, some_integer sale del alcance. Nada especial sucede.
</code></pre></pre>
<p><span class="caption">Listing 4-3: Funciones con propiedad y alcance anotado</span></p>
<p>Si intentamos usar <code>s</code> después de la llamada a<code> takes_ownership</code>, Rust arrojaría
un error en tiempo de compilación. Estas comprobaciones estáticas nos protegen de
los errores. Intenta agregar código a <code>main</code> que use<code> s</code> y <code>x</code> para ver dónde puedes
usarlos y dónde las reglas de propiedad te impiden hacerlo.</p>
<h3 id="valores-de-retorno-y-alcance"><a class="header" href="#valores-de-retorno-y-alcance">Valores de retorno y alcance</a></h3>
<p>La devolución de valores también puede transferir la propiedad (<em>ownership</em>).
El listado 4-4 es un ejemplo con anotaciones similares a las del Listado 4-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership mueve su valor de 
                                        // retorno a s1

    let s2 = String::from(&quot;hello&quot;);     // s2 entra en el alcance

    let s3 = takes_and_gives_back(s2);  // s2 se mueve a takes_and_gives_back, 
                                        // que también mueve su valor 
                                        // de retorno a s3
} // Aquí, s3 sale del alcance y se descarta. s2 sale del alcance pero se movió,
  // por lo que no sucede nada. s1 sale del alcance y se descarta.

fn gives_ownership() -&gt; String {             // gives_ownership moverá su 
                                             // valor de retorno a la función 
                                             // que lo llama.

    let some_string = String::from(&quot;hello&quot;); // some_string entra en el alcance

    some_string                              // some_string se devuelve y 
                                             // se mueve a la función de llamada.
}

// takes_and_gives_back tomará un *string* y devolverá uno
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string entra en el alcance

    a_string  // a_string se devuelve y se mueve a la función de llamada
}
</code></pre></pre>
<p><span class="caption">Listing 4-4: Transferir la propiedad (<em>ownership</em>) de los valores devueltos</span></p>
<p>La propiedad (<em>ownership</em>) de una variable sigue el mismo patrón cada vez: la asignación de un valor
a otra variable lo mueve. Cuando una variable que incluye datos en el montículo queda
fuera del alcance, el valor se limpiará mediante <code>drop</code> a menos que los datos hayan
sido movidos para ser propiedad <em>owned</em> de otra variable.</p>
<p>Tomar posesión y luego devolver la propiedad (<em>ownership</em>) con cada función es un poco tedioso.
¿Qué sucede si queremos permitir que una función use un valor pero no tome posesión?
Es bastante molesto que cualquier cosa que pasemos también deba transmitirse si queremos
volver a usarlo, además de cualquier dato que provenga del cuerpo de la función que también
deseemos devolver.</p>
<p>Es posible devolver múltiples valores usando una tupla, como se muestra en el Listado 4-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Listing 4-5: Devolución de la propiedad (<em>ownership</em>) de los parámetros</span></p>
<p>Pero esto es demasiada ceremonia y mucho trabajo para un concepto que debería ser común.
Afortunadamente para nosotros, Rust tiene una característica para este concepto, llamada
<em>referencias</em> (<em>references</em>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
