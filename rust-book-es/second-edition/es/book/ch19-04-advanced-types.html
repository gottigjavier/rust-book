<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tipos Avanzados - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Cómo Trabajan las Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Partes (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis de lo Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Haciendo Referencia a Nombres en Distintos Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Trait: Acceso a los Datos a través de una Referencia</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html" class="active"><strong aria-hidden="true">19.4.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Funciones Avanzadas y Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Pakabras Clave</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Características más Recientes</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h2>
<p>El sistema de tipo Rust tiene algunas características que hemos mencionado en
este libro pero que aún no hemos discutido. Comenzaremos analizando los tipos
nuevos en general al examinar por qué los tipos nuevos son útiles como tipos.
Luego pasaremos a escribir <em>alias</em>, una característica similar a <em>newtypes</em>
pero con semántica ligeramente diferente. También discutiremos el tipo <code>!</code> Y
los tipos de tamaño dinámico.</p>
<blockquote>
<p>Nota: La siguiente sección supone que ha leído la sección anterior  “<em>The Newtype</em>
Patrón para implementar <em>traits</em> externos en tipos externos.”</p>
</blockquote>
<h3 id="uso-del-patrón-newtype-para-la-seguridad-y-la-abstracción-de-tipos"><a class="header" href="#uso-del-patrón-newtype-para-la-seguridad-y-la-abstracción-de-tipos">Uso del patrón <em>Newtype</em> para la seguridad y la abstracción de tipos</a></h3>
<p>El patrón de tipo nuevo es útil para tareas más allá de las que hemos
discutido hasta ahora, incluida la aplicación estática de que los valores
nunca se confundan y que indiquen las unidades de un valor. Viste un ejemplo
del uso de <em>newtypes</em> para indicar unidades en el listado 19-23: recuerde que
las estructuras <code>Millimeters</code> y <code>Meters</code> envolvieron los valores <code>u32</code> en un
nuevo tipo. Si escribimos una función con un parámetro de tipo <code>Millimeters</code>,
no podríamos compilar un programa que accidentalmente intentó llamar a esa
función con un valor de tipo <code>Meters</code> o simplemente <code>u32</code>.</p>
<p>Otro uso del patrón <em>newtype</em> es abstraer algunos detalles de implementación
de un tipo: el nuevo tipo puede exponer una API pública que es diferente de
la API del tipo interno privado si usamos el nuevo tipo directamente para
restringir la funcionalidad disponible, para ejemplo.</p>
<p><em>Newtypes</em> también puede ocultar la implementación interna. Por ejemplo,
podríamos proporcionar un tipo <code>People</code> para ajustar un
<code>HashMap&lt;i32, String&gt;</code> que almacena la identificación de una persona asociada
con su nombre. El código que utiliza <code>People</code> solo interactuaría con la API
pública que proporcionamos, como un método para agregar un <em>string</em> de nombre
a la colección <code>People</code>; ese código no necesitaría saber que asignamos una
identificación <code>i32</code> a los nombres internamente. El nuevo patrón de tipo es
una forma ligera de lograr la encapsulación para ocultar los detalles de
implementación, que discutimos en la sección “Encapsulación que oculta
detalles de implementación” del Capítulo 17.</p>
<h3 id="creación-de-sinónimos-de-tipo-con-alias-de-tipo"><a class="header" href="#creación-de-sinónimos-de-tipo-con-alias-de-tipo">Creación de sinónimos de tipo con alias de tipo</a></h3>
<p>Junto con el patrón de <em>newtype</em>, Rust proporciona la capacidad de declarar
un <em>type alias</em> para dar a un tipo existente otro nombre. Para esto, usamos
la palabra clave <code>type</code>. Por ejemplo, podemos crear el alias <code>Kilometers</code> a
<code>i32</code> de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Ahora, el alias <code>Kilometers</code> es un <em>sinónimo</em> para <code>i32</code>; a diferencia de los
tipos <code>Millimeters</code> y <code>Meters</code> que creamos en el listado 19-23, <code>Kilometers</code>
no es un tipo nuevo e independiente. Los valores que tienen el tipo
<code>Kilometers</code> se tratarán de la misma manera que los valores de tipo <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>Debido a que <code>Kilometers</code> y <code>i32</code> son del mismo tipo, podemos agregar valores
de ambos tipos y podemos pasar valores <code>Kilometers</code> a las funciones que toman
los parámetros <code>i32</code>. Sin embargo, al usar este método, no obtenemos los
beneficios de verificación de tipo que obtenemos del nuevo patrón de tipo
discutido anteriormente.</p>
<p>El principal caso de uso para los sinónimos de tipo es reducir la repetición.
Por ejemplo, podríamos tener un tipo largo como este:</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<p>Escribir este tipo largo en las firmas de función y como anotaciones de tipo
en todo el código puede ser molesto y propenso a errores. Imagine tener un
proyecto lleno de código como ese en el listado 19-32.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-32: Usar un <em>tipo largo</em> (<em>long type</em>) en
muchos lugares</span></p>
<p>Un tipo <em>alias</em> hace que este código sea más manejable al reducir la
repetición. En el listado 19-33, hemos introducido un <em>alias</em> llamado <code>Thunk</code>
para el tipo detallado y podemos reemplazar todos los usos del tipo con el
<em>alias</em> más corto <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-33: Presentamos un tipo de <em>alias</em> <code>Thunk</code>
para reducir la repetición</span></p>
<p>¡Este código es mucho más fácil de leer y escribir! Elegir un nombre
significativo para un tipo <em>alias</em> también puede ayudarlo a comunicar su
intención (<em>thunk</em> es una palabra para evaluar el código más adelante, por lo
que es un nombre apropiado para un <em>closure</em> que se almacena).</p>
<p>Los <em>alias</em> de tipo también se usan comúnmente con el tipo <code>Result &lt;T, E&gt;</code>
para reducir la repetición. Considere el módulo <code>std::io</code> en la biblioteca
estándar. Las operaciones de E/S a menudo devuelven un <code>Result&lt;T, E&gt;</code> para
manejar situaciones cuando las operaciones no funcionan. Esta biblioteca
tiene una estructura <code>std::io::Error</code> que representa todos los posibles
errores de E/S. Muchas de las funciones en <code>std::io</code> devolverán
<code>Result &lt;T, E&gt;</code> donde <code>'E</code> es <code>std::io::Error</code>, como estas funciones en el
<em>trait</em> <code>Write</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>El <code>Result&lt;..., Error&gt;</code> se repite mucho. Como tal, <code>std::io</code> tiene este tipo
de declaración de <em>alias</em>:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Como esta declaración está en el módulo <code>std::io</code>, podemos usar el <em>alias</em>
totalmente calificado <code>std::io::Result &lt;T&gt;</code>-es decir, un <code>Result &lt;T, E&gt;</code> con
el <code>E</code> rellenado como <code>std::io::Error</code>. Las firmas de funciones de <em>traits</em>
<code>Write</code> terminan pareciéndose a esto:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>El <em>alias</em> tipo ayuda de dos maneras: hace que el código sea más fácil de
escribir <em>y</em> nos da una interfaz consistente en todo el <code>std::io</code>. Como es un
<em>alias</em>, es simplemente otro <code>Result &lt;T, E&gt;</code>, lo que significa que podemos
usar cualquier método que funcione en <code>Result &lt;T, E&gt;</code> con él, así como una
sintaxis especial como el operador <code>?</code>.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust tiene un tipo especial llamado <code>!</code> que se conoce en la jerga de teoría
de tipos como <em>tipo vacío</em> (<em>empty type</em>) porque no tiene valores. Preferimos
llamarlo <em>never type</em> porque se encuentra en el lugar del tipo de devolución
cuando una función nunca volverá. Aquí hay un ejemplo:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<p>Este código se lee como “la función <code>bar</code> nunca retorna”. Las funciones que
retornan nunca se llaman <em>funciones divergentes</em>. No podemos crear valores
del tipo <code>!</code> para que <code>bar</code> nunca pueda regresar.</p>
<p>Pero, ¿para qué sirve un tipo para el que nunca se pueden crear valores?.
Recordar el código del listado 2-5; hemos reproducido una parte aquí en el
listado 19-34.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let guess = &quot;3&quot;;
</span><span class="boring">loop {
</span>let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
<span class="boring">break;
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-34: Un <code>match</code> con un brazo que termina en
<code>continue</code></span></p>
<p>En ese momento, omitimos algunos detalles en este código. En el Capítulo 6 de
la sección “El operador de flujo de control <code>match</code>”, discutimos que los
brazos del <code>match</code> deben devolver el mismo tipo. Entonces, por ejemplo, el
siguiente código no funciona:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>El tipo de <code>guess</code> en este código debería ser un entero <em>y</em> un <em>string</em>, y
Rust requiere que <code>guess</code> tenga solo un tipo. Entonces, ¿qué devuelve
<code>continue</code>?.Cómo se nos permitió devolver un <code>u32</code> de un brazo y tener otro
brazo que termina con <code>continue</code> en el Listado 19-34?</p>
<p>Como habrás adivinado, <code>continue</code> tiene un valor <code>!</code>. Es decir, cuando Rust
calcula el tipo de <code>guess</code>, mira ambos brazos del <em>match</em>, el primero con un
valor de <code>u32</code> y el último con un valor <code>!</code>. Debido a que <code>!</code> nunca puede
tener un valor, Rust decide que el tipo de <code>guess</code> es <code>u32</code>.</p>
<p>La forma formal de describir este comportamiento es que las expresiones de
tipo <code>!</code> pueden forzarse en cualquier otro tipo. Podemos terminar este brazo
<code>match</code> con <code>continue</code> porque <code>continue</code> no devuelve un valor; en su lugar,
mueve el control de nuevo a la parte superior del ciclo, por lo que en el
caso de <code>Err</code>, nunca asignamos un valor a <code>guess</code>.</p>
<p>El tipo nunca es útil con la macro <code>panic!</code> También. ¿Recuerda la función
<code>unwrap</code> que llamamos a los valores <code>Option&lt;T&gt;</code> para producir un valor o
pánico?. Aquí está su definición:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>En este código, sucede lo mismo que en el <code>match</code> en el Listado 19-34: Rust
ve que <code>val</code> tiene el tipo <code>T</code> y <code>panic!</code> tiene el tipo <code>!</code>, por lo que el
resultado de la expresión general de <code>match</code> es <code>T</code>. Este código funciona
porque <code>panic!</code> No produce un valor; termina el programa. En el caso <code>None</code>,
no devolveremos un valor de <code>unwrap</code>, por lo que este código es válido.</p>
<p>Una expresión final que tiene el tipo <code>!</code> es un <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Aquí, el ciclo nunca termina, entonces <code>!</code> es el valor de la expresión. Sin
embargo, esto no sería cierto si incluyéramos un <code>break</code>, porque el ciclo
terminaría cuando llegara al <code>break</code>.</p>
<h3 id="tipos-dinámicamente-dimensionados-y-el-trait-sized"><a class="header" href="#tipos-dinámicamente-dimensionados-y-el-trait-sized">Tipos dinámicamente dimensionados y el <em>Trait</em> <code>Sized</code></a></h3>
<p>Debido a la necesidad de Rust de conocer ciertos detalles, como la cantidad
de espacio para asignar un valor de un tipo particular, hay una esquina de su
sistema de tipo que puede ser confusa: el concepto de <em>tipos de tamaño
dinámico</em>. A veces denominados <em>DSTs</em> o <em>unsized types</em>, estos tipos nos
permiten escribir código utilizando valores cuyo tamaño solo podemos conocer
en tiempo de ejecución.</p>
<p>Vamos a profundizar en los detalles de un tipo de tamaño dinámico llamado
<code>str</code>, que hemos estado utilizando a lo largo del libro. Así es, no <code>&amp;str</code>,
sino <code>str</code> en sí mismo, es un DST. No podemos saber cuánto tiempo dura la
<em>string</em> hasta el tiempo de ejecución, lo que significa que no podemos crear
una variable de tipo <code>str</code>, ni podemos tomar un argumento de tipo <code>str</code>.
Considere el siguiente código, que no funciona:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>Rust necesita saber cuánta memoria asignar para cualquier valor de un tipo
particular, y todos los valores de un tipo deben usar la misma cantidad de
memoria. Si Rust nos permitiera escribir este código, estos dos valores <code>str</code>
necesitarían ocupar la misma cantidad de espacio. Pero tienen diferentes
longitudes: <code>s1</code> necesita 12 bytes de almacenamiento y <code>s2</code> necesita 15. Es
por eso que no es posible crear una variable que tenga un tipo de tamaño
dinámico.</p>
<p>¿Asi que que hacemos?. En este caso, ya conoce la respuesta: hacemos los
tipos de <code>s1</code> y <code>s2</code> a <code>&amp;str</code> en lugar de <code>str</code>. Recuerde que en la sección
String Slices” del Capítulo 4, dijimos que la estructura de datos de sectores
almacena la posición inicial y la longitud del sector.</p>
<p>Entonces, aunque un <code>&amp;T</code> es un valor único que almacena la dirección de
memoria de donde el <code>T</code> se encuentra, un <code>&amp;str</code> es <em>dos</em> valores: la
dirección del <code>str</code> y su longitud. Como tal, podemos conocer el tamaño de un
valor <code>&amp;str</code> en tiempo de compilación: es el doble de la longitud de un
<code>usize</code>. Es decir, siempre sabemos el tamaño de un <code>&amp;str</code>, no importa cuánto
tiempo se refiere al <em>string</em> a la que se refiere. En general, este es el
camino en qué tipos de tamaño dinámico se usan en Rust: tienen un poco más de
metadatos que almacena el tamaño de la información dinámica. La regla de oro
de tipos de tamaño dinámico es que siempre debemos poner valores de tamaño
dinámico tipos detrás de un puntero de algún tipo.</p>
<p>Podemos combinar <code>str</code> con todo tipo de punteros: por ejemplo,<code>Box&lt;str&gt;</code> o
<code>Rc&lt;str&gt;</code>. De hecho, ya has visto esto antes, pero con una dinámica diferente
tipo de tamaño: <em>traits</em>. Cada característica es un tipo de tamaño dinámico
al que podemos hacer referencia usando el nombre del <em>trait</em>. En el Capítulo
17 en la sección “Uso de <em>Trait Objects</em> que permiten valores de diferentes
tipos” mencionamos que para usar los <em>traits</em> como <em>trait objects</em>, debemos
ponerlos detrás de un puntero, como <code>&amp;Trait</code> o <code>Box&lt;Trait&gt;</code>
(<code>Rc&lt;Trait&gt;</code> también funcionaría).</p>
<p>Para trabajar con los DST, Rust tiene un <em>trait</em> particular llamado el
<em>trait</em> <code>Sized</code> para determinar si se conoce o no el tamaño de un tipo en el
momento de la compilación. Este <em>trait</em> es implementado automáticamente para
todo cuyo tamaño se conoce en tiempo de compilación. Además, Rust agrega
implícitamente un límite en <code>Sized</code> a cada función genérica.
Es decir, una definición de función genérica como esta:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>en realidad se trata como si hubiéramos escrito esto:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>Por defecto, las funciones genéricas solo funcionarán en los tipos que tienen
un tamaño conocido en el momento de la compilación. Sin embargo, puede usar
la siguiente sintaxis especial para relajar esta restricción:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>Un <em>trait</em> ligado en <code>?Sized</code> es el opuesto de un <em>trait</em> ligado en <code>Sized</code>:
leemos esto como “<code>T</code> puede o no ser <code>Sized</code>”.Esta sintaxis solo está
disponible para <code>Sized</code>, no cualquier otro <em>trait</em>.</p>
<p>También tenga en cuenta que cambiamos el tipo del parámetro <code>t</code> de <code>T</code> a
<code>&amp;T</code>. Debido a que el tipo puede no ser <code>Sized</code>, tenemos que usarlo detrás de
algún tipo de puntero. En este caso, hemos elegido una referencia.</p>
<p>¡A continuación, hablaremos sobre funciones y closures!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-03-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
