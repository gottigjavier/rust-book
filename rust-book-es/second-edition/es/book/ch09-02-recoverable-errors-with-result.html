<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Errores Recuperables con Result - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Cómo Trabajan las Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Partes (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis de lo Métodos</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> El Operador de Estructuras de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Módulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod y el Sistema de Archivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlando la Visibilidad con pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Haciendo Referencia a Nombres en Distintos Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Error Estándar" en lugar de "Salida Estándar"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Trait: Acceso a los Datos a través de una Referencia</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones Coinciden con la Estructura de Valores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Funciones Avanzadas y Closures</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Pakabras Clave</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Características más Recientes</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="errores-recuperables-con-result"><a class="header" href="#errores-recuperables-con-result">Errores recuperables con <code>Result</code></a></h2>
<p>La mayoría de los errores no son lo suficientemente graves como para requerir
que el programa se detenga por completo. A veces, cuando una función falla,
es por una razón que puede interpretar y responder fácilmente. Por ejemplo,
si intenta abrir un archivo y esa operación falla porque el archivo no existe
es posible que desee crear el archivo en lugar de finalizar el proceso.</p>
<p>Recuerde “<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">Manejo de la falla potencial con el tipo <code>Result</code></a> <!-- ignore -->” en el Capítulo 2 que la enumeración <code>Result</code> se define como que tiene dos variantes, <code>Ok</code> y <code>Err</code>, como sigue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>El <code>T</code> y <code>E</code> son parámetros de tipo genérico: discutiremos los genéricos con
más detalle en el Capítulo 10. Lo que necesita saber ahora es que <code>T</code>
representa el tipo del valor que se devolverá en un éxito caso dentro de la
variante <code>Ok</code>, y <code>E</code> representa el tipo de error que se devolverá en un caso
de falla dentro de la variante <code>Err</code>. Como <code>Result</code> tiene estos parámetros de
tipo genérico, podemos utilizar el tipo <code>Result</code> y las funciones que la
biblioteca estándar ha definido en él en muchas situaciones diferentes en las
que el valor correcto y el valor de error que queremos devolver pueden
diferir.</p>
<p>Llamemos a una función que devuelve un valor <code>Result</code> porque la función
podría fallar. En el Listado 9-3 tratamos de abrir un archivo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: Apertura de un archivo</span></p>
<p>¿Cómo sabemos que <code>File::open</code> devuelve un <code>Result</code>? ¡Podríamos mirar la
documentación estándar de la API de la biblioteca, o podríamos preguntarle al
compilador! Si le damos a <code>f</code> una anotación de tipo que sabemos que es <em>no</em> el tipo de retorno de la función y luego tratamos de compilar el código, el compilador nos dirá que los tipos no coinciden. El mensaje de error nos dirá
qué tipo de <code>f</code> <em>es</em>. ¡Vamos a intentarlo! Sabemos que el tipo de devolución
de <code>File::open</code> no es del tipo <code>u32</code>, así que cambiemos la declaración <code>let f</code> a esto:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Intentar compilar ahora nos da el siguiente resultado:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>Esto nos dice que el tipo de retorno de la función <code>File::open</code> es
<code>Result &lt;T, E&gt;</code>. El parámetro genérico <code>T</code> se ha rellenado aquí con el tipo
de valor de éxito,<code>std::fs::File</code>, que es un manejador de archivo. El tipo de
<code>E</code> utilizado en el valor de error es <code>std::io::Error</code>.</p>
<p>Este tipo de devolución significa que la llamada a <code>File::open</code> puede tener
éxito y devolver un manejador de archivo que podemos leer o escribir en. La
llamada a la función también puede fallar: por ejemplo, es posible que el
archivo no exista o que no tengamos permiso para acceder al archivo. La
función <code>File::open</code> necesita tener una forma de decirnos si tuvo éxito o no,
y al mismo tiempo proporcionarnos el identificador del archivo o la
información del error. Esta información es exactamente lo que transmite el
enum de <code>Result</code>.</p>
<p>En el caso donde <code>File::open</code> tiene éxito, el valor en la variable <code>f</code> será
una instancia de <code>Ok</code> que contiene un manejador de archivo. En el caso donde
falla, el valor en <code>f</code> será una instancia de <code>Err</code> que contiene más
información sobre el tipo de error que ocurrió.</p>
<p>Necesitamos agregar al código en el Listado 9-3 para tomar diferentes
acciones dependiendo del valor <code>File: open</code> returns. El Listado 9-4 muestra
una forma de manejar el <code>Result</code> utilizando una herramienta básica, la
expresión <code>match</code> que analizamos en el Capítulo 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-4: Usar una expresión <code>match</code> para manejar las variantes <code>Result</code> que pueden ser devueltas</span></p>
<p>Tenga en cuenta que, al igual que la enumeración <code>Option</code>, el enum <code>Result</code> y
sus variantes se han importado en el preludio, por lo que no es necesario que
especifique <code>Result::</code> antes de las variantes <code>Ok</code> y <code>Err</code> en los brazos del <code>match</code>.</p>
<p>Aquí le decimos a Rust que cuando el resultado es <code>Ok</code>, devuelve el valor
<code>file</code> interno de la variante <code>Ok</code>, y luego asignamos ese valor de manejo de
archivo a la variable <code>f</code>. Después del <code>match</code>, podemos usar el manejador del
archivo para leer o escribir.</p>
<p>El otro brazo del <code>match</code> maneja el caso donde obtenemos un valor <code>Err</code> de
<code>File::open</code>. En este ejemplo, hemos elegido llamar a la macro <code>panic!</code>. Si
no hay un archivo llamado <em>hello.txt</em> en nuestro directorio actual y
ejecutamos este código, veremos el siguiente resultado de la macro <code>panic!</code>:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>Como de costumbre, este resultado nos dice exactamente qué salió mal.</p>
<h3 id="coincidencia-en-diferentes-errores"><a class="header" href="#coincidencia-en-diferentes-errores">Coincidencia en diferentes errores</a></h3>
<p>El código en el Listado 9-4 entrará en <code>panic!</code>. No importa por qué
<code>File::open</code> falló. Lo que queremos hacer en su lugar es tomar diferentes
acciones por diferentes motivos de falla: si <code>File::open</code> falló porque el
archivo no existe, queremos crear el archivo y devolver el manejador al nuevo
archivo. Si <code>File::open</code> falló por alguna otra razón, por ejemplo, porque no
teníamos permiso para abrir el archivo, aún queremos que el código se <code>panic!</code> de la misma manera que en el Listado 9-4 . Mire el Listado 9-5, que agrega otro brazo al <code>match</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore esta prueba porque de lo contrario crea hello.txt que causa
que otras pruebas fallen lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listing 9-5: Manejando diferentes tipos de errores de
diferentes maneras</span></p>
<p>El tipo del valor que <code>File::open</code> devuelve dentro de la variante <code>Err</code> es
<code>io::Error</code>, que es una estructura proporcionada por la biblioteca estándar.
Esta estructura tiene un método <code>kind</code> al que podemos llamar para obtener un
valor <code>io::ErrorKind</code>. La enumeración <code>io::ErrorKind</code> es proporcionado por la
biblioteca estándar y tiene variantes que representa los diferentes tipos de
errores que pueden resultar de un <code>io</code> operación. La variante que
queremos usar es <code>ErrorKind::NotFound</code>, que indica el archivo que intentamos abrir aún no existe.</p>
<p>La condición <code>if error.kind() == ErrorKind::NotFound</code> se llama
<em>match guard</em>: es una condición adicional en un brazo de <code>match</code> que refina
aún más el patrón <em>brazos</em>. Esta condición debe ser verdadera para que se
ejecute el código de ese brazo; de otra manera, la coincidencia de patrones se moverá para considerar el próximo brazo en el <code>match</code>. los
<code>ref</code> en el patrón es necesario para que <code>error</code> no se mueva a la condición
de guardia pero simplemente es referenciado por él. La razón por la que usas
<code>ref</code> para crear una referencia en un patrón en lugar de <code>&amp;</code> se tratará en
detalle en el Capítulo 18. En resumen, en el contexto de un patrón, <code>&amp;</code>
coincide con una referencia y le da su valor, pero <code>ref</code> coincide con un
valor y le da una referencia.</p>
<p>La condición que queremos verificar en el guarda <em>match</em> es si el valor devueltopor <code>error.kind()</code> es la variante <code>NotFound</code> de la enumeración
<code>ErrorKind</code>. Si esto es, intentamos crear el archivo con <code>File::create</code>.
Sin embargo, como <code>File:: reate</code> también podría fallar, también necesitamos
agregar una declaración de interna al <code>match</code>. Cuando el archivo no se puede abrir, se imprimirá un mensaje de error diferente. El último brazo del
<code>match</code> externa permanece igual, por lo que el programa entra en pánico por
cualquier error además de el error de archivo faltante.</p>
<h3 id="atajos-para-pánico-en-caso-de-error-unwrap-y-expect"><a class="header" href="#atajos-para-pánico-en-caso-de-error-unwrap-y-expect">Atajos para pánico en caso de error: <code>unwrap</code> y<code> expect</code></a></h3>
<p>Usar <code>match</code> funciona bastante bien, pero puede ser un poco detallado y no
siempre comunica bien el intento. El tipo <code>Result &lt;T, E&gt;</code> tiene muchos
métodos auxiliares definidos para realizar diversas tareas. Uno de esos
métodos, llamado <code>unwrap</code>, es un método abreviado que se implementa como la
declaración <code>match</code> que escribimos en el Listado 9-4. Si el valor <code>Result</code> es
la variante <code>Ok</code>, <code>unwrap</code> devolverá el valor dentro del <code>Ok</code>. Si el <code>Result</code>
es la variante <code>Err</code>, <code>unwrap</code> llamará a la macro <code>panic!</code> para nosotros.
Aquí hay un ejemplo de <code>unwrap</code> en acción:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Si ejecutamos este código sin un archivo <em>hello.txt</em>, veremos un mensaje de
error de la llamada <code>panic!</code> que el método <code>unwrap</code> hace:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Otro método, <code>expect</code>, que es similar a <code>unwrap</code>, nos permite elegir el
mensaje de error <code>panic!</code>. Usar <code>expect</code> en lugar de <code>unwrap</code> y proporcionar
buenos mensajes de error puede transmitir su intención y facilitar el rastreo
del origen de un ataque de pánico. La sintaxis de <code>expect</code> se ve así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p>Usamos <code>expect</code> de la misma manera que <code>unwrap</code>: para devolver el manejador
de archivo o llamar a la macro <code>panic!</code>. El mensaje de error utilizado por
<code>expect</code> en su llamada a <code>panic!</code> será el parámetro que pasamos a <code>expect</code>,
en lugar del mensaje <code>panic!</code> Predeterminado que <code>unwrap</code> usa. Esto es lo que
parece:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>Como este mensaje de error comienza con el texto que especificamos, <code>Failed to open hello.txt</code>, será más fácil encontrar el origen del código en el que
se origina este mensaje de error. Si usamos <code>unwrap</code> en varios lugares, puede
llevar más tiempo averiguar exactamente qué <code>unwrap</code> está causando el pánico,ya que todas las llamadas <code>unwrap</code> que entran en pánico imprimen el mismo
mensaje.</p>
<h3 id="propagación-de-errores"><a class="header" href="#propagación-de-errores">Propagación de errores</a></h3>
<p>Cuando está escribiendo una función cuya implementación llama a algo que
puede fallar, en lugar de manejar el error dentro de esta función, puede
devolver el error al código de llamada para que pueda decidir qué hacer. Esto
se conoce como <em>propagar</em> el error y le da más control al código de llamada,donde podría haber más información o lógica que dicte cómo se debe manejar el
error que lo que tiene disponible en el contexto de su código.</p>
<p>Por ejemplo, el Listado 9-6 muestra una función que lee un nombre de usuario
de un archivo. Si el archivo no existe o no se puede leer, esta función
devolverá esos errores al código que llamó a esta función.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-6: Una función que devuelve errores al código
de llamada con <code>match</code></span></p>
<p>Mire primero el tipo de retorno de la función:
<code>Resultado &lt;String, io::Error&gt;</code>. Esto significa que la función devuelve un
valor del tipo <code>Result &lt;T, E&gt;</code> donde el parámetro genérico <code>T</code> se ha
rellenado con el tipo concreto <code>String</code> y el tipo genérico <code>E</code> se ha
rellenado con el tipo concreto <code>io::Error</code>. Si esta función tiene éxito sin
ningún problema, el código que llama a esta función recibirá un valor <code>Ok</code> que contiene una <code>String</code>, el nombre de usuario que esta función lee del
archivo. Si esta función encuentra algún problema, el código que llama a esta
función recibirá un valor <code>Err</code> que contiene una instancia de <code>io::Error</code> que
contiene más información sobre cuáles fueron los problemas. Elegimos
<code>io::Error</code> como el tipo de retorno de esta función porque ese es el tipo del
valor de error devuelto por las dos operaciones que estamos llamando en el
cuerpo de esta función que puede fallar: la función <code>File::open</code> y el método
<code>read_to_string</code>.</p>
<p>El cuerpo de la función comienza llamando a la función <code>File::open</code>. Entonces
nosotros manejamos el valor <code>Result</code> devuelto con un <code>match</code> similar al
<code>match</code> en Listado 9-4, solo en lugar de llamar <code>panic!</code> En el caso de <code>Err</code>,
retornamos temprano de esta función y pasamos el valor de error de
<code>File::open</code> vuelve al código de llamada como el valor de error de esta
función. Si <code>File::open</code> tiene éxito, almacenamos el archivo maneja en la
variable <code>f</code> y continúa.</p>
<p>Luego creamos un nuevo <code>String</code> en la variable <code>s</code> y llamamos <code>read_to_string</code>
método en el manejador de archivo en <code>f</code> para leer el contenido del archivo
en<code>s</code>. El método <code>read_to_string</code> también devuelve un <code>Result</code> porque puede
fallar, incluso aunque <code>File::open</code> tenga éxito. Entonces, necesitamos otro
<code>match</code> para manejar eso <code>Result</code>: si <code>read_to_string</code> tiene éxito, entonces nuestra función ha tenido éxito, y nosotros devuelve el nombre de usuario del
archivo que ahora está en <code>s</code> envuelto en un <code>Ok</code>. Si <code>read_to_string</code> falla,
devolvemos el valor de error de la misma manera que devolvió el valor del
error en el <code>match</code> que manejaba el valor de retorno de <code>File::open</code>.
Sin embargo, no necesitamos decir explícitamente <code>return</code>, porque esto
es la última expresión en la función.</p>
<p>El código que llama a este código manejará obtener un valor <code>Ok</code>
que contiene un nombre de usuario o un valor <code>Err</code> que contiene un
<code>io::Error</code>. Nosotros no sabemos qué hará el código de llamada con esos
valores. Si el código de llamada obtiene un valor <code>Err</code>, podría llamar <code>panic!</code> y bloquear el programa, usar un nombre de usuario predeterminado, o
busque el nombre de usuario desde otro lugar que no sea un archivo, por
ejemplo. No tenemos suficiente información sobre lo que el código de llamada
realmente intenta hacer, por lo que propagamos toda la información de éxito o
error hacia arriba para que se maneje adecuadamente.</p>
<p>Este patrón de errores de propagación es tan común en Rust que Rust
proporciona el operador de signo de interrogación <code>?</code> para hacer esto más
fácil.</p>
<h4 id="un-atajo-para-propagar-errores-el-operador-"><a class="header" href="#un-atajo-para-propagar-errores-el-operador-">Un atajo para propagar errores: el operador <code>?</code></a></h4>
<p>El Listado 9-7 muestra una implementación de <code>read_username_from_file</code> que
tiene la misma funcionalidad que tenía en el listado 9-6, pero esta
implementación usa el operador <code>?</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-7: Una función que devuelve errores al código de llamada utilizando el operador <code>?</code></span></p>
<p>El <code>?</code> colocado después de que se haya definido un valor de <code>Result</code> funciona
casi de la misma manera que las expresiones <code>match</code> que definimos para
manejar los valores <code>Result</code> en el Listado 9-6. Si el valor del <code>Result</code> es
un <code>Ok</code>, el valor dentro de <code>Ok</code> se devolverá a partir de esta expresión, y el programa continuará. Si el valor es un <code>Err</code>, el valor dentro de <code>Err</code> se devolverá de la función completa como si hubiéramos usado la palabra clave <code>return</code> para que el valor de error se propague al código de llamada.</p>
<p>Hay una diferencia entre lo que hacen la expresión <code>match</code> del Listado 9-6 y
lo que hace el operador <code>?</code>: los valores de error utilizados con <code>?</code> Pasan
por la función <code>from</code>, definida en el <em>trair</em> <code>From</code> en la biblioteca
estándar, que se usa para convertir errores de un tipo a otro. Cuando el
operador <code>?</code> llama a la función <code>from</code>, el tipo de error recibido se
convierte al tipo de error definido en el tipo de retorno de la función
actual. Esto es útil cuando una función devuelve un tipo de error para
representar todas las formas en que una función puede fallar, incluso si las
partes pueden fallar por muchas razones diferentes. Siempre que cada tipo de
error implemente la función <code>from</code> para definir cómo convertirse al tipo de
error devuelto, el operador <code>?</code> se ocupará de la conversión automáticamente.</p>
<p>En el contexto del Listado 9-7, el <code>?</code> al final de la llamada <code>File::open</code>
devolverá el valor dentro de un <code>Ok</code> a la variable <code>f</code>. Si ocurre un error,
el operador <code>?</code> saldrá temprano de toda la función y dará cualquier valor
<code>Err</code> al código de llamada. Lo mismo se aplica al operador <code>?</code> al final de la
llamada <code>read_to_string</code>.</p>
<p>El operador <code>?</code> Elimina una gran cantidad de texto repetitivo y simplifica la
implementación de esta función. Incluso podríamos acortar este código aún más
mediante el encadenamiento de llamadas de método inmediatamente después del
<code>?</code>, Como se muestra en el Listado 9-8.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 9-8: Llamadas al método de encadenamiento
después del operador <code>?</code></span></p>
<p>Hemos movido la creación del nuevo <code>String</code> en <code>s</code> al comienzo de la función;
esa parte no ha cambiado. En lugar de crear una variable <code>f</code>, hemos
encadenado la llamada a <code>read_to_string</code> directamente en el resultado de
<code>File::open(&quot;hello.txt&quot;)?</code>. Todavía tenemos un <code>?</code> al final de la llamada
<code>read_to_string</code>, y aún devolvemos un valor <code>Ok</code> que contiene el nombre de
usuario en <code>s</code> cuando tanto <code>File::open</code> como <code>read_to_string</code> tienen éxito en lugar de devolver errores. La funcionalidad es nuevamente la misma que en el Listado 9-6 y el Listado 9-7; esta es solo una forma diferente y más ergonómica de escribirlo.</p>
<h4 id="el-operador--solo-se-puede-usar-en-funciones-que-devuelven-result"><a class="header" href="#el-operador--solo-se-puede-usar-en-funciones-que-devuelven-result">El operador <code>?</code> solo se puede usar en funciones que devuelven <code>Result</code></a></h4>
<p>El operador <code>?</code> solo puede usarse en funciones que tienen un tipo de retorno
de <code>Result</code>, porque está definido para funcionar de la misma manera que la
expresión <code>match</code> que definimos en el Listado 9-6. La parte del <code>match</code> que
requiere un tipo de devolución de <code>Result</code> es <code>return Err(e)</code>, por lo que el
tipo de devolución de la función debe ser un <code>Result</code> para que sea compatible
con este <code>return</code>.</p>
<p>Veamos qué pasa si usamos el operador <code>?</code> en la función <code>main</code>, que recordará que tiene un tipo de retorno de <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>Cuando compilamos este código, recibimos el siguiente mensaje de error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `(): std::ops::Try` is not satisfied
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             the `?` operator can only be used in a function that returns
  `Result` (or another type that implements `std::ops::Try`)
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>Este error indica que solo podemos usar el operador <code>?</code> en una función que
devuelve <code>Result</code>. En las funciones que no devuelven <code>Result</code>, cuando llama a
otras funciones que devuelven <code>Result</code>, necesitará usar <code>match</code> o uno de los
métodos <code>Result</code> para manejar <code>Result</code> en lugar de usar el operador <code>?</code> para
propagar potencialmente el error al código de llamada.</p>
<p>Ahora que hemos discutido los detalles de llamar <code>panic!</code> o devolver
<code>Result</code>, volvamos al tema de cómo decidir en qué casos cuál es el adecuado.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
