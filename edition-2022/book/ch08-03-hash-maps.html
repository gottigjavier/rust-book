<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mapas Hash - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Estructura de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Gestión de Proyectos en Crecimiento con Packages, Crates y Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo Módulos para Controlar el Scope y la Privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html" class="active"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones y Coincidencias</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="almacenamiento-de-claves-con-valores-asociados-en-hash-maps-mapa-hash"><a class="header" href="#almacenamiento-de-claves-con-valores-asociados-en-hash-maps-mapa-hash">Almacenamiento de claves con valores asociados en <em>Hash Maps</em> (<em>mapa hash</em>)</a></h2>
<p>La última de nuestras colecciones comunes es el <em>hash map</em>. El tipo
<code>HashMap&lt;K, V&gt;</code> almacena una asignación de claves de tipo <code>K</code> a valores de
tipo<code> V</code>. Lo hace mediante una <em>función de hash</em>, que determina cómo coloca
estas claves y valores en la memoria. Muchos lenguajes de programación
admiten este tipo de estructura de datos, pero a menudo usan un nombre
diferente, como hash, mapa, objeto, tabla hash o matriz asociativa, solo por
nombrar algunos.</p>
<p>Los mapas Hash (<em>hash map</em>) son útiles cuando se quiere buscar datos no
usando un índice, como se puede hacer con vectores, sino usando una clave que
puede ser de cualquier tipo. Por ejemplo, en un juego, puede hacer un
seguimiento del puntaje de cada equipo en un mapa hash en el que cada clave
es el nombre de un equipo y los valores son el puntaje de cada equipo. Dado
el nombre de un equipo, puedes recuperar su puntaje.</p>
<p>Repasaremos la API básica de los mapas hash en esta sección, pero muchas más
cosas se esconden en las funciones definidas en <code>HashMap &lt;K, V&gt;</code> por la
biblioteca estándar. Como siempre, consulte la documentación estándar de la
biblioteca para obtener más información.</p>
<h3 id="crear-un-nuevo-mapa-hash-hash-map"><a class="header" href="#crear-un-nuevo-mapa-hash-hash-map">Crear un nuevo <em>mapa hash</em> (<em>Hash Map</em>)</a></h3>
<p>Puede crear un mapa hash vacío con <code>new</code> y agregar elementos con <code>insert</code>. En
el Listado 8-20, estamos haciendo un seguimiento de las puntuaciones de dos
equipos cuyos nombres son “Blue” y “Yellow”. El equipo “Blue” comienza con 10
puntos, y el equipo “Yellow” comienza con 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-20: Creando un nuevo mapa hash e insertando
algunas claves y valores</span></p>
<p>Tenga en cuenta que necesitamos primero <code>use</code> el <code>HashMap</code> de la porción de
colecciones de la biblioteca estándar. De nuestras tres colecciones comunes,
esta es la menos utilizada, por lo que no está incluida en las
características introducidas automáticamente en el preludio. Los mapas Hash
también tienen menos soporte de la biblioteca estándar; no hay una macro
incorporada para construirlos, por ejemplo.</p>
<p>Al igual que los vectores, los mapas hash almacenan sus datos en el montículo
(<em>heap</em>). Este <code>HashMap</code> tiene claves de tipo <code>String</code> y valores de tipo
<code>i32</code>. Al igual que los vectores, los mapas hash son homogéneos: todas las
claves deben tener el mismo tipo, y todos los valores deben tener el mismo
tipo.</p>
<p>Otra forma de construir un mapa hash es usar el método <code>collect</code> en un vector
de tuplas, donde cada tupla consiste en una clave y su valor. El método
<code>collect</code> reúne datos en varios tipos de colección, incluido <code>HashMap</code>. Por
ejemplo, si tuviéramos los nombres de los equipos y puntajes iniciales en dos
vectores separados, podríamos usar el método <code>zip</code> para crear un vector de
tuplas donde “Blue” está emparejado con 10, y así sucesivamente. Entonces
podríamos usar el método <code>collect</code> para convertir ese vector de tuplas en un
mapa hash, como se muestra en el Listado 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-21: Crear un mapa hash a partir de una lista
de equipos y una lista de puntajes</span></p>
<p>La anotación de tipo <code>HashMap &lt;_, _&gt;</code> es necesaria aquí porque es posible
<code>recopilar</code> en muchas estructuras de datos diferentes y Rust no sabe cuál
quiere a menos que usted especifique. Para los parámetros para la clave y los
tipos de valor, sin embargo, usamos guiones bajos, y Rust puede inferir los
tipos que contiene el hash map en función de los tipos de datos en los
vectores.</p>
<h3 id="hash-maps-mapa-hash-y-propiedad"><a class="header" href="#hash-maps-mapa-hash-y-propiedad"><em>Hash Maps</em> (<em>mapa hash</em>) y Propiedad</a></h3>
<p>Para los tipos que implementan el <em>trait</em> <code>Copy</code>, como <code>i32</code>, los valores se
copian en el mapa hash. Para valores de propiedad como <code>String</code>, los valores
se moverán y el mapa de hash será el propietario de esos valores, como se
muestra en el Listado 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name y field_value no son válidos en este punto, intente usarlos y
// ¡mira qué error de compilación recibes!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-22: Mostrar que las claves y los valores son
propiedad del mapa hash una vez que se insertan</span></p>
<p>No podemos usar las variables <code>field_name</code> y <code>field_value</code> después de que se
hayan movido al mapa hash con la llamada a <code>insert</code>.</p>
<p>Si insertamos referencias a valores en el mapa hash, los valores no se
moverán al mapa hash. Los valores a los que apuntan las referencias deben ser
válidos por lo menos mientras el mapa hash sea válido. Hablaremos más sobre
estos temas en la sección “Validación de referencias con períodos de
vigencia” en el Capítulo 10.</p>
<h3 id="acceso-a-valores-en-un-mapa-hash-hash-map"><a class="header" href="#acceso-a-valores-en-un-mapa-hash-hash-map">Acceso a valores en un mapa hash (<em>Hash Map</em>)</a></h3>
<p>Podemos obtener un valor del <em>hash map</em> (<em>mapa hash</em>) proporcionando su clave
para el método <code>get</code>, como se muestra en el Listado 8-23.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-23: Accediendo al puntaje para el equipo azul
almacenado en el mapa hash</span></p>
<p>Aquí, <code>score</code> tendrá el valor asociado con el equipo Blue, y el resultado
será <code>Some(&amp;10)</code>. El resultado se envuelve en <code>Some</code> porque <code>get</code> devuelve
una <code>Opción &lt;&amp;V&gt;</code>; si no hay ningún valor para esa clave en el mapa hash,<code>get</code> devolverá <code>None</code>. El programa deberá manejar la <code>Option</code> en una de las
formas que cubrimos en el Capítulo 6.</p>
<p>Podemos iterar sobre cada par clave / valor en un mapa hash de manera similar a como lo hacemos con los vectores, usando un bucle <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimirá cada par en un orden arbitrario:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="actualización-de-un-mapa-hash-hash-map"><a class="header" href="#actualización-de-un-mapa-hash-hash-map">Actualización de un mapa Hash (<em>Hash Map</em>)</a></h3>
<p>Aunque la cantidad de claves y valores puede crecer, cada clave solo puede
tener un valor asociado con ella a la vez. Cuando desee cambiar los datos en
un <em>hash map</em> (<em>mapa hash</em>), debe decidir cómo manejar el caso cuando una
clave ya tiene un valor asignado. Puede reemplazar el valor anterior por el
nuevo valor, sin tener en cuenta el valor anterior. Puede mantener el valor
anterior e ignorar el nuevo valor, solo agregando el nuevo valor si la clave
<em>no</em> tiene ya un valor. O puede combinar el valor anterior y el nuevo valor.
¡Veamos cómo hacer cada uno de estos!</p>
<h4 id="sobrescribir-un-valor"><a class="header" href="#sobrescribir-un-valor">Sobrescribir un valor</a></h4>
<p>Si insertamos una clave y un valor en un mapa hash e insertamos esa misma
clave con un valor diferente, el valor asociado con esa clave será
reemplazado. Aunque el código en el Listado 8-24 llama <code>insert</code> dos veces, el
hash map solo contendrá un par de clave/valor porque estamos insertando el
valor para la clave del equipo azul en ambas ocasiones.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-24: Reemplazar un valor almacenado con una
clave particular</span></p>
<p>Este código imprimirá <code>{&quot;Blue&quot;: 25}</code>. El valor original de <code>10</code> ha sido
sobrescrito.</p>
<h4 id="solo-insertar-un-valor-si-la-clave-no-tiene-valor"><a class="header" href="#solo-insertar-un-valor-si-la-clave-no-tiene-valor">Solo insertar un valor si la clave no tiene valor</a></h4>
<p>Es común verificar si una clave en particular tiene un valor y, si no lo
tiene, insertar un valor para ella. Los mapas hash tienen una API especial
para esta llamada <code>entry</code> que toma la clave que desea verificar como
parámetro. El valor de retorno del método <code>entry</code> es una enumeración llamada
<code>Entry</code> que representa un valor que podría existir o no. Digamos que
queremos verificar si la clave del equipo amarillo tiene un valor asociado.
Si no es así, queremos insertar el valor 50, y lo mismo para el equipo azul.
Usando la API <code>entry</code>, el código se ve como el Listado 8-25.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-25: Usando el método <code>entry</code> para insertar
solo si la clave ya no tiene un valor</span></p>
<p>El método <code>or_insert</code> en <code>Entry</code> se define para devolver una referencia
mutable al valor de la tecla <code>Entry</code> correspondiente si esa clave existe, y
si no, inserta el parámetro como el nuevo valor para esta clave y devuelve
una referencia mutable al nuevo valor. Esta técnica es mucho más limpia que
escribir la lógica nosotros mismos y, además, juega mejor con el comprobador
de préstamos.</p>
<p>Al ejecutar el código en el Listado 8-25 se imprimirá
<code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. La primera llamada a <code>entry</code> insertará la
clave para el equipo Amarillo con el valor 50 porque el equipo Amarillo ya no
tiene un valor. La segunda llamada a <code>entry</code> no cambiará el <em>hash map</em>
(<em>mapa hash</em>) porque el equipo azul ya tiene el valor 10.</p>
<h4 id="actualización-de-un-valor-basado-en-el-valor-anterior"><a class="header" href="#actualización-de-un-valor-basado-en-el-valor-anterior">Actualización de un valor basado en el valor anterior</a></h4>
<p>Otro caso de uso común para los mapas hash es buscar el valor de una clave y
luego actualizarla en función del valor anterior. Por ejemplo, el Listado
8-26 muestra un código que cuenta cuántas veces aparece cada palabra en algún
texto. Usamos un mapa hash con las palabras como teclas e incrementamos el
valor para realizar un seguimiento de cuántas veces hemos visto esa palabra.
Si es la primera vez que vemos una palabra, primero insertamos el valor 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-26: Recuento de ocurrencias de palabras
usando un mapa hash que almacena palabras y cuenta</span></p>
<p>Este código imprimirá <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. El método
<code>or_insert</code> en realidad devuelve una referencia mutable (<code>&amp;mut V</code>) al valor
de esta clave. Aquí almacenamos esa referencia mutable en la variable <code>count</code>,por lo que para asignar a ese valor, primero debemos eliminar la referencia
<code>count</code> utilizando el asterisco (<code>*</code>). La referencia mutable sale del alcance
al final del ciclo <code>for</code>, por lo que todos estos cambios son seguros y están
permitidos por las reglas de préstamo.</p>
<h3 id="funciones-hash"><a class="header" href="#funciones-hash">Funciones <em>hash</em></a></h3>
<p>Por defecto, <code>HashMap</code> utiliza una función hashing criptográficamente segura
que puede proporcionar resistencia a los ataques de denegación de servicio
(DoS). Este no es el algoritmo de hashing más rápido disponible, pero vale la
pena la compensación para una mejor seguridad que viene con la caída en el
rendimiento. Si perfila su código y descubre que la función hash
predeterminada es demasiado lenta para sus propósitos, puede cambiar a otra
función especificando un <em>hasher</em> diferente. Un <em>hasher</em> es un tipo que
implementa el <em>trait</em> <code>BuildHasher</code>. Hablaremos sobre los <em>trait</em> y cómo
implementarlos en el Capítulo 10. No necesariamente tiene que implementar su
propio hasher desde cero; [crates.io] (https://crates.io) tiene bibliotecas
compartidas por otros usuarios de Rust que proporcionan <em>hashers</em> que
implementan muchos algoritmos <em>hash</em> comunes.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>Los vectores, <em>string</em> y <em>hash maps</em> proporcionarán una gran cantidad de
funcionalidad necesaria en los programas cuando necesite almacenar, acceder y
modificar datos. Aquí hay algunos ejercicios que ahora debes estar preparado
para resolver:</p>
<ul>
<li>Dada una lista de enteros, usa un vector y regresa la media (el valor
promedio), la media (cuando se clasifica, el valor en la posición media) y el modo (el valor que ocurre con mayor frecuencia, un <em>hash maps</em> será útil aquí ) de la lista.</li>
<li>Convertir <em>strings to pig latin</em>. La primera consonante de cada palabra se
mueve al final de la palabra y se agrega “ay”, por lo que “first” se convierte en “irst-fay.” Las palabras que comienzan con una vocal tienen “hay”agregado al final (&quot;apple &quot;Se convierte en “apple-hay”). ¡Tenga en cuenta los detalles sobre la codificación UTF-8!</li>
<li>Utilizando un <em>hash maps</em> y vectores, cree una interfaz de texto para
permitir que un usuario agregue nombres de empleados a un departamento de una empresa. Por ejemplo, &quot;Agregar Sally a la ingeniería&quot; o &quot;Agregar Amir a las ventas&quot;. Luego, permita que el usuario obtenga una lista de todas las personas de un departamento o de todas las personas de la empresa por departamento, ordenados alfabéticamente.</li>
</ul>
<p>¡La documentación estándar de la API de la biblioteca describe los métodos
que los vectores, los <em>string</em> y los <em>hash maps</em> ¡Eso será útil para estos
ejercicios!</p>
<p>Estamos entrando en programas más complejos en los que las operaciones pueden
fallar, por lo tanto, es un momento perfecto para analizar el manejo de
errores. ¡Haremos eso en el próximo!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-02-strings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-00-error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-02-strings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-00-error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
