<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>El Lenguaje de Programación Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Estructura de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-packages-crates-modules.html"><strong aria-hidden="true">7.</strong> Gestión de Proyectos en Crecimiento con Packages, Crates y Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo Módulos para Controlar el Scope y la Privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Llevando Rutas al Scope con la Palabra Clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separación de Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones y Coincidencias</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prefacio"><a class="header" href="#prefacio">Prefacio</a></h1>
<p>No siempre fue tan claro, pero el lenguaje de programación Rust se fundamenta en el <em>empoderamiento</em>: no importa qué tipo de código esté escribiendo ahora, Rust te permite llegar más lejos, programar con confianza en una variedad más amplia de dominios que antes.</p>
<p>Tomemos, por ejemplo, el trabajo a “nivel de sistemas” que trata detalles de bajo nivel de administración de memoria, representación de datos y concurrencia. Tradicionalmente, este dominio de la programación se ve como algo arcano, accesible solo para unos pocos que han dedicado los años necesarios para aprender a evitar sus infames escollos. E incluso aquellos
que lo practican lo hacen con precaución, no sea que su código esté abierto a vulnerabilidades, fallos o corrupción.</p>
<p>Rust rompe estas barreras al eliminar las viejas trampas y proporcionar un conjunto amigable y pulido de herramientas para ayudarte en el camino. Los programadores que necesitan “sumergirse” en el control del bajo nivel pueden hacerlo con Rust, sin asumir el riesgo habitual de bloqueos o brechas de seguridad, y sin tener que aprender los puntos finos de una cadena de herramientas voluble. Mejor aún, el lenguaje está diseñado para guiarlo de manera natural hacia un código confiable que sea eficiente en términos de velocidad y uso de la memoria.</p>
<p>Los programadores que ya están trabajando con código de bajo nivel pueden usar Rust para elevar sus ambiciones. Por ejemplo, introducir el paralelismo en Rust es una operación de relativamente bajo riesgo: el compilador detectará los errores clásicos por usted. Y puede abordar optimizaciones más agresivas en su código con la confianza de que no introducirá accidentalmente
fallas o vulnerabilidades.</p>
<p>Pero Rust no se limita a la programación de sistemas de bajo nivel. Es lo suficientemente expresivo y ergonómico para hacer que las aplicaciones CLI los servidores web y muchos otros tipos de código sean bastante agradables de escribir: encontrará ejemplos simples de ambos más adelante en el libro. Trabajar con Rust te permite desarrollar habilidades que se transfieren de un dominio a otro; puede aprender Rust escribiendo una aplicación web, luego aplicar esas mismas habilidades para apuntar a su Raspberry Pi.</p>
<p>Este libro abarca por completo el potencial de Rust para empoderar a sus usuarios. Es un texto amigable y accesible, pensado para ayudarlo a subir de nivel no solo su conocimiento de Rust, sino también su alcance y confianza como programador en general. Así que sumérjase, prepárese para aprender, ¡y bienvenido a la comunidad de Rust!</p>
<p>— Nicholas Matsakis and Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<blockquote>
<p>Nota: esta edición del libro es igual a
<a href="https://nostarch.com/rust">The Rust Programming Language</a> disponible en formato de impresión
y ebook desde <a href="https://nostarch.com/">No Starch Press</a>.</p>
</blockquote>
<p>Bienvenido a <em>El lenguaje de programación de Rust</em> (<em>The Rust Programming Language</em>), un libro introductorio sobre Rust. El lenguaje de programación Rust le ayuda a escribir software más rápido y confiable. La ergonomía de alto nivel y el control de bajo nivel a menudo están en desacuerdo en el diseño del lenguaje de programación; Rust desafía ese conflicto. Al equilibrar una capacidad técnica poderosa y una excelente experiencia de desarrollador, Rust le brinda la opción de controlar detalles de bajo nivel (como el uso de la memoria) sin todas las molestias asociadas tradicionalmente con dicho control.</p>
<h2 id="para-quién-es-rust"><a class="header" href="#para-quién-es-rust">Para Quién es Rust</a></h2>
<p>Rust es ideal para muchas personas por una variedad de razones. Veamos algunos de los grupos más importantes.</p>
<h3 id="equipos-de-desarrolladores"><a class="header" href="#equipos-de-desarrolladores">Equipos de Desarrolladores</a></h3>
<p>Rust está demostrando ser una herramienta productiva para colaborar entre grandes equipos de desarrolladores con diferentes niveles de conocimiento de programación de sistemas. El código de bajo nivel es propenso a una variedad de errores sutiles, que en la mayoría de los otros lenguajes solo se pueden atrapar mediante pruebas exhaustivas y una cuidadosa revisión del código por parte de desarrolladores experimentados. En Rust, el compilador desempeña un
rol de guardián al negarse a compilar código con estos esquivos errores, incluidos los errores de concurrencia. Al trabajar junto con el compilador, el equipo puede dedicar su tiempo a enfocarse en la lógica del programa en lugar de buscar errores.</p>
<p>Rust también trae herramientas de desarrollo contemporáneas al mundo de programación de sistemas:</p>
<ul>
<li>Cargo, el administrador de dependencias incluido y la herramienta de compilación hace que agregar, compilar y gestionar dependencias sea sencillo y consistente en todo el ecosistema de Rust.</li>
<li>Rustfmt garantiza un estilo de codificación consistente entre los desarrolladores.</li>
<li>Rust Language Server impulsa la integración del entorno de desarrollo integrado (IDE) para la finalización del código y mensajes de error en línea.</li>
</ul>
<p>Al usar estas y otras herramientas en el ecosistema de Rust, los desarrolladores pueden ser productivos al escribir código a nivel de sistema.</p>
<h3 id="estudiantes"><a class="header" href="#estudiantes">Estudiantes</a></h3>
<p>Rust es para estudiantes y aquellos que están interesados en aprender sobre conceptos de sistemas. Con Rust, muchas personas han aprendido sobre temas como el desarrollo de sistemas operativos. La comunidad es muy acogedora y está feliz de responder las preguntas de los estudiantes. A través de esfuerzos como este libro, los equipos de Rust quieren que los conceptos de sistemas sean más accesibles para más personas, especialmente aquellos que son nuevos en la programación.</p>
<h3 id="compañías"><a class="header" href="#compañías">Compañías</a></h3>
<p>Cientos de empresas, grandes y pequeñas, usan Rust en producción para una variedad de tareas. Esas tareas incluyen herramientas de línea de comandos, servicios web, herramientas DevOps, dispositivos integrados, análisis y transcodificación de audio y video, criptomonedas, bioinformática, motores de búsqueda, aplicaciones de <em>Internet de las Cosas</em>, machine learning e
incluso partes importantes del navegador web <em>Firefox</em>.</p>
<h3 id="desarrolladores-de-código-abierto"><a class="header" href="#desarrolladores-de-código-abierto">Desarrolladores de Código Abierto</a></h3>
<p>Rust es para las personas que desean construir el lenguaje de programación Rust, la comunidad, las herramientas de desarrollo y las bibliotecas. Nos encantaría que contribuyera al lenguaje Rust.</p>
<h3 id="personas-que-valoran-la-velocidad-y-la-estabilidad"><a class="header" href="#personas-que-valoran-la-velocidad-y-la-estabilidad">Personas que Valoran la Velocidad y la Estabilidad</a></h3>
<p>Rust es para personas que buscan velocidad y estabilidad en un lenguaje. Por velocidad, nos referimos a la velocidad de los programas que puede crear con Rust y la velocidad a la que Rust le permite escribirlos. Las comprobaciones del compilador de Rust garantizan la estabilidad a través de la adición de características y la refactorización. Esto contrasta con el frágil código heredado en lenguajes sin estas comprobaciones, que los desarrolladores a menudo temen modificar. Al esforzarse por lograr abstracciones de costo cero, características de alto nivel que se compilan en código de bajo nivel tan rápido como el código escrito manualmente, Rust se esfuerza por hacer que el código seguro también sea código rápido.</p>
<p>El lenguaje Rust espera admitir también a muchos otros usuarios; los mencionados aquí son simplemente algunos de los principales interesados. En general, la mayor ambición de Rust es eliminar las concesiones que los programadores han aceptado durante décadas proporcionando seguridad y productividad, velocidad y ergonomía. Pruebe Rust y vea si sus opciones funcionan para usted.</p>
<h2 id="para-quién-es-este-libro"><a class="header" href="#para-quién-es-este-libro">Para Quién es este Libro</a></h2>
<p>Este libro asume que ha escrito código en otro lenguaje de programación, pero no hace ninguna suposición sobre cuál. Hemos tratado de hacer que el material sea ampliamente accesible para aquellos con una gran variedad de antecedentes en programación. No dedicamos mucho tiempo a hablar sobre qué es la programación o cómo pensar en ella. Si es completamente nuevo en la programación, sería mejor que leyera un libro que brinde específicamente una introducción a la programación.</p>
<h2 id="cómo-usar-este-libro"><a class="header" href="#cómo-usar-este-libro">Cómo Usar Este Libro</a></h2>
<p>En general, este libro asume que lo está leyendo en secuencia desde principio hacia el final. Los capítulos posteriores se basan en conceptos de capítulos anteriores, y es posible que los capítulos anteriores no profundicen en los detalles de un tema; por lo general, retomamos el tema en un capítulo posterior.</p>
<p>Encontrará dos tipos de capítulos en este libro: capítulos conceptuales y capítulos proyecto. En los capítulos conceptuales, aprenderá sobre un aspecto de Rust. En los capítulos del proyecto, crearemos pequeños programas juntos, aplicando lo que has aprendido hasta ahora. Los capítulos 2, 12 y 20 son capítulos de proyectos; el resto son capítulos conceptuales.</p>
<p>El Capítulo 1 explica cómo instalar Rust, cómo escribir un programa <em>Hello, world!</em>, y cómo usar Cargo, el administrador de paquetes y herramienta de compilación de Rust. El Capítulo 2 es una introducción práctica al lenguaje Rust. Aquí cubrimos conceptos a un alto nivel, y capítulos posteriores proporcionarán detalles adicionales. Si quiere ensuciarse las manos de inmediato, el Capítulo 2 es el lugar para eso. Al principio, usted podría incluso omitir el Capítulo 3, que cubre las características de Rust similares a las de otros lenguajes de programación, y dirirse directamente al Capítulo 4 para aprender sobre el <em>Sistema de Propiedad</em> de Rust. Sin embargo, si usted es un estudiante particularmente meticuloso que prefiere aprender cada detalle antes de pasar al siguiente, puede omitir el Capítulo 2 e ir directamente al Capítulo 3, regresando al Capítulo 2 cuando desee trabajar en un proyecto aplicando los detalles que ha aprendido.</p>
<p>El Capítulo 5 analiza <em>structs</em> (estructuras) y métodos, y el Capítulo 6 cubre <em>enums</em> (enumeraciones), expresiones <code>match</code> y la estructura de control <code>if let</code>. Utilizará structs y enums para crear tipos personalizados en Rust.</p>
<p>En el Capítulo 7, aprenderá sobre el sistema de módulos de Rust y sobre las reglas de privacidad para organizar su código y su Interfaz de Programación de Aplicaciones (API) pública. El Capítulo 8 analiza algunas colecciones de estructuras de datos comunes que proporciona la biblioteca estándar, como vectores, strings y mapas hash. El Capítulo 9 explora la filosofía y las técnicas de manejo de errores de Rust.</p>
<p>El Capítulo 10 explora los genéricos, los <em>traits</em> y los <em>lifetimes</em>, que le dan la capacidad de definir el código que se aplica a múltiples tipos. El Capítulo 11 trata sobre testing, que incluso con las garantías de seguridad de Rust es necesario para garantizar que la lógica de su programa sea correcta. En el Capítulo 12, construiremos nuestra propia implementación de un subconjunto de funcionalidades desde la herramienta de línea de comandos <code>grep</code> que busca texto dentro de los archivos. Para esto, usaremos muchos de los conceptos que discutimos en los capítulos anteriores.</p>
<p>El Capítulo 13 explora <em>closures</em> e iteradores: características de Rust que provienen de lenguajes de programación funcionales. En el Capítulo 14, examinaremos Cargo con más profundidad y hablaremos sobre las mejores prácticas para compartir sus bibliotecas con otras personas. El Capítulo 15 analiza los <em>puteros inteligentes</em> que proporciona la biblioteca estándar y los <em>traits</em> que permiten su funcionalidad.</p>
<p>En el Capítulo 16, analizaremos diferentes modelos de programación concurrente y hablaremos sobre cómo Rust le ayuda a programar en múltiples <em>hilos</em> (<em>threads</em>) sin miedo. El Capítulo 17 analiza cómo los modismos de Rust se comparan con los principios de programación orientada a objetos con los que puede estar familiarizado.</p>
<p>El Capítulo 18 es una referencia sobre patrones y concordancia de patrones, que son formas poderosas de expresar ideas a través de los programas de Rust. El Capítulo 19 contiene una mezcla heterogénea de temas de interés avanzados, incluido Rust <em>unsafe</em> y más <em>lifetimes</em>, <em>traits</em>, tipos, funciones y <em>closures</em>.</p>
<p>En el Capítulo 20, completaremos un proyecto en el que implementaremos un servidor web <em>multi-hilo</em> de bajo nivel.</p>
<p>Finalmente, algunos apéndices contienen información útil sobre el lenguaje en un formato más parecido a una referencia. El Apéndice A cubre las palabras clave de Rust, el Apéndice B cubre los operadores y símbolos de Rust, el Apéndice C cubre los <em>traits</em> derivables proporcionados por la biblioteca estándar, el Apéndice D cubre algunas herramientas de desarrollo útiles y el Apéndice E explica las ediciones de Rust. En el Apéndice F, puede encontrar traducciones del libro, y en el Apéndice G cubriremos cómo se hace Rust y qué es Rust nocturno.</p>
<p>No hay una manera incorrecta de leer este libro: si quiere saltarse, ¡adelante! es posible que deba volver a los capítulos anteriores si experimenta alguna confusión. Pero haga lo que sea que funcione para usted.</p>
<p>Una parte importante del proceso de aprendizaje de Rust es aprender a leer los mensajes de error que muestra el compilador: estos lo guiarán hacia el código que funciona. Como tal, proporcionaremos muchos ejemplos que no compilan junto con el mensaje de error que el compilador le mostrará en cada situación. Sepa que si ingresa y ejecuta un ejemplo aleatorio, ¡es posible que no se compile! Asegúrese de leer el texto que lo rodea para ver si el ejemplo que está tratando de ejecutar está destinado a un error.</p>
<p>En la mayoría de las situaciones, lo guiaremos a la versión correcta de cualquier código que no se compile.</p>
<blockquote>
<p>Nota del Traductor:</p>
<blockquote>
<p>Algunos conceptos en el mundo de la programación están muy ligados a una palabra o expresión en el idioma inglés y/o son de uso muy habitual. En esos casos se ha decidido realizar una traducción de la mejor manera posible y sólo en los primeros usos. Esto, además de evitar hambigüedades, beneficia tanto a los lectores que ya manejan dichos conceptos, como a los que recién los descubren, dándoles la oportunidad de incorporar su utilización.</p>
</blockquote>
</blockquote>
<h2 id="código-fuente"><a class="header" href="#código-fuente">Código fuente</a></h2>
<p><em>Los archivos de origen de los que se genera este libro se pueden encontrar en (versión original ingles)</em>:
<a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.</p>
<p>Versión en español:
<a href="https://github.com/gottigjavier/rust-book/tree/master/edition-2022/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empezando"><a class="header" href="#empezando">Empezando</a></h1>
<p>¡Comencemos su viaje a Rust! Hay mucho que aprender, pero
cada viaje comienza en alguna parte. En este capítulo, discutiremos:</p>
<ul>
<li>Instalación de Rust en Linux, macOS y Windows</li>
<li>Escribir un programa que imprime <code>Hello, world!</code></li>
<li>Uso de <code>cargo</code>, el administrador de paquetes y sistema de compilación de Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalación"><a class="header" href="#instalación">Instalación</a></h2>
<p>El primer paso es instalar Rust. Descargaremos Rust a través de <code>rustup</code>, una
herramienta de línea de comando para administrar las versiones de Rust y las
herramientas asociadas. Necesitará una conexión a Internet para la descarga.</p>
<blockquote>
<p>Nota: si prefiere no usar <code>rustup</code> por algún motivo, consulte <a href="https://www.rust-lang.org/install.html">la página de instalación de Rust</a> para ver otras opciones.</p>
</blockquote>
<p>Los siguientes pasos instalan la última versión estable del compilador Rust.
Todos los ejemplos y resultados de este libro usan Rust 1.21.0 estable. Las
garantías de estabilidad de Rust aseguran que todos los ejemplos en el libro
que se compilan continúen compilando con versiones más nuevas de Rust. La
salida puede variar ligeramente entre las versiones, porque Rust a menudo
mejora los mensajes de error y las advertencias. En otras palabras, cualquier
versión más nueva y estable de Rust que instale utilizando estos pasos
debería funcionar como se espera con el contenido de este libro.</p>
<blockquote>
<h3 id="notación-de-línea-de-comando"><a class="header" href="#notación-de-línea-de-comando">Notación de línea de comando</a></h3>
<p>En este capítulo y en todo el libro, mostraremos algunos comandos
utilizados en la terminal. Las líneas que debe ingresar en un terminal
comienzan todas con <code>$</code>. No necesita escribir el caracter <code>$</code>; indica el
inicio de cada comando. Las líneas que no comienzan con <code>$</code> típicamente
muestran el resultado del comando anterior. Además, los ejemplos específicos
de PowerShell usarán <code>&gt;</code> en lugar de <code>$</code>.</p>
</blockquote>
<h3 id="instalando-rustup-en-linux-o-macos"><a class="header" href="#instalando-rustup-en-linux-o-macos">Instalando <code>rustup</code> en Linux o macOS</a></h3>
<p>Si está utilizando Linux o macOS, abra una terminal e ingrese el siguiente
comando:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>El comando descarga un script e inicia la instalación de la herramienta
<code>rustup</code>, que instala la última versión estable de Rust. Es posible que se le
pida su contraseña. Si la instalación es exitosa, aparecerá la siguiente
línea:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Si lo prefiere, puede descargar el script e inspeccionarlo antes de
ejecutarlo.</p>
<p>La secuencia de comandos de instalación agrega automáticamente Rust al
PATH del sistema después de su próximo inicio de sesión. Si desea comenzar a
usar Rust de inmediato en lugar de reiniciar su terminal, ejecute el
siguiente comando para agregar Rust al PATH del sistema manualmente:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Alternativamente, puede agregar la siguiente línea a su <em>~/.bash_profile</em>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<p>Además, necesitará un <em>enlazador</em> (<em>linker</em>) de algún tipo. Es probable que
ya esté instalado, pero cuando intenta compilar un programa de Rust y obtiene
errores que indican que un enlazador no se pudo ejecutar, eso significa que
un enlazador no está instalado en su sistema y tendrá que instalar uno
manualmente. Los compiladores C normalmente vienen con el enlazador correcto.
Consulte la documentación de su plataforma para saber cómo instalar un
compilador de C. Además, algunos paquetes comunes de Rust dependen del código
C y necesitarán un compilador de C. Por lo tanto, podría valer la pena
instalar uno ahora.</p>
<h3 id="instalando-rustup-en-windows"><a class="header" href="#instalando-rustup-en-windows">Instalando <code>rustup</code> en Windows</a></h3>
<p>En Windows, vaya a [https://www.rust-lang.org/install.html][install] y siga
las instrucciones para instalar Rust. En algún momento de la instalación,
recibirá un mensaje explicando que también necesitará las herramientas de
compilación de C ++ para Visual Studio 2013 o posterior. La forma más fácil
de adquirir las herramientas de compilación es instalar
<a href="https://www.visualstudio.com/downloads/">Build Tools for Visual Studio</a>. Las herramientas se
encuentran en la sección Otras herramientas y marcos.</p>
<p>El resto de este libro usa comandos que funcionan tanto en <em>cmd.exe</em> como en
PowerShell. Si hay diferencias específicas, explicaremos cuál usar.</p>
<h3 id="actualización-y-desinstalación"><a class="header" href="#actualización-y-desinstalación">Actualización y desinstalación</a></h3>
<p>Después de haber instalado Rust mediante <code>rustup</code>, es fácil actualizar a la
última versión. Desde su shell, ejecute el siguiente script de actualización:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<p>Para desinstalar Rust y <code>rustup</code>, ejecute el siguiente script de
desinstalación desde su terminal:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<h3 id="solución-de-problemas"><a class="header" href="#solución-de-problemas">Solución de problemas</a></h3>
<p>Para verificar si tiene instalado Rust correctamente, abra un terminal e ingrese
esta línea:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Debería ver el número de versión, el hash de confirmación y la fecha de
confirmación para la última versión estable que se ha publicado en el
siguiente formato:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Si ve esta información, ¡ha instalado Rust con éxito! Si no ve esta
información y está en Windows, verifique que Rust esté en su variable de
sistema <code>%PATH%</code>. Si eso es todo correcto y Rust todavía no funciona, hay
varios lugares donde puede obtener ayuda. El más fácil es
<a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a><!-- ignore -->, al que se
puede acceder a través de <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. En esa dirección puedes chatear
con otros Rustáceos (un sobrenombre ridículo que nos llamamos a nosotros
mismos) que pueden ayudarte. Otros recursos geniales incluyen <a href="https://users.rust-lang.org/">el foro de usuarios</a> y <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<h3 id="documentación-local"><a class="header" href="#documentación-local">Documentación local</a></h3>
<p>El instalador también incluye una copia de la documentación localmente, para
que pueda leerla sin conexión. Ejecute <code>rustup doc</code> para abrir la
documentación local en su navegador.</p>
<p>Cada vez que la biblioteca estándar proporciona un tipo o función y no está
seguro de qué hace ni cómo usarla, ¡utilice la documentación de la interfaz
de programación de aplicaciones (API) para averiguarlo!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-mundo"><a class="header" href="#hola-mundo">Hola, Mundo!</a></h2>
<p>Ahora que ha instalado Rust, vamos a escribir su primer programa Rust. Es
tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa
que imprime el texto <code>Hello, world!</code> en la pantalla, ¡así que haremos lo
mismo aquí!</p>
<blockquote>
<p>Nota: Este libro asume familiaridad básica con la línea de comando. Rust no
exige nada específico acerca de su edición o herramienta, ni dónde vive su
código, por lo que si prefiere utilizar un entorno de desarrollo integrado
(IDE) en lugar de la línea de comandos, puede usar su IDE favorito. Muchos
IDEs ahora tienen cierto grado de compatibilidad con Rust; revise la
documentación del IDE para más detalles. Recientemente, el equipo de Rust se
ha centrado en permitir un excelente soporte de IDE a través de, por ejemplo, <code>rust-analyzer</code>,
¡y se ha avanzado rápidamente en ese frente!</p>
</blockquote>
<h3 id="crear-un-directorio-de-proyectos"><a class="header" href="#crear-un-directorio-de-proyectos">Crear un Directorio de Proyectos</a></h3>
<p>Comenzará haciendo un directorio para almacenar su código Rust. A Rust no le
importa dónde vive su código, pero para los ejercicios y proyectos de este
libro, le sugerimos que cree un directorio <em>projects</em> en su directorio
personal y que mantenga todos sus proyectos allí.</p>
<p>Abra un terminal e ingrese los siguientes comandos para crear un directorio
<em>projects</em> y un directorio para el proyecto <em>Hello, world!</em> dentro del
directorio <em>projects</em>.</p>
<p>Para Linux y macOS, ingrese esto:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Para Windows CMD, ingrese esto:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>Para Windows PowerShell, ingrese esto:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="escribir-y-ejecutar-un-programa-en-rust"><a class="header" href="#escribir-y-ejecutar-un-programa-en-rust">Escribir y Ejecutar un Programa en Rust</a></h3>
<p>A continuación, cree un nuevo archivo fuente y llámelo <em>main.rs</em>. Los
archivos Rust siempre terminan con la extensión <em>.rs</em>. Si usa más de una
palabra en su nombre de archivo, use un guión bajo para separarlas. Por
ejemplo, use <em>hello_world.rs</em> en lugar de <em>helloworld.rs</em>.</p>
<p>Ahora abra el archivo <em>main.rs</em> que acaba de crear e ingrese el código en el
Listado 1-1.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listado 1-1: Un programa que imprime
<code>Hello, world!</code></span></p>
<p>Guarde el archivo y regrese a la ventana de su terminal. En Linux o macOS,
ingrese los siguientes comandos para compilar y ejecutar el archivo:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>En Windows, ingrese el comando <code>.\main.exe</code> en lugar de <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Independientemente de su sistema operativo, la cadena <code>Hello, world!</code> debe
imprimirse en la terminal. Si no ve esta salida, consulte la sección
<a href="ch01-01-installation.html#soluci%C3%B3n-de-problemas">“Solución de problemas”</a> para obtener ayuda.</p>
<p>Si <code>Hello, world!</code> se imprimió, ¡felicitaciones! Usted ha escrito
oficialmente un programa de Rust. Eso le convierte en un programador de Rust,
¡bienvenido!</p>
<h3 id="anatomía-de-un-programa-de-rust"><a class="header" href="#anatomía-de-un-programa-de-rust">Anatomía de un Programa de Rust</a></h3>
<p>Repasemos en detalle lo que acaba de suceder en su programa <em>Hello, world!</em>.
Aquí está la primera pieza del rompecabezas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas líneas definen una función llamada <code>main</code>. La función <code>main</code> es especial:
siempre es el primer código que se ejecuta en cada programa ejecutable de
Rust. La primera línea declara una función llamada <code>main</code> que no tiene
parámetros y no devuelve nada. Si hubiera parámetros, entrarían entre
paréntesis, <code>()</code>.</p>
<p>El cuerpo de la función está envuelto en llaves, <code>{}</code>. Rust requiere llaves alrededor de todos los cuerpos de funciones. Es un buen estilo colocar la llave de apertura en la misma línea que la
declaración de función, agregando un espacio intermedio.</p>
<blockquote>
<p>Nota: si desea apegarse a un estilo estándar en todos los proyectos de Rust, puede usar una herramienta de formateo automático llamada <code>rustfmt</code> para formatear su código en un estilo particular (más información sobre <code>rustfmt</code> en el <a href="appendix-04-useful-development-tools.html">Apéndice D</a>). El equipo de Rust ha incluido esta herramienta con la distribución estándar de Rust, como rustc, ¡así que ya debería estar instalada en su computadora!</p>
</blockquote>
<p>Dentro de la función <code>main</code> está el siguiente código:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Esta línea hace todo el trabajo en este pequeño programa: imprime texto en la pantalla. Hay cuatro detalles importantes para notar aquí.</p>
<p>Primero, el estilo Rust es indentar con cuatro espacios, no con una <em>tabulación</em>.</p>
<p>Segundo, <code>println!</code> llama a una macro de Rust. Si llamara a una función en su lugar, se ingresaría como <code>println</code> (sin el <code>!</code>). Analizaremos las macros de Rust con más detalle en el Capítulo 19. Por ahora, solo necesita saber que usar <code>!</code> significa que está llamando a una macro en lugar de a una función normal, y que las macros a veces no siguen algunas reglas de las funciones.</p>
<p>Tercero,  el <em>string</em> <code>&quot;Hello, world!&quot;</code>. Pasamos este <em>string</em> como un argumento a <code>println!</code>, Y el <em>string</em> se imprime en la pantalla.</p>
<p>Cuarto, terminamos la línea con un punto y coma (<code>;</code>), lo que indica que esta expresión ha terminado y la siguiente está lista para comenzar. La mayoría de las líneas de código Rust terminan con un punto y coma.</p>
<h3 id="compilar-y-ejecutar-son-pasos-separados"><a class="header" href="#compilar-y-ejecutar-son-pasos-separados">Compilar y Ejecutar son <em>Pasos Separados</em></a></h3>
<p>Acaba de ejecutar un programa recién creado, así que examinemos cada paso del proceso.</p>
<p>Antes de ejecutar un programa Rust, debe compilarlo usando el compilador Rust ingresando el comando <code>rustc</code> y pasándole el nombre de su archivo fuente, de esta manera:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Si tiene experiencia en C o C++, notará que esto es similar a <code>gcc</code> o <code>clang</code>. Después de compilar con éxito, Rust genera un ejecutable binario.</p>
<p>En Linux, macOS y PowerShell en Windows, puede ver el ejecutable ingresando el comando <code>ls</code> en su shell. En Linux y macOS, verá dos archivos. Con PowerShell en Windows, verá los mismos tres archivos que vería con CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>Con CMD en Windows, debe ingresar lo siguiente:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Esto muestra el archivo de código fuente con la extensión <em>.rs</em>, el archivo ejecutable (<em>main.exe</em> en Windows, pero <em>main</em> en todas las demás plataformas y, cuando se usa CMD, un archivo que contiene información de depuración con extensión <em>.pdb</em>. Desde aquí, ejecute el archivo <em>main</em> o <em>main.exe</em>, como este:</p>
<pre><code class="language-text">$ ./main   # .\main.exe en Windows
</code></pre>
<p>Si <em>main.rs</em> fue su programa &quot;Hello, world!&quot;, esta línea imprimiría <code>Hello, world!</code> en su terminal.</p>
<p>Si está más familiarizado con un lenguaje dinámico, como Ruby, Python o JavaScript, es posible que no esté acostumbrado a compilar y ejecutar un programa como pasos separados. Rust es un lenguaje <em>compilado con anticipación</em>, lo que significa que puede compilar un programa y darle el ejecutable a otras personas, y ellas pueden ejecutarlo incluso sin tener instalado Rust. Si le da a alguien un archivo <em>.rb</em>, <em>.py</em> o <em>.js</em>, debe tener instalada una implementación de Ruby, Python o JavaScript (respectivamente). Pero en esos lenguajes, solo necesita un comando para compilar y ejecutar su programa. Todo es una compensación en el diseño del lenguaje.</p>
<p>Compilar con <code>rustc</code> está bien para programas simples, pero a medida que crece su proyecto, querrá administrar todas las opciones y facilitar el compartir su código. A continuación, le presentaremos la herramienta <em>Cargo</em>, que le ayudará a escribir programas Rust del mundo real.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hola-cargo"><a class="header" href="#hola-cargo">Hola, Cargo!</a></h2>
<p>Cargo es el sistema de compilación y gestor de paquetes de Rust. La mayoría de los Rustáceos utilizan esta herramienta para administrar sus proyectos Rust porque Cargo maneja muchas tareas por usted, como construir su código, descargar las bibliotecas de las que depende su código y construir esas bibliotecas. (A las bibliotecas que su código necesita las llamamos <em>dependencias</em>).</p>
<p>Los programas más simples de Rust, como el que hemos escrito hasta ahora, no tienen ninguna dependencia. Entonces, si hubiéramos construido el proyecto <em>Hello, world!</em> con Cargo, solo usaría la parte de Cargo que maneja la construcción de su código. Al escribir programas de Rust más complejos, agregará dependencias, y si inicia un proyecto utilizando Cargo, agregar dependencias será mucho más fácil de hacer.</p>
<p>Debido a que la gran mayoría de los proyectos de Rust usan Cargo, el resto de este libro asume que también está utilizando Cargo. Cargo viene instalado con Rust si utilizó los instaladores oficiales discutidos en la sección <a href="ch01-01-installation.html#instalaci%C3%B3n">“Instalación”</a>. Si instaló Rust por otros medios, verifique si Cargo se instaló ingresando lo siguiente en su terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>Si ve un número de versión, ¡ya lo tiene!. Si ve un error, como
<code>command not found</code>, consulte la documentación de su método de instalación
para determinar cómo instalar Cargo por separado.</p>
<h3 id="creando-un-proyecto-con-cargo"><a class="header" href="#creando-un-proyecto-con-cargo">Creando un Proyecto con Cargo</a></h3>
<p>Vamos a crear un nuevo proyecto utilizando Cargo y veamos cómo difiere de
nuestro proyecto original <em>Hello, world!</em>. Vuelva a su directorio
<em>projects</em> (o donde haya decidido almacenar su código). Luego, en cualquier
sistema operativo, ejecute lo siguiente:</p>
<pre><code class="language-bash">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>El primer comando crea un nuevo ejecutable binario llamado <em>hello_cargo</em>. El
argumento <code>--bin</code> pasado a <code>cargo new</code> crea una aplicación ejecutable (a
menudo simplemente llamada <em>binary</em>) en lugar de una biblioteca (<code>--lib</code>). Si omite el indicador, cargo asumirá por defecto el indicador <code>--bin</code>.
Hemos nombrado nuestro proyecto <em>hello_cargo</em>, y Cargo crea sus archivos en un
directorio del mismo nombre.</p>
<p>Vaya al directorio <em>hello_cargo</em> y liste los archivos. Verá que Cargo ha generado dos archivos y un directorio para nosotros: un archivo <em>Cargo.toml</em> y un directorio <em>src</em> con un archivo <em>main.rs</em> dentro. También ha inicializado un nuevo repositorio de Git junto con un archivo <em>.gitignore</em>. Los archivos Git no se generarán si ejecuta <code>cargo new</code> dentro de un repositorio Git existente; puede sobreescribir este comportamiento usando <code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Nota: Git es un sistema de control de versiones común. Puede cambiar
<code>cargo new</code> para usar un sistema de control de versiones diferente o ningún
sistema de control de versiones usando el indicador <code>--vcs</code>. Ejecute
<code>cargo new --help</code> para ver las opciones disponibles.</p>
</blockquote>
<p>Abra <em>Cargo.toml</em> en su editor de texto de su elección. Debería verse simila
al código en el Listado 1-2.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# Vea más claves y sus definiciones en https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Listado 1-2: Contenido de <em>Cargo.toml</em> generado por
<code>cargo new</code></span></p>
<p>Este archivo está en formato <a href="https://github.com/toml-lang/toml"><em>TOML</em></a> <!-- ignore --> (<em>Tom's Obvious, Minimal Language</em>), que es el formato de configuración de Cargo.</p>
<p>La primera línea, <code>[package]</code>, es un encabezado de sección que indica que las siguientes declaraciones están configurando un paquete. A medida que agreguemos más información a este archivo, agregaremos otras secciones.</p>
<p>Las siguientes tres líneas establecen la información de configuración que Cargo necesita para compilar su programa: el nombre, la versión y la edición de Rust usada. Hablaremos de la clave <code>edición</code> en el <a href="appendix-05-editions.html">Apéndice E</a>.</p>
<p>La última línea, <code>[dependencies]</code>, es el comienzo de una sección para que usted liste cualquiera de las dependencias de su proyecto. En Rust, los paquetes de código se conocen como <em>crates</em>. No necesitaremos otros <em>crates</em> para este proyecto, pero lo haremos en el primer proyecto en el Capítulo 2, entonces usaremos esta sección de dependencias.</p>
<p>Ahora abra <em>src/main.rs</em> y eche un vistazo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo ha generado un programa <em>Hello, world!</em> para usted, ¡como el que escribimos en el Listado 1-1! Hasta ahora, las diferencias entre nuestro proyecto anterior y el proyecto que Cargo genera son que Cargo colocó el código en el directorio <em>src</em>, y tenemos un archivo de configuración
<em>Cargo.toml</em> en el directorio superior.</p>
<p>Cargo espera que sus archivos fuente vivan dentro del directorio <em>src</em>. El directorio del proyecto de nivel superior es solo para archivos README, información de licencia, archivos de configuración y cualquier otra cosa no relacionada con su código. Usar Cargo te ayuda a organizar tus proyectos. Hay un lugar para todo, y todo está en su lugar.</p>
<p>Si comenzó un proyecto que no usa Cargo, como lo hicimos con el proyecto <em>Hello, world!</em>, puede convertirlo a un proyecto que sí utiliza Cargo. Mueva el código del proyecto al directorio <em>src</em> y cree un archivo <em>Cargo.toml</em> apropiado.</p>
<h3 id="construir-y-ejecutar-un-proyecto-con-cargo"><a class="header" href="#construir-y-ejecutar-un-proyecto-con-cargo">Construir y Ejecutar un Proyecto con Cargo</a></h3>
<p>Ahora veamos qué es diferente cuando construimos y ejecutamos el programa <em>Hello, world!</em> con Cargo. Desde su directorio <em>hello_cargo</em>, construya su proyecto ingresando el siguiente comando:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando crea un archivo ejecutable en <em>target/debug/hello_cargo</em> (o <em>target\debug\hello_cargo.exe</em> en Windows) en lugar de en su directorio actual. Debido a que la compilación predeterminada es una compilación de depuración, Cargo coloca el binario en un directorio llamado <em>debug</em>. Puede ejecutar el ejecutable con este comando:</p>
<pre><code class="language-toml">$ ./target/debug/hello_cargo # .\target\debug\hello_cargo.exe en Windows
Hello, world!
</code></pre>
<p>Si todo va bien, <code>Hello, world!</code> debería imprimirse en la terminal. Ejecutar <code>cargo build</code> por primera vez también hace que Cargo cree un nuevo archivo en el nivel superior: <em>Cargo.lock</em>. Este archivo realiza un seguimiento de las versiones exactas de las dependencias en su proyecto. Este proyecto no tiene dependencias, por lo que el archivo es un poco escaso. Nunca necesitará
cambiar este archivo manualmente; Cargo maneja sus contenidos por usted.</p>
<p>Acabamos de crear un proyecto con <code>cargo build</code> y lo ejecutamos con <code>./target/debug/hello_cargo</code>, pero también podemos usar <code>cargo run</code> para compilar el código y luego ejecutar el ejecutable resultante en un solo comando:</p>
<pre><code class="language-toml">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Usar <code>cargo run</code> es más conveniente que tener que recordar ejecutar <code>cargo build</code> y luego usar la ruta completa al binario, por lo que la mayoría de los desarrolladores usan <code>cargo run</code>.</p>
<p>Tenga en cuenta que esta vez no vimos la salida que indica que Cargo estaba compilando <code>hello_cargo</code>. Cargo descubrió que los archivos no habían cambiado por lo que simplemente ejecutó el binario. Si hubiera modificado su código fuente, Cargo habría reconstruido el proyecto antes de ejecutarlo, y usted habría visto esta salida:</p>
<pre><code class="language-toml">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo también proporciona un comando llamado <code>cargo check</code>. Este comando verifica rápidamente su código para asegurarse de que compila pero no produce un ejecutable:</p>
<pre><code class="language-toml">$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>¿Por qué no querría un ejecutable?. A menudo, <code>cargo check</code> es mucho más rápido que <code>cargo build</code> porque se salta el paso de producir un ejecutable. Si continuamente revisa su trabajo mientras escribe el código, ¡usar <code>cargo check</code> acelerará el proceso de informarle si su proyecto aún se está compilando! Como tal, muchos Rustáceos llevan a cabo un <code>cargo check</code> periódicamente mientras escriben su programa para asegurarse de que compila. Luego ejecutan <code>cargo build</code> cuando están listos para usar el ejecutable.</p>
<p>Repasemos lo que hemos aprendido hasta ahora sobre Cargo:</p>
<ul>
<li>Podemos crear un proyecto usando <code>cargo new</code>.</li>
<li>Podemos construir un proyecto usando <code>cargo build</code>.</li>
<li>Podemos construir y ejecutar un proyecto en un solo paso usando <code>cargo run</code>.</li>
<li>Podemos construir un proyecto para chequear errores sin crear un binario usando <code>cargo check</code>.</li>
<li>En lugar de guardar el resultado de la construcción en el mismo directorio
que nuestro código, Cargo lo almacena en el directorio <em>target/debug</em>.</li>
</ul>
<p>Una ventaja adicional de usar Cargo es que los comandos son los mismos sin importar en qué sistema operativo esté trabajando. Entonces, en este punto, ya no brindaremos instrucciones específicas para Linux y macOS en comparación con Windows.</p>
<h3 id="construyendo-para-lanzamiento-producción"><a class="header" href="#construyendo-para-lanzamiento-producción">Construyendo para Lanzamiento (Producción)</a></h3>
<p>Cuando su proyecto finalmente esté listo para su lanzamiento, puede usar <code>cargo build --release</code> para compilarlo con optimizaciones. Este comando creará un ejecutable en <em>target/release</em> en lugar de <em>target/debug</em>. Las optimizaciones hacen que su código Rust se ejecute más rápido, pero al activarlas, se alarga el tiempo que tarda su programa en compilarse. Esta es la razón por la cual hay dos perfiles diferentes: uno para el desarrollo, cuando desea recompilar rápidamente y con frecuencia, y otro para compilar el programa final que le dará a un usuario, que no se recmpilará repetidamente y que se ejecutará tan rápido como posible. Si está evaluando el tiempo de ejecución de su código, asegúrese de ejecutar <code>carga build --release</code> y <em>marcar la referencia</em> con el ejecutable en <em>target/release</em>.</p>
<h3 id="cargo-como-convención"><a class="header" href="#cargo-como-convención">Cargo como Convención</a></h3>
<p>Con proyectos simples, Cargo no le da mucho valor a simplemente usar <code>rustc</code>, pero demostrará su valor a medida que sus programas se vuelven más intrincados. Con proyectos complejos compuestos de múltiples <em>crates</em>, es mucho más fácil dejar que Cargo coordine la compilación.</p>
<p>Aunque el proyecto <code>hello_cargo</code> es simple, ahora usa muchas de las herramientas reales que usará en el resto de su carrera en Rust. De hecho, para trabajar en cualquier proyecto existente, puede usar los siguientes comandos para verificar el código usando Git, cambiar al directorio de ese proyecto y compilar:</p>
<pre><code class="language-bash">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Para obtener más información sobre Cargo, consulte <a href="https://doc.rust-lang.org/cargo/">su documentación</a>.</p>
<h2 id="resumen"><a class="header" href="#resumen">Resumen</a></h2>
<p>¡Ya ha tenido un gran comienzo en su viaje a Rust! En este capítulo, ha aprendido a:</p>
<ul>
<li>Instalar la última versión estable de Rust usando <code>rustup</code></li>
<li>Actualizar a una versión más reciente de Rust</li>
<li>Abrir documentación instalada localmente</li>
<li>Escribir y ejecutar un programa <em>Hello, world!</em> que usa <code>rustc</code> directamente</li>
<li>Crear y ejecutar un nuevo proyecto utilizando las convenciones de Cargo</li>
</ul>
<p>Este es un buen momento para crear un programa más sustancial para acostumbrarse a leer y escribir el código Rust. Entonces, en el Capítulo 2, construiremos un programa de adivinanzas. Si prefiere comenzar aprendiendo cómo funcionan los conceptos de programación común en Rust, consulte el Capítulo 3 y luego regrese al Capítulo 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programando-un-juego-de-adivinanzas"><a class="header" href="#programando-un-juego-de-adivinanzas">Programando un Juego de Adivinanzas</a></h1>
<p>¡Saltemos a Rust trabajando juntos en un proyecto práctico!. En este capítulo, le presentamos algunos conceptos comunes de Rust mostrándole cómo usarlos en un programa real. Aprenderá sobre <code>let</code>, <code>match</code>, métodos, funciones asociadas, <em>crates</em> externos y más. Los siguientes capítulos
explorarán estas ideas con más detalle. En este capítulo, practicará los fundamentos.</p>
<p>Implementaremos un problema clásico de programación para principiantes: un
juego de adivinanzas. Así es como funciona: el programa generará un entero
aleatorio entre 1 y 100. Luego pedirá al jugador que ingrese una conjetura.
Después de ingresar una conjetura, el programa indicará si la conjetura es
demasiado baja o demasiado alta. Si la conjetura es correcta, el juego
imprimirá un mensaje de felicitación y saldrá.</p>
<h2 id="configuración-de-un-nuevo-proyecto"><a class="header" href="#configuración-de-un-nuevo-proyecto">Configuración de un Nuevo Proyecto</a></h2>
<p>Para configurar un nuevo proyecto, vaya al directorio <em>projects</em> que creó en
el Capítulo 1 y cree un nuevo proyecto utilizando Cargo, de la siguiente
manera:</p>
<pre><code class="language-bash">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>El primer comando, <code>cargo new</code>, toma el nombre del proyecto (<code>guessing_game</code>) como primer argumento. El segundo comando cambia al directorio del nuevo proyecto.</p>
<p>Mire el archivo generado <em>Cargo.toml</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<p>Como vio en el Capítulo 1, <code>cargo new</code> genera un programa “Hello, world!” para usted. Mire el archivo <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Ahora compilemos este programa “Hello, world!” y ejecutémoslo en el mismo paso usando el comando <code>cargo run</code>:</p>
<pre><code class="language-toml">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>El comando <code>run</code> es útil cuando necesita iterar rápidamente en un proyecto, como lo haremos en este juego, probando rápidamente cada iteración antes de pasar a la siguiente.</p>
<p>Vuelva a abrir el archivo <em>src/main.rs</em>. Estará escribiendo todo el código en este archivo.</p>
<h2 id="procesando-una-conjetura"><a class="header" href="#procesando-una-conjetura">Procesando una Conjetura</a></h2>
<p>La primera parte del programa del juego de adivinación pedirá la entrada del usuario, procesará esa entrada y verificará que la entrada esté en el formato esperado. Para comenzar, le permitiremos al jugador ingresar una conjetura. Ingrese el código en el listado 2-1 en <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listado 2-1: Código que obtiene una conjetura del
usuario y la imprime</span></p>
<p>Este código contiene mucha información, así que vamos a revisarlo línea por línea. Para obtener la entrada del usuario y luego imprimir el resultado como salida, tenemos que traer la biblioteca <code>io</code> (<em>input/output</em>),(<em>entrada/salida</em>) al <em>alcance o ámbito</em> (<em>scope</em>). La biblioteca <code>io</code> proviene de la biblioteca estándar (que se conoce como <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">  
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Por defecto, Rust solo tiene un conjunto de elementos definidos en la biblioteca estándar que trae al ámbito de cada programa. Este conjunto se llama el preludio, y puede ver todo lo que contiene en la <a href="https://doc.rust-lang.org/std/prelude/index.html">documentación de la biblioteca estándar</a>.</p>
<p>Si un tipo que desea utilizar no está en el preludio, debe traer ese tipo al ámbito explícitamente con una instrucción <code>use</code>. El uso de la biblioteca <code>std::io</code> proporciona varias funciones útiles, incluida la capacidad de aceptar las entradas del usuario.</p>
<p>Como se vio en el Capítulo 1, la función <code>main</code> es el punto de entrada al programa:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>La sintaxis <code>fn</code> declara una nueva función, los paréntesis (vacíos) <code>()</code> indican que no hay parámetros, y la llave <code>{</code> inicia el cuerpo de la función.</p>
<p>Como también aprendió en el Capítulo 1, <code>println!</code> Es una macro que imprime
un <em>string</em> en la pantalla:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Este código está imprimiendo un mensaje indicando qué es el juego y solicitando la opción del usuario.</p>
<h3 id="almacenando-valores-con-variables"><a class="header" href="#almacenando-valores-con-variables">Almacenando Valores con Variables</a></h3>
<p>A continuación, crearemos una varable para almacenar la entrada del usuario, así:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>        let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>¡Ahora el programa se está poniendo interesante!. Están sucediendo muchas cosas en esta pequeña línea. Usamos la sentencia <code>let</code> crear la <em>variable</em>. Aquí hay otro ejemplo:</p>
<pre><code class="language-rust ignore">let apples = 5;
</code></pre>
<p>Esta línea crea una nueva variable llamada <code>apples</code> y la vincula al valor <code>5</code>. En Rust, las variables son inmutables de forma predeterminada, lo que significa que una vez que le damos un valor a la variable, el valor no cambiará. Discutiremos este concepto en detalle en la sección <a href="ch03-01-variables-and-mutability.html#variables-y-mutabilidad">&quot;Variables y Mutabilidad&quot;</a> en el Capítulo 3. Para hacer que una variable sea mutable, agregamos <code>mut</code> antes del nombre de la variable:</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable
</code></pre>
<blockquote>
<p>Nota: La sintaxis <code>//</code> inicia un comentario que continúa hasta el final de la línea. Rust ignora todo en los comentarios, que se tratan con más detalle en el <a href="ch03-04-comments.html#comentarios">Capítulo 3</a>.</p>
</blockquote>
<p>Regresemos al programa de adivinanzas. Ahora sabe que <code>let mut guess</code> introducirá una variable mutable llamada <code>guess</code>. A la derecha del signo igual (<code>=</code>) está el valor al que <code>guess</code> está vinculado, que es el resultado de llamar a <code>String::new()</code>, una función que devuelve una nueva instancia vacía de tipo <code>String</code>. <a href="ch08-02-strings.html"><code>String</code></a> <!-- ignore --> es un tipo de <em>string</em> proporcionado por la biblioteca estándar que es un fragmento de texto codificado en UTF-8 que puede crecer.</p>
<blockquote>
<p>Nota del traductor: no pasar por alto que <code>String</code> no es un tipo de dato primitivo como podría serlo en otros lenguajes sino que forma parte de la biblioteca estandar de Rust. Para más información visite <a href="https://doc.rust-lang.org/std/string/struct.String.html">Struct std::string::String</a>.</p>
</blockquote>
<p>La sintaxis <code>::</code> en la línea <code>::new()</code> indica que <code>new()</code> es una <em>función asociada</em> del tipo <code>String</code>. Una <a href="ch05-03-method-syntax.html#funciones-asociadas"><code>función asociada</code></a> es una función que se implementa en un tipo, en este caso un <code>String</code>, y no en una instancia particular de ese tipo, como lo haría un método. Algunos lenguajes llaman a esto un <em>método estático</em>.</p>
<p>Esta función <code>new()</code> crea un nuevo <em>string</em> vacío. Encontrará una función <code>new()</code> en muchos tipos, porque es un nombre común para darle una función asociada que crea un nuevo valor de algún tipo.</p>
<p>En resumen, la línea <code>let mut guess = String::new();</code> ha creado una variable mutable que actualmente está vinculada a una nueva instancia vacía de <code>String</code>. ¡Uf!</p>
<h3 id="recibiendo-la-entrada-del-usuario"><a class="header" href="#recibiendo-la-entrada-del-usuario">Recibiendo la Entrada del Usuario</a></h3>
<p>Recuerde que incluimos la funcionalidad de <em>entrada/salida</em> de la biblioteca estándar con <code>use std::io;</code> en la primera línea del programa. Ahora llamaremos a la función asociada <code>stdin</code> del módulo <code>io</code>, que nos permitirá manejar la entrada del usuario:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Si no hubiésemos enumerado la línea <code>use std::io</code> al comienzo del programa, podríamos haber escrito esta llamada de función como <code>std::io::stdin</code>. La función <code>stdin</code> devuelve una instancia de <a href="https://doc.rust-lang.org/stable/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a> <!-- ignore -->, que es un tipo que representa un <em>manejador</em> de la entrada estándar para su terminal.</p>
<p>A continuación, la línea <code>.read_line(&amp;mut guess)</code>, llama al método <a href="https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> <!-- ignore --> en el controlador de entrada estándar para obtener la entrada del usuario. También estamos pasando <code>&amp;mut guess</code> como argumento a <code>read_line</code> para decirle qué <em>string</em> almacenar la entrada del usuario. El trabajo completo de <code>read_line</code> es tomar lo que el usuario escriba en la entrada estándar y agregarlo a un <em>string</em> (sin sobrescribir su contenido ), por lo que pasamos ese <em>string</em> como argumento. El argumento <em>string</em> debe ser mutable para que el método pueda cambiar el contenido del <em>string</em>.</p>
<p>El <code>&amp;</code> indica que este argumento es una <em>referencia</em>, que le permite dejar que varias partes de su código accedan a una parte de los datos sin necesidad de copiar esos datos en la memoria varias veces. Las referencias son una característica compleja, y una de las principales ventajas de Rust es la seguridad y facilidad de uso de las referencias. No necesita saber muchos de
esos detalles para finalizar este programa. Por ahora, todo lo que necesita saber es que, al igual que las variables, las referencias son inmutables por defecto. Por lo tanto, debe escribir <code>&amp;mut guess</code>en lugar de <code>&amp;guess</code> para que sea mutable. (El Capítulo 4 explicará las referencias más a fondo).</p>
<h3 id="manejando-la-falla-potencial-con-el-tipo-result"><a class="header" href="#manejando-la-falla-potencial-con-el-tipo-result">Manejando la Falla Potencial con el Tipo <code>Result</code></a></h3>
<p>No hemos terminado con esta línea de código. Aunque lo que hemos discutido hasta ahora es una sola línea de texto, es solo la primera parte de la única línea lógica de código. La segunda parte es este método:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Podríamos haber escrito este código como:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>Sin embargo, una línea larga es difícil de leer, por lo que es mejor dividirla. A menudo es aconsejable introducir una nueva línea y otros espacios en blanco para ayudar a dividir las líneas largas cuando llama a un método con la sintaxis <code>.method_name()</code>. Ahora analicemos lo que hace esta línea.</p>
<p>Como se mencionó anteriormente, <code>read_line</code> pone lo que el usuario ingresa en el <em>string</em> que le pasamos, pero también devuelve un valor Result. <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a> es una <a href="ch06-00-enums.html">enumeración</a>, a menudo llamada <em>enum</em>, que es un tipo que puede estar en uno de varios estados posibles. Llamamos a cada estado posible una variante.</p>
<p>El Capítulo 6 cubrirá enumeraciones en más detalle.</p>
<p>Para <code>Result</code>, las variantes son <code>Ok</code> o <code>Err</code>. La variante <code>Ok</code> indica que la operación fue exitosa, y dentro de <code>Ok</code> está el valor generado exitosamente. La variante <code>Err</code> significa que la operación falló, y <code>Err</code> contiene información sobre cómo o por qué falló la operación.</p>
<p>Los valores de tipo <code>Result</code>, como los valores de cualquier tipo, tienen métodos definidos en ellos. Una instancia de <code>io::Result</code> tiene un <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">método <code>expect</code></a> <!-- ignore --> al que puede llamar. Si esta instancia de <code>io::Result</code> es un valor <code>Err</code>, <code>expect</code> hará que el programa se cuelgue y mostrará el mensaje que pasó como argumento para <code>expect</code>. Si el método <code>read_line</code> devuelve un <code>Err</code>, probablemente sea el resultado de un error proveniente del sistema operativo subyacente. Si esta instancia de <code>io::Result</code> es un valor <code>Ok</code>, <code>expect</code> tomará el valor de retorno que <code>Ok</code> está reteniendo y le devolverá ese valor para que pueda usarlo. En este caso, ese valor es el número de bytes en lo que el usuario ingresó en la entrada estándar.</p>
<p>Si no llama a <code>expect</code>, el programa compilará, pero recibirá una advertencia:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust advierte que no ha utilizado el valor <code>Result</code> devuelto por <code>read_line</code>, lo que indica que el programa no ha manejado un posible error.</p>
<p>La forma correcta de suprimir la advertencia es escribir el manejo de errores, pero en nuestro caso solo queremos bloquear este programa cuando ocurre un problema, por lo que podemos usar <code>expect</code>. Aprenderá sobre la recuperación de errores en el <a href="ch09-02-recoverable-errors-with-result.html">Capítulo 9</a> <!-- ignore -->.</p>
<h3 id="impresión-de-valores-con-placeholders-marcadores-de-posición-de--println"><a class="header" href="#impresión-de-valores-con-placeholders-marcadores-de-posición-de--println">Impresión de Valores con <em>Placeholders</em> (<em>marcadores de posición</em>) de  <code>println!</code></a></h3>
<p>Aparte de las llaves cierre, solo hay una línea más para discutir en el código agregado hasta el momento, que es el siguiente:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {guess}&quot;);
<span class="boring">}
</span></code></pre>
<p>Esta línea imprime la cadena que ahora contiene la entrada del usuario. El conjunto de corchetes <code>{}</code> es un marcador de posición: piense en <code>{}</code> como pequeñas pinzas de cangrejo que mantienen un valor en su lugar. Puede imprimir más de un valor utilizando corchetes: el primer conjunto de corchetes contiene el primer valor que aparece después de la cadena de formato, el segundo conjunto contiene el segundo valor, y así sucesivamente. Imprimiendo múltiples valores en una llamada a <code>println!</code> se vería así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimiría <code>x = 5 e y = 10</code>.</p>
<h3 id="probando-la-primera-parte"><a class="header" href="#probando-la-primera-parte">Probando la Primera Parte</a></h3>
<p>Probemos la primera parte del juego de adivinanzas. Ejecútalo usando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>En este punto, la primera parte del juego está lista: recibimos información del teclado y luego la imprimimos.</p>
<h2 id="generando-un-número-secreto"><a class="header" href="#generando-un-número-secreto">Generando un Número Secreto</a></h2>
<p>A continuación, necesitamos generar un número secreto que el usuario intentará adivinar. El número secreto debe ser diferente cada vez, por lo que es divertido jugar más de una vez. Usaremos un número aleatorio entre 1 y 100 para que el juego no sea demasiado difícil. Rust aún no incluye la funcionalidad de números aleatorios en su biblioteca estándar. Sin embargo, el equipo de Rust proporciona un <a href="https://crates.io/crates/rand">crate <code>rand</code></a> con dicha funcionalidad.</p>
<h3 id="usar-un-crate-para-obtener-más-funcionalidades"><a class="header" href="#usar-un-crate-para-obtener-más-funcionalidades">Usar un <em>Crate</em> para Obtener más Funcionalidades</a></h3>
<p>Recuerde que un <em>crate</em> es un paquete de archivos de código fuente de Rust. El proyecto que hemos estado creando es un <em>binary crate</em>, que es un ejecutable. El <em>crate</em><code>rand</code> es una <em>library crate</em>, que contiene un código que no se puede ejecutar por sí mismo sino que está destinado a ser utilizado en otros programas.</p>
<p>La coordinación de <em>crates</em> externos de Crago es donde Cargo realmente brilla. Antes de que podamos escribir el código que usa <code>rand</code>, necesitamos modificar el archivo <em>Cargo.toml</em> para incluir el <em>crate</em> <code>rand</code> como una dependencia. Abra ese archivo ahora y agregue la siguiente línea en la parte inferior debajo del encabezado de la sección <code>[dependencies]</code> que Cargo creó para usted. Asegúrese de especificar <code>rand</code> exactamente como lo tenemos aquí, con este número de versión, o los ejemplos de código en este tutorial pueden no funcionar.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.8.3&quot;
</code></pre>
<p>En el archivo <em>Cargo.toml</em>, todo lo que sigue a un encabezado es parte de una sección que continúa hasta que se inicia otra sección. La sección <code>[dependencies]</code> es donde le dice a Cargo de qué <em>crates</em> externos depende su proyecto y qué versiones de esos <em>crates</em> necesita. En este caso, especificaremos el <em>crate</em> <code>rand</code> con el especificador de versión semántica <code>0.8.3</code>. Cargo entiende <a href="http://semver.org">Versión semántica</a> <!-- ignore --> (a veces llamado <em>SemVer</em>), que es un estándar para escribir números de versión. El número <code>0.8.3</code> es en realidad una abreviatura para <code>^0.8.3</code>, que significa “cualquier versión que se al menos <code>0.8.3</code> pero inferior a <code>0.9.0</code>”.</p>
<p>Cargo considera que estas versiones tienen API públicas compatibles con la versión <code>0.8.3</code>, y esta especificación garantiza que obtendrá el último parche que se compilará con el código de este capítulo. No se garantiza que cualquier versión <code>0.9.0</code> o superior tenga la misma API que la que usan los siguientes ejemplos.</p>
<p>Ahora, sin cambiar ninguno de los códigos, construyamos el proyecto, como se muestra en el Listado 2-2.</p>
<pre><code class="language-text">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Listado 2-2: El resultado de ejecutar <code>cargo build</code> después de agregar el <em>crate rand</em> como una dependencia</span></p>
<p>Es posible que vea diferentes números de versión (¡pero todos serán compatibles con el código, gracias a SemVer!), y las líneas pueden estar en un orden diferente.</p>
<p>Cuando incluimos una dependencia externa, Cargo obtiene las últimas versiones de todo lo que necesita la dependencia desde el <em>registro</em>, que es una copia de los datos de <a href="https://crates.io">Crates.io</a>. Crates.io es donde las personas en el ecosistema de Rust publican sus proyectos Rust de código abierto para que otros los usen.</p>
<p>Después de actualizar el registro, Cargo comprueba la sección <code>[dependencies]</code> y descarga los <em>crates</em> listados que aún no se han descargado. En este caso, aunque solo listamos <code>rand</code> como una dependencia, Cargo también tomó otros <em>crates</em> de las que depende <code>rand</code> para funcionar. Después de descargar los <em>crates</em>, Rust los compila y luego compila el proyecto con las dependencias disponibles.</p>
<p>Si inmediatamente ejecuta <code>cargo build</code> nuevamente sin realizar ningún cambio, no obtendrá ningún resultado aparte de la línea <code>Finished</code>. Cargo sabe que ya ha descargado y compilado las dependencias, y no ha cambiado nada sobre ellas en su archivo <em>Cargo.toml</em>. Cargo también sabe que no ha cambiado nada sobre su código, por lo que tampoco lo recompila. Sin nada que
hacer, simplemente sale.</p>
<p>Si abre el archivo <em>src/main.rs</em>, realiza un cambio trivial, y luego lo guarda y compila de nuevo, solo verá dos líneas de salida:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Estas líneas muestran que Cargo solo actualiza la construcción con su pequeño cambio al archivo *src/main.rs *. Sus dependencias no han cambiado, por lo que Cargo sabe que puede reutilizar lo que ya ha descargado y compilado para esas.</p>
<h4 id="asegurar-compilaciones-reproducibles-con-el-archivo-cargolock"><a class="header" href="#asegurar-compilaciones-reproducibles-con-el-archivo-cargolock">Asegurar Compilaciones Reproducibles con el Archivo <em>Cargo.lock</em></a></h4>
<p>Cargo tiene un mecanismo que garantiza que pueda reconstruir el mismo artefacto cada vez que usted o cualquier otra persona construya su código: Cargo usará solo las versiones de las dependencias que especificó hasta que indique lo contrario. Por ejemplo, supongamos que la próxima semana sale la versión <em>0.8.4</em> del <em>crate</em> <code>rand</code>, y esa versión contiene una corrección de errores importante, pero también contiene una regresión que romperá su código. Para manejar esto, Rust crea el archivo <em>Cargo.lock</em> la primera vez que ejecuta <code>cargo build</code>, por lo que ahora tenemos esto en el directorio guessing_game.</p>
<p>Cuando crea un proyecto por primera vez, Cargo descubre todas las versiones de las dependencias que se ajustan a los criterios y luego las escribe en el archivo Cargo.lock. Cuando construya su proyecto en el futuro, Cargo verá que el archivo Cargo.lock existe y usará las versiones especificadas allí en lugar de hacer todo el trabajo de averiguar las versiones nuevamente. Esto le permite tener una compilación reproducible automáticamente. En otras palabras, su proyecto permanecerá en <code>0.8.3</code> hasta que lo actualice explícitamente, gracias al archivo <em>Cargo.lock</em>. Debido a que el archivo <em>Cargo.lock</em> es importante para compilaciones reproducibles, a menudo se verifica dentro del control de código fuente con el resto del código de su proyecto.</p>
<h4 id="actualización-de-un-crate-para-obtener-una-nueva-versión"><a class="header" href="#actualización-de-un-crate-para-obtener-una-nueva-versión">Actualización de un <em>crate</em> para Obtener una Nueva Versión</a></h4>
<p>Cuando <em>desea</em> actualizar un crate, Cargo proporciona el comando <code>update</code>, que ignorará el archivo <em>Cargo.lock</em> y descubrirá todas las versiones más recientes que se ajusten a sus especificaciones en <em>Cargo.toml</em>. Cargo luego escribirá esas versiones en el archivo <em>Cargo.lock</em>. De lo contrario, por defecto, Cargo solo buscará versiones superiores a la <code>0.8.3</code> e inferiores a la <code>0.9.0</code>. Si el <em>crate</em> <code>rand</code> ha lanzado las dos nuevas versiones <code>0.8.4</code> y <code>0.9.0</code>, verá lo siguiente si ejecuta <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
<p>Cargo ignora la versión <code>0.9.0</code>. En este punto, también notará un cambio en su archivo <em>Cargo.lock</em> que indica que la versión del <em>crate</em> <code>rand</code> que está usando ahora es <code>0.8.4</code>. Para usar la versión <code>0.9.0</code> de <code>rand</code> o cualquier versión de la serie <code>0.9.x</code>, debe actualizar el archivo <code>Cargo.toml</code> para que tenga este aspecto:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>La próxima vez que ejecute <code>cargo build</code>, Cargo actualizará el registro de <em>crates</em> disponibles y reevaluará sus requisitos de <code>rand</code> de acuerdo con la nueva versión que ha especificado.</p>
<p>Hay mucho más que decir sobre <a href="http://doc.crates.io">Cargo</a> <!-- ignore --> y <a href="http://doc.crates.io/crates-io.html">su ecosistema</a> <!-- ignore --> que veremos en el Capítulo 14, pero por ahora, esto es todo lo que necesita saber. Cargo hace que sea muy fácil reutilizar las bibliotecas, por lo que los <em>Rustáceos</em> pueden
escribir proyectos más pequeños que se ensamblan a partir de una serie de paquetes.</p>
<h3 id="generando-un-número-aleatorio"><a class="header" href="#generando-un-número-aleatorio">Generando un Número Aleatorio</a></h3>
<p>Ahora que ha agregado el <em>crate</em> <code>rand</code> a <em>Cargo.toml</em>, comencemos a usar
<code>rand</code>. El siguiente paso es actualizar <em>src/main.rs</em>, como se muestra en el
Listado 2-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listado 2-3: Agregando código para generar un número aleatorio</span></p>
<p>Primero, agregamos la línea <code>use rand::Rng</code>. El <em>trait</em> <code>Rng</code> define los métodos que implementan los generadores de números aleatorios, y este <em>trait</em> debe estar dentro del ámbito para que podamos usar esos métodos. El capítulo 10 cubrirá los <em>traits</em> en detalle.</p>
<p>Además, estamos agregando dos líneas más en el medio. La función
<code>rand::thread_rng</code> nos dará el generador de números aleatorios particular
que vamos a usar: uno que es local al subproceso actual de ejecución y sembrado
por el sistema operativo. A continuación, llamamos al método <code>gen_range</code> en
el generador de números aleatorios. Este método está definido por el <em>trait</em>
<code>Rng</code> que trajimos al ámbito con la sentencia <code>use rand::Rng</code>. El método
<code>gen_range</code> toma dos números como argumentos y genera un número aleatorio
entre ellos. El tipo de expresión de rango que estamos usando aquí toma la forma <code>(start..=end)</code> y es inclusiva en los límites inferior y superior, por lo que debemos especificar <code>(1..=100)</code> para solicitar un número entre 1 y 100. Otra forma es <code>(start, end)</code>, inclusiva en el límite inferior pero exclusiva en el límite superior, por lo que deberíamos especificar <code>(1, 101)</code> para solicitar un número entre 1 y 100.</p>
<blockquote>
<p>Nota: No solo sabrá qué <em>traits</em> usar y qué métodos y funciones llamar desde
un <em>crate</em>. Las instrucciones para usar un <em>crate</em> están en la
documentación de cada <em>crate</em>. Otra buena característica de Cargo es que
puede ejecutar el comando <code>cargo doc --open</code>, que construirá la
documentación provista por todas sus dependencias localmente y la abrirá
en su navegador. Si está interesado en otra funcionalidad del <em>crate</em>
<code>rand</code>, por ejemplo, ejecute <code>cargo doc --open</code> y haga clic en <code>rand</code> en
la barra lateral de la izquierda.</p>
</blockquote>
<p>La segunda línea que agregamos al código imprime el número secreto. Esto es útil mientras desarrollamos el programa para poder probarlo, pero lo eliminaremos de la versión final. ¡No es gran cosa si el programa imprime la respuesta tan pronto como comienza!</p>
<p>Intente ejecutar el programa varias veces:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Debería obtener diferentes números aleatorios, y todos deberían ser números entre 1 y 100. ¡Buen trabajo!</p>
<h2 id="comparando-la-conjetura-con-el-número-secreto"><a class="header" href="#comparando-la-conjetura-con-el-número-secreto">Comparando la Conjetura con el Número Secreto</a></h2>
<p>Ahora que tenemos una entrada de usuario y un número aleatorio, podemos compararlos. Ese paso se muestra en el Listado 2-4. Tenga en cuenta que este código no se compilará todavía, como explicaremos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listado 2-4: Manejo de los posibles valores de retorno de la comparación de dos números</span></p>
<p>Primero añadimos otra declaración <code>use</code>, que trae un tipo
llamado <code>std::cmp::Ordering</code> al ámbito desde la biblioteca estándar. Como
<code>Result</code>, <code>Ordering</code> es otra enumeración, pero las variantes para <code>Ordering</code>
son <code>Less</code>, <code>Greater</code>, y <code>Equal</code>. Estos son los tres resultados posibles
cuando compara dos valores.</p>
<p>Luego agregamos cinco líneas nuevas en la parte inferior que usan el tipo
<code>Ordering</code>. El método <code>cmp</code> compara dos valores y puede invocarse sobre
cualquier cosa que se pueda comparar. Toma una referencia a lo que sea que
quiera comparar: aquí está comparando el <code>guess</code> con el <code>secret_number</code>.
Luego devuelve una variante de la enumeración <code>Ordering</code> que trajimos al
ámbito con la sentencia <code>use</code>. Usamos una expresión
<a href="ch06-02-match.html"><code>match</code></a> <!-- ignore --> para decidir qué hacer a continuación en
función de qué variante de <code>Ordering</code> se devolvió de la llamada a <code>cmp</code> con
los valores en <code>guess</code> y <code>secret_number</code>.</p>
<p>Una expresión <code>match</code> se compone de <em>brazos</em> (<em>arms</em>). Un brazo consta de un <em>patrón</em> y el código que debería ejecutarse si el valor dado al comienzo del <code>match</code> se ajusta al patrón de ese brazo. Rust toma el valor otorgado a <code>match</code> y mira a través del patrón de cada brazo por turno. La construcción <code>match</code> y los patrones son potentes funciones en Rust que te permiten
expresar una variedad de situaciones puede encontrar el código y asegúrese de manejarlas todas. Estas características se tratarán en detalle en el Capítulo 6 y el Capítulo 18, respectivamente.</p>
<p>Veamos un ejemplo de lo que sucedería con la expresión <code>match</code> usada aquí. Digamos que el usuario ha supuesto 50 y el número secreto generado aleatoriamente esta vez es 38. Cuando el código compara 50 a 38, el método <code>cmp</code> devolverá <code>Ordering::Greater</code>, porque 50 es mayor que 38. La expresión <code>match</code> obtiene el valor <code>Ordering::Greater</code> y comienza a verificar el patrón de cada brazo. Mira el patrón del primer brazo, <code>Ordering::Less</code>, y ve que el valor <code>Ordering::Greater</code> no coincide con <code>Ordering::Less</code>, por lo que ignora el código en ese brazo y pasa al siguiente brazo . El siguiente patrón del brazo, <code>Ordering::Greater</code>, <em>coincide</em> con <code>Ordering::Greater</code>. !El código asociado en ese brazo se ejecutará e imprimirá <code>Too big!</code> en la pantalla. La expresión <code>match</code> termina porque no es necesario mirar el último brazo en este escenario.</p>
<p>Sin embargo, el código en el listado 2-4 no se compilará todavía. Vamos a intentarlo:</p>
<pre><code class="language-text">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` due to previous error
</code></pre>
<p>El núcleo del error indica que hay <em>tipos no coincidentes</em> (<em>mismatched types</em>). Rust tiene un fuerte sistema de tipo estático. Sin embargo, también tiene tipo de inferencia. Cuando escribimos
<code>let guess = String::new()</code>, Rust pudo inferir que <code>guess</code> debería ser <code>String</code> y no nos hizo escribir el tipo. El <code>secret_number</code>, por otro lado, es un tipo de número. Algunos tipos de números pueden tener un valor entre 1 y 100: <code>i32</code>, un número de 32 bits; <code>u32</code>, un número de 32 bits sin signo; <code>i64</code>, un número de 64 bits; así como otros. Rust tiene como valor predeterminado un <code>i32</code>, que es el tipo de <code>secret_number</code> a menos que agregue información de tipo en otro lugar que haría que Rust infiera un tipo numérico diferente. La razón del error es que Rust no puede comparar un <em>string</em> y un tipo <em>número</em>.</p>
<p>En última instancia, queremos convertir el <code>String</code> que el programa lee como entrada en un tipo de número para que podamos compararlo numéricamente con el número secreto. Podemos hacer eso agregando la siguiente línea al cuerpo de la función <code>main</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span>
    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>La nueva línea es:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>Creamos una variable llamada <code>guess</code>. Pero espere, ¿el programa no tiene ya una variable llamada <code>guess</code>? Sí, pero Rust nos permite <em>sombrear</em> el valor anterior de <code>guess</code> con uno nuevo. El <em>sombreado</em> (shadowing) nos permite reutilizar el nombre de la variable <code>guess</code> en lugar de obligarnos a crear dos variables únicas, como <code>guess_str</code> y <code>guess</code>, por ejemplo. Cubriremos esto con más detalle en el Capítulo 3, pero por ahora sepa que esta característica se usa a menudo cuando desea convertir un valor de un tipo a otro tipo.</p>
<p>Vinculamos <code>guess</code> a la expresión <code>guess.trim().Parse()</code>. El <code>guess</code> en la expresión se refiere a al <code>guess</code> original que contiene la entrada como un <em>string</em>. El método <code>trim</code> en una instancia <code>String</code> eliminará cualquier espacio en blanco, salto de línea (<code>\n</code>), etc., al principio y al final para poder comparar con un <code>u32</code>, que solo puede contener caracteres numéricos. El usuario debe presionar <span class="keystroke">enter</span> para ingresar el dato y cumplir con <code>read_line</code>. Cuando el usuario presiona <span class="keystroke">enter</span>, se agrega un caracter de nueva línea al <em>string</em>. Por ejemplo, si el usuario escribe <span class="keystroke">5</span> y presiona <span class="keystroke">enter</span>, <code>guess</code> se ve así: <code>5\n</code>. El <code>\n</code> representa “nueva línea” (En Windows, al presionar <span class="keystroke">enter</span> se produce un retorno de carro y una nueva línea, \r\n). El método <code>trim</code> elimina <code>\n</code> o <code>\r\n</code>, lo que da como resultado solo <code>5</code>.</p>
<p>El método <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse"><code>parse</code> en <em>string</em></a> <!-- ignorar --> convierte un <em>string</em> a algún otro tipo. Aquí lo utilizamos para convertir de string a número. Debemos decirle a Rust el tipo exacto de número que queremos utilizando <code>let guess: u32</code>. Los dos puntos (<code>:</code>) después de <code>guess</code> le dicen a Rust que <em>anotaremos</em> el tipo de la variable. Rust tiene algunos tipos de números incorporados; el <code>u32</code> que se ve aquí es un entero sin signo de 32 bits. Es una buena opción predeterminada para un pequeño número positivo. Aprenderá sobre otros tipos de números en el Capítulo 3. Además, la anotación <code>u32</code> en este programa de ejemplo y la comparación con <code>secret_number</code> significa que Rust inferirá que <code>secret_number</code> también debería ser <code>u32</code>. ¡Entonces la comparación será entre dos valores del mismo tipo!</p>
<p>El método <code>parse</code> solo funcionará en caracteres que puedan convertirse lógicamente en números y, por lo tanto, puede causar errores fácilmente. Si, por ejemplo, el <em>string</em> contiene <code>A👍%</code>, no habría forma de convertir eso en un número. Debido a que podría fallar, el método <code>parse</code> arroja un tipo <code>Result</code>, muy parecido al método <code>read_line</code> (descrito anteriormente en “Manejo de la
falla potencial con el tipo de resultado”). Trataremos este <code>Result</code> de la misma manera utilizando el método <code>expect</code> nuevamente. Si <code>parse</code> devuelve una variante <code>Err</code> de <code>Result</code> porque no pudo crear un número a partir del <em>string</em>, la llamada <code>expect</code> <em>colgará</em> el juego e imprimirá el mensaje que le damos. Si <code>parse</code> puede convertir con éxito el <em>string</em> en un número,
devolverá la variante <code>Ok</code> de <code>Result</code>, y <code>expect</code> devolverá el número que queremos del valor <code>Ok</code>.</p>
<p>¡Corramos el programa ahora!.</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>¡Bien! Aunque se agregaron espacios antes de la suposición, el programa aún descubrió que el usuario adivinó 76. Ejecute el programa varias veces para verificar el comportamiento diferente con diferentes tipos de entrada: adivine el número correctamente, adivine un número que sea demasiado alto, y adivina un número que es demasiado bajo.</p>
<p>Tenemos la mayor parte del juego funcionando ahora, pero el usuario solo puede hacer una conjetura. ¡Cambiemos eso agregando un bucle!</p>
<h2 id="permitir-múltiples-conjeturas-con-bucle"><a class="header" href="#permitir-múltiples-conjeturas-con-bucle">Permitir Múltiples Conjeturas con Bucle</a></h2>
<p>La palabra clave <code>loop</code> crea un bucle infinito. Añadiremos eso ahora para dar a los usuarios más oportunidades de adivinar el número:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">
</span>    // --snip--

<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">        let mut guess = String::new();
</span>
<span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>Como puede ver, hemos movido todo, desde el indicador de entrada de adivinanzas, a un bucle. Asegúrese de sangrar las líneas dentro del bucle otros cuatro espacios cada una y vuelva a ejecutar el programa. El programa ahora pedirá otra conjetura para siempre, lo que en realidad introduce un nuevo problema. ¡No parece que el usuario pueda salir!</p>
<p>El usuario siempre puede detener el programa utilizando el atajo de teclado <span class="keystroke">ctrl-c</span>. Pero hay otra forma de escapar de este monstruo insaciable, como se menciona en la discusión <code>parse</code> en <a href="ch02-00-guessing-game-tutorial.html#comparando-la-conjetura-con-el-n%C3%BAmero-secreto">“Comparando la Conjetura con el Número Secreto”</a>: si el usuario ingresa una respuesta sin número, el programa se bloqueará. El usuario puede
aprovechar eso para salir, como se muestra aquí:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Al escribir <code>quit</code> en realidad se cierra el juego, pero también lo hará cualquier otra entrada que no sea numérica. Sin embargo, esto es poco óptimo por decir lo menos. Queremos que el juego se detenga automáticamente cuando se adivine el número correcto.</p>
<h3 id="saliendo-después-de-una-conjetura-correcta"><a class="header" href="#saliendo-después-de-una-conjetura-correcta">Saliendo Después de una Conjetura Correcta</a></h3>
<p>Vamos a programar que el juego se cierre cuando el usuario gana agregando una sentencia <code>break</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span>
        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Agregar la línea <code>break</code> después de <code>You win!</code> hace que el programa salga del ciclo <code>loop</code> cuando el usuario adivina el número secreto correctamente. Salir del bucle también significa salir del programa, porque el bucle es la última parte de <code>main</code>.</p>
<h3 id="manejo-de-entrada-iinválida"><a class="header" href="#manejo-de-entrada-iinválida">Manejo de Entrada Iinválida</a></h3>
<p>Para refinar aún más el comportamiento del juego, en lugar de bloquear el programa cuando el usuario ingresa algo que no es un número , hagamos que el juego ignore un ingreso no numérico para que el usuario pueda seguir adivinando. Podemos hacerlo alterando la línea donde <code>guess</code> se convierte de <code>String</code> a <code>u32</code>, como se muestra en el Listado 2-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        //  --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = matc guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listado 2-5: Ignorar una conjetura sin número y pedir otra conjetura en lugar de bloquear el programa</span></p>
<p>Cambiamos de una llamada a <code>expect</code> a una expresión <code>match</code> para pasar de estrellarnos en un error a manejar el error. Recuerde que <code>parse</code> devuelve un tipo <code>Result</code> y <code>Result</code> es una enumeración que tiene las variantes <code>Ok</code> o <code>Err</code>. Estamos usando una expresión <code>match</code> aquí, como
hicimos con el resultado <code>Ordering</code> del método <code>cmp</code>.</p>
<p>Si <code>parse</code> puede convertir con éxito el <em>string</em> en un número, devolverá un
valor <code>Ok</code> que contiene el número resultante. Ese valor <code>Ok</code> coincidirá con
el patrón del primer brazo, y la expresión <code>match</code> simplemente devolverá el
valor <code>num</code> que <code>parse</code> produjo y lo puso dentro del valor <code>Ok</code>. Ese número
terminará justo donde lo queremos en la nueva variable <code>guess</code> que estamos
creando.</p>
<p>Si <code>parse</code> <em>no</em> puede convertir el <em>string</em> en un número, devolverá un valor <code>Err</code> que contiene más información sobre el error. El valor <code>Err</code> no coincide con el patrón <code>Ok(num)</code> en el primer brazo del <code>match</code>, pero sí con el patrón <code>Err(_)</code> en el segundo brazo. El guión bajo <code>_</code> es un valor comodín. En este ejemplo, estamos diciendo que queremos hacer coincidir todos los valores <code>Err</code> sin importar la información que contengan. Entonces el programa ejecutará el código del segundo brazo, <code>continue</code>, que le dice al programa que vaya a la siguiente iteración del <code>loop</code> y pida otra conjetura. ¡De manera efectiva, el programa ignora todos los errores que <code>parse</code> podría encontrar!</p>
<p>Ahora todo en el programa debería funcionar como se esperaba. Vamos a intentarlo:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>¡Increíble! Con un pequeño ajuste final, terminaremos el juego de adivinanzas. Recuerde que el programa todavía está imprimiendo el número secreto. Eso funcionó bien para las pruebas, pero arruina el juego. Vamos a eliminar el <code>println!</code> que muestra el número secreto. El listado 2-6 muestra el código final.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listado 2-6: El código del juego de adivinanzas completo</span></p>
<h2 id="resumen-1"><a class="header" href="#resumen-1">Resumen</a></h2>
<p>En este punto, ha construido con éxito el juego de adivinanzas. ¡Felicitaciones!</p>
<p>Este proyecto fue una forma práctica de presentarle muchos conceptos nuevos de Rust: <code>let</code>, <code>match</code>, métodos, funciones asociadas, uso de <em>crates</em> externos y más. En los siguientes capítulos, aprenderá sobre estos conceptos con más detalle. El Capítulo 3 cubre conceptos que tienen la mayoría de los lenguajes de programación, como variables, tipos de datos y funciones, y
muestra cómo usarlos en Rust. El Capítulo 4 explora la propiedad, una característica que hace que Rust sea diferente de otros lenguajes. El Capítulo 5 discute estructuras y sintaxis de métodos, y el Capítulo 6 explica cómo funcionan las enumeraciones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceptos-comunes-de-programación"><a class="header" href="#conceptos-comunes-de-programación">Conceptos Comunes de Programación</a></h1>
<p>Este capítulo cubre conceptos que aparecen en casi todos los lenguajes de programación, y cómo funcionan en Rust. Muchos lenguajes de programación tienen mucho en común en su núcleo. Ninguno de los conceptos presentados en este capítulo son exclusivos de Rust, pero los discutiremos en el contexto de Rust y explicaremos las convenciones sobre el uso de estos conceptos.</p>
<p>Específicamente, aprenderá sobre variables, tipos básicos, funciones, comentarios y estructuras de control (<em>control flow</em>). Estos fundamentos estarán en cada programa de Rust, y aprenderlos temprano le dará un núcleo fuerte para empezar.</p>
<blockquote>
<h3 id="palabras-clave"><a class="header" href="#palabras-clave">Palabras Clave</a></h3>
<p>El lenguaje Rust tiene un conjunto de <em>palabras clave</em> que están reservadas
para el uso exclusivo del lenguaje, al igual que en otros lenguajes. Tenga
en cuenta que no puede usar estas palabras como nombres de variables o
funciones. La mayoría de las palabras clave tienen un significado especial,
y las usará para realizar diversas tareas en sus programas de Rust; algunos
no tienen ninguna funcionalidad actual asociada pero se han reservado para
la funcionalidad que podría agregarse a Rust en el futuro. Puede encontrar
una lista de palabras clave en el <a href="appendix-01-keywords.html">Apéndice A</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables-y-mutabilidad"><a class="header" href="#variables-y-mutabilidad">Variables y Mutabilidad</a></h2>
<p>Como se mencionó en la sección <a href="ch02-00-guessing-game-tutorial.html#almacenando-valores-con-variables">&quot;Almacenando Valores con Variables&quot;</a>, las variables por defecto son inmutables. Este es uno de los muchos empujones que Rust le da para escribir su código de una manera que aproveche la seguridad y la fácil concurrencia que ofrece Rust. Sin embargo, todavía tiene la opción de hacer que sus variables sean mutables. Exploremos cómo y por qué Rust lo anima a elegir la inmutabilidad y por qué a veces es posible que desee no optar por ella.</p>
<p>Cuando una variable es inmutable, una vez que un valor está vinculado a un nombre, no puede cambiar ese valor. Para ilustrar esto, generemos un nuevo proyecto llamado <em>variables</em> en su directorio <em>projects</em> usando <code>cargo new variables</code>.</p>
<p>Luego, en su nuevo directorio <em>variables</em>, abra <em>src/main.rs</em> y reemplace su
código con el siguiente código que no se compilará aún:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>Guarde y ejecute el programa usando <code>cargo run</code>. Debería recibir un mensaje
de error, como se muestra en este resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Este ejemplo muestra cómo el compilador le ayuda a encontrar errores en sus programas. Aunque los errores del compilador pueden ser frustrantes, solo se refieren a que su programa todavía no está haciendo lo que quiere hacer de manera segura; ello <em>no</em> significan, ¡que no es un buen programador! Los <em>Rustáceos</em> experimentados aún tienen errores de compilación.</p>
<p>El mensaje de error indica que la causa del error es que <code>no puede asignar dos veces a la variable inmutable 'x'</code>, porque trató de asignar un segundo valor a la variable inmutable <code>x</code>.</p>
<p>Es importante que obtengamos errores de tiempo de compilación cuando intentamos cambiar un valor que previamente hemos designado como inmutable porque esta misma situación puede conducir a fallas. Si una parte de nuestro código opera bajo el supuesto de que el valor nunca cambiará y otra parte de nuestro código cambia ese valor, es posible que la primera parte del código
no haga lo que estaba diseñado para hacer. La causa de este tipo de error puede ser difícil de rastrear después del hecho, especialmente cuando la segunda parte del código cambia el valor solo <em>algunas veces</em>.</p>
<p>En Rust, el compilador garantiza que cuando declara que un valor no cambiará, realmente no cambiará. Eso significa que cuando está leyendo y escribiendo código, no es necesario que realice un seguimiento de cómo y dónde puede cambiar un valor. Su codigo es así más fácil de razonar.</p>
<p>Pero la mutabilidad puede ser muy útil. Las variables son inmutables solo por
defecto. Como lo hizo en el Capítulo 2, puede hacer que sean mutables
añadiendo <code>mut</code> delante del nombre de la variable. Además de permitir que
este valor cambie, <code>mut</code> transmite intención para los futuros lectores del
código al indicar que en otras partes del código esta variable cambiará de valor.</p>
<p>Por ejemplo, cambiemos <em>src/main.rs</em> a lo siguiente:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Cuando ejecutamos el programa ahora, obtenemos esto:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Podemos cambiar el valor vinculado a <code>x</code> de <code>5</code> a <code>6</code> cuando se usa <code>mut</code>. En última instancia, decidir si usar la mutabilidad o no depende de usted y depende de lo que crea que es más claro en esa situación particular.</p>
<h3 id="constantes"><a class="header" href="#constantes">Constantes</a></h3>
<p>Al igual que las variables inmutables, las <em>constantes</em> son valores que están vinculados a un nombre y no se les permite cambiar, pero existen algunas diferencias entre las constantes y las variables.</p>
<p>Primero, no está permitido usar <code>mut</code> con constantes. Las constantes no son
solo inmutables por defecto, siempre son inmutables. Usted declara constantes usando la palabra clave <code>const</code> en lugar de la palabra clave <code>let</code>, y el tipo del valor <em>debe</em> ser anotado. Estamos a punto de cubrir <em>types</em> (tipos) y <em>type annotations</em> (anotaciones de tipo) en la siguiente sección, <a href="ch03-02-data-types.html">&quot;Tipos de datos&quot;</a>, así que no se preocupe por los detalles en este momento. Solo debe saber que siempre debe anotar el tipo.</p>
<p>Las constantes se pueden declarar en cualquier ámbito, incluido el ámbito global, lo que las hace útiles para valores que muchas partes del código necesitan conocer.</p>
<p>La última diferencia es que las constantes pueden establecerse sólo de una expresión constante, no como el resultado de un valor que solo podría calcularse en tiempo de ejecución.</p>
<p>Aquí hay un ejemplo de una declaración constante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<p>El nombre de la constante es <code>THREE_HOURS_IN_SECONDS</code> y su valor se establece en el resultado de multiplicar 60 (el número de segundos en un minuto) por 60 (el número de minutos en una hora) por 3 (el número de horas que queremos contar en este programa). La convención de nomenclatura de Rust para las constantes es usar todo en mayúsculas con guiones bajos entre palabras. El compilador puede evaluar un conjunto limitado de operaciones en tiempo de compilación, lo que nos permite optar por escribir este valor en un manera que sea más fácil de entender y verificar, en lugar de establecer esta constante al valor 10.800. Consulte la sección de <a href="https://doc.rust-lang.org/stable/reference/const_eval.html">Rust Reference sobre &quot;Evaluación Constante&quot; (en inglés)</a> para obtener más información sobre qué operaciones se pueden utilizar al declarar constantes. </p>
<p>Las constantes son válidas durante todo el tiempo que se ejecuta un programa, dentro del alcance en el que fueron declaradas, lo que las convierte en una opción útil para los valores en su dominio de aplicación que varias partes del programa podrían necesitar conocer, como la cantidad máxima de puntos que cualquier jugador de un juego puede ganar o la velocidad de la luz.</p>
<p>Nombrar como constantes a los valores codificados usados a lo largo de su programa es útil para transmitir el significado de ese valor a los futuros mantenedores del código. También ayuda tener solo un lugar en el código que necesitaría cambiar si el valor codificado debe actualizarse en el futuro.</p>
<h3 id="sombreado-shadowing"><a class="header" href="#sombreado-shadowing"><em>Sombreado</em> (<em>Shadowing</em>)</a></h3>
<p>Como se vio en el <a href="ch02-00-guessing-game-tutorial.html">Capítulo 2</a>, puede declarar una nueva variable con el mismo nombre que una variable anterior. Los Rustáceos dicen que la primera variable es <em>sombreada</em> por la segunda, lo que significa que el valor de la segunda variable es lo que el compilador verá cuando se use el nombre de la variable. En efecto, la segunda variable <em>sombrea</em> a la primera, tomando cualquier uso del nombre de la variable para sí misma hasta que <em>es oscurecida</em> de nuevo o finaliza su ámbito. Podemos sombrear una variable usando el mismo nombre de variable y repitiendo el uso de la palabra clave <code>let</code> de la siguiente manera:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Este programa primero enlaza <code>x</code> al valor <code>5</code>. Luego crea una nueva variable <code>x</code> repitiendo <code>let x =</code>, tomando el valor original y sumándole <code>1</code>, así que ahora el valor de <code>x</code> es <code>6</code>. Luego, dentro de un ámbito interno creado por las llaves, el tercer <code>let</code> también sombrea <code>x</code> y crea una nueva variable, multiplicando el valor previo por <code>2</code>, dando a <code>x</code> un valor de <code>12</code>. Cuando ese alcance termina, el sombreado interno también termina y <code>x</code> vuelve a ser <code>6</code>. Cuando ejecutamos este programa, arrojará lo siguiente: </p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>El <em>sombreado</em> (<em>shadowing</em>) es diferente a marcar una variable como <code>mut</code>,
porque obtendremos un error en tiempo de compilación si accidentalmente
intentamos reasignar a esta variable sin usar la palabra clave <code>let</code>. Al
usar <code>let</code> podemos realizar algunas transformaciones en un valor, pero la
variable sigue siendo inmutable después de que se hayan completado esas
transformaciones.</p>
<p>La otra diferencia entre <code>mut</code> y <em>shadowing</em> es que, debido a que estamos
creando efectivamente una nueva variable cuando usamos nuevamente la palabra 
clave <code>let</code>, podemos cambiar el <em>tipo</em> del valor pero reutilizar el mismo
nombre. Por ejemplo, supongamos que nuestro programa le pide al usuario que
muestre cuántos espacios quiere entre algunos textos ingresando caracteres
de espacio en blanco, pero realmente queremos almacenar esa entrada como un número:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>La primera variable <code>spaces</code> es un tipo <em>string</em> y la segunda variable <code>spaces</code>, que es una nueva variable que pasa a tener el mismo nombre que la primera, es un tipo <em>número</em>. El
sombreado nos ahorra tener que pensar en diferentes nombres, como <code>spaces_str</code> y <code>spaces_num</code>. En su lugar, podemos reutilizar simplemente el nombre de <code>spaces</code>. Sin embargo, si tratamos de usar <code>mut</code> para esto, como se muestra aquí, obtendremos un error en tiempo de compilación:</p>
<pre><code class="language-rust ignore">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<p>El error dice que no podemos cambiar el tipo de una variable:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Ahora que hemos explorado cómo funcionan las variables, veamos qué más tipos de
datos pueden haber.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de Datos</a></h2>
<p>Cada valor en Rust es de un determinado tipo de datos, lo que le dice a Rust qué tipo de datos se especifica para que sepa cómo trabajar con esos datos. Veremos dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<p>Tenga en cuenta que Rust es un lenguaje <em>estáticamente tipado</em>, lo que significa que debe conocer los tipos de todas las variables en tiempo de compilación. El compilador generalmente puede inferir qué tipo queremos usar en función del valor y cómo lo usamos. En los casos en que son posibles muchos tipos, como cuando convertimos un <code>String</code> a un tipo numérico usando <code>parse</code> en la sección <a href="ch02-00-guessing-game-tutorial.html#comparando-la-conjetura-con-el-n%C3%BAmero-secreto">“Comparando la conjetura con el número secreto”</a> en el Capítulo 2, debemos agregar una <em>anotación de tipo</em> (<em>type annotation</em>), como esta :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Si no agregamos la anotación de tipo <code>:u32</code> antes, Rust mostrará el siguiente error, lo que significa que el compilador necesita más información de parte nuestra para saber qué tipo queremos usar:</p>
<pre><code class="language-text">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>Verá anotaciones de tipo diferentes para otros tipos de datos.</p>
<h3 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos Escalares</a></h3>
<p>Un tipo <em>escalar</em> representa un solo valor. Rust tiene cuatro tipos escalares básicos: enteros, números de punto flotante, booleanos y caracteres. Puede reconocer estos de otros lenguajes de programación. Veamos cómo funcionan en Rust.</p>
<h4 id="tipos-enteros-integer"><a class="header" href="#tipos-enteros-integer">Tipos <em>Enteros</em> (<em>Integer</em>)</a></h4>
<p>Un <em>entero</em> es un número sin un componente fraccionario. Usamos un tipo entero en el Capítulo 2, el tipo <code>u32</code>. Esta declaración de tipo indica que el valor con el que está asociado debe ser un entero sin signo (los tipos enteros con signo comienzan con <code>i</code>, en lugar de <code>u</code>) que ocupan 32 bits de espacio. La Tabla 3-1 muestra los tipos enteros incorporados en Rust. Podemos usar cualquiera de estas variantes para declarar el tipo de un valor entero.</p>
<p><span class="caption">Tabla 3-1: Tipos enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Cada variante puede ser &quot;con signo&quot; o &quot;sin signo&quot; y tiene un tamaño explícito. <em>Con signo</em> y <em>sin signo</em> se refieren a si es posible que el número sea negativo; en otras palabras, si el número debe tener un signo con él (<em>Signed</em>) o si solo será positivo y, por lo tanto, puede representarse sin signo (<em>Unsigned</em>). Es como escribir números en un papel: cuando el signo importa, un número se muestra con un signo más o un signo menos; sin embargo, cuando es seguro asumir que el número es positivo, se muestra <em>sin signo</em>. Los números <em>con signo</em> se almacenan usando la representación <a href="https://es.wikipedia.org/wiki/Complemento_a_dos">complemento a dos</a>.</p>
<p>Cada variante <em>con signo</em> puede almacenar números de -(2<sup>n - 1</sup>) a
2<sup>n - 1</sup> - 1 inclusive, donde <em>n</em> es el número de bits que utiliza la
variante. Entonces, un <code>i8</code> puede almacenar números de -(2<sup>7</sup>) a
2<sup>7</sup> - 1, lo que equivale de -128 a 127. Las variantes <em>sin signo</em>
pueden almacenar números de 0 al 2<sup>n</sup> - 1, por lo que un <code>u8</code> puede
almacenar números de 0 a 2<sup>8</sup> - 1, es decir, de 0 a 255.</p>
<p>Además, los tipos <code>isize</code> y <code>usize</code> dependen del tipo de computadora en la que se ejecute el programa: 64 bits si está en una arquitectura de 64 bits y 32 bits si está en una arquitectura de 32 bits.</p>
<p>Puede escribir literales enteros en cualquiera de las formas que se muestran en la tabla 3-2. Tenga en cuenta que los literales numéricos que pueden ser varios tipos numéricos permiten un sufijo de tipo, como <code>57u8</code>, para designar el tipo. Los literales numéricos también pueden usar <code>_</code> como separador visual para que el número sea más fácil de leer, como <code>1_000</code>, que tendrá el mismo valor que si hubiera especificado <code>1000</code>.</p>
<p><span class="caption">Tabla 3-2: Literales enteros en Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Entonces, ¿cómo saber qué tipo de número entero usar? Si no está seguro, los valores predeterminados de Rust generalmente son buenas opciones. El tipo predeterminado para enteros es <code>i32</code>. La situación principal en la que usaría <code>isize</code> o <code>usize</code> es al indexar algún tipo de colección.</p>
<blockquote>
<p><strong>Desbordamiento de Enteros</strong></p>
<p>Digamos que tiene una variable de tipo <code>u8</code> que puede contener valores entre 0 y 255. 
Si intenta cambiar la variable a un valor fuera de ese rango, como como 256, ocurrirá un <em>desbordamiento de enteros</em>, lo que puede resultar en uno de dos comportamientos.</p>
<p>Cuando está compilando en modo de depuración, Rust incluye verificaciones de desbordamiento de enteros que hacen que su programa entre en <em>pánico</em> en tiempo de ejecución si ocurre este comportamiento. Rust usa el término entrar en pánico cuando un programa se cierra por un error. Discutiremos los <em>pánicos</em> con más profundidad en la sección <a href="ch09-01-unrecoverable-errors-with-panic.html">&quot;Errores Irrecuperables con panic!”</a> del capítulo 9.</p>
<p>Cuando esté compilando en modo de lanzamiento con la bandera <code>--release</code>, Rust no incluye comprobaciones de desbordamiento de enteros que causen pánico. En cambio, si se produce un desbordamiento, Rust realiza el ajuste de complemento a dos. En resumen, los valores mayores que el valor máximo que el tipo puede contener &quot;ajustan&quot; al mínimo de los valores que el tipo puede contener. En el caso de un <code>u8</code>, el valor 256 se convierte en 0, el valor 257 se convierte en 1, y así sucesivamente. El programa no entrará en pánico, pero la variable tendrá un valor que probablemente no sea el que esperaba tener. Confiar en el comportamiento de ajuste del desbordamiento de enteros se considera un error.</p>
<p>Para manejar explícitamente la posibilidad de desbordamiento, puede usar estas familias de métodos proporcionadas por la biblioteca estándar para tipos numéricos primitivos:</p>
<ul>
<li>Restrinja en todos los modos con los métodos <code>wrapping_*</code>, tales como <code>wrapping_add</code></li>
<li>Devuelva el valor <code>None</code> si hay desbordamiento con los métodos <code>checked_*</code></li>
<li>Devuelva el valor y un booleano que indica si hubo desbordamiento con los métodos <code>overflowing_*</code></li>
<li>Sature en los valores mínimo o máximo del valor con métodos <code>saturating_*</code></li>
</ul>
</blockquote>
<h4 id="tipos-de-punto-flotante"><a class="header" href="#tipos-de-punto-flotante">Tipos de Punto Flotante</a></h4>
<p>Rust también tiene dos tipos primitivos para <em>números de punto flotante</em>, que son números con cifras decimales. Los tipos de punto flotante de Rust son <code>f32</code> y <code>f64</code>, que son de 32 bits y 64 bits de tamaño, respectivamente. El tipo predeterminado es <code>f64</code> porque en las CPU modernas se trata con más o menos la misma velocidad que <code>f32</code>, pero es capaz de obtener más precisión. Todos los tipos de punto flotante son <em>con signo</em>.</p>
<p>Aquí hay un ejemplo que muestra los números de punto flotante en acción:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Los números de punto flotante se representan según el estándar IEEE-754. El tipo <code>f32</code> es un <em>float</em> de precisión simple, y <code>f64</code> tiene doble precisión.</p>
<h4 id="operaciones-numéricas"><a class="header" href="#operaciones-numéricas">Operaciones Numéricas</a></h4>
<p>Rust soporta las operaciones matemáticas básicas que esperaría para todos los tipos de números: adición, sustracción, multiplicación, división y residuo (resto de la división entera). La división de enteros se redondea al entero inferior más próximo. El siguiente código muestra cómo usaría cada uno en una declaración <code>let</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10; // 15

    // subtraction
    let difference = 95.5 - 4.3; // 91.2

    // multiplication
    let product = 4 * 30; // 120

    // division
    let quotient = 56.7 / 32.2; // 1.7608695652173911

    // remainder
    let remainder = 43 % 5; // 3
}
</code></pre></pre>
<p>Cada expresión en estas declaraciones usa un operador matemático y la evalúa a un solo valor, que luego se vincula a una variable. El <a href="appendix-02-operators.html">Apéndice B</a> contiene una lista de todos los operadores que Rust proporciona.</p>
<h4 id="el-tipo-booleano-boolean"><a class="header" href="#el-tipo-booleano-boolean">El Tipo <em>Booleano</em> (<em>Boolean</em>)</a></h4>
<p>Como en la mayoría de los demás lenguajes de programación, un tipo <em>booleano</em> en Rust tiene dos valores posibles: <code>true</code> y <code>false</code>. Los booleanos tienen un tamaño de un byte. El tipo <em>booleano</em> en Rust se especifica con <code>bool</code>. Por ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // con &quot;anotación de tipo&quot; explícita
}
</code></pre></pre>
<p>La forma principal de usar valores <em>booleanos</em> es mediante condicionales, como una expresión <code>if</code>. Cubriremos cómo funcionan las expresiones <code>if</code> en Rust en la sección <a href="ch03-05-control-flow.html">“Estructuras de Control”</a>.</p>
<h4 id="el-tipo-caracter"><a class="header" href="#el-tipo-caracter">El Tipo Caracter</a></h4>
<p>El tipo <code>char</code> de Rust es el tipo alfabético más primitivo del lenguaje. Aquí hay algunos ejemplos de cómo declarar valores <code>char</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // con &quot;anotación de tipo&quot; explícita
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Tenga en cuenta que el literal <code>char</code> se especifica con comillas simples, a diferencia de los literales <em>strings</em>, que usan comillas dobles. El tipo <code>char</code> de Rust tiene un tamaño de cuatro bytes y representa un valor escalar Unicode, lo que significa que puede representar mucho más que solo ASCII. Letras acentuadas; caracteres chinos, japoneses y coreanos; emoji; y los <em>espacios de ancho cero</em> son todos valores <code>char</code> válidos en Rust. Los valores escalares Unicode van desde <code>U + 0000</code> a <code>U + D7FF</code> y <code>U + E000</code> a <code>U + 10FFFF</code> inclusive. Sin embargo, un “caracter” no es realmente un concepto en Unicode, por lo que su intuición humana para lo que es un “caracter” puede no coincidir con lo que es un <code>char</code> en Rust. Discutiremos este tema en detalle en <a href="ch08-02-strings.html">“Almacenamiento de texto codificado en UTF-8 con Strings”</a> en el Capítulo 8.</p>
<h3 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos Compuestos</a></h3>
<p><em>Los tipos compuestos</em> pueden agrupar múltiples valores en un tipo. Rust tiene dos tipos de compuestos primitivos: tuplas y arrays.</p>
<h4 id="el-tipo-tupla-tuple"><a class="header" href="#el-tipo-tupla-tuple">El Tipo <em>Tupla</em> (<em>Tuple</em>)</a></h4>
<p>Una tupla es una forma general de agrupar juntos un número de valores con una variedad de tipos dentro de un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, no pueden crecer ni encogerse de tamaño.</p>
<p>Creamos una tupla escribiendo una lista de valores separados por comas dentro de un paréntesis. Cada posición en la tupla tiene un tipo, y los tipos de los diferentes valores en la tupla no tienen que ser iguales. Agregamos anotaciones de tipo opcionales en este ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>La variable <code>tup</code> se vincula a la tupla completa, porque una tupla se considera un solo elemento compuesto. Para obtener los valores individuales de una tupla, podemos usar la coincidencia de patrones para desestructurar un valor de tupla como este:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>Este programa crea primero una tupla y la vincula a la variable <code>tup</code>. Luego usa un patrón con <code>let</code> para tomar <code>tup</code> y convertirlo en tres variables separadas, <code>x</code>, <code>y</code>, y <code>z</code>. Esto se llama <em>desestructuración</em>, porque divide la tupla individual en tres partes. Finalmente, el programa imprime el valor de <code>y</code>, que es <code>6.4</code>.</p>
<p>También podemos acceder a un elemento de tupla directamente usando un punto (<code>.</code>) seguido del índice del valor al que queremos acceder. Por ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Este programa crea la tupla, <code>x</code>, y luego crea nuevas variables para cada elemento usando su índice. Como con la mayoría de los lenguajes de programación, el primer índice en una tupla es 0.</p>
<p>La tupla sin ningún valor tiene un nombre especial: <em>unidad</em>. Este valor y su correspondiente tipo se escriben <code>()</code> y representan un valor vacío o un tipo de retorno vacío. Las expresiones devuelven implícitamente el valor <em>unidad</em> si no devuelven cualquier otro valor. </p>
<h4 id="el-tipo-array-arreglo-o-matriz"><a class="header" href="#el-tipo-array-arreglo-o-matriz">El Tipo <em>Array</em> (<em>Arreglo o Matriz</em>)</a></h4>
<p>Otra forma de tener una colección de valores múltiples es con un <em>Array</em>. A diferencia de una tupla, cada elemento de un <em>array</em> debe tener el mismo tipo. A diferencia de algunos otros lenguajes, los <em>arrays</em> en Rust tienen una longitud fija: una vez declarados, no pueden crecer o reducirse de tamaño.</p>
<p>En Rust, los valores en un <em>array</em> se escriben como una lista separada por comas, entre corchetes:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Los arrays son útiles cuando quiere que sus datos se asignen en el <em>Stack</em> en lugar de en el <em>Heap</em> (discutiremos más sobre <em>Stack</em> y <em>Heap</em> en el <a href="ch04-01-what-is-ownership.html#la-pila-stack-y-el-mont%C3%ADculo-heap">Capítulo 4</a>) o cuando quiera asegurarse de tener siempre una cantidad fija de elementos. Sin embargo, un array no es tan flexible como el tipo vector. Un vector es un tipo de colección similar provisto por la biblioteca estándar <em>que</em> puede crecer o reducir su tamaño. Si no está seguro de utilizar un array o un vector, probablemente debería usar un vector. El <a href="ch08-01-vectors.html">Capítulo 8</a> discute los vectores con más detalle.</p>
<p>Sin embargo, los arrays son más útiles cuando sabe que no será necesario cambiar la cantidad de elementos. Por ejemplo, si estuviera usando los nombres de los meses en un programa, probablemente usaría un array en lugar de un vector porque sabe que siempre contendrá 12 elementos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Escriba el tipo de un array usando corchetes con el tipo de cada elemento, un punto y coma, y luego la cantidad de elementos en la matriz, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Aquí, <code>i32</code> es el tipo de cada elemento. Después del punto y coma, el número <code>5</code> indica que el array contiene cinco elementos.</p>
<p>También puede inicializar un array para que contenga el mismo valor para cada elemento especificando entre corchetes: el valor inicial, seguido de un punto y coma, y luego la longitud del array, como se muestra aquí:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>El array llamado <code>a</code> contendrá 5 elementos que se inicalizarán en el valor <code>3</code>. Esto es lo mismo que escribir <code>let a = [3, 3, 3, 3, 3];</code> pero de una manera más concisa.</p>
<h5 id="acceso-a-los-elementos-del-array"><a class="header" href="#acceso-a-los-elementos-del-array">Acceso a los Elementos del Array</a></h5>
<p>Un array es un fragmento único de memoria, de tamaño fijo conocido, que se puede asignar al <em>Stack</em>. Puede acceder a los elementos de un array mediante la indexación, así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>En este ejemplo, la variable llamada <code>first</code> obtendrá el valor <code>1</code>, porque ese es el valor en el índice <code>[0]</code> del array. La variable llamada <code>second</code> obtendrá el valor <code>2</code> del índice <code>[1]</code> del array.</p>
<h5 id="acceso-a-elementos-no-válidos-de-un-array"><a class="header" href="#acceso-a-elementos-no-válidos-de-un-array">Acceso a Elementos <em>no válidos</em> de un Array</a></h5>
<p>Veamos qué sucede si intenta acceder a un elemento de un array que está más allá del final del array. Supongamos que ejecuta este código, similar al juego de adivinanzas del Capítulo 2, para obtener del usuario un índice del array: </p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}
</code></pre>
<p>Este código se compila correctamente. Si ejecuta este código usando <code>cargo run</code> e ingresa 0, 1, 2, 3 o 4, el programa imprimirá el valor correspondiente a ese índice en el array. Si, en cambio, ingresa un número de índice después del final del array, como <code>10</code>, verá un resultado como este: </p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>El programa resultó en un <em>error en tiempo de ejecución</em> al momento de usar un valor no válido en la operación de indexación. El programa salió con un mensaje de error y no ejecutó la declaración final <code>println!</code>. Cuando intenta acceder a un elemento utilizando la indexación, Rust comprobará que el índice que ha especificado es menor que la longitud del array. Si el índice es mayor o igual que la longitud, Rust entrará en pánico. Esta verificación tiene que ocurrir en tiempo de ejecución, especialmente en este caso, porque el compilador no puede saber qué valor ingresará un usuario cuando se ejecute el código más tarde.</p>
<p>Este es un ejemplo de los principios de seguridad de la memoria de Rust en acción. En muchos lenguajes de bajo nivel, este tipo de verificación no se realiza, y cuando proporciona un índice incorrecto, se puede acceder a memoria no válida. Rust le protege contra este tipo de error al salir inmediatamente en lugar de permitir el acceso a la memoria y continuar. El Capítulo 9 analiza más sobre el manejo de errores de Rust y cómo puede escribir un código legible y seguro que no entre en pánico ni permita el acceso no válido a la memoria.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funciones"><a class="header" href="#funciones">Funciones</a></h2>
<p>Las funciones predominan en el código Rust. Ya ha visto una de las
funciones más importantes en el lenguaje: la función <code>main</code>, que es el punto
de entrada de muchos programas. También ha visto la palabra clave <code>fn</code>, que le
permite declarar nuevas funciones.</p>
<p>El código de Rust usa <em>&quot;snake case&quot;</em> como estilo convencional para nombres de funciones y variables. En <em>snake case</em>, todas las letras son minúsculas y las palabras separadas se unen con un guión bajo. Aquí hay un programa que contiene una definición de función de ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Las definiciones de funciones en Rust comienzan con <code>fn</code> y tienen un par de
paréntesis después del nombre de la función. Las llaves le dicen al compilador
dónde comienza y termina el cuerpo de la función.</p>
<p>Podemos llamar a cualquier función que hayamos definido ingresando su nombre
seguido de un conjunto de paréntesis. Debido a que <code>another_function</code> se define
en el programa, puede ser llamada desde el interior de la función <code>main</code>. Tenga
en cuenta que definimos <code>another_function</code> <em>después de (y fuera del cuerpo de)</em> la función <code>main</code> en el código fuente; podríamos haberla definido antes también. A Rust no le importa
dónde define sus funciones, solo que estén definidas en alguna parte.</p>
<p>Comencemos un nuevo proyecto binario llamado <em>functions</em> para explorar un poco más allá las funciones. Coloque el ejemplo <code>another_function</code> en <em>src/main.rs</em> y ejecútelo. Usted
debería ver el siguiente resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Las líneas se ejecutan en el orden en que aparecen en la función <code>main</code>.
En primer lugar se imprime el mensaje: <em>&quot;¡Hello, world!&quot;</em>. Luego es llamada
<code>another_function</code> y se imprime su mensaje: <em>&quot;Another function.&quot;</em>.</p>
<h3 id="parámetros-de-una-función"><a class="header" href="#parámetros-de-una-función">Parámetros de una función</a></h3>
<p>Podemos definir funciones para que tengan <em>parámetros</em>, que son
variables especiales que forman parte de la firma de una función. Cuando una
función tiene parámetros, puede proporcionarle valores concretos para esos
parámetros. Técnicamente, los valores concretos se llaman <em>argumentos</em>,
pero en una conversación informal, la gente tiende usar las palabras
<em>parámetro</em> y <em>argumento</em> indistintamente ya sea para las variables
en la definición de una función o los valores concretos pasados cuando se llama
a una función.</p>
<p>La siguiente versión reescrita de <code>another_function</code> muestra cómo se ven los parámetros
en Rust:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Intente ejecutar este programa; debería obtener el siguiente resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>La declaración de <code>another_function</code> tiene un parámetro llamado <code>x</code>. El tipo de <code>x</code> se especifica como <code>i32</code>. Cuando <code>5</code> se le pasa a <code>another_function</code>, la macro <code>println!</code> inserta <code>5</code> en formato <em>string</em> donde estaba el par de llaves que contenía a <code>x</code>.</p>
<p>En las firmas de funciones, <em>debe</em> declarar el tipo de cada parámetro. Esta es una decisión deliberada en el diseño de Rust: requerir <em>anotaciones de tipo</em> en las definiciones de función significa que el compilador casi nunca necesita que las use en otra parte del código para averiguar a qué tipo se refiere. El compilador también puede dar mensajes de error más útiles si sabe qué tipos espera la función.</p>
<p>Cuando desee que una función tenga múltiples parámetros, separe las declaraciones
de parámetros con comas, como esta:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {value}{unit_label}&quot;);
}
</code></pre></pre>
<p>Este ejemplo crea una función llamada <code>print_labeled_measurement</code> con dos parámetros. El primer parámetro se llama <code>value</code>y es un <code>i32</code>; el segundo es nombrado <code>unit_labely</code> es tipo <code>char</code>. La función luego imprime texto que contiene ambos: <code>value</code> y <code>unit_label</code>. </p>
<p>Intentemos ejecutar este código. Reemplace el programa actualmente en sus proyecto
<em>src/main.rs</em>, <em>functions</em> con el ejemplo anterior y ejecútelo usando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Llamamos a la función con <code>5</code> como el valor para <code>value</code> y <code>'h'</code> como el valor para <code>unit_label</code>, entonces la salida del programa contiene esos valores.</p>
<h3 id="sentencias-y-expresiones"><a class="header" href="#sentencias-y-expresiones">Sentencias y Expresiones</a></h3>
<p>Los cuerpos de las funciones están formados por una serie de sentencias que opcionalmente
terminan en una expresión. Hasta ahora, las funciones que hemos cubierto no han incluido una expresión final, pero ya ha visto una expresión como parte de una sentencia. Debido a que Rust es un lenguaje basado en expresiones, esta es una distinción importante de entender.
Otros lenguajes no tienen las mismas distinciones, así que veamos qué son sentencias y expresiones, y cómo sus diferencias afectan los cuerpos de las funciones.</p>
<p>Las <em>Sentencias</em> son instrucciones que realizan alguna acción y no devuelven un valor. Las <em>Expresiones</em> se evalúan y arrojan un valor resultante. Veamos algunos ejemplos.</p>
<p>De hecho, ya hemos usado sentencias y expresiones. Crear una variable y asignarle un valor con la palabra clave <code>let</code> es una sentencia. En el Listado 3-1, <code>let y = 6;</code> es una sentencia.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Listing 3-1: La declaración de función <code>main</code> contiene una sentencia</span></p>
<p>Las definiciones de las funciones también son sentencias; todo el ejemplo anterior es un
sentencia en sí misma.</p>
<p>Las sentencias no devuelven valores. Por lo tanto, no puede asignar una sentencia <code>let</code>
a otra variable, como intenta hacer el siguiente código; obtendrá un error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Cuando ejecuta este programa, el error que obtendrá es similar a este:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  | 

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<p>La sentencia <code>let y = 6</code> no devuelve un valor, por lo que no hay nada para vincular a <code>x</code>. Esto es diferente de lo que sucede en otros lenguajes, como C y Ruby, donde la asignación devuelve el valor de esa asignación. En esos lenguajes puede escribir <code>x = y = 6</code>, y tanto <code>x</code> como <code>y</code> tienen el valor <code>6</code>. Ese no es el caso en Rust.</p>
<p>Las expresiones se evalúan como un valor y constituyen la mayor parte del resto del código que escribirá en Rust. Considere una operación matemática simple, como <code>5 + 6</code>, que es una expresión que se evalúa como valor <code>11</code>. Las expresiones pueden ser parte de sentencias: en el Listado 3-1, el <code>6</code> en la sentencia <code> let y = 6;</code> es una expresión que se evalúa como valor <code>6</code>. Llamar a una función es una expresión. Llamar a una macro es una expresión. El bloque <code>{}</code> que utilizamos para crear nuevos ámbitos, es una expresión, por ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>Esta expresión:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>es un bloque que, en este caso, se evalúa como <code>4</code>. Ese valor se vincula a <code>y</code> como parte de la sentencia <code>let</code>. Tenga en cuenta que la línea <code>x + 1</code> no tiene un punto y coma en el final, a diferencia de la mayoría de las líneas que ha visto hasta ahora. Las expresiones no incluyen el punto y coma final. Si agrega un punto y coma al final de una expresión la convierte en una sentencia, entonces no devolverá un valor. Tenga esto en cuenta mientras explora los valores devueltos por las funciones y las expresiones a continuación.</p>
<h3 id="funciones-con-valores-de-retorno"><a class="header" href="#funciones-con-valores-de-retorno">Funciones con Valores de Retorno</a></h3>
<p>Las funciones pueden devolver valores al código que las llama. No nombramos los valores
de retorno, pero debemos declarar su tipo después de una flecha (<code>-&gt;</code>). En Rust, el retorno
del valor de la función es sinónimo del valor de la expresión final en el bloque del cuerpo de una función. Se puede adelantar la devolución de una función usando la palabra clave <code>return</code> y especificando un valor, pero la mayoría de las funciones devuelven implícitamente la última expresión. Aquí hay un ejemplo de una función que devuelve un valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>No hay llamadas a funciones, macros, o incluso sentencias <code>let</code> en la función <code>five</code>,
solo el número <code>5</code> por sí mismo. Esa es una función perfectamente válida en Rust.
Tenga en cuenta que el tipo de retorno de la función también se especifica como <code>-&gt; i32</code>.
Trate ejecutando este código; la salida debería verse así:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>El <code>5</code> en <code>five</code> es el valor de retorno de la función, por lo que el tipo de retorno
es <code>i32</code>. Examinemos esto con más detalle. Hay dos partes importantes:</p>
<p>Primero, la línea <code>let x = five ();</code> muestra que estamos usando el valor de retorno de una
función para inicializar una variable. Debido a que la función <code>five</code> devuelve un <code>5</code>,
esa línea es la misma que la siguiente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Segundo, la función <code>five</code> no tiene parámetros y define el tipo de valor de retorno, pero el cuerpo de la función es un <code>5</code> solitario sin punto y coma, porque es una expresión cuyo valor queremos devolver.</p>
<p>Veamos otro ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Al ejecutar este código se imprimirá <code>The value of x is: 6</code>. Pero si colocamos un
punto y coma al final de la línea que contiene <code>x + 1</code>, cambiándola de una
expresión a una sentencia, obtendremos un error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>La ejecución de este código genera un error de la siguiente manera:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<p>El mensaje de error principal, “mismatched types” (tipos no coincidentes), revela el problema central con este código. La definición de la función <code>plus_one</code> dice que devolverá un <code>i32</code>, pero las sentencias no se evalúan a un valor, lo que se expresa por <code>()</code>, el tipo <em>unit</em>. Por lo tanto, no se devuelve nada, lo que contradice la definición de la función y resulta en un error. En esta salida, Rust proporciona un mensaje que posiblemente ayude a rectificar este problema:
sugiere eliminar el punto y coma, que arreglaría el error.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h2>
<p>Todos los programadores se esfuerzan por hacer que su código sea fácil de
entender, pero a veces una explicación adicional está justificada. En estos casos,
los programadores dejan <em>comentarios</em> en su código fuente, que el compilador
ignorará, pero que a la gente que lo lea le puede ser útil.</p>
<p>Aquí hay un comentario simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<p>En Rust, los comentarios deben comenzar con dos barras y continuar hasta el fin de
línea. Para comentarios que se extienden más allá de una sola línea, deberá incluir
<code>//</code> en cada línea, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
<span class="boring">}
</span></code></pre></pre>
<p>Los comentarios también pueden colocarse al final de las líneas que contienen el código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<p>Pero con mayor frecuencia los verá en el siguiente formato, con el comentario
en un línea separada sobre el código que está anotando:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust también tiene otro tipo de comentario, comentarios de documentación, que
trataremos en la sección &quot;Publicando una Crate en Crates.io&quot; del Capítulo 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="estructuras-de-control-control-flow"><a class="header" href="#estructuras-de-control-control-flow">Estructuras de control (control flow)</a></h2>
<blockquote>
<p>Nota del traductor:</p>
<blockquote>
<p>La traducción literal del enunciado <em>control flow</em> es <em>flujo de control</em>, pero sería más acertado traducirlo como <em>control de flujo</em> ya que la expresión se refiere a la manera de controlar el flujo de la ejecución del código.
En español, cuando se trata el tema, se lo titula apelando a las estructuras que que ejercen ese control, llamadas <em>Estructuras de Control</em>. Este último es el enfoque que se utilizará.</p>
</blockquote>
</blockquote>
<p>La capacidad de ejecutar algún código dependiendo de si una condición es verdadera, o ejecutar algún código repetidamente mientras una condición es verdadera, es básico en la construcción de bloques de codigo en la mayoría de los lenguajes de programación. Las construcciones más comunes que le permiten controlar el flujo de ejecución del código Rust son las expresiones <code>if</code> y los bucles.</p>
<h3 id="expresiones-if"><a class="header" href="#expresiones-if">Expresiones <code>if</code></a></h3>
<p>Una expresión <code>if</code> le permite bifurcar su código dependiendo de las condiciones. Proporcione una condición y diga: “Si se cumple esta condición, ejecute este bloque de código; si la condición no se cumple, no ejecute este bloque de código”.</p>
<p>Cree un nuevo proyecto llamado <em>branches</em> en su directorio <em>projects</em> para explorar
la expresión <code>if</code>. En el archivo <em>src/main.rs</em>, ingrese lo siguiente:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Todas las expresiones <code>if</code> comienzan con la palabra clave <code>if</code> seguida por una
condición. En este caso, la condición verifica si la variable <code>number</code> tiene un valor
menor que 5. El bloque de código que queremos ejecutar si la condición es verdadera se
coloca inmediatamente después de la condición dentro de llaves.
Los bloques de código asociados con las condiciones en las expresiones <code>if</code> son
a veces llamados <em>brazos</em>, igual que los brazos en expresiones <code>match</code> que
tratamos en la sección <a href="ch02-00-guessing-game-tutorial.html#comparando-la-conjetura-con-el-n%C3%BAmero-secreto">“Comparando la conjetura con el número secreto”</a> del Capitulo 2.</p>
<p>Opcionalmente, también podemos incluir una expresión <code>else</code>, que elegimos hacer aquí, para
darle al programa un bloque de código alternativo que debería ejecutar si la condición
se evalúa como falsa. Si no proporciona una expresión <code>else</code> y la condición es falsa, el programa
saltará el bloque <code>if</code> y continuará al siguiente código.</p>
<p>Intente ejecutar este código; debería ver el siguiente resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Probemos cambiando el valor de <code>number</code> a un valor que haga que la condición sea
<code>false</code> para ver qué sucede:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Ejecute el programa nuevamente y observe el resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was false
</code></pre>
<p>También vale la pena señalar que la condición en este código <em>debe</em> ser un <code>bool</code>. Si
la condición no es un <code>bool</code>, obtendremos un error. Por ejemplo, intente ejecutar el
siguiente código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>La condición <code>if</code> se evalúa a un valor de <code>3</code> esta vez, y Rust arroja un
error:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>El error indica que Rust esperaba un <code>bool</code> pero obtuvo un número entero. A diferencia de lenguajes como Ruby y JavaScript, Rust no intentará convertir tipos no booleanos en booleanos.
Debe ser explícito y siempre proporcionar <code>if</code> con un Booleano como condición. 
Si queremos que se ejecute el bloque de código <code>if</code> solo cuando un número no es igual a <code>0</code>,
por ejemplo, podemos cambiar la expresión <code>if</code> a lo siguiente:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>Ejecutando este código se imprimirá <code>number was something other than zero</code>.</p>
<h4 id="manejo-de-múltiples-condiciones-con-else-if"><a class="header" href="#manejo-de-múltiples-condiciones-con-else-if">Manejo de múltiples condiciones con <code>else if</code></a></h4>
<p>Puede tener múltiples condiciones combinando <code>if</code> y <code>else</code> en una expresión <code>else if</code>.
Por ejemplo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>Este programa tiene cuatro caminos posibles que puede tomar. Después de ejecutarlo, debería
ver el siguiente resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Cuando se ejecuta este programa, comprueba cada una de las expresiones <code>if</code> y se ejecuta
el primer cuerpo para el cual la condición es verdadera. Tenga en cuenta que, aunque 6 es
divisible por 2, no vemos la salida <code>number is divisible by 2</code>, ni tampoco
vemos el texto <code>number is not divisible by 4, 3, or 2</code> del bloque <code>else</code>.
Eso es porque Rust solo ejecuta el bloque para la primera condición verdadera, y
una vez que encuentra una, ni siquiera comprueba el resto.</p>
<p>Si usa demasiadas expresiones <code>else if</code> puede saturar su código. Entonces si tiene más
de una, es posible que desee refactorizar su código. El Capítulo 6 describe una poderosa
estructura de ramificación de Rust llamado <code>match</code> para estos casos.</p>
<h4 id="usando-if-en-una-sentencia-let"><a class="header" href="#usando-if-en-una-sentencia-let">Usando <code>if</code> en una Sentencia <code>let</code></a></h4>
<p>Como <code>if</code> es una expresión, podemos usarla en el lado derecho de una sentencia <code>let</code>, como en el Listado 3-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">Listing 3-2: Asignando el resultado de una expresión <code>if</code>
a una variable</span></p>
<p>La variable <code>number</code> se vinculará a un valor basado en el resultado de la expresión <code>if</code>. Ejecute este código para ver qué sucede:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Recuerde que los bloques de código evalúan la última expresión en ellos, y
los números en sí mismos también son expresiones. En este caso, el valor de toda la expresión <code>if</code> depende de qué bloque de código se ejecute. Esto significa que los valores que tienen el potencial de ser resultados de cada brazo del <code>if</code> deben ser del mismo tipo. En el Listado 3-2, los resultados tanto del brazo <code>if</code> como del brazo <code>else</code> eran enteros <code>i32</code>. Si los tipos no coinciden, como en el siguiente ejemplo, obtendremos un error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>Cuando intentemos compilar este código, obtendremos un error. Los brazos <code>if</code> y <code>else</code>
tienen tipos de valores que son incompatibles, y Rust indica exactamente dónde se
encuentra el problema en el programa:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>La expresión en el bloque <code>if</code> se evalúa como un entero, y la expresión en
el bloque <code>else</code> se evalúa como un <em>string</em>. Esto no funcionará porque las variables
deben tener un solo tipo. Rust necesita saber definitivamente en tiempo de compilación de qué tipo es la variable <code>number</code>. Conocer el tipo de <code>number</code> permite que el el compilador verifique que el tipo sea válido en todos los lugares donde usamos number.
Rust no podría hacer eso si el tipo de <code>number</code> solo se determina en tiempo de ejecución.
El compilador sería más complejo y daría menos garantías sobre el código si tuviera
que realizar un seguimiento de múltiples tipos hipotéticos para cualquier variable.</p>
<h3 id="repetición-con-bucles"><a class="header" href="#repetición-con-bucles">Repetición con Bucles</a></h3>
<p>Suele ser útil ejecutar un bloque de código más de una vez. Para esta tarea, Rust proporciona varios <em>bucles</em>, que se ejecutarán a través del código dentro del cuerpo del bucle hasta el final y luego volverán a empezar inmediatamente desde el principio. Para experimentar con bucles, hagamos un nuevo proyecto llamado <em>loops</em>.</p>
<p>Rust tiene tres tipos de bucles: <code>loop</code>,<code>while</code> y <code>for</code>. Probemos cada uno.</p>
<h4 id="repetición-de-código-con-loop"><a class="header" href="#repetición-de-código-con-loop">Repetición de código con <code>loop</code></a></h4>
<p>La palabra clave <code>loop</code> le dice a Rust que ejecute un bloque de código una y otra vez
por siempre o hasta que explícitamente le diga que se detenga.</p>
<p>Como ejemplo, cambie el archivo <em>loops</em> en su directorio <em>src/main.rs</em> para que
se vea así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>Cuando ejecutemos este programa, veremos <code>again!</code> impreso una y otra vez continuamente hasta que detengamos el programa manualmente. La mayoría de los terminales admiten un atajo de teclado, <span class = "keystroke">ctrl-c</span>, para detener un programa que está atorado en un
bucle continuo. Démosle una oportunidad:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>El símbolo <code>^C</code> representa donde presionó <span class =" keystroke ">ctrl-c</span>
Puede o no ver la palabra <code>again!</code> impresa después de <code>^C</code>,
dependiendo de dónde estaba el código en el bucle cuando recibió la señal de detención.</p>
<p>Afortunadamente, Rust ofrece otra forma más confiable de salir de un bucle.
Puede colocar la palabra clave <code>break</code> dentro del ciclo para indicarle al programa cuándo
dejar de ejecutar el ciclo. Recuerde que hicimos esto en el juego de adivinanzas en
la sección <a href="ch02-00-guessing-game-tutorial.html#abandonar-despu%C3%A9s-de-una-conjetura-correcta">“Abandonar después de una conjetura correcta”</a> del Capítulo 2 para salir
del programa cuando el usuario ganó el juego adivinando el número correcto.</p>
<p>También usamos <code>continue</code> en el juego de adivinanzas, que le dice al programa que omita cualquier código restante en esta iteración del bucle y vaya a la próxima iteración.</p>
<h4 id="devolver-valores-desde-loops"><a class="header" href="#devolver-valores-desde-loops">Devolver Valores desde Loops</a></h4>
<p>Uno de los usos de un <code>loop</code> es reiterar una operación que sabe que podría fallar, como sería verificar si un hilo ha completado su trabajo. Es posible que también deba pasar el resultado de esa operación fuera del bucle al resto de su código. Para hacer esto, puede agregar el valor que desea devolver después de la expresión <code>break</code> que use para detener el bucle. Ese valor se devolverá fuera del bucle para que pueda usarlo, como se muestra aquí:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}
</code></pre></pre>
<p>Antes del ciclo, declaramos una variable llamada <code>counter</code> y la inicializamos a <code>0</code>. Luego declaramos una variable llamada <code>result</code> que espera el valor devuelto por el bucle. En cada iteración del bucle, sumamos <code>1</code> a la variable <code>counter</code>, y luego verifica si el contador es igual a <code>10</code>. Cuando lo es, usamos la palabra clave <code>break</code> con el valor <code>counter * 2</code>. Después del bucle, usamos un punto y coma para finalizar la sentencia que asigna el valor a <code>result</code>. Finalmente, imprimimos el valor en <code>result</code>, que en este caso es <code>20</code>.</p>
<h4 id="etiquetas-de-bucle-para-desambiguar-entre-múltiples-bucles"><a class="header" href="#etiquetas-de-bucle-para-desambiguar-entre-múltiples-bucles">Etiquetas de Bucle para Desambiguar entre Múltiples Bucles</a></h4>
<p>Si tiene bucles dentro de bucles, <code>break</code> y <code>continue</code> se aplican al bucle más interno en ese punto. Opcionalmente, puede especificar una <em>etiqueta de bucle</em> en un bucle que luego se puede usar con <code>break</code> o <code>continue</code> para especificar que esas palabras clave se apliquen al bucle etiquetado en lugar del bucle más interno. Las etiquetas de bucle deben comenzar con una comilla simple. Aquí hay un ejemplo con dos bucles anidados:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}
</code></pre></pre>
<p>El bucle externo tiene la etiqueta <code>'counting_up</code>, y contará de <code>0</code> a <code>2</code>. El bucle interno sin etiqueta cuenta hacia atrás de <code>10</code> a <code>9</code>. El primer <code>break</code>, que no especifica una etiqueta, solo saldrá del ciclo interno. La declaración <code>break 'counting_up;</code> saldrá del ciclo externo. Este código imprime:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="bucles-condicionales-con-while"><a class="header" href="#bucles-condicionales-con-while">Bucles Condicionales con <code>while</code></a></h4>
<p>A menudo es útil para un programa evaluar una condición dentro de un bucle. Mientras
la condición es verdadera, el ciclo se ejecuta. Cuando la condición deja de ser verdadera,
el programa llama a <code>break</code>, deteniendo el bucle. Este tipo de bucle podría implementarse
usando una combinación de <code>loop</code>,<code>if</code>, <code>else</code>, y <code>break</code>. Podría intentar eso
ahora en un programa, si lo desea.</p>
<p>Sin embargo, este patrón es tan común que Rust tiene una estructura en el lenguaje
incorporada para ello, llamada bucle <code>while</code>. El listado 3-3 utiliza <code>while</code> para que el código se ejecute tres veces, contando hacia atras cada vez. Luego, después del bucle,
imprime otro mensaje y sale.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 3-3: Usando un ciclo <code>while</code> para ejecutar código mientras
la condición es verdadera</span></p>
<p>Esta estructura elimina una gran cantidad de anidamiento que sería necesario si utilizó
<code>loop</code>,<code> if</code>, <code>else</code> y <code>break</code>; y es más claro. Mientras se cumple una condición,
el código dentro del bucle se ejecuta; de lo contrario, sale del bucle.</p>
<h4 id="looping-a-través-de-una-colección-con-for"><a class="header" href="#looping-a-través-de-una-colección-con-for">Looping a través de una Colección con <code>for</code></a></h4>
<p>Podría usar la estructura <code>while</code> para recorrer los elementos de una colección,
como un array. Por ejemplo, veamos el Listado 3-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p><span class="caption">Listado 3-4: Looping a través de cada elemento de una colección
usando un bucle <code>while</code></span></p>
<p>Aquí, el código cuenta hacia arriba a través de los elementos en el array. Comienza en el índice
<code>0</code>, y luego realiza un bucle hasta que alcanza el índice final en el array (es decir,
cuando <code>index &lt; 5</code> ya no es verdadero). Al ejecutar este código, se imprimirá cada elemento
del array:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Los cinco valores del array aparecen en la terminal, como se esperaba. Aunque <code>index</code>
alcanzará un valor de <code>5</code> en algún punto, el ciclo deja de ejecutarse antes de intentar
obtener un sexto valor en el array.</p>
<p>Sin embargo, este enfoque es propenso a errores; podríamos causar que el programa entrara en pánico si el valor del índice o la condición de prueba son incorrectos. Por ejemplo, si cambió la definición del array <code>a</code> para tener cuatro elementos, pero se olvidó de actualizar la condición a <code>while index &lt; 4</code>, el código entraría en pánico. También es lento, porque el compilador agrega código de tiempo de ejecución para realizar la verificación condicional de si el index está dentro de los límites del array en cada iteración a través del ciclo.</p>
<p>Como una alternativa más concisa, puede usar un bucle <code>for</code> y ejecutar algún código
para cada elemento en una colección. Un bucle <code>for</code> se parece al código del Listado 3-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-5: Looping a través de cada elemento de una colección
usando un bucle <code>for</code></span></p>
<p>Cuando ejecutamos este código, veremos el mismo resultado que en el listado 3-4. Lo más
importante, es que ahora hemos aumentado la seguridad del código y eliminado la
posibilidad de errores que podrían resultar de ir más allá del final del array o no
ir lo suficientemente lejos y perder algunos elementos.</p>
<p>Utilizando el bucle <code>for</code>, no necesitaría recordar cambiar ningún otro código si cambió la cantidad de valores en el array, como lo haría con el método utilizado en el Listado 3-4. </p>
<p>La seguridad y la concisión de los bucles <code>for</code> los convierten en el bucle más utilizado
en Rust. Incluso en situaciones en las que desea ejecutar algún código cierto número de veces, como en el ejemplo de cuenta regresiva que usó un bucle <code>while</code> en el Listado 3-3, la mayoría de los Rustáceos usaría un bucle <code>for</code>. La forma de hacerlo sería usar un <code>Range</code>, que es un tipo proporcionado por la biblioteca estándar que genera todos los números en secuencia a partir de un número y finalizando antes de otro número.</p>
<p>Así es como se vería la cuenta atrás utilizando un ciclo <code>for</code> y otro método
todavía no hemos hablado, <code>rev</code>, para invertir el rango:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>Este código es un poco mejor, ¿no?</p>
<h2 id="resumen-2"><a class="header" href="#resumen-2">Resumen</a></h2>
<p>¡Lo hizo! Este fue un capítulo considerable: aprendió sobre variables, tipos de datos escalares
y compuestos, funciones, comentarios, expresiones <code>if</code> y bucles.
Si quiere practicar con los conceptos discutidos en este capítulo, intente construir
programas para hacer lo siguiente:</p>
<ul>
<li>Convertir temperaturas entre Fahrenheit y Celsius.</li>
<li>Generar el enésimo número de Fibonacci.</li>
<li>Imprimir la letra del villancico &quot;Los Doce Días de Navidad&quot;
aprovechando la repetición en la canción.</li>
</ul>
<p>Cuando esté listo para seguir adelante, hablaremos de un concepto en Rust que <em>no</em>
comúnmente existe en otros lenguajes de programación: propiedad (<em>ownership</em>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprender-la-propiedad-ownership"><a class="header" href="#comprender-la-propiedad-ownership">Comprender la Propiedad (Ownership)</a></h1>
<p>La propiedad (<em>Ownership</em>) es la característica más exclusiva de Rust y tiene profundas implicaciones para el resto del lenguaje. Permite a Rust garantizar la seguridad de la memoria sin necesidad de un recolector de basura, por lo que es importante comprender cómo funciona la propiedad. En este capítulo, hablaremos sobre la propiedad, así como sobre varias características relacionadas: préstamo (<em>borrowing</em>), segmentos (<em>slices</em>) y cómo Rust distribuye los datos en la memoria.</p>
<blockquote>
<p>Nota del traductor:</p>
<blockquote>
<p>En la programación orientada a objetos es habitual el uso de la palabra <em>propiedad</em> como característica de un objeto. Esto puede llevar a cierta confusión debido a que en el idioma español, <em>propiedad</em> puede referirse tanto a una característica como a una posesión.</p>
<p>Se debe enfatizar entonces que en este capítulo <em><strong>propiedad = posesión</strong></em>.</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qué-es-la-propiedad-ownership"><a class="header" href="#qué-es-la-propiedad-ownership">¿Qué es la Propiedad (Ownership)?</a></h2>
<p>La <em>propiedad</em> es un conjunto de reglas que rigen cómo un programa Rust administra la memoria. Todos los programas tienen que administrar la forma en que usan la memoria de una
computadora mientras se ejecutan. Algunos lenguajes tienen un <em>recolector de basura</em>, que constantemente busca memoria que ya no se usa mientras el programa se ejecuta. En otros lenguajes, el programador debe explícitamente asignar y liberar la memoria. Rust utiliza un tercer enfoque: la memoria se gestiona a través de un sistema de propiedad con un conjunto de reglas que el compilador verifica en tiempo de compilación. Ninguna de las características de propiedad ralentizará su programa mientras se está ejecutando.</p>
<p>Como la propiedad es un concepto nuevo para muchos programadores, lleva tiempo
acostumbrarse a ella. La buena noticia es que cuanto más experimentado se vuelva con Rust
y las reglas del sistema de propiedad (<em>ownership</em>), más podrá, naturalmente,
desarrollar código que sea seguro y eficiente. ¡Sígalo!</p>
<p>Cuando comprenda la <em>propiedad</em>, tendrá una base sólida para la comprensión
las características que hacen que Rust sea único. En este capítulo, aprenderá sobre <em>propiedad</em> a través de algunos ejemplos que se centran en una estructura de datos muy común: <em>strings</em>.</p>
<blockquote>
<h3 id="la-pila-stack-y-el-montículo-heap"><a class="header" href="#la-pila-stack-y-el-montículo-heap">La Pila (<em>Stack</em>) y el Montículo (<em>Heap</em>).</a></h3>
<p>En muchos lenguajes de programación, no tiene que pensar muy a menudo en <em>Stack</em> y <em>Heap</em>, pero en un lenguaje de programación de sistemas como Rust, que un valor esté en el <em>Stack</em> o el <em>Heap</em> tiene más de un efecto sobre cómo el lenguaje se comporta y por qué tiene que tomar ciertas decisiones. Partes de la <em>propiedad</em> se describirán en relación con <em>Stack</em> y <em>Heap</em> más adelante en este capítulo, por lo que aquí hay una breve explicación a modo de preparación.</p>
<p>Tanto el <em>Stack</em> como el <em>Heap</em> son partes de la memoria que está disponible para usar en su código en tiempo de ejecución, pero están estructurados de diferentes maneras. El <em>stack</em> almacena los valores en el orden en que los obtiene y elimina los valores en el orden opuesto. Esto se conoce como <em>last in, first out</em>, <em>LIFO</em>, (último en entrar, primero en salir). Piense en una pila de platos: cuando agrega más platos, los pone encima de la pila, y cuando necesita un plato, toma uno de la parte superior. Agregar o quitar platos del medio o abajo ¡no funcionaría tan bien! Agregar datos se llama <em>pushing onto the stack</em> (~poniendo sobre la pila), y eliminar datos se llama <em>popping off the stack</em> (~sacando de arriba de la pila). Todos los datos almacenados en el <em>Stack</em> deben tener un tamaño conocido y fijo. Los datos con un tamaño desconocido en el momento de la compilación o cuyo tamaño podría cambiar deben ser almacenados en el <em>Heap</em>.</p>
<p>El <em>Heap</em> está menos organizado: cuando pone datos en el <em>Heap</em>, pide una cierta cantidad de espacio, el asignador de memoria encuentra un lugar vacío en algún lugar del <em>Heap</em> que sea lo suficientemente grande, lo marca como que esta en uso, y devuelve un <em>puntero</em>, que es la dirección de esa ubicación. Este proceso se llama <em>allocating on the Heap</em> (<em>asignando en el montículo</em>), a veces abreviado solo como “allocating” (insertar valores en el <em>Stack</em> no se considera asignación). Debido a que el puntero es de un tamaño conocido y fijo, se puede almacenar el puntero en el <em>Stack</em>, pero cuando quiere los datos reales, debe seguir el puntero. Piense en sentarse en un restaurante. Cuando ingresa, indica la cantidad de personas de su grupo, y el personal encuentra una mesa vacía que se adapta a todos y le lleva allí. Si alguien en su grupo llega tarde, pueden preguntar dónde ha estado sentado para encontrarle.</p>
<p>Colocar datos en el <em>Stack</em> es rápido debido a que el asignador de memoria nunca tiene que buscar un lugar para poner los nuevos datos: el lugar siempre es la parte superior de la pila. Comparativamente, asignar espacio en el <em>Heap</em> requiere más trabajo, porque el asignador primero debe encontrar un espacio lo suficientemente grande para mantener los datos, y luego realizar la contabilidad para prepararse para la siguiente asignación. </p>
<p>Acceder a los datos en el <em>Heap</em> es más lento que acceder a los datos en el <em>Stack</em> porque tiene que seguir un puntero para llegar allí. Los procesadores contemporáneos son más rápidos si saltan menos en la memoria. Continuando con la analogía, considere un mesero en un restaurante que recibe pedidos de muchas mesas. Es más eficiente obtener todos los pedidos en una mesa antes de pasar a la siguiente. Tomar una orden de la mesa A, luego una orden de la mesa B, luego  otra vez una de la mesa A, y entonces una más de la mesa B, sería un proceso mucho más lento. Por la misma razón, un procesador puede hacer su trabajo mejor si funciona con datos que están cerca de otros datos (como en el <em>Stack</em>) en lugar de estar más lejos (como puede ser en el <em>Heap</em>).</p>
<p>Cuando su código llama a una función, los valores pasados a la función (incluidos, potencialmente, punteros a datos en el <em>Heap</em>) y las variables locales de la función se colocan en el <em>Stack</em>. Cuando la función termina, esos valores se eliminan del <em>Stack</em>.</p>
<p>Hacer un seguimiento de qué partes del código están usando qué datos en el <em>Heap</em>, minimizar la cantidad de datos duplicados en el <em>Heap</em>, limpiar datos sin usar en el <em>Heap</em> para que no se quede sin espacio, son todos problemas que aborda la <em>propiedad</em> (<em>ownership</em>). Una vez que comprenda la <em>propiedad</em>, no tendrá que pensar en el <em>Stack</em> y el <em>Heap</em> con frecuencia, pero saber que el objetivo principal de la <em>propiedad</em> es administrar los datos del <em>Heap</em> puede ayudar a explicar por qué funciona de la manera en que lo hace.</p>
</blockquote>
<h3 id="reglas-de-propiedad-ownership"><a class="header" href="#reglas-de-propiedad-ownership">Reglas de Propiedad (<em>Ownership</em>)</a></h3>
<p>Primero, echemos un vistazo a las reglas de propiedad. Tenga en cuenta estas reglas cuando trabaje a través de los ejemplos que los ilustran:</p>
<ul>
<li>Cada valor en Rust tiene un propietario.</li>
<li>Solo puede haber un propietario a la vez.</li>
<li>Cuando el propietario queda fuera del ámbito, el valor se eliminará.</li>
</ul>
<h3 id="Ámbito-de-una-variable-scope"><a class="header" href="#Ámbito-de-una-variable-scope">Ámbito de una Variable (<em>Scope</em>)</a></h3>
<p>Ahora que hemos pasado la sintaxis básica, no incluiremos todo el código <code>fn main () {</code> en ejemplos, así que tendrá que poner los siguientes ejemplos dentro de una función <code>main</code> de forma manual. Como resultado, nuestros ejemplos serán un poco más concisos, dejándonos enfocarnos en los detalles reales en lugar de código repetitivo.</p>
<p>Como primer ejemplo de <em>propiedad</em>, veremos el ámbito o alcance (<em>scope</em>) de algunas variables. Un <em>scope</em> es el rango dentro de un programa para el cual un elemento es válido. Digamos que tenemos una variable que se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>La variable <code>s</code> se refiere a un <em>string</em> literal, donde el valor del <em>string</em> es
codificado en el texto de nuestro programa. La variable es válida desde el punto en el
que se declara hasta el final del <em>scope</em> actual. El listado 4-1 tiene comentarios
anotando donde la variable <code>s</code> es válida.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s no es válida aquí, aún no está declarada
    let s = &quot;hello&quot;;   // s es válida a partir de este punto

    // hacer cosas con s, sigue siendo válida
}                      // este ámbito ha terminado, y s ya no es válida
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-1: Una variable y el ámbito en el que es válida</span></p>
<p>En otras palabras, hay dos puntos importantes en el tiempo aquí:</p>
<ul>
<li>Cuando <code>s</code> entra en el <em>scope</em>, es válida.</li>
<li>Sigue siendo válida hasta que se sale del <em>scope</em>.</li>
</ul>
<p>En este punto, la relación entre los ámbitos y cuándo las variables son válidas es similar a la de otros lenguajes de programación. Ahora construiremos sobre esta comprensión introduciendo el tipo <code>String</code>.</p>
<h3 id="el-tipo-string"><a class="header" href="#el-tipo-string">El Tipo <code>String</code></a></h3>
<p>Para ilustrar las reglas de propiedad (<em>ownership</em>), necesitamos un tipo de datos que sea más complejo que los que cubrimos en la sección <a href="ch03-02-data-types.html#tipos-de-datos">&quot;Tipos de datos&quot;</a> del Capítulo 3. Los tipos cubiertos anteriormente son todos de un tamaño conocido, pueden ser almacenados en la pila (<em>stack</em>) y sacarse de la pila cuando su alcance ha terminado, pueden ser rápida y trivialmente copiados para hacer una nueva instancia independiente si otra parte del código necesita usar el mismo valor en un ámbito diferente. Pero queremos observar los datos que se almacenan en el montículo (<em>heap</em>) y explorar cómo Rust sabe cuándo limpiar esos datos, y el tipo <code>String</code> es un gran ejemplo.</p>
<p>Nos concentraremos en las partes de <code>String</code> que se relacionan con la <em>propiedad</em>. Estos aspectos también se aplican a otros tipos de datos complejos provistos por la biblioteca estándar (<em>std</em>) o creados por usted. Estudiaremos el tipo <code>String</code> con más profundidad en el <a href="ch08-02-strings.html">Capítulo 8</a>.</p>
<p>Ya vimos <em>string</em> literales, donde un valor de <em>string</em> está codificado en nuestro programa. Los literales <em>string</em> son convenientes, pero no son adecuados para toda situación en la cual podríamos querer usar texto. Una razón es que son inmutables. Otra es que no todos los valores de <em>string</em> se pueden conocer cuando escribimos nuestro código: por ejemplo, ¿qué sucede si queremos tomar la entrada del usuario y almacenarla? por estas situaciones, Rust tiene un segundo tipo de <em>string</em>, <code>String</code>. Este tipo maneja datos asignados en el montículo (<em>heap</em>) y como tal, es capaz de almacenar una cantidad de texto que es desconocida para nosotros en tiempo de compilación. Puede crear un <code>String</code> a partir de un literal <em>string</em> usando la <em>función asociada</em> <code>from</code>, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>El operador dos puntos (<code>::</code>) nos permite asignar un espacio de nombres a esta función <code>from</code> particular bajo el tipo <code>String</code> en lugar de usar algún tipo de nombre como <code>string_from</code>. Discutiremos más esta sintaxis en la sección <a href="ch05-03-method-syntax.html">&quot;Sintaxis del método&quot;</a> del Capítulo 5 y cuando hablemos sobre el espacio de nombres con módulos en <a href="ch07-03-importing-names-with-use.html">&quot;Rutas para hacer Referencia a un Elemento en el Árbol de Módulos&quot;</a> en el Capítulo 7.</p>
<p>Este tipo de <em>string</em> puede mutar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() agrega un literal a un String

println!(&quot;{}&quot;, s);      // Esto imprimirá `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>Entonces, ¿cuál es la diferencia aquí? ¿Por qué <code>String</code> puede mutarse pero los literales no?
La diferencia es cómo estos dos tipos lidian con la memoria</p>
<h3 id="memoria-y-asignación"><a class="header" href="#memoria-y-asignación">Memoria y Asignación</a></h3>
<p>En el caso de un <em>string</em> literal, conocemos el contenido en tiempo de compilación, por lo que el texto está codificado directamente en el ejecutable final. Esta es la razón por la que los <em>string</em> literales son rápidos y eficientes. Pero estas propiedades solo provienen de la inmutabilidad del literal del <em>string</em>. Desafortunadamente, no podemos poner una burbuja de memoria en el binario por cada fragmento de texto cuyo tamaño se desconoce en el momento de la compilación y cuyo tamaño podría cambiar mientras se ejecuta el programa.</p>
<p>Con el tipo <code>String</code>, para admitir un fragmento de texto mutable y ampliable, necesitamos asignar una cantidad de memoria en el Heap, desconocida en tiempo de compilación, para almacenar el contenidos. Esto significa:</p>
<ul>
<li>La memoria debe solicitarse al asignador de memoria en tiempo de ejecución.</li>
<li>Necesitamos una forma de devolver esta memoria al asignador cuando hayamos terminado con nuestro <code>String</code>.</li>
</ul>
<p>Esa primera parte la hacemos nosotros: cuando llamamos a <code>String::from</code>, su implementación solicita la memoria que necesita. Esto es bastante universal en los lenguajes de programación.</p>
<p>Sin embargo, la segunda parte es diferente. En lenguajes con un <em>recolector de basura (garbage collector - GC)</em>, el GC realiza un seguimiento y limpia la memoria que ya no se usa, y no necesitamos pensar en ello. En la mayoría de los lenguajes sin un GC, es nuestra responsabilidad identificar cuándo ya no se usa la memoria y llamar al código para liberarla explícitamente, tal como lo hicimos para solicitarla. Hacer esto correctamente ha sido históricamente un problema de programación difícil. Si lo olvidamos, desperdiciamos memoria. Si lo hacemos demasiado pronto, tendremos una variable inválida. Si lo hacemos dos veces, también es un error. Necesitamos emparejar exactamente un <code>allocate</code> con exactamente un <code>free</code>.</p>
<p>Rust toma una ruta diferente: la memoria se devuelve automáticamente una vez que la variable que lo posee queda fuera del ámbito. Aquí hay una versión de nuestro ejemplo de ámbito del Listado 4-1 usando un <code>String</code> en lugar de un literal de <em>string</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s es válida a partir de este punto

    // hacer cosas con s
}                                  // este ámbito ha terminado, y s ya no es válida
<span class="boring">}
</span></code></pre></pre>
<p>Aquí hay un punto natural en el que podemos devolver la memoria que nuestro <code>String</code> necesita al asignador cuando <code>s</code> sale del ámbito. Cuando una variable sale del ámbito, Rust llama a una función especial para nosotros. Esta función se llama <code>drop</code>, y es donde el autor de <code>String</code> podría poner el código para devolver la memoria. Rust llama a <code>drop</code> automáticamente al cierre de la llave.</p>
<blockquote>
<p>Nota: En C ++, este patrón de desasignación de recursos al final de la vida útil de un elemento se denomina a veces <em>Resource Acquisition Is Initialization (RAII)</em> (<em>Inicialización de adquisición de recursos (RAII)</em>).
La función <code>drop</code> en Rust le resultará familiar si ha utilizado patrones RAII.</p>
</blockquote>
<p>Este patrón tiene un profundo impacto en la forma en que se escribe el código de Rust. Puede parecer simple en este momento, pero el comportamiento del código puede ser inesperado en situaciones más complicadas cuando queremos que múltiples variables usen los datos que hemos asignado en el <em>Heap</em>. Exploremos algunas de esas situaciones ahora.</p>
<h4 id="formas-en-que-interactúan-las-variables-y-los-datos-mover"><a class="header" href="#formas-en-que-interactúan-las-variables-y-los-datos-mover">Formas en que Interactúan las Variables y los Datos: Mover</a></h4>
<p>Múltiples variables pueden interactuar con los mismos datos de diferentes maneras en Rust.
Veamos un ejemplo usando un número entero en el Listado 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-2: Asignando el valor entero de la variable <code>x</code> a <code>y</code></span></p>
<p>Probablemente podamos adivinar qué está haciendo esto: “vincula el valor <code>5</code> a <code>x</code>; luego hace una copia del valor en <code>x</code> y la agrega a <code>y</code>.” Ahora tenemos dos variables,<code>x</code> e <code>y</code>, y ambas son <code>5</code>. De hecho, esto es lo que está sucediendo, porque los enteros son valores simples con un tamaño conocido y fijo, y estos dos valores <code>5</code> se colocan en el <em>Stack</em>.</p>
<p>Ahora veamos la versión <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Esto se ve muy similar al código anterior, por lo que podemos suponer que la forma en que funciona sería la misma: es decir, la segunda línea haría una copia del valor en <code>s1</code> y lo vincularía a <code>s2</code>. Pero esto no es exactamente lo que sucede.</p>
<p>Eche un vistazo a la Figura 4-1 para ver lo que está sucediendo con <code>String</code> debajo de la superficie. Un <code>String</code> se compone de tres partes, que se muestran a la izquierda: un puntero a la memoria que guarda el contenido del <em>string</em>, una longitud y una capacidad. Este grupo de datos se almacena en el <em>Stack</em>. A la derecha está la memoria en el <em>Heap</em> que guarda los contenidos.</p>
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-1: Representación en memoria de un <code>String</code> conteniendo el valor <code>&quot;hello&quot;</code> vinculado a <code>s1</code></span></p>
<p>La longitud es la cantidad de memoria, en bytes, que está usando actualmente el contenido de <code>String</code>. La capacidad es la cantidad total de memoria, en bytes, que el <code>String</code> recibió del asignador. La diferencia entre la logitud y la capacidad importa, pero no en este contexto,
por lo que, por ahora, está bien ignorar la capacidad.</p>
<p>Cuando asignamos <code>s1</code> a <code>s2</code>, los datos de <code>String</code> se copian, lo que significa que copiamos el puntero, la longitud y la capacidad, que están en el <em>Stack</em>. No copiamos los datos del <em>Heap</em> al que hace referencia el puntero. En otras palabras, la representación de datos en la memoria se parece a la Figura 4-2.</p>
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-2: Representación en memoria de la variable <code>s2</code> que tiene una copia del puntero, longitud y capacidad de <code>s1</code></span></p>
<p>La representación <em>NO</em> se parece a la Figura 4-3, que es como se vería la memoria si Rust copiara también los datos del Heap. Si Rust hiciera esto, la operación <code>s2 = s1</code> podría ser muy costosa en términos de rendimiento en tiempo de ejecución si los datos en el Heap fueran grandes.</p>
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-3: Otra posibilidad para qué <code>s2 = s1</code> podría hacer si Rust copiara los datos del <em>Heap</em> también</span></p>
<p>Anteriormente, dijimos que cuando una variable queda fuera del alcance, Rust llama automáticamente a la función <code>drop</code> y limpia la memoria del Heap para esa variable. Pero la Figura 4-2 muestra ambos punteros de datos apuntando a la misma ubicación. Esto es un problema: cuando <code>s2</code> y <code>s1</code> salen del ámbito, ambos intentarán liberar la misma memoria. Esto se conoce como error de <em>doble liberación</em> (double free) y es uno de los errores de seguridad de la memoria que mencionamos anteriormente. Liberar memoria dos veces puede provocar daños en la memoria, lo que puede generar vulnerabilidades de seguridad.</p>
<p>Para garantizar la seguridad de la memoria, después de la línea <code>let s2 = s1</code>, Rust ya considera <code>s1</code> como no válido. Por lo tanto, Rust no necesita liberar nada cuando <code>s1</code> queda fuera del ámbito. Mire lo que sucede cuando intenta usar <code>s1</code> después que <code>s2</code> es creado; no funcionará: </p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>Recibirá un error como este porque Rust le impide usar la referencia invalidada:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Si ha escuchado los términos <em>shallow copy</em> (<em>copia superficial</em>) y <em>deep copy</em> (<em>copia profunda</em>) mientras trabaja con otros lenguajes, el concepto de copiar el puntero, la longitud y la capacidad sin copiar los datos probablemente suene como una copia superficial. Pero debido a que Rust también invalida la primera variable, en lugar de llamarse copia superficial, se la
conoce como <em>mover</em>. En este ejemplo, diríamos que <code>s1</code> se <em>movió</em> a <code>s2</code>. Entonces, lo que realmente sucede se muestra en la Figura 4-4.</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-4: La representación en memoria después de <code>s1</code> ha sido invalidada</span></p>
<p>¡Eso resuelve nuestro problema! Con solo <code>s2</code> válida, cuando salga del ámbito, ella sola
liberará la memoria y terminaremos.</p>
<p>Además, hay una opción de diseño implícita: Rust nunca creará automáticamente copias “profundas”
de sus datos. Por lo tanto, se puede suponer que cualquier copiado <em>automático</em> es económico en
términos de rendimiento en tiempo de ejecución.</p>
<h4 id="formas-en-que-interactúan-las-variables-y-los-datos-clonar"><a class="header" href="#formas-en-que-interactúan-las-variables-y-los-datos-clonar">Formas en que Interactúan las Variables y los Datos: Clonar</a></h4>
<p>Si queremos hacer una <em>copia profunda</em> de los datos en el <em>Heap</em> de <code>String</code> y no sólo los datos del <em>Stack</em>, podemos usar un método común llamado <code>clone</code>. Estudiaremos la sintaxis del método en el Capítulo 5, pero dado que los métodos son una característica común en muchos lenguajes de programación, probablemente ya los haya visto antes.</p>
<p>Aquí hay un ejemplo del método <code>clone</code> en acción:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Esto funciona correctamente y produce explícitamente el comportamiento que se muestra en la Figura 4-3, donde los datos del Heap se copian.</p>
<p>Cuando ve una llamada a <code>clone</code>, sabe que se está ejecutando algún código arbitrario y que ese código puede ser costoso. Es un indicador visual de que algo diferente está sucediendo.</p>
<h4 id="datos-de-sólo-pila-copiar"><a class="header" href="#datos-de-sólo-pila-copiar">Datos de Sólo-Pila: Copiar</a></h4>
<p>Hay otro aspecto del que aún no hemos hablado. Este código que usa números enteros, parte del cual se mostró en el Listado 4-2, funciona y es válido:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Pero este código parece contradecir lo que acabamos de aprender: no tenemos una llamada a
<code>clone</code>, pero<code> x</code> sigue siendo válida y no se movió a <code>y</code>.</p>
<p>La razón es que los tipos como los enteros, que tienen un tamaño conocido en el momento
de la compilación, se almacenan completamente en el Stack, por lo que las copias de los
valores actuales son rápidos de realizar. Eso significa que no hay ninguna razón por la que
quisiéramos evitar que <code>x</code> sea válida después de que creamos la variable<code> y</code>. En otras
palabras, aquí no hay diferencia entre la copia profunda y la poco profunda, por lo que
llamar a <code>clone</code> no haría nada diferente de la copia superficial normal y podemos omitirlo.</p>
<p>Rust tiene una anotación especial llamada el <em>trait</em> <code>Copy</code> que podemos colocar en tipos como enteros que están almacenados en el Stack (hablaremos más sobre los <em>traits</em> en el <a href="ch10-02-traits.html">Capítulo 10</a>). Si un tipo implementa el <em>trait</em> <code>Copy</code>, las variables que lo usan no son movidas, sino que se copian trivialmente, haciéndolas aún válidas después de la asignación a otra variable.</p>
<p>Rust no nos permitirá anotar un tipo con <code>Copy</code> si el tipo, o cualquiera de sus partes, ha implementado el <em>trait</em> <code>Drop</code>. Si el tipo necesita que ocurra algo especial cuando el valor se sale del ámbito y agregamos la anotación <code>Copy</code> a ese tipo, obtendremos un error en tiempo de compilación. Para obtener información sobre cómo agregar la anotación <code>Copy</code> a su tipo para implementar el <em>trait</em>, consulte <a href="appendix-03-derivable-traits.html">&quot;Traits Derivables”</a> en el Apéndice C.</p>
<p>Entonces, ¿qué tipos implementan el <em>trait</em> <code>Copy</code>? Puede verificar la documentación del tipo dado para asegurarse, pero como regla general, cualquier grupo de valores escalares simples puede ser <code>Copy</code>, y nada que requiera asignación o es alguna forma de recurso es <code>Copy</code>. Estos son algunos de los tipos que implementan <code>Copy</code>:</p>
<ul>
<li>Todos los tipos de enteros, como <code>u32</code>.</li>
<li>El tipo booleano, <code>bool</code>, con los valores <code>true</code> y <code>false</code>.</li>
<li>Todos los tipos de punto flotante, como <code>f64</code>.</li>
<li>El tipo de carácter, <code>char</code>.</li>
<li>Tuplas, pero solo si contienen tipos que también implementan <code>Copy</code>. Por ejemplo,
<code>(i32, i32)</code> implementa <code>Copy</code>, pero <code>(i32, String)</code> no lo hace.</li>
</ul>
<h3 id="propiedad-y-funciones"><a class="header" href="#propiedad-y-funciones">Propiedad y Funciones</a></h3>
<p>La mecánica para pasar un valor a una función es similar a la de asignar un valor a una variable. Pasar una variable a una función la moverá o la copiará, tal como lo hace la asignación. El listado 4-3 tiene un ejemplo con algunos comentarios que muestran dónde las variables entran y salen del ámbito (<em>scope</em>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s entra en el scope

    takes_ownership(s);             // s's el valor se mueve a la función ...
                                    // ... y entonces ya no es válido aquí

    let x = 5;                      // x entra en el scope

    makes_copy(x);                  // x se movería a la función,
                                    // pero i32 es Copy, así que está bien
                                    // todavía puede usarse x después

} // Aquí, x sale del scope, luego s. Pero como el valor de s se movió, nada
  // sucede de manera especial.

fn takes_ownership(some_string: String) { // some_string entra en el scope
    println!(&quot;{}&quot;, some_string);
} // Aquí, some_string sale del scope y se llama `drop`. La memoria de
  // respaldo se libera.

fn makes_copy(some_integer: i32) { // some_integer entra en el scope
    println!(&quot;{}&quot;, some_integer);
} // Aquí, some_integer sale del scope. Nada especial sucede.
</code></pre></pre>
<p><span class="caption">Listing 4-3: Funciones con propiedad y scope comentado</span></p>
<p>Si intentamos usar <code>s</code> después de la llamada a<code> takes_ownership</code>, Rust arrojaría un error en tiempo de compilación. Estas comprobaciones estáticas nos protegen de los errores. Intente agregar código a <code>main</code> que use<code> s</code> y <code>x</code> para ver dónde puede usarlos y dónde las reglas de propiedad le impiden hacerlo.</p>
<h3 id="valores-de-retorno-y-Ámbito"><a class="header" href="#valores-de-retorno-y-Ámbito">Valores de Retorno y Ámbito</a></h3>
<p>Los valores devueltos también puede transferir la propiedad (<em>ownership</em>).
El listado 4-4 es un ejemplo con comentarios similares a las del Listado 4-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership mueve su valor de 
                                        // retorno a s1

    let s2 = String::from(&quot;hello&quot;);     // s2 entra en el scope

    let s3 = takes_and_gives_back(s2);  // s2 se mueve a takes_and_gives_back, 
                                        // que también mueve su valor 
                                        // de retorno a s3
} // Aquí, s3 sale del scope y se descarta. s2 sale del scope pero se movió,
  // por lo que no sucede nada. s1 sale del scope y se descarta.

fn gives_ownership() -&gt; String {             // gives_ownership moverá su 
                                             // valor de retorno a la función 
                                             // que lo llama.

    let some_string = String::from(&quot;hello&quot;); // some_string entra en el scope

    some_string                              // some_string se devuelve y 
                                             // se mueve a la función de llamada.
}

// takes_and_gives_back tomará un *string* y devolverá uno
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string entra en el scope

    a_string  // a_string se devuelve y se mueve a la función de llamada
}
</code></pre></pre>
<p><span class="caption">Listing 4-4: Transferir la propiedad (<em>ownership</em>) de los valores devueltos</span></p>
<p>La propiedad (<em>ownership</em>) de una variable sigue el mismo patrón cada vez: la asignación de un valor a otra variable mueve la propiedad. Cuando una variable que incluye datos en el Heap queda fuera del scope, el valor se limpiará mediante <code>drop</code> a menos que los datos hayan sido movidos para ser propiedad (<em>ownership</em>) de otra variable.</p>
<p>Tomar posesión y luego devolver la propiedad (<em>ownership</em>) con cada función es un poco tedioso.
¿Qué sucede si queremos permitir que una función use un valor pero no tome posesión?
Es bastante molesto que cualquier cosa que pasemos también deba devolverse si queremos
volver a usarla, además de cualquier dato que provenga del cuerpo de la función que también
deseemos devolver.</p>
<p>Rust nos permite devolver múltiples valores usando una tupla, como se muestra en el Listado 4-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() devuelve la longitud de un String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Listing 4-5: Devolución de la propiedad (<em>ownership</em>) de los parámetros</span></p>
<p>Pero esto es demasiada ceremonia y mucho trabajo para un concepto que debería ser común.
Afortunadamente para nosotros, Rust tiene una característica usar un valor sin transferir la propiedad, llamada <em>referencias</em> (<em>references</em>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referencias-y-préstamos-references-and-borrowing"><a class="header" href="#referencias-y-préstamos-references-and-borrowing">Referencias y Préstamos (<em>References and Borrowing</em>)</a></h2>
<p>El problema con el código de tupla en el Listado 4-5 es que tenemos que devolver el <code>String</code> a la función de llamada para que podamos seguir usando el <code>String</code> después de la llamada a <code>calculate_length</code>, porque el <code>String</code> se movió a <code>calculate_length</code>.  En su lugar, podemos proporcionar una referencia al valor del <code>String</code>. Una <em>referencia</em> es como un puntero en el sentido de que es una dirección que podemos seguir para acceder los datos almacenados en esa dirección; esos datos son propiedad de alguna otra variable. A diferencia de un puntero, se garantiza que una referencia apunte a un valor válido de un tipo particular durante la vida de esa referencia. </p>
<p>Aquí se explica cómo definiría y usaría una función <code>calculate_length</code> que hace referencia a
un objeto como parámetro en lugar de tomar posesión del valor:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Primero, observe que todo el código de tupla en la declaración de la variable y el valor de retorno de la función han desaparecido. En segundo lugar, tenga en cuenta que pasamos <code>&amp;s1</code> a <code>calculate_length</code> y, en su definición, tomamos <code>&amp;String</code> en lugar de <code>String</code>. Estos <em>ampersands</em> (<code>&amp;</code>) representan <em>referencias</em>, y le permiten referirse a algún valor sin tomar posesión de él. 
La figura 4-5 muestra un diagrama.</p>
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
<p><span class="caption">Figure 4-5: Un diagrama de <code>&amp;String s</code> apuntando a <code>String s1</code></span></p>
<blockquote>
<p>Nota: lo contrario de <em>referenciar</em> usando <code>&amp;</code> es <em>desreferenciar</em>, que se
logra con el operador de desreferencia, <code>*</code>. Veremos algunos usos del operador de
desreferencia en el Capítulo 8 y discutiremos los detalles de desreferenciación en
el Capítulo 15.</p>
</blockquote>
<p>Echemos un vistazo más de cerca a la llamada de función aquí:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span>let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
<span class="boring">}
</span></code></pre></pre>
<p>La sintaxis <code>&amp;s1</code> nos permite crear una <em>referencia</em> al valor de <code>s1</code> pero no lo posee. Como no es el propietario, el valor al que apunta no se eliminará cuando la referencia deje de usarse.</p>
<p>Del mismo modo, la firma de la función usa <code>&amp;</code> para indicar que el tipo del parámetro <code>s</code> es una referencia. Agreguemos algunos comentarios explicativos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s es una referencia a un String
    s.len()
} // Aquí, s sale del scope. Pero como no tiene propiedad de lo que referencia,
  // no sucede nada.
<span class="boring">}
</span></code></pre></pre>
<p>El scope en el que la variable <code>s</code> es válida es el mismo que el scope de cualquier parámetro de función, pero el valor al que apunta la referencia no se elimina cuando <code>s</code> deja de usarse porque <code>s</code> no tiene propiedad. Cuando las funciones tienen referencias como parámetros en lugar de los valores reales, no necesitaremos devolver los valores para devolver la propiedad, porque nunca tuvimos la propiedad.</p>
<p>A la acción de crear una <em>referencia</em> la llamamos <em>préstamo</em> (<em>borrowing</em>). Como en la vida real, si una persona posee algo, se lo puede pedir prestado. Cuando haya terminado, debe devolverlo. No lo posee.</p>
<p>Entonces, ¿qué sucede si tratamos de modificar algo que estamos pidiendo prestado?
Pruebe el código en el Listado 4-6. Alerta de spoiler: ¡no funciona!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Listing 4-6: Intentando modificar un valor prestado</span></p>
<p>Aquí está el error:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Así como las variables son inmutables por defecto, también lo son las referencias.
No se nos permite modificar algo a lo que tenemos una referencia.</p>
<h3 id="referencias-mutables"><a class="header" href="#referencias-mutables">Referencias Mutables</a></h3>
<p>Podemos corregir el código del Listado 4-6 para permitirnos modificar un valor prestado con solo unos pequeños ajustes usando una referencia mutable:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>Primero, cambiamos <code>s</code> para que sea <code>mut</code>. Luego creaamos una referencia mutable con <code>&amp;mut s</code> donde llamamos a la función <code>change</code> y actualizamos la firma de la función para aceptar una referencia mutable con <code>some_string: &amp;mut String</code>. Esto deja muy claro que la función <code>change</code> mutará el valor que toma prestado.</p>
<p>Las referencias mutables tienen una gran restricción: si tiene una referencia mutable a un valor, no puede tener otras referencias a ese mismo valor. Este código que intenta crear dos referencias mutables a <code>s</code> fallará:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<p>Aquí está el error:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Este error dice que este código no es válido porque no podemos tomar prestado <code>s</code> como mutable más de una vez al mismo tiempo. El primer préstamo mutable está en <code>r1</code> y debe durar hasta que se use en <code>println!</code>, pero entre la creación de esa referencia mutable y su uso, intentamos crear otra referencia mutable en <code>r2</code> que toma prestados los mismos datos que <code>r1</code>.</p>
<p>La restricción que impide múltiples referencias mutables a los mismos datos al mismo tiempo permite la mutación, pero de una manera muy controlada. Es algo con lo que los nuevos Rustáceos luchan, porque la mayoría de los lenguajes le permiten mutar cuando lo desee.</p>
<p>El beneficio de tener esta restricción es que Rust puede evitar carreras de datos en tiempo de compilación. Una <em>data race</em> es similar a una condición de carrera y ocurre cuando se producen estos tres comportamientos:</p>
<ul>
<li>Dos o más punteros acceden a los mismos datos al mismo tiempo.</li>
<li>Al menos uno de los punteros se está utilizando para escribir en los datos.</li>
<li>No se usa ningún mecanismo para sincronizar el acceso a los datos.</li>
</ul>
<p>Las carreras de datos causan un comportamiento indefinido y pueden ser difíciles de diagnosticar y corregir cuando intenta rastrearlos en tiempo de ejecución. Rust evita que este problema ocurra porque se negará a compilar código con <em>data race</em>.</p>
<p>Como siempre, podemos usar llaves para crear un nuevo ámbito, permitiendo múltiples referencias mutables, pero no <em>simultáneas</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 queda fuera del scope aquí, por lo que podemos hacer una nueva referencia sin problemas.

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Rust aplica una regla similar para combinar referencias mutables e inmutables. Este código da como resultado un error:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<p>Aquí está el error:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>¡Uf! <em>Tampoco</em> podemos tener una referencia mutable mientras tengamos una referencia inmutable al mismo valor.</p>
<p>¡Los usuarios de una referencia inmutable no esperan que el valor cambie repentinamente debajo de ellos! Sin embargo, se permiten múltiples referencias inmutables porque nadie que solo esté leyendo los datos tiene la capacidad de afectar la lectura de los datos de otra persona.</p>
<p>Tenga en cuenta que el scope de una referencia comienza desde donde se introdujo y continúa hasta la última vez que se usó esa referencia. Por ejemplo, este código se compilará porque el último uso de las referencias inmutables, <code>¡println!</code>, ocurre antes de que se introduzca la referencia mutable:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 y r2 no deben usarse después de este punto

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre>
<p>Los scopes de las referencias inmutables <code>r1</code> y <code>r2</code> terminan después de <code>println!</code>, donde se usaron por última vez, que es antes de que se cree la referencia mutable <code>r3</code>. Estos scopes no se superponen, por lo que este código está permitido. La capacidad del compilador para decir que una referencia ya no se usa en un punto antes del final del scope se llama <em>Non-Lexical Lifetimes</em> (NLL para abreviar). Puede leer más sobre esto en <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes">The Edition Guide</a>.</p>
<p>Aunque estos errores pueden ser frustrantes a veces, recuerde que es el compilador Rust el que señala un posible error anticipadamente (en tiempo de compilación en lugar de en tiempo de ejecución) y le muestra exactamente dónde está el problema. Entonces no tiene que rastrear por qué sus datos no son lo que pensaba que eran.</p>
<h3 id="referencias-colgantes"><a class="header" href="#referencias-colgantes">Referencias Colgantes</a></h3>
<p>En lenguajes con punteros, es fácil crear erróneamente un <em>puntero colgante</em> (un puntero que hace referencia a una ubicación en la memoria que se le puede haber dado a alguien más) al liberar algo de la memoria mientras se conserva un puntero a esa memoria. En Rust, por el contrario, el compilador garantiza que las referencias nunca serán referencias colgantes: si tiene una referencia a algunos datos, el compilador se asegurará de que los datos no queden fuera del scope antes que lo haga la referencia a esos datos.</p>
<p>Intentemos crear una referencia colgante para ver cómo Rust las previene con un error en tiempo de compilación: </p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>Aquí está el error:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Este mensaje de error se refiere a una función que aún no hemos cubierto: tiempos de vida.
Analizaremos los tiempos de vida en detalle en el Capítulo 10. Pero, si ignora las partes
acerca de tiempos de vida, el mensaje contiene la clave de por qué este código es un problema:</p>
<pre><code class="language-text">en-this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.

es-el tipo de devolución de esta función contiene un valor prestado, pero no hay
ningún valor para que se tome prestado.
</code></pre>
<p>Echemos un vistazo más de cerca a lo que está sucediendo exactamente en cada etapa de
nuestro código <code>dangle</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle devuelve una referencia a un String

    let s = String::from(&quot;hello&quot;); // s es un nuevo String

    &amp;s // devolvemos una referencia al String s
} // s sale del scope y se descarta. Desaparece de la memoria.
  // ¡Peligro!
</code></pre>
<p>Debido a que <code>s</code> se crea dentro de <code>dangle</code>, cuando el código de <code>dangle</code> finaliza, <code>s</code> será desasignado. Pero tratamos de devolver una referencia a <code>s</code>. Eso significa que esta referencia estaría apuntando a un <code>String</code> inválido ¡Eso no es bueno! Rust no nos dejará hacer esto.</p>
<p>La solución aquí es devolver el <code>String</code> directamente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<p>Esto funciona sin ningún problema. La propiedad se trasladó y no se desasignó nada.</p>
<h3 id="las-reglas-de-las-referencias"><a class="header" href="#las-reglas-de-las-referencias">Las Reglas de las Referencias</a></h3>
<p>Repasemos lo que hemos visto sobre las referencias:</p>
<ul>
<li>En cualquier momento dado puede tener: <em>o</em> una referencia mutable, <em>o</em> cualquier cantidad de referencias inmutables.</li>
<li>Las referencias deben ser siempre válidas.</li>
</ul>
<p>A continuación, veremos un tipo diferente de referencia: <em>slices</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="el-tipo-slice-segmento"><a class="header" href="#el-tipo-slice-segmento">El Tipo Slice (Segmento)</a></h2>
<p>Los <em>Slices</em> le permiten hacer referencia a un secuencia contigua de elementos en una colección en lugar de toda la colección. Un <em>Slice</em> es una especie de referencia, por lo que no tiene la propiedad.</p>
<p>He aquí un pequeño problema de programación: escriba una función que tome una cadena (<em>string</em>) de palabras (separadas por espacios) y devuelva la primera palabra que encuentre en ese <em>string</em>. Si la función no encuentra un espacio en el <em>string</em>, todo el <em>string</em> debe ser una palabra, por lo que se debe devolver el <em>string</em> completo. </p>
<p>Analicemos cómo escribiríamos la firma de esta función sin usar <em>Slices</em>, para entender el problema que luego resolverán los <em>Slices</em>:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>La función <code>first_word</code> tiene un <code>&amp;String</code> como parámetro. No queremos la <em>propiedad</em>, así que eso está bien. Pero, ¿qué deberíamos devolver? Realmente no tenemos una forma de hablar sobre <em>parte</em> de un <em>string</em>. Sin embargo, podríamos devolver el índice del final de la palabra, indicado por un espacio. Probemos eso, como se muestra en el Listado 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 4-7: La función <code>first_word</code> que devuelve un valor de índice de byte en el parámetro <code>String</code></span></p>
<p>Debido a que necesitamos recorrer el <code>String</code> elemento por elemento y comprobar si un valor es un espacio, convertiremos nuestro <code>String</code> a un array de bytes utilizando el método <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>A continuación, creamos un iterador sobre el array de bytes utilizando el método <code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Analizaremos iteradores con más detalle en el <a href="ch13-02-iterators.html">Capítulo 13</a>. Por ahora, sepa que <code>iter</code> es un método que devuelve cada elemento de una colección y que <code>enumerate</code> adapta el resultado de <code>iter</code> y en su lugar devuelve cada elemento como parte de una tupla. El primer elemento de la tupla devuelta de <code>enumerate</code> es el índice, y el segundo elemento es una referencia al elemento. Esto es un poco más conveniente que calcular el índice nosotros mismos.</p>
<p>Debido a que el método <code>enumerate</code> devuelve una tupla, podemos usar patrones
para desestructurar esa tupla. Hablaremos más sobre los patrones en el <a href="ch06-02-match.html">Capítulo 6</a>. En el bucle <code>for</code>, especificamos un patrón que tiene <code>i</code> para el
índice en la tupla y <code>&amp;item</code> para el byte simple en la tupla. Como de <code>.iter().enumerate()</code> obtenemos una referencia al elemento, usamos <code>&amp;</code> en el patrón.</p>
<p>Dentro del bucle <code>for</code>, buscamos el byte que representa el espacio usando la sintaxis
literal de byte. Si encontramos un espacio, devolvemos la posición. De lo contrario,
devolvemos la longitud del <em>string</em> usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">   let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">   for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Ahora tenemos una forma de averiguar el índice del final de la primera palabra en el <em>string</em>,
pero hay un problema. Estamos devolviendo un <code>usize</code> por sí solo, pero es un número
significativo sólo en el contexto de <code>&amp;String</code>. En otras palabras, como es un valor separado de
<code>String</code>, no hay garantía de que siga siendo válido en el futuro. Considere el programa en
el Listado 4-8 que usa la función <code>first_word</code> del Listado 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word obtendrá el valor 5

    s.clear(); // esto vacía el String, haciéndolo igual a &quot;&quot;

    // word todavía tiene el valor 5 aquí, pero no hay más un string con el que podamos
    // usar significativamente el valor 5. ¡word ahora es totalmente inválido!
}
</code></pre></pre>
<p><span class="caption">Listing 4-8: Almacenar el resultado de llamar a la función <code>first_word</code>
y luego cambiar el contenido de <code>String</code></span></p>
<p>Este programa compila sin ningún error y también lo haría si usáramos <code>word</code> después de llamar a <code>s.clear()</code>. Debido a que <code>word</code> no está conectado en absoluto al estado de <code>s</code>, <code>word</code> todavía contiene el valor <code>5</code>. Podríamos usar ese valor <code>5</code> con la variable <code>s</code> para intentar extraer la primera palabra, pero esto sería un error porque el contenido de <code>s</code> ha cambiado desde que guardamos <code>5</code> en <code>word</code>.</p>
<p>Tener que preocuparse de que el índice en <code>word</code> esté fuera de sincronía con los
datos en <code>s</code> es tedioso y propenso a errores. La gestión de estos índices es aún
más frágil si escribimos una función <code>second_word</code>. Su firma debería verse así:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Ahora estamos rastreando un índice de inicio <em>y</em> uno final, y tenemos
aún más valores que se calcularon a partir de datos en un estado particular,
pero que no están vinculados a ese estado en absoluto. Ahora tenemos tres variables
no relacionadas flotando alrededor que deben mantenerse sincronizadas.</p>
<p>Afortunadamente, Rust tiene una solución a este problema: <em>string slices</em> (segmentos de cadenas).</p>
<h3 id="string-slices-segmentos-de-cadenas"><a class="header" href="#string-slices-segmentos-de-cadenas">String Slices (Segmentos de Cadenas)</a></h3>
<p>Un <em>string slice</em> es una referencia a parte de un <code>String</code>, y se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>En lugar de una referencia a todo el <code>String</code>, <code>hello</code> es una referencia a una parte del <code>String</code>, especificado en el agregado extra <code>[0..5]</code>. Creamos segmentos usando un rango entre corchetes especificando <code>[índice_inicial..índice_final]</code>, donde el <code>índice_inicial</code> es la primera posición en el segmento y el <code>índice_final</code> es uno más que la última posición en el segmento. Internamente, la estructura de datos del segmento almacena la posición inicial y la longitud del segmento, que corresponde al <code>índice_final</code> menos el <code>índice_inicial</code>. Entonces, en el caso de <code>let world = &amp;s[6..11];</code>, <code>world</code> sería un segmento que contiene un puntero al byte con índice 6 de <code>s</code>, con un valor de longitud 5.</p>
<p>La figura 4-6 muestra esto en un diagrama.</p>
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-6: <em>string slice</em> refiriéndose a parte de un
<code>String</code></span></p>
<p>Con la sintaxis de rango <code>..</code> de Rust, si desea comenzar en el primer índice (cero),
puede omitir el valor antes de los dos puntos. En otras palabras, estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello&quot;);

    let slice = &amp;s[0..2];
    let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>De la misma manera, si su segmento incluye el último byte del <code>String</code>, puede omitir el
número final. Eso significa que estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello&quot;);

    let len = s.len();

    let slice = &amp;s[3..len];
    let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>También puede omitir ambos valores para tomar un segmento de la cadena completa.
Entonces estos son iguales:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello&quot;);

    let len = s.len();

    let slice = &amp;s[0..len];
    let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Nota: Los índices de rango de <em>string slice</em> deben darse en límites válidos de caracteres UTF-8. Si intenta crear un <em>string slice</em> en el medio de un caracter multibyte, su programa se cerrará con un error. A los efectos de introducir <em>string slices</em>, estamos asumiendo sólo ASCII en esta sección. Una discusión más detallada del manejo de UTF-8 se encuentra en la sección <a href="ch08-02-strings.html">“Almacenamiento de texto codificado en UTF-8 con Strings”</a> del Capítulo 8.</p>
</blockquote>
<p>Con toda esta información en mente, reescribamos <code>first_word</code> para devolver un
<em>slice</em>. El tipo indicado para “string slice” se escribe como <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Obtenemos el índice para el final de la palabra de la misma manera que lo hicimos en el Listado 4-7, buscando la primera aparición de un espacio. Cuando encontramos un espacio, devolvemos un <em>string slice</em> usando el inicio del <em>string</em> y el índice del espacio como los índices inicial y final.</p>
<p>Ahora, cuando llamamos a <code>first_word</code>, obtenemos un valor único que está vinculado a los datos subyacentes. El valor se compone de una referencia al punto inicial del segmento (<em>slice</em>) y el número de elementos en ese segmento.</p>
<p>Devolver un segmento también funcionaría para una función <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Ahora tenemos una API sencilla que es mucho más difícil de estropear, porque el compilador se asegurará de que las referencias a <code>String</code> sigan siendo válidas. ¿Recuerda el error en el programa del Listado 4-8, cuando obtuvimos el índice al final de la primera palabra pero luego borramos el <em>string</em>, por lo que nuestro índice no era válido? Ese código era lógicamente incorrecto pero no mostraba ningún error inmediato. Los problemas aparecerían más adelante si siguiéramos intentando usar el índice de la primera palabra con un <em>string</em> vaciado. Los <em>slices</em> hacen que este error sea imposible y nos avisan que tenemos un problema con nuestro código mucho antes. El uso de la versión <em>slice</em> de <code>first_word</code> generará un error en tiempo de compilación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>Aquí está el error del compilador:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Recuerde de las reglas de préstamo que: si tenemos una referencia inmutable a algo, no podemos tener también una referencia mutable. Debido a que <code>clear</code> necesita truncar el <code>String</code>, necesita obtener una referencia mutable. El <code>println!</code> después de la llamada a <code>clear</code> usa la referencia en <code>word</code>, por lo que la referencia inmutable aún debe estar activa en ese punto. Rust no permite que la referencia mutable en <code>clear</code> y la referencia inmutable en <code>word</code> existan al mismo tiempo, y la compilación falla. ¡Rust no solo ha hecho que nuestra API sea más fácil de usar, sino que también ha eliminado toda una clase de errores en el momento de la compilación!</p>
<h4 id="string-literales-son-slices"><a class="header" href="#string-literales-son-slices">String Literales son Slices</a></h4>
<p>Recordemos que hablamos sobre <em>string literales</em> (<em>cadenas literales</em>) que se almacenan dentro del binario. Ahora que sabemos acerca de <em>slices</em>, podemos entender correctamente los <em>string literales</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>El tipo de <code>s</code> aquí es <code>&amp;str</code>: es un <em>slice</em> que apunta a ese punto específico del
binario. Esta es también la razón por la cual los <em>string literales</em> son inmutables;
<code>&amp;str</code> es una referencia inmutable.</p>
<h4 id="string-slices-como-parámetros"><a class="header" href="#string-slices-como-parámetros">String Slices como Parámetros</a></h4>
<p>Saber que podemos tomar segmentos de valores literales y valores <code>String</code> nos lleva
a una mejora más en <code>first_word</code>, y esa es su firma:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Un <em>Rustáceo</em> más experimentado escribiría la firma que se muestra en el Listado 4-9 porque nos permite usar la misma función tanto en los valores <code>&amp;String</code> como en los valores <code>&amp;str</code>.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 4-9: Mejorando la función <code>first_word</code> usando un <em>slice string</em>
para el tipo del parámetro <code>s</code></span></p>
<p>Si tenemos un <em>string slice</em>, podemos pasarlo directamente. Si tenemos un <code>String</code>, podemos pasar un <em>slice</em> de <code>String</code> o una referencia a <code>String</code>. Esta flexibilidad aprovecha la <em>&quot;deref coercions&quot;</em>, una característica que cubriremos en la sección <a href="ch15-02-deref.html#implicaciones-deref-impl%C3%ADcitas-con-funciones-y-m%C3%A9todos">&quot;Deref Coercions Implícitas con Funciones y Métodos&quot;</a> del Capítulo 15. Definir una función que toma un <em>string slice</em> en lugar de una referencia a un <code>String</code> hace que nuestra API sea más general y útil sin perder ninguna funcionalidad:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` funciona en segmentos de `String`s, ya sean parciales o completos
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    
    // `first_word` también funciona en referencias a `String`s, las cuales son 
    // el equivalente a porciones completas de `String`s
    let word = first_word(&amp;my_string);

    // Asignamos una cadena literal 
    let my_string_literal = &quot;hello world&quot;;

    // `first_word` funciona en &quot;segmentos&quot; de &quot;cadenas literales&quot;, 
    // ya sean parciales o completos
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Debido a que las &quot;cadenas literales&quot; *ya son* &quot;segmentos de cadena&quot;, 
    // esto también funciona, ¡sin la sintaxis de &quot;slice [..]&quot;!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3 id="otros-slices"><a class="header" href="#otros-slices">Otros Slices</a></h3>
<p>String slices, como puedes imaginar, son específicas de los <em>strings</em>. Pero también hay un tipo de <em>slice</em> más general. Considera este array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Del mismo modo que podríamos querer referirnos a una parte de un <em>string</em>, es posible que deseemos referirnos a parte de un array. Lo haríamos así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Este <em>slice</em> tiene el tipo <code>&amp;[i32]</code>. Funciona de la misma manera que los <em>string slices</em>,
almacenando una referencia al primer elemento y una longitud. Utilizará este tipo de <em>slices</em> para todo tipo de otras colecciones. Discutiremos sobre estas colecciones en detalle cuando hablemos de vectores en el Capítulo 8.</p>
<h2 id="resumen-3"><a class="header" href="#resumen-3">Resumen</a></h2>
<p>Los conceptos de <em>ownership</em> (propiedad), <em>borrowing</em> (préstamo) y <em>slices</em> (segmentos) garantizan la seguridad de la memoria en los programas de Rust en tiempo de compilación. El lenguaje Rust le permite controlar el uso de la memoria de la misma manera que otros lenguajes de programación de sistemas, pero hacer que el propietario de los datos limpie automáticamente esos datos cuando el propietario se sale del <em>scope</em> (alcance) significa que no tiene que escribir y depurar código adicional para obtener este control.</p>
<p>La propiedad afecta el funcionamiento de muchas otras partes de Rust, por lo que hablaremos
más de estos conceptos a lo largo del resto del libro. Pasemos al Capítulo 5 y veamos cómo
agrupar piezas de datos en un <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usar-structs-para-estructurar-datos-relacionados"><a class="header" href="#usar-structs-para-estructurar-datos-relacionados">Usar <em>Structs</em> para Estructurar Datos Relacionados</a></h1>
<p>Un <em>struct</em> (<em>estructura</em>), es un tipo de dato personalizado que le permite empaquetar juntos y nombrar varios valores relacionados que forman un grupo significativo. Si está familiarizado con un lenguaje orientado a objetos, un <em>struct</em> es como <em>los atributos de los datos de un objeto</em>. En este capítulo, compararemos y contrastaremos <em>tuples</em> con <em>structs</em> para desarrollar lo que ya sabe y demostrar cuándo los <em>structs</em> son una mejor manera de agrupar datos.</p>
<p>Demostraremos cómo definir e instanciar <em>structs</em>. Discutiremos cómo definir funciones asociadas, especialmente el tipo de funciones asociadas llamadas <em>métodos</em>, para especificar el comportamiento asociado con un tipo <em>struct</em>. Los <em>structs</em> y los <em>enums</em> (discutidos en el Capítulo 6) son los componentes básicos para crear nuevos tipos en el dominio de su programa y aprovechar al máximo la verificación de tipos en tiempo de compilación de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definir-e-instanciar-structs"><a class="header" href="#definir-e-instanciar-structs">Definir e Instanciar <em>Structs</em></a></h2>
<p>Los <em>structs</em> son similares a las tuplas, discutidas en la sección <a href="ch03-02-data-types.html#el-tipo-tupla-tuple">&quot;El Tipo Tupla&quot;</a>, en el sentido de que ambos contienen múltiples valores relacionados. Al igual que las tuplas, las piezas de un <em>struct</em> pueden ser de diferentes tipos. A diferencia de las tuplas, en un <em>struct</em> nombrará cada dato para que quede claro lo que significan los valores. Agregar estos nombres significa que los <em>structs</em> son más flexibles que las tuplas: no tiene que confiar en el orden de los datos para especificar o acceder a los valores de una instancia.</p>
<p>Para definir un <em>struct</em>, ingresamos la palabra clave <code>struct</code> y nombramos el
<em>struct</em> completo. El nombre de un <em>struct</em> debe describir el significado de
las piezas de datos que se agrupan. Luego, dentro de las llaves, definimos los nombres
y tipos de los datos, que llamamos <em>campos</em>. Por ejemplo, el Listado 5-1 muestra
un <em>struct</em> que almacena información sobre una cuenta de usuario.</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 5-1: Definición del <em>struct</em> <code>User</code></span></p>
<p>Para usar un <em>struct</em> después de haberlo definido, creamos una <em>instancia</em> de ese <em>struct</em> especificando valores concretos para cada uno de los campos. Creamos una instancia indicando el nombre del <em>struct</em> y luego agregamos llaves que contienen pares <em>(clave: valor)</em> <code>key: value</code>, donde las claves son los nombres de los campos y los valores son los datos que queremos almacenar en esos campos. No tenemos que especificar los campos en el mismo orden en que los declaramos en el <em>struct</em>. En otras palabras, la definición de un <em>struct</em> es como una plantilla general para el tipo, y las instancias completan esa plantilla con datos particulares para crear valores de ese tipo. Por ejemplo, podemos declarar un usuario particular como se muestra en el Listado 5-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-2: Creando una instancia del <em>struct</em> <code>User</code></span></p>
<p>Para obtener un valor específico de un <em>struct</em>, usamos la notación de punto. Por ejemplo, para acceder a la dirección de correo electrónico de este usuario, usamos <code>user1.email</code>. Si la instancia es mutable, podemos cambiar un valor usando la notación de punto y la asignación en un campo particular. El listado 5-3 muestra cómo cambiar el valor en el campo <code>email</code> de una instancia <code>User</code> mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 5-3: Cambiar el valor en el campo <code>email</code> de una instancia <code>User</code></span></p>
<p>Tenga en cuenta que toda la instancia debe ser mutable; Rust no nos permite marcar solo ciertos campos como mutables. Al igual que con cualquier expresión, podemos construir una nueva instancia del <em>struct</em> como la última expresión en el cuerpo de la función para devolver implícitamente esa nueva instancia.</p>
<p>El listado 5-4 muestra una función <code>build_user</code> que devuelve una instancia <code>User</code> con el correo electrónico y el nombre de usuario dados. El campo <code>active</code> obtiene el valor de <code>true</code>, y <code>sign_in_count</code> obtiene un valor de <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-4: Una función <code>build_user</code> que toma un correo electrónico y un nombre de usuario y devuelve una instancia <code>User</code></span></p>
<p>Tiene sentido nombrar los parámetros de la función con el mismo nombre que los campos del <em>struct</em>, pero tener que repetir los nombres y variables de campo <code>email</code> y<code> username</code> es un poco tedioso. Si el <em>struct</em> tuviera más campos, repetir cada nombre sería aún más molesto. Afortunadamente, ¡hay una abreviatura conveniente!</p>
<h3 id="uso-de-field-init-shorthand"><a class="header" href="#uso-de-field-init-shorthand">Uso de <em>Field Init Shorthand</em></a></h3>
<p>Debido a que los nombres de los parámetros y los nombres de los campos del <em>struct</em> son
exactamente los mismos en el Listado 5-4, podemos usar la sintaxis <em>field init shorthand</em> (<em>abreviación de inicio de campo</em>) para reescribir <code>build_user</code> y así se comporte exactamente igual pero no tenga la repetición <code>email</code> y <code>username</code>, como se muestra en el Listado 5-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-5: Una función <code>build_user</code> que usa <em>field init shorthand</em> porque los parámetros<code> email</code> y <code>username</code> tienen el mismo nombre que los campos struct</span></p>
<p>Aquí, estamos creando una nueva instancia del <em>struct</em> <code>User</code>, que tiene un campo llamado <code>email</code>. Queremos establecer el valor del campo <code>email</code> al valor en el parámetro <code>email</code> de la función <code>build_user</code>. Debido a que el campo <code>email</code> y el parámetro <code>email</code> tienen el mismo nombre, solo necesitamos escribir <code>email</code> en lugar de <code>email: email</code>.</p>
<h3 id="crear-instancias-desde-otras-instancias-con-la-sintaxis-de-actualización-de-struct"><a class="header" href="#crear-instancias-desde-otras-instancias-con-la-sintaxis-de-actualización-de-struct">Crear Instancias desde Otras Instancias con la Sintaxis de Actualización de Struct</a></h3>
<p>A menudo es útil crear una nueva instancia de un <em>struct</em> que utiliza la mayoría de los valores de una instancia anterior, pero cambia algunos. Pude hacer esto usando <em>struct update syntax</em> (sintaxis de actualización de struct).</p>
<p>Primero, en el Listado 5-6 mostramos cómo crear una nueva instancia <code>User</code> en <code>user2</code>
normalmente, sin la sintaxis de actualización. Establecemos un nuevo valor para <code>email</code> pero para los demás campos usamos los mismos valores de <code>user1</code> que creamos en el Listado 5-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre></pre>
<p><span class="caption">Listing 5-6: Creando una nueva instancia de <code>User</code> usando valores de <code>user1</code></span></p>
<p>Usando <em>struct update syntax</em>, podemos lograr el mismo efecto con menos código, como se muestra en el listado 5-7. La sintaxis <code>..</code> especifica que los campos restantes no establecidos explícitamente deben tener el mismo valor que los campos en la instancia dada.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}
</code></pre></pre>
<p><span class="caption">Listing 5-7: Usar <em>struct update syntax</em> para establecer el nuevo
valor de <code>email</code> para una instancia <code>User</code>, pero usar el resto de los valores de los campos de la instancia desde la variable <code>user1</code></span></p>
<p>El código del Listado 5-7 también crea una instancia en <code>user2</code> que tiene un valor diferente para <code>email</code>, pero tiene los mismos valores para los campos <code>username</code>, <code>active</code> y <code>sign_in_count</code> de <code>user1</code>. La línea <code>..user1</code> debe ser la última para especificar que los campos restantes deben obtener sus valores de los campos correspondientes en <code>user1</code>, pero podemos optar por especificar valores para tantos campos como queramos en cualquier orden, independientemente del orden de los campos en la definición de la estructura.</p>
<p>Tenga en cuenta que <em>struct update syntax</em> usa <code>=</code> como una asignación; esto se debe a que mueve los datos, tal como vimos en la sección <a href="ch04-01-what-is-ownership.html#formas-en-que-interact%C3%BAan-las-variables-y-los-datos-mover">“Formas en que Interactúan las Variables y los Datos: mover”</a>. En este ejemplo, ya no podemos usar <code>user1</code> después de crear <code>user2</code> porque el <code>String</code> en el campo <code>username</code> de <code>user1</code> se movió a <code>user2</code>. Si le hubiéramos dado a <code>user2</code> nuevos valores <code>String</code> para <code>email</code> y <code>username</code> y, por lo tanto, solo usáramos los valores <code>active</code> y <code>sign_in_count</code> de <code>user1</code>, entonces <code>user1</code> seguiría siendo válido después de crear <code>user2</code>. Los tipos de <code>active</code> y <code>sign_in_count</code> son tipos que implementan el <em>trait</em> Copiar, por lo que se aplicaría el comportamiento que discutimos en la sección <a href="ch04-01-what-is-ownership.html#datos-de-s%C3%B3lo-pila-copiar">&quot;Datos de Sólo-Pila: Copiar&quot;</a>.</p>
<h3 id="usar-tuple-structs-sin-campos-nombrados-para-crear-diferentes-tipos"><a class="header" href="#usar-tuple-structs-sin-campos-nombrados-para-crear-diferentes-tipos">Usar <em>Tuple Structs</em> sin Campos Nombrados para Crear Diferentes Tipos</a></h3>
<p>Rust también admite estructuras que se parecen a las tuplas, llamadas <em>tuple structs</em> (<em>estructuras de tupla</em>). Las <em>tuple structs</em> tienen el significado adicional que proporciona el nombre del <em>struct</em>, pero no tienen nombres asociados con sus campos; más bien, solo tienen los tipos de los campos. Las <em>tuple structs</em> son útiles cuando se quiere dar un nombre a la tupla completa y hacer que la tupla sea un tipo diferente de otras tuplas, y cuando nombrar cada campo como en un <em>struct</em> regular sería detallado o redundante.</p>
<p>Para definir una <em>tuple struct</em>, comience con la palabra clave <code>struct</code> y el nombre del <em>struct</em> seguido de los tipos en la tupla. Por ejemplo, aquí hay definiciones y usos de dos <em>tuple structs</em> denominadas <code>Color</code> y <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<p>Tenga en cuenta que los valores <code>black</code> y <code>origin</code> son de tipos diferentes, porque son instancias de diferentes <em>tuple structs</em>. Cada <em>struct</em> que define es de su propio tipo, aunque los campos dentro del <em>struct</em> tienen los mismos tipos. Por ejemplo, una función que toma un parámetro de tipo <code>Color</code> no puede tomar un <code>Point</code> como argumento, aunque ambos tipos están compuestos por tres valores <code>i32</code>. Por otro lado, las instancias de <em>tuple struct</em> son similares a las tuplas en el sentido de que puede desestructurarlas en sus piezas individuales, y puede usar un <code>.</code> seguido del índice para acceder a un valor individual.</p>
<h3 id="unit-like-structs-structs-sin-ningún-campo"><a class="header" href="#unit-like-structs-structs-sin-ningún-campo"><em>Unit-Like Structs</em>. Structs sin Ningún Campo</a></h3>
<p>¡También puede definir <em>structs</em> que no tienen ningún campo! Estos se denominan <em>unit-like structs</em> (<em>estructuras similares a unidades</em>) porque se comportan de manera similar a (), el tipo <em>unit</em> (<em>unidad</em>) que mencionamos al final de la sección <a href="ch03-02-data-types.html#el-tipo-tupla-tuple">&quot;El Tipo Tupla&quot;</a>. Los <em>unit-like structs</em> pueden ser útiles cuando necesita implementar un <em>trait</em> en algún tipo pero no tiene ningún dato que desee almacenar en el tipo en sí. Hablaremos de los <em>traits</em><sup class="footnote-reference"><a href="#1">1</a></sup> en el Capítulo 10. Aquí hay un ejemplo de cómo declarar e instanciar un <em>unit struct</em> <em>(estructura unidad)</em> llamado <code>AlwaysEqual</code>:</p>
<pre><code class="language-rust ignore">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre>
<p>Para definir <code>AlwaysEqual</code>, usamos la palabra clave <code>struct</code>, el nombre que queremos, luego un punto y coma. ¡No hay necesidad de corchetes o paréntesis! Entonces podemos obtener una instancia de <code>AlwaysEqual</code> en la variable <code>subject</code> de una manera similar: usando el nombre que definimos, sin corchetes ni paréntesis. Imagine que más adelante implementaremos un comportamiento para este tipo, de modo que cada instancia de <code>AlwaysEqual</code> siempre sea igual a cada instancia de cualquier otro tipo, tal vez para tener un resultado conocido con fines de prueba. ¡No necesitaríamos ningún dato para implementar ese comportamiento! Verá en el Capítulo 10 cómo definir <em>traits</em> e implementarlos en cualquier tipo, incluidas las <em>unit-like structs</em>.</p>
<blockquote>
<h3 id="propiedad-de-los-datos-de-un-struct"><a class="header" href="#propiedad-de-los-datos-de-un-struct">Propiedad de los Datos de un Struct</a></h3>
<p>En la definición del <em>struct</em> <code>User</code> en el listado 5-1, utilizamos el tipo
<code>String</code> para la propiedad en lugar del tipo <em>string slice</em> <code>&amp;str</code>. Esta es
una elección deliberada porque queremos que cada instancia de este
<em>struct</em> sea propietaria de todos sus datos y que los datos sean
válidos mientras el <em>struct</em> completo sea válido.</p>
<p>Es posible que los <em>structs</em> almacenen referencias a datos que son propiedad
de otra cosa, pero para hacerlo se requiere el uso de <em>lifetimes</em>, una
característica de Rust que discutiremos en el Capítulo 10. Lifetimes
garantiza que los datos a los que hace referencia un <em>struct</em> son
válidos mientras el <em>struct</em> lo sea. Digamos que intenta almacenar
una referencia en un <em>struct</em> sin especificar <em>lifetimes</em>, como esta, que
no funcionará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>El compilador se quejará de que necesita especificadores <em>lifetime</em>:</p>
<pre><code class="language-text">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>En el Capítulo 10, discutiremos cómo solucionar estos errores para que pueda
almacenar referencias en <em>structs</em>, pero por ahora, corregiremos errores como
estos utilizando tipos propios como <code>String</code> en lugar de referencias como <code>&amp;str</code>.</p>
</blockquote>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> <small>Nota del traductor: por el momento, puede asemejar los <em>traits</em> a lo que son las <em>intefaces</em> en otros lenguajes, aunque luego se verán las diferencias.</small></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="un-programa-de-ejemplo-usando-structs"><a class="header" href="#un-programa-de-ejemplo-usando-structs">Un Programa de Ejemplo usando Structs</a></h2>
<p>Para entender cuándo podríamos querer usar <em>structs</em>, escribamos un programa que calcule el área de un rectángulo. Comenzaremos usando variables individuales y luego refactorizaremos el programa hasta que usemos <em>structs</em> en su lugar.</p>
<p>Hagamos un nuevo proyecto binario con Cargo llamado <em>rectangles</em>  que tomará el ancho y la altura de un rectángulo especificado en píxeles y calculará el área del rectángulo. El listado 5-8 muestra un programa corto con una forma de hacer exactamente eso en <em>src/main.rs</em> de nuestro proyecto.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    // [píxeles cuadrados] es una unidad de área como lo es, por ejemplo, [metros cuadrados]
    println!(
        &quot;El área del rectángulo es {} [píxeles cuadrados].&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Listing 5-8: Cálculo del área de un rectángulo especificado por variables de ancho y altura separadas</span></p>
<p>Ahora, ejecute este programa usando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
El área del rectángulo es 1500 [píxeles cuadrados].
</code></pre>
<p>Este código logra calcular el área del rectángulo llamando a la función <code>area</code> con cada dimensión, pero podemos hacer más para que este código sea claro y legible.</p>
<p>El problema con este código es evidente en la firma de <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;El área del rectángulo es {} [píxeles cuadrados].&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre>
<p>Se supone que la función <code>area</code> calcula el área de un rectángulo, pero la función que escribimos tiene dos parámetros, y no está claro en ninguna parte de nuestro programa que los parámetros estén relacionados. Sería más legible y manejable agrupar el ancho y el alto juntos. Ya hemos discutido una forma en que podríamos hacer eso en la sección <a href="ch03-02-data-types.html#el-tipo-tupla-tuple">&quot;El Tipo Tupla&quot;</a> del Capítulo 3: mediante el uso de tuplas.</p>
<h3 id="refactorización-con-tuplas"><a class="header" href="#refactorización-con-tuplas">Refactorización con Tuplas</a></h3>
<p>Listing 5-9  muestra otra versión de nuestro programa que usa tuplas.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;El área del rectángulo es {} [píxeles cuadrados].&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Listing 5-9: Especificando el ancho y alto del rectángulo con una tupla</span></p>
<p>En cierto modo, este programa es mejor. Las tuplas nos permiten agregar un poco de estructura y ahora estamos pasando solo un argumento. Pero en otro sentido, esta versión es menos clara: las tuplas no nombran sus elementos, por lo que tenemos que indexar las partes de la tupla, lo que hace que nuestro cálculo sea menos obvio.</p>
<p>Mezclar el ancho y la altura no importaría para el cálculo del área, pero si queremos dibujar el rectángulo en la pantalla, ¡sería importante! Tendríamos que tener en cuenta que el <em>ancho</em> es el índice <code>0</code> y la <em>altura</em> es el índice <code>1</code> de la tupla. Esto sería aún más difícil de entender y de tener en cuenta para otra persona si tuviera que usar nuestro código. Debido a que no hemos transmitido el significado de nuestros datos en nuestro código, ahora es más fácil introducir errores.</p>
<h3 id="refactorización-con-structs-agregando-más-significado"><a class="header" href="#refactorización-con-structs-agregando-más-significado">Refactorización con Structs: Agregando más Significado</a></h3>
<p>Usamos <em>structs</em> para agregar significado al etiquetar los datos. Podemos transformar la tupla que estamos usando en un <em>struct</em> con un nombre para el todo y nombres para las partes, como se muestra en el Listado 5-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { 
        width: 30,
        height: 50,
    };

    println!(
        &quot;El área del rectángulo es {} [píxeles cuadrados].&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Listing 5-10: Definiendo un struct <code>Rectangle</code></span></p>
<p>Aquí hemos definido una estructura y la hemos llamado <code>Rectangle</code>. Dentro de las llaves, definimos los campos como <code>width</code> y <code>height</code> (ancho y altura), ambos tienen el tipo <code>u32</code>. Luego, en <code>main</code>, creamos una instancia particular de <code>Rectangle</code> que tiene un ancho de 30 y una altura de 50.</p>
<p>Nuestra función <code>area</code> ahora se define con un parámetro, que hemos llamado <code>rectangle</code>, cuyo tipo es un préstamo inmutable de una instancia <em>struct</em> <code>Rectangle</code>. Como se mencionó en el Capítulo 4, queremos tomar prestado el <em>struct</em> en lugar de tomar posesión de él. De esta manera, <code>main</code> conserva su propiedad<sup class="footnote-reference"><a href="#1">1</a></sup> y puede continuar usando <code>rect1</code>, que es la razón por la que usamos <code>&amp;</code> en la firma de la función y donde llamamos a la función.</p>
<p>La función de <code>area</code> accede a los campos <code>width</code> y <code>height</code> de la instancia <code>Rectangle</code> (tenga en cuenta que acceder a los campos de una instancia <em>struct</em> prestada no mueve los valores de los campos, razón por la cual a menudo ve préstamos de <em>structs</em>). Nuestra firma de función para <code>area</code> ahora dice exactamente lo que queremos decir: calcule el área de <code>Rectangle</code>, usando sus campos <code>width</code> y <code>height</code>. Esto transmite que el ancho y el alto están relacionados entre sí, y da nombres descriptivos a los valores en lugar de usar los valores de índice de tupla de <code>0</code> y <code>1</code>. Esta es una victoria para la claridad.</p>
<h3 id="añadiendo-funcionalidad-Útil-con-traits-derivados"><a class="header" href="#añadiendo-funcionalidad-Útil-con-traits-derivados">Añadiendo Funcionalidad Útil con <em>Traits</em> Derivados</a></h3>
<p>Sería útil poder imprimir una instancia de <code>Rectangle</code> mientras depuramos nuestro programa y ver los valores para todos sus campos. El listado 5-11 intenta usar la macro <code>println!</code> como hemos hecho en capítulos anteriores. Sin embargo, esto no funcionará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Listing 5-11: Intentando imprimir una instancia de <code>Rectangle</code></span></p>
<p>Cuando ejecutamos este código, obtenemos un error con este mensaje central:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>La macro <code>println!</code> Puede hacer muchos tipos de formateo, y de forma predeterminada, las llaves indican a <code>println!</code> que use el formato conocido como <code>Display</code>: salida destinada para el consumo directo del usuario final. Los tipos primitivos que hemos visto hasta ahora implementan <code>Display</code> de forma predeterminada, ya que solo hay una forma en la que querría mostrar un <code>1</code> o cualquier otro tipo primitivo a un usuario. Pero con structs, la forma en que <code>println!</code> debería formatear la salida es menos clara porque hay más posibilidades de visualización: ¿Quiere comas o no? ¿Quiere imprimir las llaves? ¿Deberían mostrarse todos los campos? Debido a esta ambigüedad, Rust no intenta adivinar lo que queremos, y los <em>structs</em> no tienen una implementación provista por <code>Display</code> para usar con <code>println!</code> y el marcador <code>{}</code>.</p>
<p>Si continuamos leyendo los errores, encontraremos esta nota útil:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>¡Vamos a intentarlo! La llamada a la macro <code>println!</code> se verá como <code>println (&quot;rect1 es {:?} &quot;, rect1);</code>. Poner el especificador <code>:?</code> dentro de las llaves le dice a <code>println!</code> que queremos usar un formato de salida llamado <code>Debug</code>. El <em>trait</em> <code>Debug</code> nos permite imprimir nuestro estructuro <em>struct</em> de una manera que es útil para los desarrolladores, para que podamos ver su
valor mientras depuramos nuestro código.</p>
<p>Ejecuta el código con este cambio. ¡Arrg! Todavía recibimos un error:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Pero, de nuevo, el compilador nos da una nota útil:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>no</em> incluye funcionalidad para imprimir información de depuración,
pero tenemos que optar explícitamente para que esa funcionalidad esté disponible
para nuestro <em>struct</em>. Para hacer eso, agregamos el atributo <code>#[derive(Debug)]</code>
justo antes de la definición del <em>struct</em>, como se muestra en el Listado 5-12.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Listing 5-12: Añadiendo el atributo para derivar el <em>trait</em> <code>Debug</code>
e imprimir la instancia <code>Rectangle</code> utilizando el formato de depuración</span></p>
<p>Ahora cuando ejecutamos el programa, no obtendremos ningún error, y veremos el siguiente resultado:</p>
<pre><code class="language-text">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>¡Bien!, no es el resultado más bonito, pero muestra los valores de todos los
campos para esta instancia, lo que definitivamente ayudaría durante la depuración.
Cuando tenemos estructuras más grandes, es útil tener una salida que sea un poco
más fácil de leer; en esos casos, podemos usar <code>{:#?}</code> en lugar de <code>{:?}</code> en el
<em>string</em> <code>println!</code>. Cuando usamos el estilo <code>{:#?}</code> En el ejemplo, la salida se verá así:</p>
<pre><code class="language-text">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Otra forma de imprimir un valor usando el formato <code>Debug</code> es usar la <a href="https://doc.rust-lang.org/std/macro.dbg.html">macro dbg!</a>, que se apropia de una expresión (a diferencia de println! que toma una referencia), imprime el archivo y el número de línea donde se esa llamada a la macro <code>dbg!</code> se produce en su código, junto con la expresión, el valor resultante de esa expresión y retorna la propiedad del valor.</p>
<blockquote>
<p>Nota: Llamar a la macro <code>dbg!</code> imprime en el flujo de la consola de <em>errores estándar</em> (<code>stderr</code>), a diferencia de <code>println!</code> que imprime en el flujo de consola de <em>salida estándar</em> (<code>stdout</code>). Hablaremos más sobre <code>stderr</code> y <code>stdout</code> en la sección <a href="ch12-06-writing-to-stderr-instead-of-stdout.html#escribiendo-mensajes-de-error-en-standard-error-en-lugar-de-standard-output">&quot;Escribiendo Mensajes de Error en &quot;Standard Error&quot; en lugar de &quot;Standard Output&quot; en el Capítulo 12</a>.</p>
</blockquote>
<p>Aquí hay un ejemplo en el que estamos interesados en el valor que se asigna al campo <code>width</code>, así como el valor de todo el <em>struct</em> en <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></pre>
<p>Podemos poner <code>dbg!</code> encerrando la expresión <code>30 * scale</code> y, porque <code>dbg!</code> devuelve la propiedad del valor de la expresión, el campo <code>width</code> obtendrá el mismo valor que si no tuviéramos la llamada a <code>dbg!</code> allí. En la siguiente llamada, no queremos <code>dbg!</code> tome la posesión de <code>rect1</code>, por lo que usamos una referencia a <code>rect1</code>. Así es como se ve el resultado de este ejemplo:</p>
<pre><code class="language-text">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Podemos ver que la primera parte de la salida proviene de la línea 10 de <em>src/main.rs</em>, donde estamos depurando la expresión <code>30 * scale</code>, y su valor resultante es 60 (el formato <code>Debug</code> implementado para enteros es imprimir solo su valor). La llamada a <code>dbg!</code> en la línea 14 de <em>src/main.rs</em> genera el valor de <code>&amp;rect1</code>, que es el <em>struct</em> <code>Rectangle</code>. Esta salida utiliza el bonito formato <code>Debug</code> del tipo <code>Rectangle</code> ¡La macro <code>dbg!</code> puede ser realmente útil cuando intenta averiguar qué está haciendo su código!</p>
<p>Además del <em>trait</em> <code>Debug</code>, Rust ha proporcionado una serie de <em>traits</em> para que los usemos con el atributo <code>derive</code>, que puede agregar un comportamiento útil a nuestros tipos personalizados. Esos <em>traits</em> y sus comportamientos están listados en el <a href="appendix-03-derivable-traits.html">Apéndice C</a>. Cubriremos cómo implementar estos <em>traits</em> con comportamiento personalizado y cómo crear sus propios <em>traits</em> en el Capítulo 10. También hay muchos atributos además de <code>derive</code>. Para obtener más información, consulte la <a href="https://doc.rust-lang.org/reference/attributes.html#attributes">sección &quot;Atributos&quot; de la Referencia de Rust</a>.</p>
<p>Nuestra función <code>area</code> es muy específica: solo calcula el área de los rectángulos. Sería útil relacionar este comportamiento más estrechamente con nuestro <em>struct</em> <code>Rectangle</code>, porque no funcionará con ningún otro tipo. Veamos cómo podemos continuar refactorizando este código convirtiendo la función <code>area</code> en un <em>método</em> <code>area</code> definido en nuestro tipo <code>Rectangle</code>.</p>
<p></br></br></br></br></p>
<p><small><sup class="footnote-reference"><a href="#1">1</a></sup> Nota del traductor: se tradujo el texto conservando su sentido en forma literal. El texto <em>(en inglés)</em> infiere que la propiedad del contenido de <code>rect1</code> también es propiedad de la función <code>main</code>. Difiero en este concepto. La función <code>main</code> provee un <em>scope</em> (ámbito) donde <code>rect1</code> es propietaria del contenido, pero la función <code>main</code> no es propietaria del contenido en sí. Cuando se transfiere la propiedad a través de los parámetros de una función, no es la función la que recibe la propiedad, sino que ésta provee un <em>scope</em> donde son los parámetros los que adquieren la propiedad.</small></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sintaxis-del-método-method-syntax"><a class="header" href="#sintaxis-del-método-method-syntax">Sintaxis del Método <em>Method Syntax</em></a></h2>
<p>Los <em>métodos</em> son similares a las funciones: los declaramos con la palabra clave <code>fn</code> y un nombre, pueden tener parámetros y un valor de retorno, y contienen algún código que se ejecuta cuando el método es llamado desde otro lugar. A diferencia de las finciones, los métodos se definen dentro del contexto de un <em>struct</em> (o en un <em>enum</em> o un objeto <em>trait</em>, que cubrimos en los Capítulos 6 y 17, respectivamente), y su primer parámetro es siempre <code>self</code>, que representa la instancia del <em>struct</em> de la cual el método es llamado.</p>
<h3 id="definición-de-métodos"><a class="header" href="#definición-de-métodos">Definición de Métodos</a></h3>
<p>Cambiemos la función <code>area</code> que tiene una instancia <code>Rectangle</code> como parámetro y, en su lugar, hagamos que un método <code>area</code> se defina en el <em>struct</em> <code>Rectangle</code>, como se muestra en el Listado 5-13.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;El área del rectángulo es {} [píxeles cuadrados].&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Listing 5-13: Definir un método <code>area</code> en el <em>struct</em> <code>Rectangle</code></span></p>
<p>Para definir la función dentro del contexto de <code>Rectangle</code>, comenzamos un bloque <code>impl</code> (implementación) para <code>Rectangle</code>. Todo lo que se encuentre dentro de este bloque <code>impl</code> se asociará con el tipo <code>Rectangle</code>. Luego movemos la función <code>area</code> dentro de las llaves de <code>impl</code> y cambiamos el primer (y en este caso, el único) parámetro para que sea <code>self</code> en la firma y en todas partes dentro del cuerpo. En <code>main</code>, donde llamamos a la función <code>area</code> y pasamos <code>rect1</code> como un argumento, podemos en su lugar usar la <em>sintaxis del método</em> para llamar al método <code>area</code> en nuestra instancia <code>Rectangle</code>. La <em>sintaxis del método</em> va después de una instancia: añadimos un punto, seguido del nombre del método, paréntesis y cualquier argumento.</p>
<p>En la firma de <code>area</code>, usamos <code>&amp;self</code> en lugar de <code>rectangle: &amp;Rectangle</code>. El <code>&amp;self</code> es en realidad la abreviatura de <code>self: &amp;Self</code>. Dentro de un bloque <code>impl</code>, el tipo <code>Self</code> es un <em>alias</em> del tipo al cual se asocia el bloque <code>impl</code>. Los métodos deben tener un parámetro llamado <code>self</code> de tipo <code>Self</code> como su primer parámetro, así que Rust le permite abreviar esto solo con el nombre <code>self</code>. Tenga en cuenta que aún necesitamos usar <code>&amp;</code> delante de la abreviatura <code>self</code> para indicar que este método toma prestada la instancia <code>Self</code>, tal como lo hicimos en <code>rectangle: &amp;Rectangle</code>. Los métodos pueden tomar la propiedad (<em>ownership</em>) de <code>self</code>, tomar prestado <code>self</code> inmutable como lo hemos hecho aquí, o tomar prestado <code>self</code> mutable, tal como pueden hacerlo con cualquier otro parámetro.</p>
<p>Hemos elegido <code>&amp;self</code> aquí por la misma razón que usamos <code>&amp;Rectangle</code> en versión de función: no queremos tener la propiedad, y solo queremos leer los datos en el <em>struct</em>, no escribir en él. Si quisiéramos cambiar la instancia en la que llamamos al método como parte de lo que hace el método, usaríamos <code>&amp;mut self</code> como el primer parámetro. Tener un método que tome posesión de la
instancia usando solo <code>self</code> como el primer parámetro es raro; esta técnica se suele usar
cuando el método transforma <code>self</code> en otra cosa y quiere evitar que quien llama utilice la instancia original después de la transformación.</p>
<p>La principal razón para usar métodos en lugar de funciones, además de proporcionar la <em>sintaxis del método</em> y no tener que repetir el tipo de <code>self</code> en la firma de cada método, es por motivos de organización. Hemos puesto todas las cosas que podemos hacer con una instancia de un tipo en un bloque <code>impl</code>, en lugar de hacer que los futuros usuarios de nuestro código busquen capacidades de <code>Rectangle</code> en varios lugares de la biblioteca que proporcionamos.</p>
<p>Tenga en cuenta que podemos optar por dar a un método el mismo nombre que uno de los campos del <em>struct</em>. Por ejemplo, podemos definir un método en <code>Rectangle</code> también llamado <code>width</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre></pre>
<p>Aquí, elegimos hacer que el método <code>width</code> devuelva <code>true</code> si el valor en el campo <code>width</code> de la instancia es mayor que 0, y <code>false</code> si el valor es 0: podemos usar un campo dentro de un método del mismo nombre para cualquier propósito. En general, cuando seguimos <code>rect1.width</code> de paréntesis, Rust sabe que nos referimos al método <code>width</code>. Cuando no usamos paréntesis, Rust sabe que nos referimos al campo <code>width</code>.</p>
<p>A menudo, pero no siempre, cuando proporcionamos métodos con el mismo nombre que un campo, queremos que solo devuelva el valor en ese campo y no haga nada más. Los métodos como este se denominan <em>getters</em>, y Rust no los implementa automáticamente para los campos de <em>structs</em> como lo hacen otros lenguajes. Los <em>getters</em> son útiles porque se puede hacer que el campo sea privado pero el método sea público y, por lo tanto, permitir el acceso de &quot;solo lectura&quot; a ese campo como parte de la API pública del tipo. Discutiremos qué son &quot;público&quot; y &quot;privado&quot; y cómo designar un campo o método como &quot;público&quot; o &quot;privado&quot; en el capítulo 7.</p>
<blockquote>
<h3 id="dónde-está-el-operador--"><a class="header" href="#dónde-está-el-operador--">¿Dónde está el operador <code>-&gt;</code>?</a></h3>
<p>En C y C++, se utilizan dos operadores diferentes para llamar a los métodos: se utiliza <code>.</code> si está llamando directamente a un método en el objeto y <code>-&gt;</code> si está llamando al método en un puntero al objeto y necesita <em>desreferenciar</em> (eliminar la referencia) el puntero primero. En otras palabras, si <code>object</code> es un puntero, <code>object-&gt;algo()</code> es similar a <code>(*object).algo()</code>.</p>
<p>Rust no tiene un equivalente al operador <code>-&gt;</code>; en cambio, Rust tiene una característica llamada <em>automatic referencing and dereferencing</em> (<em>referenciado y desreferenciado automáticos</em>). La llamada a métodos es uno de los pocos lugares en Rust que tienen este comportamiento.</p>
<p>Así es como funciona: cuando llama a un método con <code>object.algo()</code>, Rust automáticamente agrega <code>&amp;</code>, <code>&amp;mut</code>, o <code>*</code> para que <code>object</code> coincida con la firma del método. En otras palabras, los siguientes son los mismos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>El primero se ve mucho más limpio. Este comportamiento de referencia automática funciona porque los métodos tienen un receptor claro: el tipo de <code>self</code>. Dado el receptor y el nombre de un método, Rust puede determinar definitivamente si el método está leyendo (<code>&amp;self</code>), mutando (<code>&amp;mut self</code>), o consumiendo (<code>self</code>). El hecho de que Rust haga que el préstamo sea implícito para los receptores de métodos es una gran parte de hacer que la propiedad sea ergonómica en la práctica.</p>
</blockquote>
<h3 id="métodos-con-más-parámetros"><a class="header" href="#métodos-con-más-parámetros">Métodos con Más Parámetros</a></h3>
<p>Practiquemos el uso de métodos implementando un segundo método en el <em>struct</em> <code>Rectangle</code>. Esta vez, queremos que una instancia de <code>Rectangle</code> tome otra instancia de <code>Rectangle</code> y devuelva <code>true</code> si el segundo <code>Rectangle</code> puede caber completamente dentro de <code>self</code> (el primer <code>Rectangle</code>); de lo contrario, debería devolver <code>false</code>. Es decir, una vez que hayamos definido el método <code>can_hold</code>, queremos poder escribir el programa que se muestra en el Listado 5-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-14: Usando el método aún no escrito <code>can_hold</code></span></p>
<p>Y la salida esperada se vería como la siguiente, porque ambas dimensiones de <code>rect2</code>
son más pequeñas que las dimensiones de<code> rect1</code> pero <code>rect3</code> es más ancha que<code> rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Sabemos que queremos definir un método, por lo que estará dentro del bloque <code>impl Rectangle</code>.
El nombre del método será <code>can_hold</code>, y tomará un préstamo inmutable de otro <code>Rectangle</code> como parámetro.
Podemos decir cuál será el tipo de parámetro mirando el código que llama al método:
<code>rect1.can_hold(&amp;rect2)</code> le pasa <code>&amp;rect2</code>, que es un préstamo inmutable de <code>rect2</code>,
una instancia de <code>Rectangle</code>. Esto tiene sentido porque solo necesitamos leer <code>rect2</code>
(en lugar de escribir, lo que significaría que necesitaríamos un préstamo mutable),
y queremos que <code>main</code> conserve la propiedad de <code>rect2</code> para poder usarlo
nuevamente después de llamar el método <code>can_hold</code>. El valor de retorno de <code>can_hold</code>
será un Booleano, y la implementación comprobará si el ancho y la altura de <code>self</code>
son mayores que el ancho y la altura del otro <code>Rectangle</code>, respectivamente.
Agreguemos el nuevo método <code>can_hold</code> al bloque <code>impl</code> del Listado 5-13,
que se muestra en el Listado 5-15.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-15: Implementando el método <code>can_hold</code> en <code>Rectangle</code>
que toma otra instancia <code>Rectangle</code> como parámetro</span></p>
<p>Cuando ejecutamos este código con la función <code>main</code> en el listado 5-14,
obtendremos nuestro resultado deseado. Los métodos pueden tomar múltiples
parámetros, que agregamos a la firma después del parámetro <code>self</code>, y esos parámetros
funcionan igual que los parámetros en las funciones.</p>
<h3 id="funciones-asociadas"><a class="header" href="#funciones-asociadas">Funciones Asociadas</a></h3>
<p>Todas las funciones definidas dentro de un bloque <code>impl</code> se denominan <em>funciones asociadas</em> porque están asociadas con el tipo que lleva el nombre de <code>impl</code>. Podemos definir funciones asociadas que no tienen <code>self</code> como su primer parámetro (y por lo tanto no son métodos) porque no necesitan una instancia del tipo para trabajar. Ya hemos usado una función como esta: la función <code>String::from</code> que está definida en el tipo <code>String</code>.</p>
<p>Las funciones asociadas que no son métodos a menudo se usan para constructores que devolverán una nueva instancia del <em>struct</em>. Estas a menudo se nombran <code>new</code>, pero <code>new</code> no es un nombre especial y no está integrado en el lenguaje. Por ejemplo, podríamos optar por proporcionar una función asociada llamada <code>square</code> que tendría un parámetro de dimensión y usarlo tanto como ancho y como altura, lo que facilitaría la creación de un <code>Rectangle</code> cuadrado en lugar de tener que especificar el mismo valor dos veces:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>Las palabras clave <code>Self</code> en el tipo de devolución y en el cuerpo de la función son alias para el tipo que aparece después de la palabra clave <code>impl</code>, que en este caso es <code>Rectangle</code>.</p>
<p>Para llamar a esta función asociada, usamos la sintaxis <code>::</code> con el nombre del <em>struct</em>; <code>let sq = Rectangle::square(3);</code> es un ejemplo. Esta función se nombró en el espacio de nombres (<a href="https://doc.rust-lang.org/reference/names/namespaces.html">namespaced</a>) del <em>struct</em>: la sintaxis <code>::</code> se usa tanto para las funciones asociadas y como para los espacios de nombres creados por los módulos. Discutiremos los módulos en el Capítulo 7.</p>
<h3 id="múltiples-bloques-impl"><a class="header" href="#múltiples-bloques-impl">Múltiples Bloques <code>impl</code></a></h3>
<p>Cada estructura puede tener múltiples bloques <code>impl</code>. Por ejemplo, el Listado 5-15 es equivalente al código que se muestra en el Listado 5-16, que tiene cada método en su propio bloque <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-16: Reescribiendo el Listado 5-15 usando múltiples bloques <code>impl</code></span></p>
<p>No hay ninguna razón para separar estos métodos en múltiples bloques <code>impl</code> aquí, pero esta es una sintaxis válida. Veremos un caso en el que varios bloques <code>impl</code> son útiles en el Capítulo 10, donde discutimos tipos genéricos y <em>traits</em>.</p>
<h2 id="resumen-4"><a class="header" href="#resumen-4">Resumen</a></h2>
<p>Los <em>structs</em> le permiten crear tipos personalizados que son significativos para su dominio. Mediante el uso de <em>structs</em>, puede mantener partes de datos asociadas conectadas entre sí y nombrar cada parte para que su código quede claro. En bloques <code>impl</code>, puede definir funciones que están asociadas con su tipo, y los métodos son un tipo de función asociada que le permite especificar el comportamiento que tienen las instancias de sus <em>structs</em>.</p>
<p>Pero los <em>structs</em> no son la única forma en que puede crear tipos personalizados: pasemos a la característica <em>enum</em> de Rust para agregar otra herramienta a su caja de herramientas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-y-coincidencia-de-patrones"><a class="header" href="#enums-y-coincidencia-de-patrones">Enums y Coincidencia de Patrones</a></h1>
<p>En este capítulo veremos las <em>enumeraciones</em> (<em>enumerations</em>), también conocidas como <em>enums</em>. Los enums le permiten definir un tipo enumerando sus posibles <em>variantes</em>. Primero, definiremos y usaremos un enum para mostrar cómo un enum puede codificar el significado junto con los datos. A continuación, exploraremos un enum particularmente útil, llamado <code>Option</code>, que expresa que un valor puede ser algo o nada. Luego veremos cómo la coincidencia de patrones en la expresión <code>match</code> facilita la ejecución de código diferente para diferentes valores de un enum. Finalmente, cubriremos cómo la construcción <code>if let</code> es otra forma conveniente y concisa disponible para manejar enums en su código.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-un-enum"><a class="header" href="#definiendo-un-enum">Definiendo un <em>Enum</em></a></h2>
<p>Donde los structs le brindan una forma de agrupar campos y datos relacionados, como un <code>Rectangle</code> con su <code>width</code> y <code>height</code>, los enums le brindan una forma de decir que un valor es uno de un posible conjunto de valores. Por ejemplo, podemos querer decir que <code>Rectangle</code> es una de un conjunto de formas posibles que también incluye <code>Circle</code> y <code>Triangle</code>. Para hacer esto, Rust nos permite codificar estas posibilidades como un enum.</p>
<p>Veamos una situación que querríamos expresar en código y veamos por qué los enums son útiles y más apropiados que los structs en este caso. Digamos que necesitamos trabajar con direcciones IP. Actualmente, se utilizan dos estándares principales para las direcciones IP: la versión cuatro y la versión seis. Debido a que estas son las únicas posibilidades para una dirección IP con las que se encontrará nuestro programa, podemos <em>enumerar</em> todas las variantes posibles, que es donde la enumeración (<em>enum</em>) recibe su nombre.</p>
<p>Cualquier dirección IP puede ser una dirección versión cuatro o seis, pero no ambas al mismo tiempo. Esa propiedad de las direcciones IP hace que la estructura de datos enum sea adecuada, porque un valor de enum solo puede ser una de sus variantes. Tanto las direcciones de la versión cuatro como las de la versión seis siguen siendo fundamentalmente direcciones IP, por lo que deben tratarse como del mismo tipo cuando el código maneja situaciones que se aplican a cualquier tipo de dirección IP.</p>
<p>Podemos expresar este concepto en código definiendo un enum <code>IpAddrKind</code> y listando los tipos posibles que una dirección IP puede ser, <code>V4</code> y <code>V6</code>. Estas son las <em>variantes</em> del enum:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> ahora es un tipo de datos personalizado que podemos usar en cualquier parte de nuestro código.</p>
<h3 id="valores-enum"><a class="header" href="#valores-enum">Valores <em>Enum</em></a></h3>
<p>Podemos crear instancias de cada una de las dos variantes de <code>IpAddrKind</code> de esta manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Tenga en cuenta que las variantes del enum son <em>espacios de nombre</em> bajo su identificador, y usamos dos puntos dobles para separar los dos. Esto es útil porque ahora ambos valores <code>IpAddrKind::V4</code> y <code>IpAddrKind::V6</code> son del mismo tipo: <code>IpAddrKind</code>. Entonces podemos, por ejemplo, definir una función que tome cualquier <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Y podemos llamar a esta función con cualquiera de las variantes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>El uso de enums tiene aún más ventajas. Pensando más en nuestro tipo de dirección IP, en este momento no tenemos una forma de almacenar <em>los datos</em> reales de la dirección IP; sólo sabemos de qué clase es. Dado que acaba de aprender acerca de structs en el Capítulo 5, es posible que tenga la tentación de abordar este problema con structs como se muestra en el Listado 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-1: Almacenar los datos y la variante <code>IpAddrKind</code> de una dirección IP usando un <code>struct</code></span></p>
<p>Aquí, hemos definido un struct <code>IpAddr</code> que tiene dos campos: un campo <code>kind</code> que es de tipo <code>IpAddrKind</code> (el enum que definimos previamente) y un campo <code>address</code> de tipo <code>String</code>. Tenemos dos instancias de este struct. El primero, <code>home</code>, tiene el valor <code>IpAddrKind::V4</code> como su valor <code>kind</code> con los datos de dirección asociados de <code>127.0.0.1</code>. La segunda instancia es <code>loopback</code>. Esta tiene la otra variante de <code>IpAddrKind</code> como su valor <code>kind</code>,<code>V6</code>, y tiene la dirección <code>::1</code> asociada a ella. Hemos utilizado un struct para agrupar los valores <code>kind</code> y <code>address</code> juntos,por lo que ahora la variante está asociada con el valor.</p>
<p>Sin embargo, representar el mismo concepto usando solo un enum es más conciso: en lugar de un enum dentro de un struct, podemos colocar los datos directamente en cada variante del <em>enum</em>. Esta nueva definición del enum <code>IpAddr</code> dice que las variantes<code> V4</code> y <code>V6</code> tendrán valores<code> String</code> asociados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Adjuntamos datos a cada variante del enum directamente, por lo que no hay necesidad de un struct adicional. Aquí también es más fácil ver otro detalle de cómo funcionan los enums: el nombre de cada variante del enum que definimos también se convierte en una función que construye una instancia del enum. Es decir, <code>IpAddr::V4()</code> es una llamada de función que toma un argumento <code>String</code> y devuelve una instancia del tipo <code>IpAddr</code>. Obtenemos automáticamente esta función constructora definida como un resultado de definir el enum.</p>
<p>Hay otra ventaja de usar un enum en lugar de un struct: cada variante puede tener diferentes tipos y cantidades de datos asociados. Las direcciones IP de tipo versión cuatro siempre tendrán cuatro componentes numéricos que tendrán valores entre 0 y 255. Si quisiéramos almacenar direcciones <code>V4</code> como cuatro valores <code>u8</code> pero aún expresar direcciones <code>V6</code> como un valor <code>String</code>, no podríamos con un struct. Los enums manejan este caso con facilidad:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Hemos mostrado varias formas diferentes de definir estructuras de datos para almacenar la versión cuatro y la versión seis de las direcciones IP. Sin embargo, resulta que querer almacenar direcciones IP y codificar de qué clase son es tan común que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la biblioteca estándar tiene una definición que podemos usar!</a> <!-- ignore --> Veamos cómo la biblioteca estándar define <code>IpAddr</code>: tiene el enum exacto y las variantes que hemos definido y utilizado, pero incorpora los datos de dirección dentro de las variantes en forma de dos structs diferentes,
que se definen de manera diferente para cada variante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código ilustra que puede poner cualquier tipo de datos dentro de una variante <em>enum</em>: strings, tipos numéricos o structs, por ejemplo. ¡Incluso puede incluir otro enum! Además, los tipos de la biblioteca estándar a menudo no son mucho más complicados de lo que se le podría ocurrir.</p>
<p>Tenga en cuenta que, aunque la biblioteca estándar contiene una definición para <code>IpAddr</code>,
aún podemos crear y usar nuestra propia definición sin conflicto porque no hemos incorporado
la definición de la biblioteca estándar a nuestro scope. Hablaremos más sobre incluir tipos en el scope en el Capítulo 7.</p>
<p>Veamos otro ejemplo de un enum en el Listado 6-2: este tiene una amplia variedad de tipos incrustados en sus variantes.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-2: El <em>enum</em> <code>Message</code> cuyas variantes almacenan diferentes cantidades y tipos de valores</span></p>
<p>Este enum tiene cuatro variantes con diferentes tipos:</p>
<ul>
<li><code>Quit</code> no tiene datos asociados a ella en absoluto.</li>
<li><code>Move</code> tiene campos con nombre como lo hace un struct.</li>
<li><code>Write</code> incluye solo un <code>String</code>.</li>
<li><code>ChangeColor</code> incluye tres valores <code>i32</code>.</li>
</ul>
<p>Definir un enum con variantes como las del Listado 6-2 es similar a
definir diferentes tipos de definiciones de struct, excepto que <em>enum</em> no usa
la palabra clave <code>struct</code> y todas las variantes se agrupan bajo el tipo <code>Mensaje</code>. Los
siguientes structs podrían contener los mismos datos que contienen las variantes
<em>enum</em> anteriores:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Pero si usáramos los diferentes structs, cada uno de los cuales tiene su propio tipo, no podríamos definir tan fácilmente una función para tomar cualquiera de estas clases de mensajes como lo haríamos con el enum <code>Message</code> definido en el Listado 6-2, que es un solo tipo.</p>
<p>Hay una similitud más entre enums y structs: del mismo modo que podemos definir métodos en los structs usando <code>impl</code>, también podemos definir métodos en los enums. Aquí hay un método llamado <code>call</code> que podríamos definir en nuestro enum <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    Write(String),
</span><span class="boring">    ChangeColor(i32, i32, i32),
</span><span class="boring">}
</span><span class="boring">
</span>impl Message {
    fn call(&amp;self) {
        // el cuerpo del método se definiría aquí
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
<span class="boring">}
</span></code></pre></pre>
<p>El cuerpo del método usaría <code>self</code> para obtener el valor que llamamos en el método. En este ejemplo, hemos creado una variable <code>m</code> que tiene el valor <code>Message::Write(String::from(&quot;hello&quot;))</code>, y eso es lo que será <code>self</code> en el cuerpo del método <code>call</code> cuando <code>m.call()</code> se ejecuta.</p>
<p>Veamos otro enum en la biblioteca estándar que es muy común y útil: <code>Option</code>.</p>
<h3 id="el-enum-option-y-sus-ventajas-sobre-valores-nulos"><a class="header" href="#el-enum-option-y-sus-ventajas-sobre-valores-nulos">El <em>Enum</em> <code>Option</code> y sus Ventajas Sobre Valores Nulos</a></h3>
<p>Esta sección explora un caso de estudio de <code>Option</code>, que es otro enum definido por la biblioteca estándar. El tipo <code>Option</code> codifica el escenario muy común en el que un valor podría ser algo o podría no ser nada.</p>
<p>Por ejemplo, si solicita el primero de una lista que contiene elementos, obtendrá un valor. Si solicita el primer elemento de una lista vacía, no obtendría nada. Expresar este concepto en términos del sistema de tipos significa que el compilador puede verificar si ha manejado todos los casos que debería manejar; esta funcionalidad puede prevenir errores que son extremadamente comunes en otros lenguajes de programación.</p>
<p>El diseño del lenguaje de programación a menudo se piensa en términos de las características que incluye, pero las características que excluye también son importantes. Rust no tiene la característica null que tienen muchos otros lenguajes. <em>Null</em> es un valor que significa que no hay ningún valor allí. En lenguajes con null, las variables siempre pueden estar en uno de dos estados: null o not-null.</p>
<p>En su presentación de 2009 “Null References: The Billion Dollar Mistake”, Tony Hoare, el inventor de null, dice lo siguiente:</p>
<blockquote>
<p>Yo lo llamo mi error de mil millones de dólares. En ese momento, estaba diseñando el primer sistema completo de tipos para referencias en un lenguaje orientado a objetos. Mi objetivo era garantizar que todos los usos de las referencias fueran absolutamente seguros, con la verificación realizada automáticamente por el compilador. Pero no pude resistir la tentación de poner una referencia nula, simplemente porque era muy fácil de implementar. Esto ha llevado a innumerables errores, vulnerabilidades y bloqueos del sistema, que probablemente han causado mil millones de dólares en dolor y daños en los últimos cuarenta años.</p>
</blockquote>
<p>El problema con los valores nulos es que si intenta usar un valor nulo como un valor no nulo, obtendrá algún tipo de error. Debido a que esta propiedad nula o no nula es generalizada, es extremadamente fácil cometer este tipo de error.</p>
<p>Sin embargo, el concepto que <em>null</em> intenta expresar sigue siendo útil: un valor nulo es un valor que actualmente no es válido o está ausente por algún motivo.</p>
<p>El problema no es realmente con el concepto sino con la implementación particular.
Como tal, Rust no tiene <em>null</em>, pero tiene un enum que puede codificar el
concepto de un valor presente o ausente. Este enum es <code>Opción&lt;T&gt;</code>, y está
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">definido por la biblioteca estándar</a> <!-- ignore --> de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p>El enum <code>Option&lt;T&gt;</code> es tan útil que incluso está incluido en el <em>prelude</em>; no es necesario que lo incluya explícitamente en el scope. Sus variantes también se incluyen en el <em>prelude</em>: puede usar <code>Some</code> y <code>None</code> directamente sin el prefijo <code>Option::</code>. El enum <code>Option&lt;T&gt;</code> sigue siendo solo un enum regular, y <code>Some(T)</code> y <code>None</code> siguen siendo variantes del tipo <code>Option&lt;T&gt;</code>.</p>
<p>La sintaxis <code>&lt;T&gt;</code> es una característica de Rust de la que aún no hemos hablado. Es un parámetro
de tipo genérico, y trataremos los genéricos más detalladamente en el Capítulo 10. Por ahora,
todo lo que necesita saber es que <code>&lt;T&gt;</code> significa que la variante <code>Some</code> del enum <code>Option</code> puede contener una pieza de datos de cualquier tipo, y que cada tipo concreto que se usa en lugar de <code>T</code> hace que el tipo general <code>Option&lt;T&gt;</code> sea un tipo diferente. Estos son algunos ejemplos del uso de valores de <code>Option</code> para contener tipos numéricos y tipos string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>El tipo de <code>some_number</code> es <code>Option&lt;i32&gt;</code>. El tipo de <code>some_char</code> es <code>Option&lt;char&gt;</code>, que es un tipo diferente. Rust puede inferir estos tipos porque hemos especificado un valor dentro de la variante <code>Some</code>. Para <code>absent_number</code>, Rust requiere que anotemos el tipo general de <code>Option</code>: el compilador no puede inferir el tipo que tendrá la variante <code>Some</code> correspondiente mirando solo un valor <code>None</code>. Aquí, le decimos a Rust que queremos que <code>absent_number</code> sea del tipo <code>Option&lt;i32&gt;</code>.</p>
<p>Cuando tenemos un valor <code>Some</code>, sabemos que un valor está presente y el valor se mantiene dentro de <code>Some</code>. Cuando tenemos un valor <code>None</code>, en cierto sentido, significa lo mismo que null: no tenemos un valor válido. Entonces, ¿por qué es mejor tener <code>Option&lt;T&gt;</code> que tener null?</p>
<p>En resumen, debido a que <code>Option&lt;T&gt;</code> y <code>T</code> (donde <code>T</code> puede ser de cualquier tipo) son tipos diferentes, el compilador no nos permitirá usar un valor de <code>Option&lt;T&gt;</code> como si definitivamente fuera un valor válido. Por ejemplo, este código no se compilará porque está intentando sumar un <code>i8</code> a un <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>Si ejecutamos este código, recibimos un mensaje de error como este:</p>
<pre><code class="language-text">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;&amp;'a f32 as Add&lt;f32&gt;&gt;
            &lt;&amp;'a f64 as Add&lt;f64&gt;&gt;
            &lt;&amp;'a i128 as Add&lt;i128&gt;&gt;
            &lt;&amp;'a i16 as Add&lt;i16&gt;&gt;
            &lt;&amp;'a i32 as Add&lt;i32&gt;&gt;
            &lt;&amp;'a i64 as Add&lt;i64&gt;&gt;
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;'a isize as Add&lt;isize&gt;&gt;
          and 48 others

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>¡Intenso! En efecto, este mensaje de error significa que Rust no entiende cómo
sumar un <code>i8</code> y un <code>Opción&lt;i8&gt;</code>, porque son tipos diferentes. Cuando tenemos
un valor de un tipo como <code>i8</code> en Rust, el compilador se asegurará de que siempre tengamos
un valor válido. Podemos proceder con confianza sin tener que verificar el valor
nulo antes de usar ese valor. Solo cuando tenemos un <code>Opción&lt;i8&gt;</code>
(o el tipo de valor con el que estemos trabajando) tenemos que preocuparnos por
la posibilidad de no tener un valor, y el compilador se asegurará de que manejemos ese
caso antes de usar el valor.</p>
<p>En otras palabras, debe convertir un <code>Opción&lt;T&gt;</code> a un <code>T</code> antes de poder realizar operaciones de <code>T</code> con él. Generalmente, esto ayuda a detectar uno de los problemas más comunes con <em>null</em>: asumir que algo no es nulo cuando en realidad lo es.</p>
<p>Eliminar el riesgo de asumir incorrectamente un valor no nulo lo ayuda a tener más confianza en su código. Para tener un valor que posiblemente sea nulo, debe optar explícitamente haciendo que el tipo de ese valor sea <code>Option&lt;T&gt;</code>. Luego, cuando usa ese valor, debe manejar explícitamente el caso cuando el valor es nulo. Siempre que un valor tenga un tipo que no sea <code>Option&lt;T&gt;</code>, puede suponer con seguridad que el valor no es nulo. Esta fue una decisión de diseño deliberada de Rust para limitar la omnipresencia de <em>null</em> y aumentar la seguridad del código Rust.</p>
<p>Entonces, ¿cómo se obtiene el valor <code>T</code> de una variante <code>Some</code> cuando tiene un valor de tipo <code>Opción&lt;T&gt;</code> para que pueda usar ese valor? El enum <code>Option&lt;T&gt;</code> tiene una gran cantidad de métodos que son útiles en una variedad de situaciones; puede verlos en <a href="https://doc.rust-lang.org/std/option/enum.Option.html">su documentación</a> <!-- ignore -->. Familiarizarse con los métodos en <code>Option&lt;T&gt;</code> será extremadamente útil en su
viaje con Rust.</p>
<p>En general, para usar un valor <code>Option&lt;T&gt;</code>, desea tener un código que maneje cada variante. Desea un código que se ejecutará solo cuando tenga un valor <code>Some(T)</code>, y este código podrá usar el <code>T</code> interno. Desea que se ejecute algún otro código si tiene un valor <code>None</code> y ese código no tiene un valor <code>T</code> disponible. La expresión <code>match</code> es una <em>estructura de control</em> que hace justamente esto cuando se usa con <em>enums</em>: ejecutará un código diferente dependiendo de la variante del enum que tenga, y ese código puede usar los datos dentro del valor coincidente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="la-estructura-de-control-match"><a class="header" href="#la-estructura-de-control-match">La Estructura de Control <code>match</code></a></h2>
<p>Rust tiene una estructura de control extremadamente poderosa llamada <code>match</code>que le permite comparar un valor con una serie de patrones y luego ejecutar el código según el patrón que coincida. Los patrones pueden estar formados por valores literales, nombres de variables, comodines y muchas otras cosas; El Capítulo 18 cubre todos los diferentes tipos de patrones y lo que hacen. El poder de <code>match</code> proviene de la expresividad de los patrones y del hecho de que el compilador confirma que se manejan todos los casos posibles.</p>
<p>Piense en una expresión de <code>match</code> como una máquina clasificadora de monedas: las monedas se deslizan por una pista con orificios de diferentes tamaños a lo largo de ella, y cada moneda cae por el primer orificio que encuentra que encaja. De la misma manera, los valores pasan por cada patrón en <code>match</code>, y en el primer patrón en el que el valor encaje, el valor cae en el bloque de código asociado para ser utilizado durante la ejecución.</p>
<p>Hablando sw monedas, ¡utilicémoslas como ejemplo usando <code>match</code>!
Podemos escribir una función que puede tomar una moneda desconocida de los Estados Unidos y,
de manera similar a la máquina de conteo, determinar qué moneda es y devolver su valor en
centavos, como se muestra aquí en el Listado 6-3.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-3: Un enum y una expresión <code>match</code> que tiene las variantes del enum como sus patrones</span></p>
<p>Vamos a desglosar el <code>match</code> en la función <code>value_in_cents</code>. Primero, listamos la palabra clave <code>match</code> seguida de una expresión, que en este caso es el valor <code>coin</code>. Esto parece muy similar a una expresión utilizada con <code>if</code>, pero hay una gran diferencia: con <code>if</code>, la expresión necesita devolver un valor booleano, pero aquí, puede ser de cualquier tipo. El tipo de <code>coin</code> en este ejemplo es el <em>enum</em> de <code>coin</code> que definimos en la línea 1.</p>
<p>A continuación están los brazos del <code>match</code>. Un brazo tiene dos partes: un patrón y algún código.
El primer brazo aquí tiene un patrón que es el valor <code>Coin::Penny</code> y luego el operador <code>=&gt; </code> que separa el patrón y el código a ejecutar. El código en este caso es solo el valor <code>1</code>. Cada brazo está separado del siguiente con una coma.</p>
<p>Cuando se ejecuta la expresión <code>match</code>, compara el valor resultante con el patrón de cada brazo, en orden. Si un patrón coincide con el valor, el código asociado con ese patrón se ejecuta. Si ese patrón no coincide con el valor, la ejecución continúa al siguiente brazo, al igual que en una máquina clasificadora de monedas. Podemos tener tantas brazos como necesitemos: en el Listado 6-3, nuestro <code>match</code> tiene cuatro brazos.</p>
<p>El código asociado con cada brazo es una expresión, y el valor resultante de la expresión en el brazo correspondiente es el valor que se devuelve para la expresión <code>match</code> completa.</p>
<p>Por lo general, no usamos corchetes si el código del brazo del <code>match</code> es corto, como en el Listado 6-3, donde cada brazo solo devuelve un valor. Si desea ejecutar varias líneas de código en un brazo del <code>match</code> debe usar corchetes, y la coma que sigue al brazo es opcional. Por ejemplo, el siguiente código imprimirá “Lucky penny!” cada vez que se llama al método con
un <code>Coin::Penny</code> pero aún devuelve el último valor del bloque, <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="patrones-que-se-vinculan-a-valores"><a class="header" href="#patrones-que-se-vinculan-a-valores">Patrones que se Vinculan a Valores</a></h3>
<p>Otra característica útil de los brazos del <em>match</em> es que pueden unirse a las partes
de los valores que coinciden con el patrón. Así es como podemos extraer valores de las variantes <em>enum</em>.</p>
<p>Como ejemplo, cambiemos una de nuestras variantes enum para contener datos dentro de ella. Desde 1999 hasta 2008, Estados Unidos acuñó monedas de veinticinco centavos con diferentes diseños en un lado para cada uno de los 50 estados. Ninguna otra moneda tiene diseños estatales, por lo que solo las monedas de veinticinco centavos tienen este valor adicional. Podemos agregar esta información a nuestro <code>enum</code> cambiando la variante <code>Quarter</code> para incluir un valor <code>UsState</code> almacenado dentro de él, lo que hemos hecho aquí en el Listado 6-4.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-4: Un enum <code>Coin</code> en el cual la variante <code>Quarter</code> también tiene un valor <code>UsState</code></span></p>
<p>Imaginemos que un amigo nuestro está tratando de coleccionar los <em>Quarters</em> (<em>monedas de 25 centavos</em>) de los 50 estados. Mientras clasificamos nuestro cambio suelto por tipo de moneda, también mencionaremos el nombre del estado asociado con cada <em>quarter</em>, de modo que si es uno que nuestro amigo no tiene, pueda agregarlo a su colección.</p>
<p>En la expresión match de este código, agregamos una variable llamada <code>state</code> al patrón que coincide con los valores de la variante<code> Coin::Quarter</code>. Cuando coincide un <code>Coin::Quarter</code>, la variable <code>state</code> se vinculará al valor del estado de ese <em>quarter</em>. Entonces podemos usar <code>state</code> en el código para ese brazo, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>Si tuviéramos que llamar a <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code> sería <code>Coin::Quarter(UsState::Alaska)</code>. Cuando comparamos ese valor con cada uno de los brazos del <em>match</em>, ninguno de ellos coincide hasta que llegamos a <code>Coin::Quarter(state)</code>. En ese punto, el vínculo para <code>state</code> será el valor <code>UsState::Alaska</code>. Entonces podemos usar ese vínculo en la expresión <code>println!</code>, obteniendo así el valor de estado interno de la variante del <em>enum</em>
<code>Coin</code> para <code>Quarter</code>.</p>
<h3 id="coincidencia-con-optiont"><a class="header" href="#coincidencia-con-optiont">Coincidencia con <code>Option&lt;T&gt;</code></a></h3>
<p>En la sección anterior, queríamos obtener el valor interno de <code>T</code> del caso <code>Some</code> al usar <code>Option&lt;T&gt;</code>; ¡también podemos manejar<code>Option&lt;T&gt;</code> usando <code>match</code> como lo hicimos con el enum <code>Coin</code>! En lugar de comparar monedas, compararemos las variantes de <code>Option&lt;T&gt;</code>, pero la forma en que funciona la expresión <code>match</code> sigue siendo la misma.</p>
<p>Digamos que queremos escribir una función que tome una <code>Opción&lt;i32&gt;</code> y, si hay un valor dentro, suma 1 a ese valor. Si no hay un valor dentro, la función debe devolver el valor <code>None</code> y no intentar realizar ninguna operación.</p>
<p>Esta función es muy fácil de escribir, gracias a <code>match</code>, y se verá como la del Listado 6-5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-5: Una función que usa una expresión <code>match</code> en un <code>Option&lt;i32&gt;</code></span></p>
<p>Examinemos la primera ejecución de <code>plus_one</code> con más detalle. Cuando llamamos a <code>plus_one(five)</code>, la variable <code>x</code> en el cuerpo de <code>plus_one</code> tendrá el valor <code>Some(5)</code>. Luego lo
comparamos con cada brazo del <em>match</em>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>El valor <code>Some(5)</code> no coincide con el patrón <code>None</code>, por lo que continuamos al siguiente brazo.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>¿<code>Some(5)</code> coincide con <code>Some(i)</code>? ¡Sí, lo hace! Tenemos la misma variante. El <code>i</code> se vincula al valor contenido en <code>Some</code>, entonces <code>i</code> toma el valor <code>5</code>. El código en el brazo del <em>match</em> entonces se ejecuta, por lo que sumamos 1 al valor de <code>i</code> y creamos un nuevo valor <code>Some</code> con nuestro total de <code>6</code> dentro.</p>
<p>Ahora consideremos la segunda llamada de <code>plus_one</code> en el Listado 6-5, donde <code>x</code> es <code>None</code>. Ingresamos al <code>match</code> y lo comparamos con el primer brazo.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>¡Coincide! No hay ningún valor para sumarle, por lo que el programa se detiene y devuelve el valor <code>None</code> en el lado derecho de <code>=&gt;</code>. Debido a que el primer brazo coincide, no se comparan otros brazos.</p>
<p>Combinar <code>match</code> y <em>enums</em> es útil en muchas situaciones. Verá este patrón mucho en el código Rust: haga un <code>match</code> con un enum, vincule una variable a los datos internos y luego ejecute el código en función de ello. Es un poco complicado al principio, pero una vez que se acostumbre, deseará tenerlo en todos los lenguajes. Es constantemente un favorito del usuario.</p>
<h3 id="los-matches-son-exhaustivos"><a class="header" href="#los-matches-son-exhaustivos">Los <em>Matches</em> son Exhaustivos</a></h3>
<p>Hay otro aspecto de <code>match</code> que debemos discutir: los patrones de los brazos deben cubrir todas las posibilidades. Considere esta versión de nuestra función <code>plus_one</code> que tiene un error y no compilará:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>No manejamos el caso <code>None</code>, por lo que este código provocará un error. Afortunadamente, es un error que Rust sabe capturar. Si tratamos de compilar este código, obtendremos este error:</p>
<pre><code class="language-text">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<p>¡Rust sabe que no cubrimos todos los casos posibles e incluso sabe qué patrón olvidamos! Los <em>Matches</em> en Rust son <em>exhaustivos</em>: debemos agotar hasta la última posibilidad para que el código sea válido. Especialmente en el caso de <code>Option&lt;T&gt;</code>, cuando Rust evita que olvidemos manejar explícitamente el caso <code>None</code>, nos protege de asumir que tenemos un valor cuando podríamos tener null, lo que hace que el error de mil millones de dólares discutido anteriormente sea imposible.</p>
<h3 id="patrones-comodín-catch-all-y-el-marcador-de-posición-_"><a class="header" href="#patrones-comodín-catch-all-y-el-marcador-de-posición-_">Patrones Comodín (<em>catch-all</em>) y el Marcador de Posición <code>_</code></a></h3>
<p>Al usar enums, también podemos realizar acciones especiales para algunos valores particulares, pero para todos los demás valores, realizamos una acción predeterminada. Imagine que estamos implementando un juego en el que, si saca un 3 en un lanzamiento de dados, su jugador no se mueve, sino que obtiene un nuevo sombrero elegante. Si saca un 7, su jugador pierde un sombrero elegante. Para todos los demás valores, su jugador mueve esa cantidad de espacios en el tablero de juego. Aquí hay un <code>match</code> que implementa esa lógica, con el resultado del lanzamiento de dados codificado en lugar de un valor aleatorio, y toda la otra lógica representada por funciones sin cuerpo porque implementarlas en realidad está fuera del alcance de este ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}
</span></code></pre></pre>
<p>Para los dos primeros brazos, los patrones son los valores literales 3 y 7. Para el último brazo que cubre todos los demás valores posibles, el patrón es la variable que hemos elegido nombrar <code>other</code>. El código que se ejecuta para el brazo <code>other</code> usa la variable pasándola a la función <code>move_player</code>.</p>
<p>Este código compila, aunque no hemos enumerado todos los valores posibles que puede tener un <code>u8</code>, porque el último patrón coincidirá con todos los valores no enumerados específicamente. Este patrón catch-all (<em>&quot;comodín&quot;</em> o <em>&quot;atrapa todo&quot;</em>) cumple con el requisito de que <code>match</code> debe ser exhaustivo. Tenga en cuenta que tenemos que poner el brazo catch-all en último lugar porque los patrones se evalúan en orden. Si colocamos el brazo catch-all antes, los otros brazos nunca se ejecutarán, por lo que ¡Rust nos avisará si agregamos brazos después de un catch-all!.</p>
<p>Rust también tiene un patrón que podemos usar cuando queremos un catch-all pero no queremos <em>usar</em> el valor en el patrón catch-all: <code>_</code> es un patrón especial que coincide con cualquier valor y no se vincula a ese valor. Esto le dice a Rust que no vamos a usar el valor, por lo que no nos advertirá sobre una variable no utilizada.</p>
<p>Cambiemos las reglas del juego: ahora, si saca algo que no sea un 3 o un 7, debe tirar de nuevo. Ya no necesitamos usar el valor de catch-all, por lo que podemos cambiar nuestro código para usar <code>_</code> en lugar de la variable llamada <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}
</span></code></pre></pre>
<p>Este ejemplo también cumple con el requisito de exhaustividad porque estamos ignorando explícitamente todos los demás valores en el último brazo; no hemos olvidado nada.</p>
<p>Finalmente, cambiaremos las reglas del juego una vez más, para que no suceda nada más en su turno si saca algo que no sea un 3 o un 7. Podemos expresar eso usando el valor <em>unidad</em> (el tipo de tupla vacía que mencionamos en la sección <a href="ch03-02-data-types.html#el-tipo-tupla-tuple">“El Tipo Tupla”</a>) como el código que va con el brazo <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}
</span></code></pre></pre>
<p>Aquí, le decimos a Rust explícitamente que no vamos a usar ningún otro valor que no coincida con un patrón en un brazo anterior, y no queremos ejecutar ningún código en este caso.</p>
<p>En el <a href="ch18-00-patterns.html">Capítulo 18</a> veremos más sobre patrones y coincidencias. Por ahora, vamos a pasar a la sintaxis <code>if let</code>, que puede ser útil en situaciones en las que la expresión <code>match</code> es un poco verbosa.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="estructura-de-control-concisa-con-if-let"><a class="header" href="#estructura-de-control-concisa-con-if-let">Estructura de Control Concisa con <code>if let</code></a></h2>
<p>La sintaxis <code>if let</code> le permite combinar <code>if</code> y <code>let</code> en una forma menos verbosa de manejar valores que coinciden con un patrón mientras ignora el resto. Considere el programa en el Listado 6-6 que coincide con un valor <code>Option&lt;u8&gt;</code> en la variable <code>config_max</code> pero solo quiere ejecutar código si el valor es la variante <code>Some</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {}&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-6: Un <code>match</code> que solo se preocupa por ejecutar el
código cuando el valor es <code>Some</code></span></p>
<p>Si el valor es <code>Some</code>, imprimimos el valor en la variante <code>Some</code> vinculando el valor a la variable <code>max</code> en el patrón. No queremos hacer nada con el valor <code>None</code>. Para satisfacer la expresión <code>match</code>, tenemos que agregar <code>_ =&gt; ()</code> después de procesar solo una variante, que es un código repetitivo molesto para añadir.</p>
<p>En cambio, podríamos escribir esto de una manera más corta usando <code>if let</code>. El siguiente código se comporta igual que el <code>match</code> en el Listado 6-6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {}&quot;, max);
    }
<span class="boring">}
</span></code></pre></pre>
<p>La sintaxis <code>if let</code> toma un patrón y una expresión separados por un signo igual. Funciona de la misma manera que un <code>match</code>, donde la expresión se asigna al <code>match</code> y el patrón es su primer brazo. En este caso, el patrón es <code>Some(max)</code>, y <code>max</code> se vincula al valor dentro de <code>Some</code>. Luego podemos usar <code>max</code> en el cuerpo del bloque <code>if let</code> de la misma manera que usamos <code>max</code> en el correspondiente brazo <code>match</code>. El código en el bloque <code>if let</code> no se ejecuta si el valor no coincide con el patrón.</p>
<p>Usar <code>if let</code> significa menos tipeo, menos indentación y menos código repetitivo. Sin embargo, pierde la verificación exhaustiva que impone <code>match</code>. Elegir entre <code>match</code> y <code>if let</code> depende de lo que esté haciendo en su situación particular y de si ganar concisión es una compensación adecuada por perder la verificación exhaustiva.</p>
<p>En otras palabras, puede pensar en <code>if let</code> como <em>azúcar sintáctico</em> para un <code>match</code>, que ejecuta código cuando el valor coincide con un patrón y luego ignora todos los demás valores.</p>
<p>Podemos incluir un <code>else</code> con un <code>if let</code>. El bloque de código que acompaña al <code>else</code> es el mismo que el bloque de código que iría con el caso <code>_</code> en la expresión <code>match</code> que es equivalente a <code>if let</code> y <code>else</code>. Recuerde la definición del enum <code>Coin</code> en el Listado 6-4, donde la variante <code>Quarter</code> también contenía un valor <code>UsState</code>. Si quisiéramos contar todas las monedas que no son de 25 centavos (<em>quarters</em>) y al mismo tiempo anunciar el estado de los <em>quarters</em>, podríamos hacerlo con una expresión <code>match</code> como esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring"> fn main() {
</span>    let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>O podríamos usar una expresión <code>if let</code> y <code>else</code> como esta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>Si tiene una situación en la que su programa tiene una lógica que es demasiado verbosa para expresarla usando un <code>match</code>, recuerde que<code>if let</code> también está en su caja de herramientas de Rust.</p>
<h2 id="resumen-5"><a class="header" href="#resumen-5">Resumen</a></h2>
<p>Ahora hemos cubierto cómo usar enums para crear tipos personalizados que pueden ser uno de un conjunto de valores enumerados. Mostramos cómo el tipo <code>Opción&lt;T&gt;</code> de la biblioteca estándar le ayuda a usar el sistema de tipos para evitar errores. Cuando los valores <em>enum</em> tienen datos dentro de ellos, puede usar <code>match</code> o <code>if let</code> para extraer y usar esos valores, dependiendo de la cantidad de casos que necesite manejar.</p>
<p>Sus programas en Rust ahora pueden expresar conceptos en su dominio usando <em>structs</em>
y <em>enums</em>. La creación de tipos personalizados para usar en su API garantiza
la seguridad de tipos: el compilador se asegurará de que sus funciones obtengan solo
valores del tipo que cada función espera.</p>
<p>Con el fin de proporcionar a sus usuarios una API bien organizada que sea fácil de usar y solo exponga exactamente lo que necesitarán, pasemos ahora a los módulos de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gestión-de-proyectos-en-crecimiento-con-packages-crates-y-modules"><a class="header" href="#gestión-de-proyectos-en-crecimiento-con-packages-crates-y-modules">Gestión de Proyectos en Crecimiento con Packages, Crates y Modules</a></h1>
<p>A medida que escriba programas grandes, la organización de su código será cada vez más importante. Al agrupar funcionalidad relacionada y separar código con características distintas, aclarará dónde encontrar el código que implementa una característica particular y dónde ir para cambiar el funcionamiento de una característica.</p>
<p>Los programas que hemos escrito hasta ahora han estado en un módulo <em>(module)</em> en un archivo. A medida que crece un proyecto, debe organizar el código dividiéndolo en múltiples módulos y luego en múltiples archivos. Un <em>package</em> (paquete) puede contener varios <em>crates</em><sup class="footnote-reference"><a href="#1">1</a></sup> binarios y, opcionalmente, un <em>crate</em> librería. A medida que crece un package, puede extraer partes en <em>crates</em> separados que se convierten en dependencias externas. Este capítulo cubre todas estas técnicas. Para proyectos muy grandes que comprenden un conjunto de packages interrelacionados que evolucionan juntos, Cargo proporciona <em>workspaces</em> (espacios de trabajo), que cubriremos en la sección <a href="ch14-03-cargo-workspaces.html">&quot;Espacios de Trabajo de Cargo&quot;</a> en el Capítulo 14.</p>
<p>También hablaremos sobre encapsulación de detalles de implementación, lo que le permite reutilizar código a un nivel superior: una vez que haya implementado una operación, otro código puede llamar a su código a través de su interfaz pública sin tener que saber cómo funciona la implementación. La forma en que escribe el código define qué partes son públicas para que las use otro código y qué partes son detalles de implementación privados que se reserva el derecho de cambiar. Esta es otra forma de limitar la cantidad de detalles que debe tener en mente.</p>
<p>Un concepto relacionado es <em>scope</em>: el contexto anidado en el cual se escribe el código tiene un conjunto de nombres que son definidos como <em>&quot;in scope&quot;</em> (&quot;dentro del ámbito&quot;). Al leer, escribir y compilar código, los programadores y compiladores necesitan saber si un nombre en particular en un lugar en particular se refiere a una variable, función, struct, enum, módulo, constante u otro elemento y qué significa ese elemento. Puede crear scopes y cambiar qué nombres están dentro o fuera del scope. No puede tener dos elementos con el mismo nombre en el mismo scope. Hay herramientas disponibles para resolver conflictos de nombres.</p>
<p>Rust tiene una serie de características que le permiten administrar la organización de su código, que incluyen cuáles detalles se exponen, cuáles detalles son privados y qué nombres se encuentran en cada ámbito de sus programas. Estas características, a veces denominadas colectivamente como <em>module system</em> (sistema de módulos), incluyen:</p>
<ul>
<li><strong>Packages:</strong> Una característica de Cargo que le permite construir, testear y compartir <em>crates</em></li>
<li><strong>Crates:</strong>  Un árbol de módulos el cual produce una librería o ejecutable</li>
<li><strong>Modules</strong> y <strong>use:</strong> Le permite controlar la organización, el scope y la privacidad de las rutas (paths)</li>
<li><strong>Paths:</strong> Una forma de nombrar un elemento, como un struct, función o módulo</li>
</ul>
<p>En este capítulo, cubriremos todas estas características, discutiremos cómo interactúan y explicaremos cómo usarlas para administrar el scope. Al final, debe tener una comprensión sólida del <em>module system</em> y poder ¡trabajar con scopes como un profesional!</p>
<p></br></br></br></p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> <small><em>crate</em> puede traducirse como &quot;caja&quot;, también como &quot;contenedor, caja o cajón de embalaje&quot;</small></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="packages-y-crates"><a class="header" href="#packages-y-crates">Packages y Crates</a></h2>
<p>Las primeras partes del <em>module system</em> (sistema de módulos) que cubriremos son packages y crates.</p>
<p>Un <em>crate</em> es la cantidad más pequeña de código que el compilador de Rust considera a la vez. Incluso si ejecuta <code>rustc</code> en lugar de <code>cargo</code> y pasa un solo archivo de código fuente (como hicimos en la sección &quot;Escribir y Ejecutar un Programa Rust&quot; del Capítulo 1), el compilador considera que ese archivo es un crate. Los crates pueden contener módulos, y los módulos se pueden definir en otros archivos, que son compilados con el crate, como veremos en las próximas secciones.</p>
<p>Un crate puede presentarse en una de dos formas: un <em>crate binario</em> o un <em>crate librería</em>. Los <em>crates binarios</em> son programas que se puede compilar a un ejecutable que se puede ejecutar, como un programa de línea de comandos o un servidor. Cada uno debe tener una función llamada <code>main</code> que defina lo que sucede cuando se ejecuta el ejecutable. Todos los crates que hemos creado hasta ahora han sido crates binarios.</p>
<p>Los <em>crates librerías</em> no tienen una función <code>main</code> y no se compilan a un ejecutable. En su lugar, definen la funcionalidad destinada a ser compartida con múltiples proyectos. Por ejemplo, el crate <code>rand</code> que usamos en el <a href="ch02-00-guessing-game-tutorial.html#generando-un-n%C3%BAmero-aleatorio">Capítulo 2</a> proporciona una funcionalidad que genera números aleatorios. La mayoría de las veces, cuando los Rustáceos dicen &quot;crate&quot;, se refieren a crate librería, y usan &quot;crate&quot; de manera intercambiable con el concepto general de programación &quot;librería&quot;.</p>
<p>El <em>crate raíz</em> es un archivo fuente desde el cual el compilador de Rust comienza y constituye el módulo raíz de un crate (explicaremos los módulos en profundidad en la sección <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html#definiendo-m%C3%B3dulos-para-controlar-el-scope-y-la-privacidad">&quot;Definiendo Módulos para Controlar el Scope y la Privacidad&quot;</a>).</p>
<p>Un <em>package</em> es un paquete de uno o más crates que proporciona un conjunto de funcionalidades. Un package contiene un archivo <em>Cargo.toml</em> que describe cómo construir esos crates. Cargo es en realidad un package que contiene el crate binario de la <em>herramienta de línea de comandos</em> que ha estado usando para construir su código. El package Cargo también contiene un crate librería del que depende el crate binario. Otros proyectos pueden depender del crate librería de Cargo para usar la misma lógica que usa la <em>herramienta de línea de comandos</em> de Cargo.</p>
<p>Un package puede contener tantos crates binarios como desee, pero como máximo solo un crate librería. Un package debe contener al menos un crate, ya sea un crate librería o binario.</p>
<p>Veamos qué sucede cuando creamos un package. Primero, ingresamos el comando <code>cargo new</code>:</p>
<pre><code class="language-text">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Después de ejecutar <code>cargo new</code>, usamos <code>ls</code> para ver qué crea Cargo. En el directorio del proyecto hay un archivo <em>Cargo.toml</em>, que nos da un package. También hay un directorio <em>src</em> que contiene <em>main.rs</em>. Abra <em>Cargo.toml</em> en su editor de texto y note que no se menciona <em>src/main.rs</em>. Cargo sigue una convención de que <em>src/main.rs</em> es <em>crate raíz</em> de un <em>crate binario</em> con el mismo nombre que el package. Del mismo modo, Cargo sabe que si el directorio del package contiene <em>src/lib.rs</em>, el package contiene un crate librería con el mismo nombre que el package, y <em>src/lib.rs</em> es su crate raíz. Cargo pasa los archivos del crate raíz a <code>rustc</code> para construir la librería o el binario.</p>
<p>Aquí, tenemos un package que solo contiene <em>src/main.rs</em>, lo que significa que solo contiene un crate binario llamado <code>my-project</code>. Si un package contiene <em>src/main.rs</em> y <em>src/lib.rs</em>, tiene dos crates: uno binario y uno librería, ambos con el mismo nombre que el package. Un package puede tener varios crates binarios colocando archivos en el directorio <em>src/bin</em>: cada archivo será un crate binario separado.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definiendo-módulos-para-controlar-el-scope-y-la-privacidad"><a class="header" href="#definiendo-módulos-para-controlar-el-scope-y-la-privacidad">Definiendo Módulos para Controlar el Scope y la Privacidad</a></h2>
<p>En esta sección, hablaremos sobre módulos y otras partes del module system, es decir, rutas que le permiten nombrar elementos; la palabra clave <code>use</code> que trae una ruta al scope; y la palabra clave <code>pub</code> para hacer públicos los elementos. También discutiremos la palabra clave <code>as</code>, los paquetes externos y el operador global.</p>
<p>Primero, vamos a comenzar con una lista de reglas para una fácil referencia cuando esté organizando su código en el futuro. A continuación, explicaremos en detalle cada una de las reglas.</p>
<h3 id="hoja-de-referencia-de-módulos"><a class="header" href="#hoja-de-referencia-de-módulos">Hoja de Referencia de Módulos</a></h3>
<p>Aquí proporcionamos una referencia rápida sobre cómo funcionan los módulos, las rutas, la palabra clave <code>use</code> y la palabra clave <code>pub</code> en el compilador, y cómo la mayoría de los desarrolladores organizan su código. Veremos ejemplos de cada una de estas reglas a lo largo de este capítulo, pero este es un buen lugar para referirse a él como un recordatorio de cómo funcionan los módulos.</p>
<ul>
<li>
<p><strong>Comenzar desde el crate raíz:</strong> al compilar un crate, el compilador primero busca en el archivo del crate raíz (generalmente src/lib.rs para un crate librería o src/main.rs para un crate binario) en busca de código para compilar.</p>
</li>
<li>
<p><strong>Declaración de módulos:</strong> en el archivo del crate raíz, puede declarar nuevos módulos; digamos, declara un módulo &quot;garden&quot; con <code>mod garden;</code> . El compilador buscará el código del módulo en estos lugares:</p>
<ul>
<li>En la misma línea, entre corchetes que reemplazan el punto y coma que sigue a <code>mod garden</code></li>
<li>En el archivo src/garden.rs</li>
<li>En el archivo src/garden/mod.rs</li>
</ul>
</li>
<li>
<p><strong>Declaración de submódulos:</strong> en cualquier archivo que no sea el crate raíz, puede declarar submódulos. Por ejemplo, puede declarar <code>mod vegetables;</code> en src/garden.rs. El compilador buscará el código del submódulo dentro del directorio nombrado para el módulo principal en estos lugares:</p>
<ul>
<li>En la misma línea, inmediatamente a <code>mod vegetables</code>, entre corchetes en lugar del punto y coma</li>
<li>En el archivo src/garden/vegetables.rs</li>
<li>En el archivo src/garden/vegetables/mod.rs</li>
</ul>
</li>
<li>
<p><strong>Rutas al código en los módulos:</strong> una vez que un módulo es parte de su crate, puede hacer referencia al código de ese módulo desde cualquier otro lugar en ese mismo crate, siempre que las reglas de privacidad lo permitan, usando la ruta al código. Por ejemplo, un tipo de <code>Asparagus</code> en el módulo <em>garden vegetables</em> se encontraría en <code>crate::garden::vegetables::Asparagus</code>.</p>
</li>
<li>
<p><strong>Privado vs. público:</strong> el código dentro de un módulo es privado desde sus módulos padres de forma predeterminada. Para hacer público un módulo, declárelo con <code>pub mod</code> en lugar de <code>mod</code>. Para hacer que los elementos dentro de un módulo público también sean públicos, use <code>pub</code> antes de sus declaraciones.</p>
</li>
<li>
<p><strong>La palabra clave <code>use</code>:</strong> dentro de un scope, la palabra clave <code>use</code> crea accesos directos a elementos para reducir la repetición de rutas largas. En cualquier scope que pueda hacer referencia a <code>crate::garden::vegetables::Asparagus</code>, puede crear un acceso directo con <code>use crate::garden::vegetables::Asparagus;</code> y de ahí en adelante solo necesita escribir <code>Asparagus</code> para hacer uso de ese tipo en el scope.</p>
</li>
</ul>
<p>Aquí creamos un crate binario llamado <code>backyard</code> que ilustra estas reglas. El directorio del crate, también llamado <code>backyard</code>, contiene estos archivos y directorios:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>El archivo del crate raíz en este caso es <em>src/main.rs</em> y contiene:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {:?}!&quot;, plant);
}
</code></pre>
<p>La línea <code>pub mod garden;</code> le dice al compilador que incluya el código que encuentra en <em>src/garden.rs</em>, que es:</p>
<p><span class="filename">Filename: src/garden.rs</span></p>
<pre><code class="language-rust ignore">pub mod vegetables;
</code></pre>
<p>Aquí, <code>pub mod vegetables;</code> significa que el código en <em>src/garden/vegetables.rs</em> también está incluido. Ese código es:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct Asparagus {}
</code></pre>
<p>¡Ahora entremos en los detalles de estas reglas y demostrémoslas en acción!</p>
<h3 id="agrupando-código-relacionado-en-módulos"><a class="header" href="#agrupando-código-relacionado-en-módulos">Agrupando Código Relacionado en Módulos</a></h3>
<p>Los <em>módulos</em> nos permiten organizar el código dentro de un crate para que sea legible y fácil de reutilizar. Los módulos también nos permiten controlar la <em>privacidad</em> de los elementos, porque el código dentro de un módulo es privado de forma predeterminada. Los elementos privados son detalles de implementación interna que no están disponibles para uso externo. Podemos elegir hacer públicos los módulos y los elementos dentro de ellos, lo que los expone para permitir que el código externo los use y dependa de ellos.</p>
<p>Como ejemplo, escribamos un crate librería que proporcione la funcionalidad de un restaurante. Definiremos las firmas de las funciones, pero dejaremos sus cuerpos vacíos para concentrarnos en la organización del código, en lugar de la implementación de un restaurante.</p>
<p>En la industria de los restaurantes, algunas partes de un restaurante se denominan <em>front of house</em> y otras como <em>back of house</em>. El <em>front of house</em> es donde están los clientes; esto abarca donde los anfitriones sientan a los clientes, los camareros toman los pedidos y los pagos, y los bartenders preparan las bebidas. El <em>back of house</em> es donde los chefs y cocineros trabajan en la cocina, los lavaplatos limpian y los gerentes hacen el trabajo administrativo.</p>
<p>Para estructurar nuestro crate de esta manera, podemos organizar sus funciones en módulos anidados. Cree una nueva librería llamada <code>restaurant</code> ejecutando <code>cargo new restaurant --lib</code>, luego ingrese el código del Listado 7-1 en <em>src/lib.rs</em> para definir algunos módulos y firmas de funciones. Aquí está la sección <em>front of house</em>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p><span class="caption">Listado 7-1: Un módulo <code>front_of_house</code> que contiene otros módulos que a su vez contienen funciones</span></p>
<p>Definimos un módulo con la palabra clave <code>mod</code> seguida del nombre del módulo (en este caso, <code>front_of_house</code>). El cuerpo del módulo luego va entre corchetes. Dentro de los módulos, podemos colocar otros módulos, como en este caso con los módulos de <code>hosting</code> y <code>serving</code>. Los módulos también pueden contener definiciones de otros elementos, como structs, enums, constantes, traits y, como en el Listado 7-1, funciones.</p>
<p>Mediante el uso de módulos, podemos agrupar definiciones relacionadas y nombrar por qué están relacionadas. Los programadores que utilizan este código pueden navegar por el código según los grupos en lugar de tener que leer todas las definiciones, lo que facilita encontrar las definiciones relevantes para ellos. Los programadores que agreguen nuevas funcionalidades a este código sabrían dónde colocar el código para mantener el programa organizado.</p>
<p>Anteriormente, mencionamos que <em>src/main.rs</em> y <em>src/lib.rs</em> se denominan crates raíz. La razón de su nombre es que el contenido de cualquiera de estos dos archivos forma un módulo llamado <code>crate</code> en la raíz de la estructura del módulo del crate, conocida como <em>árbol de módulos</em>.</p>
<p><span class="filename">El Listado 7-2 muestra el árbol de módulos para la estructura del Listado 7-1.</span></p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Listado 7-2: El árbol de módulos para el código del Listado 7-1</span></p>
<p>Este árbol muestra cómo algunos de los módulos encajan unos dentro de otros; por ejemplo, <code>hosting</code> está anidado dentro de <code>front_of_house</code>. El árbol también muestra que algunos módulos son <em>hermanos</em> entre sí, lo que significa que están definidos en el mismo módulo; <code>hosting</code> y <code>serving</code> son hermanos definidos dentro de <code>front_of_house</code>. Si el módulo A está contenido dentro del módulo B, decimos que el módulo A es el <em>hijo</em> del módulo B y que el módulo B es el <em>padre</em> del módulo A. Tenga en cuenta que todo el árbol del módulo tiene su raíz bajo el módulo implícito llamado <code>crate</code>.</p>
<p>El árbol de módulos puede recordarle el árbol de directorios del sistema de archivos en su computadora; ¡esta es una comparación muy acertada! Al igual que los directorios en un sistema de archivos, usted utiliza módulos para organizar su código. Y al igual que los archivos en un directorio, necesitamos una forma de encontrar nuestros módulos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rutas-para-hecer-referencia-a-un-elemento-en-el-Árbol-de-módulos"><a class="header" href="#rutas-para-hecer-referencia-a-un-elemento-en-el-Árbol-de-módulos">Rutas para hecer Referencia a un Elemento en el Árbol de Módulos</a></h2>
<p>Para mostrarle a Rust dónde encontrar un elemento en un árbol de módulos, usamos una ruta de la misma manera que usamos una ruta cuando navegamos por un sistema de archivos. Para llamar a una función, necesitamos conocer su ruta.</p>
<p>Una ruta puede tomar dos formas:</p>
<ul>
<li>Una <em>ruta absoluta</em> es la ruta completa a partir de un crate raíz. Para el código de un crate externo, la ruta absoluta comienza con el nombre del crate, y para el código del crate actual, comienza con el literal <code>crate</code>.</li>
<li>Una <em>ruta relativa</em> comienza desde el módulo actual y usa <code>self</code>, <code>super</code> o un identificador en el módulo actual.</li>
</ul>
<p>Tanto las rutas absolutas como las relativas van seguidas de uno o más identificadores separados por dos puntos dobles (<code>::</code>).</p>
<p>Volviendo al Listado 7-1, digamos que queremos llamar a la función <code>add_to_waitlist</code>. Esto es lo mismo que preguntar: ¿cuál es la ruta de la función <code>add_to_waitlist</code>? El Listado 7-3 contiene el Listado 7-1 con algunos de los módulos y funciones eliminados.</p>
<p>Mostraremos dos formas de llamar a la función <code>add_to_waitlist</code> desde una nueva función <code>eat_at_restaurant</code> definida en el crate raíz. Estas rutas son correctas, pero queda otro problema que evitará que este ejemplo se compile tal como está. Explicaremos por qué en un momento.</p>
<p>La función <code>eat_at_restaurant</code> es parte de la API pública de nuestro crate librería, por lo que la marcamos con la palabra clave <code>pub</code>. En la sección <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exponiendo-rutas-con-la-palabra-clave-pub">&quot;Exponiendo Rutas con la Palabra Clave <code>pub</code>&quot;</a>, entraremos en más detalles sobre <code>pub</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listado 7-3: Llamar a la función <code>add_to_waitlist</code> usando rutas absolutas y relativas</span></p>
<p>La primera vez que llamamos a la función <code>add_to_waitlist</code> en <code>eat_at_restaurant</code>, usamos una ruta absoluta. La función <code>add_to_waitlist</code> se define en el mismo crate que <code>eat_at_restaurant</code>, lo que significa que podemos usar la palabra clave <code>crate</code> para iniciar una ruta absoluta. Luego incluimos cada uno de los módulos sucesivos hasta llegar a <code>add_to_waitlist</code>. Puede imaginar un sistema de archivos con la misma estructura: especificaríamos la ruta <code>/front_of_house/hosting/add_to_waitlist</code> para ejecutar el programa <code>add_to_waitlist</code>; usar el nombre <code>crate</code> para comenzar desde el crate raíz es como usar <code>/</code> para comenzar desde la raíz del sistema de archivos en su shell.</p>
<p>La segunda vez que llamamos a <code>add_to_waitlist</code> en <code>eat_at_restaurant</code>, usamos una ruta relativa. La ruta comienza con <code>front_of_house</code>, el nombre del módulo definido en el mismo nivel del árbol de módulos que <code>eat_at_restaurant</code>. Aquí, el equivalente del sistema de archivos sería usar la ruta <code>front_of_house/hosting/add_to_waitlist</code>. Comenzar con un nombre de módulo significa que la ruta es relativa.</p>
<p>Elegir si usar una ruta relativa o absoluta es una decisión que tomará en función de su proyecto y depende de si es más probable que mueva el código de definición del elemento por separado o junto con el código que usa el elemento. Por ejemplo, si movemos el módulo <code>front_of_house</code> y la función <code>eat_at_restaurant</code> a un módulo llamado <code>customer_experience</code>, necesitaríamos actualizar la ruta absoluta a <code>add_to_waitlist</code>, pero la ruta relativa seguiría siendo válida. Sin embargo, si moviéramos la función <code>eat_at_restaurant</code> por separado a un módulo llamado <code>dining</code>, la ruta absoluta a la llamada <code>add_to_waitlist</code> permanecería igual, pero la ruta relativa tendría que actualizarse. Nuestra preferencia en general es especificar rutas absolutas porque es más probable que queramos mover las definiciones de código y las llamadas a elementos de forma independiente.</p>
<p>¡Intentemos compilar el Listado 7-3 y averiguar por qué no se compila todavía! El error que obtenemos se muestra en el Listado 7-4.</p>
<pre><code class="language-text">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 7-4: Errores del compilador al construir el código en el Listado 7-3</span></p>
<p>Los mensajes de error dicen que el módulo <code>hosting</code> es privado. En otras palabras, tenemos las rutas correctas para el módulo <code>hosting</code> y la función <code>add_to_waitlist</code>, pero Rust no nos deja usarlas porque no se tiene acceso a las secciones privadas. En Rust, todos los elementos (funciones, métodos, structs, enums, módulos y constantes) son privados para los módulos <em>padres</em> de forma predeterminada. Si desea hacer privado un elemento como una función o un struct, colóquelo en un módulo.</p>
<p>Los elementos de un módulo padre no pueden usar los elementos privados que están dentro de los módulos hijos, pero los elementos de los módulos hijos pueden usar los elementos de sus módulos padres. Esto se debe a que los módulos hijos encapsulan y ocultan sus detalles de implementación, pero los módulos hijos pueden ver el contexto en el que están definidos. Para continuar con nuestra metáfora, piense en las reglas de privacidad como si fueran la oficina administrativa de un restaurante: lo que sucede allí es privado para los clientes del restaurante, pero los gerentes de oficina pueden ver y hacer todo en el restaurante que operan.</p>
<p>Rust eligió que el sistema de módulos funcionara de esta manera para que ocultar los detalles internos de implementación sea el valor predeterminado. De esa forma, sabrá qué partes del código interno puede cambiar sin romper el código externo. Sin embargo, Rust le brinda la opción de exponer partes internas del código de módulos hijos a los módulos ancestros externos mediante el uso de la palabra clave <code>pub</code> para hacer público un elemento.</p>
<h3 id="exponiendo-rutas-con-la-palabra-clave-pub"><a class="header" href="#exponiendo-rutas-con-la-palabra-clave-pub">Exponiendo Rutas con la Palabra Clave <code>pub</code></a></h3>
<p>Volvamos al error del Listado 7-4 que nos decía que el módulo <code>hosting</code> es privado. Queremos que la función <code>eat_at_restaurant</code> en el módulo padre tenga acceso a la función <code>add_to_waitlist</code> en el módulo hijo, por lo que marcamos el módulo <code>hosting</code> con la palabra clave <code>pub</code>, como se muestra en el Listado 7-5.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 7-5: Declarando el módulo <code>hosting</code> como <code>pub</code> para usarlo desde <code>eat_at_restaurant</code></span></p>
<p>Desafortunadamente, el código del Listado 7-5 aún genera un error, como se muestra en el Listado 7-6.</p>
<pre><code class="language-text">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Listado 7-6: Errores del compilador al compilar el código del Listado 7-5</span></p>
<p>¿Qué sucedió? Agregar la palabra clave <code>pub</code> delante de <code>mod hosting</code> hace que el módulo sea público. Con este cambio, si podemos acceder a <code>front_of_house</code>, podemos acceder a <code>hosting</code>. Pero los <em>contenidos</em> de <code>hosting</code> siguen siendo privados; hacer público el módulo no hace público su contenido. La palabra clave <code>pub</code> en un módulo solo permite que el código en sus módulos antepasados se refiera a él, no que acceda a su código interno. Debido a que los módulos son contenedores, no hay mucho que podamos hacer si solo hacemos público el módulo; necesitamos ir más allá y elegir hacer públicos uno o más de los elementos dentro del módulo también.</p>
<p>Los errores en el Listado 7-6 dicen que la función <code>add_to_waitlist</code> es privada. Las reglas de privacidad se aplican a structs, enums, funciones y métodos, así como a módulos.</p>
<p>También hagamos pública la función <code>add_to_waitlist</code> agregando la palabra clave <code>pub</code> antes de su definición, como en el Listado 7-7.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 7-7: Agregar la palabra clave <code>pub</code> a <code>mod hosting</code> y <code>fn add_to_waitlist</code> nos permite llamar a la función desde <code>eat_at_restaurant</code></span></p>
<p>¡Ahora el código se compilará! Para ver por qué agregar la palabra clave <code>pub</code> nos permite usar estas rutas en <code>add_to_waitlist</code> con respecto a las reglas de privacidad, veamos las rutas absolutas y relativas.</p>
<p>En la ruta absoluta, empezamos con <code>crate</code>, la raíz del árbol de módulos de nuestro crate. El módulo <code>front_of_house</code> se define en el crate raíz. Mientras que <code>front_of_house</code> no es público, debido a que la función <code>eat_at_restaurant</code> está definida en el mismo módulo que <code>front_of_house</code> (es decir, <code>eat_at_restaurant</code> y <code>front_of_house</code> son hermanos), podemos referirnos a <code>front_of_house</code> desde <code>eat_at_restaurant</code>. El siguiente es el módulo <code>hosting</code> marcado con <code>pub</code>. Podemos acceder al módulo padre de <code>hosting</code>, por lo que podemos acceder a <code>hosting</code>. Finalmente, la función <code>add_to_waitlist</code> está marcada con <code>pub</code> y podemos acceder a su módulo padre, ¡así que esta llamada de función funciona!</p>
<p>En la ruta relativa, la lógica es la misma que la ruta absoluta excepto por el primer paso: en lugar de comenzar desde el crate raíz, la ruta comienza desde <code>front_of_house</code>. El módulo <code>front_of_house</code> se define dentro del mismo módulo que <code>eat_at_restaurant</code>, por lo que la ruta relativa a partir del módulo en el que se define <code>eat_at_restaurant</code> funciona. Luego, debido a que <code>hosting</code> y <code>add_to_waitlist</code> están marcados con <code>pub</code>, el resto de la ruta funciona, ¡y esta llamada de función es válida!</p>
<p>Si planea compartir su crate librería para que otros proyectos puedan usar su código, su API pública es su contrato con los usuarios de su crate que determina cómo pueden interactuar con su código. Hay muchas consideraciones en torno a la gestión de cambios en su API pública para hacerla más simple a las personas que dependen de su crate. Estas consideraciones están fuera del alcance de este libro; si está interesado en este tema, consulte las <a href="https://rust-lang.github.io/api-guidelines/">Directrices de la API de Rust</a>.</p>
<blockquote>
<h4 id="prácticas-recomendadas-para-packages-con-un-binario-y-una-librería"><a class="header" href="#prácticas-recomendadas-para-packages-con-un-binario-y-una-librería">Prácticas Recomendadas para Packages con un Binario y una Librería</a></h4>
<p>Mencionamos que un package puede contener tanto un crate raíz binario <em>src/main.rs</em> como un crate raíz librería <em>src/lib.rs</em>, y ambos crates tendrán el nombre del package de manera predeterminada. Por lo general, los packages con este patrón de contener tanto un crate librería como un crate binario tendrán sólo el suficiente código en el crate binario como para iniciar un ejecutable que llame al código con el crate librería. Esto permite que otros proyectos se beneficien de la mayor funcionalidad que proporciona el package, porque el código del crate librería se puede compartir.</p>
<p>El árbol de módulos debe definirse en <em>src/lib.rs</em>. Luego, cualquier elemento público se puede usar en el crate binario iniciando las rutas con el nombre del package. El crate binario se convierte en un usuario del crate librería tal como un crate completamente externo usaría el crate librería: este solo puede usar la API pública. Esto le ayuda a diseñar una buena API; ¡Usted no solo es el autor, también es un cliente!</p>
<p>En el <a href="ch12-00-an-io-project.html">Capítulo 12</a>, demostraremos esta práctica organizativa con un programa de línea de comandos que contendrá tanto un crate binario como un crate librería.</p>
</blockquote>
<h3 id="comenzando-rutas-relativas-con-super"><a class="header" href="#comenzando-rutas-relativas-con-super">Comenzando Rutas Relativas con <code>super</code></a></h3>
<p>Podemos construir rutas relativas que comiencen en el módulo padre, en lugar del módulo actual o el crate raíz, usando <code>super</code> al comienzo de la ruta. Esto es como iniciar una ruta de sistema de archivos con la sintaxis &quot;<code>..</code>&quot;. El uso de <code>super</code> nos permite hacer referencia a un elemento que sabemos está en el módulo padre, lo que puede facilitar la reorganización del árbol de módulos cuando el módulo está estrechamente relacionado con el padre, pero el padre podría moverse a otra parte del árbol de módulos algún día.</p>
<p>Considere el código del Listado 7-8 que modela la situación en la que un chef corrige un pedido incorrecto y se lo presenta personalmente al cliente. La función <code>fix_incorrect_order</code> definida en el módulo <code>back_of_house</code> llama a la función <code>deliver_order</code> definida en el módulo padre especificando la ruta a <code>deliver_order</code> comenzando con <code>super</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 7-8: llamando a una función usando una ruta relativa que comienza con <code>super</code></span></p>
<p>La función <code>fix_incorrect_order</code> está en el módulo <code>back_of_house</code>, por lo que podemos usar <code>super</code> para ir al módulo padre de <code>back_of_house</code>, que en este caso es <code>crate</code>, la raíz. A partir de ahí, buscamos <code>deliver_order</code> y lo encontramos. ¡Éxito! Creemos que es probable que el módulo <code>back_of_house</code> y la función <code>deliver_order</code> mantengan la misma relación entre sí y se muevan juntos si decidimos reorganizar el árbol de módulos del crate. Por lo tanto, usamos <code>super</code> para tener menos lugares donde actualizar código en el futuro si este código se mueve a un módulo diferente.</p>
<h3 id="haciendo-públicos-structs-y-enums"><a class="header" href="#haciendo-públicos-structs-y-enums">Haciendo Públicos Structs y Enums</a></h3>
<p>También podemos usar <code>pub</code> para designar structs y enums como públicos, pero hay algunos detalles adicionales al uso de <code>pub</code> con structs y enums. Si usamos <code>pub</code> antes de una definición de struct, hacemos público el struct, pero los campos del struct seguirán siendo privados. Podemos hacer público o no cada campo según el caso. En el Listado 7-9, hemos definido un struct <code>back_of_house::Breakfast</code> público con un campo <code>toast</code> público pero un campo <code>seasonal_fruit</code> privado. Este es un modelo del caso en un restaurante donde el cliente puede elegir el tipo de pan que viene con una comida, pero el chef decide qué fruta acompaña la comida en función de lo que está en temporada y en stock. La fruta disponible cambia rápidamente, por lo que los clientes no pueden elegir la fruta o incluso ver qué fruta obtendrán.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // En verano, ordene un desayuno con tostada de centeno (Rye toast)
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Cambiemos de opinión sobre qué pan nos gustaría (wheat: trigo)
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // La siguiente línea no se compilará si la descomentamos; no se nos permite 
    // ver o modificar la fruta de temporada que viene con la comida 
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 7-9: Un struct con algunos campos públicos y algunos campos privados</span></p>
<p>Debido a que el campo <code>toast</code> en el struct <code>back_of_house::Breakfast</code> es público, en <code>eat_at_restaurant</code> podemos escribir y leer en el campo <code>toast</code> usando la notación de puntos. Tenga en cuenta que no podemos usar el campo <code>seasonal_fruit</code> en <code>eat_at_restaurant</code> porque <code>seasonal_fruit</code> es privado. ¡Intente descomentar la línea que modifica el valor del campo <code>season_fruit</code> para ver qué error obtiene!</p>
<p>Además, tenga en cuenta que debido a que <code>back_of_house::Breakfast</code> tiene un campo privado, el struct debe proporcionar una función asociada pública que construya una instancia de <code>Breakfast</code> (la llamamos <code>summer</code> aquí). Si <code>Breakfast</code> no tuviera esa función, no podríamos crear una instancia de <code>Breakfast</code> en <code>eat_at_restaurant</code> porque no podríamos establecer el valor del campo privado <code>seasonal_fruit</code> en <code>eat_at_restaurant</code>.</p>
<p>Por el contrario, si hacemos público un enum, todas sus variantes son públicas. Solo necesitamos <code>pub</code> antes de la palabra clave <code>enum</code>, como se muestra en el Listado 7-10.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 7-10: Designar un enum como público hace que todas sus variantes sean públicas</span></p>
<p>Debido a que hicimos público el enum <code>Appetizer</code>, podemos usar las variantes <code>Soup</code> y <code>Salad</code> en <code>eat_at_restaurant</code>.</p>
<p>Los enums no son muy útiles a menos que sus variantes sean públicas. Sería molesto tener que anotar todas las variantes de enum con <code>pub</code> en todos los casos, por lo que el valor predeterminado para las variantes de enum es <em>público</em>. Los structs suelen ser útiles sin que sus campos sean públicos, por lo que los campos de struct siguen la regla general de que todo sea privado de forma predeterminada, a menos que se anote con <code>pub</code>.</p>
<p>Hay una situación más relacionada con <code>pub</code> que no hemos cubierto, y esa es nuestra última característica del module system: la palabra clave <code>use</code>. Primero cubriremos <code>use</code> por sí solo, y luego mostraremos cómo combinar <code>pub</code> y <code>use</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="llevando-rutas-al-scope-con-la-palabra-clave-use"><a class="header" href="#llevando-rutas-al-scope-con-la-palabra-clave-use">Llevando Rutas al Scope con la Palabra Clave <code>use</code></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="separación-de-módulos-en-diferentes-archivos"><a class="header" href="#separación-de-módulos-en-diferentes-archivos">Separación de Módulos en Diferentes Archivos</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colecciones-comunes"><a class="header" href="#colecciones-comunes">Colecciones comunes</a></h1>
<p>La biblioteca estándar de Rust incluye varias estructuras de datos muy útiles
llamadas <em>colecciones</em>. La mayoría de los otros tipos de datos representan un
valor específico, pero las colecciones pueden contener múltiples valores. A
diferencia de los tipos de matriz y tupla incorporados, los datos a los que
apuntan estas colecciones se almacenan en el montículo (<em>heap</em>), lo que
significa que no
es necesario conocer la cantidad de datos en tiempo de compilación y pueden
aumentar o disminuir a medida que se ejecuta el programa. Cada tipo de
colección tiene diferentes capacidades y costos, y elegir uno apropiado para
su situación actual es una habilidad que desarrollará con el tiempo. En este
capítulo, analizaremos tres colecciones que se utilizan muy a menudo en los
programas de Rust:</p>
<ul>
<li>Un <em>vector</em> le permite almacenar un número variable de valores uno al lado
del otro.</li>
<li>Un <em>string</em> es una colección de caracteres. Ya hemos mencionado el tipo
<code>String</code> anteriormente, pero en este capítulo hablaremos en profundidad.</li>
<li>Un <em>hash map</em> le permite asociar un valor con una clave particular. Es una
implementación particular de la estructura de datos más general llamada
<em>map</em>.</li>
</ul>
<p>Para conocer los otros tipos de colecciones proporcionadas por la biblioteca estándar, consulte <a href="../../std/collections/index.html">la documentación</a>.</p>
<p>Discutiremos cómo crear y actualizar <em>vectores</em>, <em>strings</em> y <em>mapas hash</em>, así como también lo que hace que cada especial.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenamiento-de-listas-de-valores-con-vectores"><a class="header" href="#almacenamiento-de-listas-de-valores-con-vectores">Almacenamiento de listas de valores con vectores</a></h2>
<p>El primer tipo de colección que veremos es <code>Vec &lt;T&gt;</code>, también conocido como
<em>vector</em>. Los vectores le permiten almacenar más de un valor en una sola
estructura de datos que coloca todos los valores uno al lado del otro en la
memoria. Los vectores solo pueden almacenar valores del mismo tipo. Son
útiles cuando tiene una lista de elementos, como las líneas de texto en un
archivo o los precios de los artículos en un carrito de compras.</p>
<h3 id="creando-un-nuevo-vector"><a class="header" href="#creando-un-nuevo-vector">Creando un nuevo Vector</a></h3>
<p>Para crear un nuevo vector vacío, podemos llamar a la función <code>Vec::new</code>,
como se muestra en el Listado 8-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-1: Creando un nuevo vector vacío para
contener valores del tipo <code>i32</code></span></p>
<p>Tenga en cuenta que agregamos una anotación de tipo aquí. Como no estamos
insertando ningún valor en este vector, Rust no sabe qué tipo de elementos pretendemos almacenar. Éste es un punto importante. Los vectores se
implementan usando genéricos; cubriremos cómo usar genéricos con sus propios
tipos en el Capítulo 10. Por ahora, sepa que el tipo <code>Vec &lt;T&gt;</code> proporcionado
por la biblioteca estándar puede contener cualquier tipo, y cuando un vector
específico tiene un tipo específico, el tipo se especifica dentro de los
corchetes angulares. En el listado 8-1, le hemos dicho a Rust que <code>Vec &lt;T&gt;</code>
en <code>v</code> contendrá elementos del tipo <code>i32</code>.</p>
<p>En un código más realista, Rust a menudo puede inferir el tipo de valor que
desea almacenar una vez que inserta los valores, por lo que rara vez necesita
hacer esta anotación de tipo. Es más común crear un <code>Vec &lt;T&gt;</code> que tiene
valores iniciales, y Rust proporciona la macro <code>vec!</code> Para mayor comodidad.
La macro creará un nuevo vector que contiene los valores que le das. El
listado 8-2 crea un nuevo <code>Vec &lt;i32&gt;</code> que contiene los valores <code>1</code>,<code>2</code> y <code>3</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-2: Creando un nuevo vector que contiene
valores</span></p>
<p>Como hemos dado valores iniciales de <code>i32</code>, Rust puede inferir que el tipo
de <code>v</code> es <code>Vec &lt;i32&gt;</code>, y la anotación de tipo no es necesaria. A continuación
veremos cómo modificar un vector.</p>
<h3 id="actualizando-un-vector"><a class="header" href="#actualizando-un-vector">Actualizando un Vector</a></h3>
<p>Para crear un vector y luego agregarle elementos, podemos usar el método <code>push</code>, como se muestra en el Listado 8-3.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-3: Usando el método <code>push</code> para agregar
valores a un vector</span></p>
<p>Como con cualquier variable, si queremos poder cambiar su valor, tenemos que
hacerlo mutable usando la palabra clave <code>mut</code>, como se discutió en el
Capítulo 3. Los números que colocamos dentro son todos de tipo <code>i32</code>, y Rust
infiere esto de los datos, por lo que no necesitamos la anotación <code>Vec &lt;i32&gt;</code>.</p>
<h3 id="dropping-un-vector-drops-sus-elementos"><a class="header" href="#dropping-un-vector-drops-sus-elementos">Dropping un Vector <em>Drops</em> sus elementos</a></h3>
<p>Como cualquier otra <code>struct</code>, un vector se libera cuando sale del alcance, como se indica en el Listado 8-4.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // hacer cosas con v

} // &lt;- v sale del alcance y se libera aquí
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-4: Mostrando donde el vector y sus elementos son caídos (<em>dropped</em>)</span></p>
<p>Cuando el vector se descarta, todos sus contenidos también se descartan, lo
que significa que los enteros que contiene se limpiarán. Esto puede parecer
un punto directo, pero puede ser un poco más complicado cuando comiences a
introducir referencias a los elementos del vector. ¡Vamos a abordar eso lo
próximo!</p>
<h3 id="lectura-de-elementos-de-vectores"><a class="header" href="#lectura-de-elementos-de-vectores">Lectura de elementos de vectores</a></h3>
<p>Ahora que sabe cómo crear, actualizar y destruir vectores, saber cómo leer
sus contenidos es un buen paso. Hay dos formas de referenciar un valor
almacenado en un vector. En los ejemplos, hemos anotado los tipos de valores
que se devuelven de estas funciones para una mayor claridad.</p>
<p>El Listado 8-5 muestra ambos métodos de acceso a un valor en un vector, ya
sea con sintaxis de indexación o el método <code>get</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-5: Usar la sintaxis de indexación o el método
<code>get</code> para acceder a un elemento en un vector</span></p>
<p>Tenga en cuenta dos detalles aquí. Primero, usamos el valor de índice de <code>2</code>
para obtener el tercer elemento: los vectores están indexados por número,
comenzando por cero. Segundo, las dos formas de obtener el tercer elemento
son usando <code>&amp;</code> y <code>[]</code>, que nos da una referencia, o usando el método <code>get</code>
con el índice pasado como argumento, lo que nos da una<code>Opción &lt;&amp;T&gt;</code>.</p>
<p>Rust tiene dos formas de hacer referencia a un elemento para que pueda elegir
cómo se comporta el programa cuando intenta usar un valor de índice para el
que el vector no tiene un elemento. Como ejemplo, veamos qué hará un programa
si tiene un vector que contiene cinco elementos y luego intenta acceder a un
elemento en el índice 100, como se muestra en el Listado 8-6.</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-6: Intentando acceder al elemento en el
índice 100 en un vector que contiene cinco elementos</span></p>
<p>Cuando ejecutamos este código, el primer método <code>[]</code> hará que el programa
entre en pánico porque hace referencia a un elemento inexistente. Este método
se usa mejor cuando quiere que su programa se bloquee si hay un intento de
acceder a un elemento más allá del fin del vector.</p>
<p>Cuando el método <code>get</code> se pasa un índice que está fuera del vector, regresa
<code>None</code> sin entrar en pánico. Deberías usar este método si accedes a un
elemento más allá del rango del vector ocurre ocasionalmente bajo
circunstancias normales. Su código tendrá lógica para manejar tener
<code>Some(&amp;element)</code> o <code>None</code>, como se discutió en el Capítulo 6. Por ejemplo, el
índice podría venir de una persona que ingresa un número. Si ingresan
accidentalmente un número que también es grande y el programa obtiene un
valor <code>None</code>, podría decirle al usuario cuántos artículos están en el vector
actual y les da otra oportunidad de ingresar un válido valor. Eso sería más
fácil de usar que estrellar el programa debido a un error tipográfico.</p>
<p>Cuando el programa tiene una referencia válida, el comprobador de préstamos
impone las reglas de propiedad y de endeudamiento (cubiertas en el Capítulo 4)para asegurar esta referencia y cualquier otra referencia a los contenidos
del vector sigue siendo válida. Recuerda la regla establece que no puede haber referencias mutables e inmutables en el mismo alcance. Esa regla se
aplica en el Listado 8-7, donde tenemos una referencia inmutable a el primer elemento en un vector e intenta agregar un elemento al final, que no trabajó.</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p><span class="caption">Listing 8-7: Intentando agregar un elemento a un vector
mientras se mantiene una referencia a un elemento</span></p>
<p>Compilar este código dará como resultado este error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt;
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^ mutable borrow occurs here
7 |
8 | }
  | - immutable borrow ends here
</code></pre>
<p>El código en el listado 8-7 podría parecer que debería funcionar: ¿por qué
una referencia al primer elemento se preocupa por qué cambios al final del
vector? Este error se debe a la forma en que funcionan los vectores: agregar
un nuevo elemento al final del vector puede requerir asignar nueva memoria y
copiar los elementos antiguos al nuevo espacio, si no hay espacio suficiente
para poner todos los elementos al lado de cada uno otro donde el vector es
actualmente. En ese caso, la referencia al primer elemento estaría apuntando
a la memoria desasignada. Las reglas de endeudamiento evitan que los
programas terminen en esa situación.</p>
<blockquote>
<p>Nota: para obtener más información sobre los detalles de implementación del
tipo <code>Vec &lt;T&gt;</code>, “The
Rustonomicon” en https://doc.rust-lang.org/stable/nomicon/vec.html.</p>
</blockquote>
<h3 id="iterando-sobre-los-valores-en-un-vector"><a class="header" href="#iterando-sobre-los-valores-en-un-vector">Iterando sobre los valores en un vector</a></h3>
<p>Si queremos acceder a cada elemento en un vector a su vez, podemos iterar a
través de todos los elementos en lugar de usar índices para acceder uno a la
vez. El Listado 8-8 muestra cómo usar un bucle <code>for</code> para obtener referencias
inmutables a cada elemento en un vector de valores <code>i32</code> e imprimirlos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-8: Imprimir cada elemento en un vector
iterando sobre los elementos usando un bucle <code>for</code></span></p>
<p>También podemos iterar sobre referencias mutables a cada elemento en un
vector mutable para hacer cambios a todos los elementos. El bucle <code>for</code> en el
Listado 8-9 agregará <code>50</code> a cada elemento.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-9: Iteración sobre referencias mutables a
elementos en un vector</span></p>
<p>Para cambiar el valor al que se refiere la referencia mutable, debemos usar
el operador de desreferencia (<code>*</code>) para obtener el valor en <code>i</code> antes de
poder usar el operador <code>+=</code>.</p>
<h3 id="usando-un-enum-para-almacenar-múltiples-tipos"><a class="header" href="#usando-un-enum-para-almacenar-múltiples-tipos">Usando un <em>Enum</em> para almacenar múltiples tipos</a></h3>
<p>Al comienzo de este capítulo, dijimos que los vectores solo pueden almacenar
valores que son del mismo tipo. Esto puede ser un inconveniente;
definitivamente hay casos de uso para la necesidad de almacenar una lista de
artículos de diferentes tipos. Afortunadamente, las variantes de una
enumeración se definen bajo el mismo tipo de enumeración, de modo que cuando
necesitamos almacenar elementos de un tipo diferente en un vector, podemos
definir y usar una enumeración.</p>
<p>Por ejemplo, supongamos que queremos obtener valores de una fila en una hoja
de cálculo en la que algunas de las columnas de la fila contienen números
enteros, algunos números de coma flotante y algunas cadenas. Podemos definir
una enumeración cuyas variantes contendrán los diferentes tipos de valores, y
luego todas las variantes enum se considerarán del mismo tipo: la de la
enumeración. Entonces podemos crear un vector que contenga esa enumeración y
así, en última instancia, tenga diferentes tipos. Hemos demostrado esto en el
Listado 8-10.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-10: Definir un <code>enum</code> para almacenar valores
de diferentes tipos en un vector</span></p>
<p>Rust necesita saber qué tipos estarán en el vector en el momento de la
compilación para que sepa exactamente cuánta memoria en el montículo (<em>heap</em>)
será necesaria para almacenar cada elemento. Una ventaja secundaria es que
podemos ser explícitos sobre qué tipos están permitidos en este vector. Si Rust permitiera que un vector retuviera cualquier tipo, existiría la
posibilidad de que uno o más de los tipos causen errores con las operaciones
realizadas en los elementos del vector. El uso de una expresión enum más
<code>match</code> significa que Rust se asegurará en el momento de la compilación de
que se manejen todos los casos posibles, como se discutió en el Capítulo 6.</p>
<p>Cuando estás escribiendo un programa, si no conoces el conjunto exhaustivo de
tipos que el programa obtendrá en tiempo de ejecución para almacenarlo en un vector, la técnica <em>enum</em> no funcionará. En cambio, puede usar un objeto
<em>trait</em>, que veremos en el Capítulo 17.</p>
<p>Ahora que hemos discutido algunas de las formas más comunes de usar vectores,
asegúrese de revisar la documentación de API para todos los muchos métodos
útiles definidos en <code>Vec &lt;T&gt;</code> por la biblioteca estándar. Por ejemplo, además
de <code>push</code>, un método <code>pop</code> elimina y devuelve el último elemento. Pasemos al
siguiente tipo de colección: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenamiento-de-texto-codificado-en-utf-8-con-strings"><a class="header" href="#almacenamiento-de-texto-codificado-en-utf-8-con-strings">Almacenamiento de texto codificado en UTF-8 con <em>Strings</em></a></h2>
<p>Hablamos sobre <em>strings</em> de caracteres en el Capítulo 4, pero las veremos con
más profundidad ahora. Los nuevos Rustaceans comúnmente se atascan en los
<em>strings</em> por una combinación de tres razones: la propensión de Rust a
exponer posibles errores, los <em>strings</em> son una estructura de datos más
complicada de lo que muchos programadores les dan crédito, y UTF-8. Estos
factores se combinan de una manera que puede parecer difícil cuando proviene
de otros lenguajes de programación.</p>
<p>Es útil analizar los <em>strings</em> en el contexto de las colecciones porque los
<em>strings</em> se implementan como una colección de bytes, además de algunos
métodos para proporcionar una funcionalidad útil cuando esos bytes se
interpretan como texto. En esta sección, hablaremos sobre las operaciones en
<code>String</code> que tiene cada tipo de colección, como crear, actualizar y leer.
También discutiremos las formas en que <code>String</code> es diferente de las otras
colecciones, es decir, cómo la indexación en un <code>String</code> se complica por las
diferencias entre la forma en que las personas y las computadoras interpretan
los datos de <code>String</code>.</p>
<h3 id="qué-es-un-string"><a class="header" href="#qué-es-un-string">¿Qué es un <em>String</em>?</a></h3>
<p>Primero definiremos lo que queremos decir con el término <em>string</em>. Rust solo
tiene un tipo de <em>string</em> en el nucleo del lenguaje, que es el segmento de
<em>string</em> <code>str</code> que se ve generalmente en su forma prestada <code>&amp;str</code>. En el
Capítulo 4, hablamos sobre <em>string slices</em>, que son referencias a algunos
datos de <em>string</em> codificados en UTF-8 almacenados en otro lugar. <em>String</em>
literales, por ejemplo, se almacenan en la salida binaria del programa y son
por lo tanto, secciones de <em>string</em>.</p>
<p>El tipo <code>String</code>, proporcionado por la biblioteca estándar de Rust en lugar de
codificado en el lenguaje central, es un código UTF-8 creable, mutable, de
propiedad, tipo de <em>string</em> codificado. Cuando los Rustaceos se refieren a
<em>string</em> en Rust, generalmente se refieren a lo tipos <code>String</code> y los <em>string
slice</em> <code>&amp;str</code>, no solo uno de esos tipos.
Aunque esta sección trata principalmente sobre <code>String</code>, ambos tipos se usan
mucho en la biblioteca estándar de Rust, y tanto <code>String</code> como las <em>string
slice</em> están codificadas en UTF-8.</p>
<p>La biblioteca estándar de Rust también incluye varios otros tipos de <em>string</em>,como <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, y <code>CStr</code>. Los <em>library crates</em> pueden
proporcionar incluso más opciones para almacenar datos de <em>string</em>. ¿Ve cómo todos esos nombres terminan en <code>String</code> o <code>Str</code>? Se refieren a variantes
propias y prestadas, al igual que el tipo <code>String</code> y <code>str</code> que has visto
anteriormente. Estos tipos de <em>string</em> pueden almacenar texto en diferentes
codificaciones o ser representado en la memoria de una manera diferente, por
ejemplo. No discutiremos estos otros tipos de <em>string</em> en este capítulo; ver
su documentación API para obtener más información sobre cómo usarlos y cuándo
es cada uno apropiado.</p>
<h3 id="creando-un-nuevo-string"><a class="header" href="#creando-un-nuevo-string">Creando un nuevo <em>string</em></a></h3>
<p>Muchas de las mismas operaciones disponibles con <code>Vec &lt;T&gt;</code> están disponibles con <code>String</code> también, comenzando con la función <code>new</code> para crear una <em>string</em> que se muestra en el Listado 8-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-11: Creando un nuevo <code>String</code> vacío </span></p>
<p>Esta línea crea un nuevo <em>string</em> vacío llamado <code>s</code>, en el que luego podemos
cargar datos. A menudo, tendremos algunos datos iniciales con los que
queremos comenzar el <em>string</em>. Para eso, usamos el método <code>to_string</code>, que
está disponible en cualquier tipo que implemente el <em>trait</em> <code>Display</code>, como
lo hacen los literales <em>string</em>. El Listado 8-12 muestra dos ejemplos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = &quot;initial contents&quot;;

let s = data.to_string();

// el método también funciona en un literal directamente:
let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-12: Usando el método <code>to_string</code> para crear
un <code>String</code> a partir de un <em>string</em> literal </span></p>
<p>Este código crea un <em>string</em> que contiene <code>initial contents</code>.</p>
<p>También podemos usar la función <code>String::from</code> para crear un <code>String</code> a
partir de un <em>string</em> literal. El código en el Listado 8-13 es equivalente al
código del Listado 8-12 que usa <code>to_string</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-13: Usando la función <code>String::from</code> para
crear un <code>String</code> a partir de un <em>string</em> literal</span></p>
<p>Como los <em>string</em> se utilizan para muchas cosas, podemos usar muchas API
genéricas diferentes para <em>string</em>, lo que nos brinda muchas opciones.
Algunos de ellos pueden parecer redundantes, ¡pero todos tienen su lugar! En
este caso, <code>String::from</code> y <code>to_string</code> hacen lo mismo, por lo que eligir uno u otro es una cuestión de estilo.</p>
<p>Recuerde que los <em>string</em> están codificadas en UTF-8, por lo que podemos
incluir cualquier información codificada correctamente en ellas, como se
muestra en el Listado 8-14.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-14: Almacenando de saludos en diferentes
idiomas en <em>string</em></span></p>
<p>Todos estos son valores válidos de <code>String</code>.</p>
<h3 id="actualizar-un-string"><a class="header" href="#actualizar-un-string">Actualizar un <em>String</em></a></h3>
<p>Un <code>String</code> puede crecer en tamaño y su contenido puede cambiar, al igual que
el contenido de un <code>Vec &lt;T&gt;</code>, si inserta más datos en él. Además, puede usar
convenientemente el operador <code>+</code> o la macro <code>format!</code> Para concatenar los
valores <code>String</code>.</p>
<h4 id="añadiendo-a-un-string-con-push_str-y-push"><a class="header" href="#añadiendo-a-un-string-con-push_str-y-push">Añadiendo a un <em>String</em> con <code>push_str</code> y <code>push</code></a></h4>
<p>Podemos hacer crecer un <code>String</code> utilizando el método <code>push_str</code> para añadir
un segmento de <em>string</em>, como se muestra en el Listado 8-15.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-15: Agregar un segmento de <em>string</em> a un
<code>String</code> usando el método <code>push_str</code></span></p>
<p>Después de estas dos líneas, <code>s</code> contendrá <code>foobar</code>. El método <code>push_str</code>
toma un segmento de un <em>string</em> porque no necesariamente queremos tomar
posesión del parámetro. Por ejemplo, el código en el Listado 8-16 muestra que
sería desafortunado si no pudiéramos usar <code>s2</code> después de agregar sus
contenidos a <code>s1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-16: Usando un segmento de <em>string</em> después de
añadir su contenido a un <code>String</code></span></p>
<p>Si el método <code>push_str</code> se apropiara de <code>s2</code>, no podríamos imprimir su valor
en la última línea. Sin embargo, este código funciona como esperábamos.</p>
<p>El método <code>push</code> toma un solo carácter como parámetro y lo agrega a <code>String</code>.
El Listado 8-17 muestra un código que agrega la letra <em>l</em> a un <code>String</code>
utilizando el método <code>push</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-17: Agregar un carácter a un valor <code>String</code>
con <code>push</code></span></p>
<p>Como resultado de este código, <code>s</code> contendrá <code>lol</code>.</p>
<h4 id="concatenación-con-el-operador--o-la-macro-format"><a class="header" href="#concatenación-con-el-operador--o-la-macro-format">Concatenación con el operador <code>+</code> o la Macro <code>format!</code></a></h4>
<p>A menudo, querrás combinar dos <em>string</em> existentes. Una forma es usar el operador <code>+</code>, como se muestra en el Listado 8-18.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // nota s1 se ha movido aquí y ya no se puede usar
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-18: Usando el operador <code>+</code> para combinar dos
valores <code>String</code> en un nuevo valor 'String`</span></p>
<p>El <em>string</em> <code>s3</code> contendrá <code>Hello, world!</code> como resultado de este código. El
motivo <code>s1</code> ya no es válido después de la adición y el motivo por el que
usamos una referencia a <code>s2</code> tiene que ver con la firma del método que se
llama cuando usamos el operador <code>+</code>. El operador <code>+</code> usa el método <code>add</code>,
cuya firma se ve más o menos así:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta no es la firma exacta que está en la biblioteca estándar: en la
biblioteca estándar, <code>add</code> se define usando genéricos. Aquí, estamos viendo
la firma de <code>add</code> con tipos de concreto sustituidos por los genéricos, que es
lo que sucede cuando llamamos a este método con valores <code>String</code>.
Discutiremos los genéricos en el Capítulo 10. Esta firma nos da las pistas
que necesitamos para comprender las partes difíciles del operador <code>+</code>.</p>
<p>Primero, <code>s2</code> tiene un <code>&amp;</code>, lo que significa que estamos agregando una
<em>referencia</em> de el segundo <em>string</em> a la primera <em>string</em> debido al parámetro <code>s</code>
en la función <code>add</code>: solo podemos agregar un <code>&amp; str</code>a un <code>String</code>; no podemos
agregar dos valores <code>String</code> juntos. Pero espera, el tipo de <code>&amp;s2</code> es
<code>&amp; String</code>, no <code>&amp;str</code>, como se especifica en el segundo parámetro para <code>add</code>. Entonces, ¿por qué compila el Listado 8-18?</p>
<p>La razón por la que podemos usar <code>&amp;s2</code> en la llamada a <code>add</code> es que el
compilador puede <em>forzar</em> el argumento <code>&amp;String</code> en un <code>&amp;str</code>. Cuando
llamamos al método <code>add</code>, Rust usa una coerción <em>deref</em>, que aquí convierte
<code>&amp;s2</code> en <code>&amp;s2[..]</code>. Analizaremos la coerción de <em>deref</em> con más profundidad
en el Capítulo 15. Como <code>add</code> no toma posesión del parámetro <code>s</code>, <code>s2</code>
seguirá siendo un <code>String</code> válido después de esta operación.</p>
<p>En segundo lugar, podemos ver en la firma que <code>add</code> toma posesión de <code>self</code>,
porque <code>self</code> <em>no</em> tiene un <code>&amp;</code>. Esto significa que <code>s1</code> en el Listado 8-18
se moverá a la llamada <code>add</code> y ya no será válido después de eso. Entonces,
aunque <code>let s3 = s1 + &amp;s2;</code> parece que copiará ambos <em>strings</em> y creará una
nueva, esta declaración toma posesión de <code>s1</code>, agrega una copia del contenido
de <code>s2</code>, y luego devuelve la propiedad de el resultado. En otras palabras,parece que está haciendo muchas copias pero no lo está; la implementación es más eficiente que la copia.</p>
<p>Si necesitamos concatenar varias <em>strings</em>, el comportamiento del operador <code>+</code>
se vuelve difícil de manejar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>En este punto, <code>s</code> será <code>tic-tac-toe</code>. Con todos los caracteres <code>+</code> y <code>&quot;</code>,
es difícil ver qué está sucediendo. Para una combinación de <em>string</em> más
complicada, podemos usar la macro <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Este código también establece <code>s</code> en <code>tic-tac-toe</code>. La macro <code>format!</code>
funciona de la misma manera que <code>println!</code>, pero en lugar de imprimir la
salida a la pantalla, devuelve un <code>String</code> con los contenidos. La versión del
código que utiliza <code>format!</code> es mucho más fácil de leer y no toma posesión de
ninguno de sus parámetros.</p>
<h3 id="indexación-en-strings"><a class="header" href="#indexación-en-strings">Indexación en <em>Strings</em></a></h3>
<p>En muchos otros lenguajes de programación, el acceso a caracteres
individuales en un <em>string</em> haciendo referencia a ellos por índice es una
operación válida y común. Sin embargo, si intenta acceder a partes de un
<code>String</code> usando la sintaxis de indexación en Rust, obtendrá un error.
Considere el código inválido en el Listado 8-19.</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p><span class="caption">Listing 8-19: Intentando utilizar la sintaxis de indexación con un String</span></p>
<p>Este código dará como resultado el siguiente error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>El error y la nota cuentan la historia: los <em>string</em> de Rust no son
compatibles con la indexación. ¿Pero por qué no? Para responder a esa
pregunta, debemos analizar cómo Rust almacena <em>strings</em>en la memoria.</p>
<h4 id="representación-interna"><a class="header" href="#representación-interna">Representación interna</a></h4>
<p>Un <code>String</code> es un contenedor sobre un <code>Vec &lt;u8&gt;</code>. Veamos algunas de nuestros
<em>string</em> de ejemplo UTF-8 codificadas correctamente del Listado 8-14. Primero
este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Hola&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<p>En este caso, <code>len</code> será 4, lo que significa que el vector que almacena el
<em>string</em> “Hola” tiene 4 bytes de longitud. Cada una de estas letras toma 1
byte cuando está codificada en UTF-8. Pero, ¿qué pasa con la siguiente línea?
(Tenga en cuenta que este <em>string</em> comienza con la letra cirílica mayúscula Ze,
no el número árabe 3.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Здравствуйте&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<p>Si se pregunta, cuán largo es el <em>string</em>, podría decir 12. Sin embargo,la respuesta de Rust es 24: ese es el número de bytes que se necesita para
codificar &quot;Здравствуйте&quot; en UTF-8, ya que cada valor escalar Unicode toma 2
bytes de almacenamiento. Por lo tanto, un índice en los bytes del <em>string</em> no
siempre se correlacionará con un valor escalar Unicode válido. Para demostrar,considere este código de Rust no válido:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>¿Cuál debería ser el valor de <code>answer</code>? ¿Debería ser <code>З</code>, la primera letra?
Cuando está codificado en UTF-8, el primer byte de <code>З</code> es <code>208</code> y el segundo
es <code>151</code>, por lo que <code>answer</code> debería ser <code>208</code>, pero <code>208</code> no es un carácter
válido por sí mismo. Devolver <code>208</code> probablemente no sea lo que un usuario
desearía si pidieran la primera letra de este <em>string</em>; sin embargo, esos son
los únicos datos que -Rust tiene un índice de bytes 0-. Los usuarios
generalmente no desean que se devuelva el valor del byte, incluso si el
<em>string</em> solo contiene letras latinas: si <code>&amp;&quot;hello&quot;[0]</code> eran códigos válidos
que devolvían el valor de byte, devolvería <code>104</code>, no <code>h</code>. Para evitar
devolver un valor inesperado y causar errores que podrían no descubrirse de
inmediato, Rust no compila este código en absoluto y evita malos entendidos
al principio del proceso de desarrollo.</p>
<h4 id="bytes-y-valores-escalares-y-clusters-de-grafema-oh-mi"><a class="header" href="#bytes-y-valores-escalares-y-clusters-de-grafema-oh-mi">¡Bytes y valores escalares y clusters de Grafema! ¡Oh mi!</a></h4>
<p>Otro punto acerca de UTF-8 es que en realidad hay tres formas relevantes de
mirar los <em>string</em> desde la perspectiva de Rust: como bytes, valores
escalares y clusters de grafemas (lo más parecido a lo que llamaríamos
<em>letras</em>).</p>
<p>Si miramos la palabra Hindi &quot;नमस्ते&quot; escrita en la secuencia de comandos
Devanagari, se almacena como un vector de valores 'u8` que se ve así:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Eso es 18 bytes y es la forma en que las computadoras finalmente almacenan
estos datos. Si los vemos como valores escalares Unicode, que son el tipo
<code>char</code> de Rust, esos bytes se ven así:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Aquí hay seis valores <code>char</code>, pero el cuarto y el sexto no son letras: son
diacríticos que no tienen sentido por sí mismos. Finalmente, si los vemos
como grupos de grafemas, obtendríamos lo que una persona llamaría las cuatro
letras que componen la palabra hindi:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust proporciona diferentes formas de interpretar los datos de <em>string</em> sin
formato que almacenan las computadoras para que cada programa pueda elegir la
interpretación que necesita, sin importar en qué idioma humano se encuentren
los datos.</p>
<p>Una razón final por la que Rust no nos permite indexar en un <code>String</code> para
obtener un carácter es que las operaciones de indexación siempre toman un
tiempo constante (O (1)). Pero no es posible garantizar ese rendimiento con
un <code>String</code>, porque Rust tendría que recorrer el contenido desde el principio
hasta el índice para determinar cuántos caracteres válidos había.</p>
<h3 id="cortando-strings"><a class="header" href="#cortando-strings">Cortando <em>Strings</em></a></h3>
<p>La indexación en un <em>string</em> a menudo es una mala idea porque no está claro
cuál debería ser el tipo de devolución de la operación de indexación de
<em>string</em>: un valor de byte, un carácter, un clúster de grafemas o un segmento
de <em>string</em>. Por lo tanto, Rust le pide que sea más específico si realmente
necesita usar índices para crear secciones de <em>string</em> (<em>string slices</em>).
Para ser más específico en su indexación e indicar que desea un segmento de
<em>string</em> (<em>string slices</em>), en lugar de indexar usando <code>[]</code> con un solo
número, puede usar <code>[]</code> con un rango para crear un segmento de <em>string</em>
(<em>string slices</em>) que contenga bytes particulares:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Aquí, <code>s</code> será un <code>&amp; str</code> que contiene los primeros 4 bytes del <em>string</em>.
Anteriormente, mencionamos que cada uno de estos caracteres tenía 2 bytes, lo
que significa que <code>s</code> será <code>Зд</code>.</p>
<p>¿Qué pasaría si usáramos <code>&amp;hello[0..1]</code>? La respuesta: Rust entraría en
pánico en tiempo de ejecución de la misma manera que si se accede a un índice
no válido en un vector:</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
</code></pre>
<p>Debe usar rangos para crear secciones de <em>string</em> con precaución, ya que al hacerlo puede bloquear su programa.</p>
<h3 id="métodos-para-iterar-sobre-strings"><a class="header" href="#métodos-para-iterar-sobre-strings">Métodos para iterar sobre <em>Strings</em></a></h3>
<p>Afortunadamente, puede acceder a elementos en un <em>string</em> de otras maneras.</p>
<p>Si necesita realizar operaciones en valores escalares Unicode individuales,
la mejor manera de hacerlo es usar el método <code>chars</code>. Llamar <code>chars</code> en“नमस्ते” se separa y devuelve seis valores de tipo <code>char</code>, y puede iterar sobre el resultado para acceder a cada elemento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimirá lo siguiente:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>El método <code>bytes</code> devuelve cada byte sin formato, que podría ser apropiado
para su dominio:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimirá los 18 bytes que componen este <code>String</code>:</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<p>Pero asegúrese de recordar que los valores escalares Unicode válidos pueden
estar formados por más de 1 byte.</p>
<p>Obtener clústeres de grafema a partir de <em>strings</em>es complejo, por lo que la
biblioteca estándar no proporciona esta funcionalidad. Los <em>Crates</em> están
disponibles en <a href="https://crates.io">crates.io</a> si esta es la funcionalidad que
necesita.</p>
<h3 id="los-strings-no-son-tan-simples"><a class="header" href="#los-strings-no-son-tan-simples">Los <em>Strings</em> no son tan simples</a></h3>
<p>Para resumir, los <em>string</em> son complicados. Diferentes lenguajes de
programación toman diferentes decisiones sobre cómo presentar esta
complejidad al programador. Rust ha elegido hacer que el manejo correcto de
los datos de <code>String</code> sea el comportamiento predeterminado de todos los
programas de Rust, lo que significa que los programadores tienen que pensar
más en manejar los datos de UTF-8 por adelantado. Este <em>trade-off</em> expone más
de la complejidad de los <em>string</em> de lo que es evidente en otros lenguajes de
programación, pero evita que tenga que manejar errores que involucren
caracteres no ASCII más adelante en su ciclo de vida de desarrollo.</p>
<p>Cambiemos a algo un poco menos complejo: ¡<em>hash maps</em>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="almacenamiento-de-claves-con-valores-asociados-en-hash-maps-mapa-hash"><a class="header" href="#almacenamiento-de-claves-con-valores-asociados-en-hash-maps-mapa-hash">Almacenamiento de claves con valores asociados en <em>Hash Maps</em> (<em>mapa hash</em>)</a></h2>
<p>La última de nuestras colecciones comunes es el <em>hash map</em>. El tipo
<code>HashMap&lt;K, V&gt;</code> almacena una asignación de claves de tipo <code>K</code> a valores de
tipo<code> V</code>. Lo hace mediante una <em>función de hash</em>, que determina cómo coloca
estas claves y valores en la memoria. Muchos lenguajes de programación
admiten este tipo de estructura de datos, pero a menudo usan un nombre
diferente, como hash, mapa, objeto, tabla hash o matriz asociativa, solo por
nombrar algunos.</p>
<p>Los mapas Hash (<em>hash map</em>) son útiles cuando se quiere buscar datos no
usando un índice, como se puede hacer con vectores, sino usando una clave que
puede ser de cualquier tipo. Por ejemplo, en un juego, puede hacer un
seguimiento del puntaje de cada equipo en un mapa hash en el que cada clave
es el nombre de un equipo y los valores son el puntaje de cada equipo. Dado
el nombre de un equipo, puedes recuperar su puntaje.</p>
<p>Repasaremos la API básica de los mapas hash en esta sección, pero muchas más
cosas se esconden en las funciones definidas en <code>HashMap &lt;K, V&gt;</code> por la
biblioteca estándar. Como siempre, consulte la documentación estándar de la
biblioteca para obtener más información.</p>
<h3 id="crear-un-nuevo-mapa-hash-hash-map"><a class="header" href="#crear-un-nuevo-mapa-hash-hash-map">Crear un nuevo <em>mapa hash</em> (<em>Hash Map</em>)</a></h3>
<p>Puede crear un mapa hash vacío con <code>new</code> y agregar elementos con <code>insert</code>. En
el Listado 8-20, estamos haciendo un seguimiento de las puntuaciones de dos
equipos cuyos nombres son “Blue” y “Yellow”. El equipo “Blue” comienza con 10
puntos, y el equipo “Yellow” comienza con 50.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-20: Creando un nuevo mapa hash e insertando
algunas claves y valores</span></p>
<p>Tenga en cuenta que necesitamos primero <code>use</code> el <code>HashMap</code> de la porción de
colecciones de la biblioteca estándar. De nuestras tres colecciones comunes,
esta es la menos utilizada, por lo que no está incluida en las
características introducidas automáticamente en el preludio. Los mapas Hash
también tienen menos soporte de la biblioteca estándar; no hay una macro
incorporada para construirlos, por ejemplo.</p>
<p>Al igual que los vectores, los mapas hash almacenan sus datos en el montículo
(<em>heap</em>). Este <code>HashMap</code> tiene claves de tipo <code>String</code> y valores de tipo
<code>i32</code>. Al igual que los vectores, los mapas hash son homogéneos: todas las
claves deben tener el mismo tipo, y todos los valores deben tener el mismo
tipo.</p>
<p>Otra forma de construir un mapa hash es usar el método <code>collect</code> en un vector
de tuplas, donde cada tupla consiste en una clave y su valor. El método
<code>collect</code> reúne datos en varios tipos de colección, incluido <code>HashMap</code>. Por
ejemplo, si tuviéramos los nombres de los equipos y puntajes iniciales en dos
vectores separados, podríamos usar el método <code>zip</code> para crear un vector de
tuplas donde “Blue” está emparejado con 10, y así sucesivamente. Entonces
podríamos usar el método <code>collect</code> para convertir ese vector de tuplas en un
mapa hash, como se muestra en el Listado 8-21.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-21: Crear un mapa hash a partir de una lista
de equipos y una lista de puntajes</span></p>
<p>La anotación de tipo <code>HashMap &lt;_, _&gt;</code> es necesaria aquí porque es posible
<code>recopilar</code> en muchas estructuras de datos diferentes y Rust no sabe cuál
quiere a menos que usted especifique. Para los parámetros para la clave y los
tipos de valor, sin embargo, usamos guiones bajos, y Rust puede inferir los
tipos que contiene el hash map en función de los tipos de datos en los
vectores.</p>
<h3 id="hash-maps-mapa-hash-y-propiedad"><a class="header" href="#hash-maps-mapa-hash-y-propiedad"><em>Hash Maps</em> (<em>mapa hash</em>) y Propiedad</a></h3>
<p>Para los tipos que implementan el <em>trait</em> <code>Copy</code>, como <code>i32</code>, los valores se
copian en el mapa hash. Para valores de propiedad como <code>String</code>, los valores
se moverán y el mapa de hash será el propietario de esos valores, como se
muestra en el Listado 8-22.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name y field_value no son válidos en este punto, intente usarlos y
// ¡mira qué error de compilación recibes!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-22: Mostrar que las claves y los valores son
propiedad del mapa hash una vez que se insertan</span></p>
<p>No podemos usar las variables <code>field_name</code> y <code>field_value</code> después de que se
hayan movido al mapa hash con la llamada a <code>insert</code>.</p>
<p>Si insertamos referencias a valores en el mapa hash, los valores no se
moverán al mapa hash. Los valores a los que apuntan las referencias deben ser
válidos por lo menos mientras el mapa hash sea válido. Hablaremos más sobre
estos temas en la sección “Validación de referencias con períodos de
vigencia” en el Capítulo 10.</p>
<h3 id="acceso-a-valores-en-un-mapa-hash-hash-map"><a class="header" href="#acceso-a-valores-en-un-mapa-hash-hash-map">Acceso a valores en un mapa hash (<em>Hash Map</em>)</a></h3>
<p>Podemos obtener un valor del <em>hash map</em> (<em>mapa hash</em>) proporcionando su clave
para el método <code>get</code>, como se muestra en el Listado 8-23.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-23: Accediendo al puntaje para el equipo azul
almacenado en el mapa hash</span></p>
<p>Aquí, <code>score</code> tendrá el valor asociado con el equipo Blue, y el resultado
será <code>Some(&amp;10)</code>. El resultado se envuelve en <code>Some</code> porque <code>get</code> devuelve
una <code>Opción &lt;&amp;V&gt;</code>; si no hay ningún valor para esa clave en el mapa hash,<code>get</code> devolverá <code>None</code>. El programa deberá manejar la <code>Option</code> en una de las
formas que cubrimos en el Capítulo 6.</p>
<p>Podemos iterar sobre cada par clave / valor en un mapa hash de manera similar a como lo hacemos con los vectores, usando un bucle <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprimirá cada par en un orden arbitrario:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="actualización-de-un-mapa-hash-hash-map"><a class="header" href="#actualización-de-un-mapa-hash-hash-map">Actualización de un mapa Hash (<em>Hash Map</em>)</a></h3>
<p>Aunque la cantidad de claves y valores puede crecer, cada clave solo puede
tener un valor asociado con ella a la vez. Cuando desee cambiar los datos en
un <em>hash map</em> (<em>mapa hash</em>), debe decidir cómo manejar el caso cuando una
clave ya tiene un valor asignado. Puede reemplazar el valor anterior por el
nuevo valor, sin tener en cuenta el valor anterior. Puede mantener el valor
anterior e ignorar el nuevo valor, solo agregando el nuevo valor si la clave
<em>no</em> tiene ya un valor. O puede combinar el valor anterior y el nuevo valor.
¡Veamos cómo hacer cada uno de estos!</p>
<h4 id="sobrescribir-un-valor"><a class="header" href="#sobrescribir-un-valor">Sobrescribir un valor</a></h4>
<p>Si insertamos una clave y un valor en un mapa hash e insertamos esa misma
clave con un valor diferente, el valor asociado con esa clave será
reemplazado. Aunque el código en el Listado 8-24 llama <code>insert</code> dos veces, el
hash map solo contendrá un par de clave/valor porque estamos insertando el
valor para la clave del equipo azul en ambas ocasiones.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-24: Reemplazar un valor almacenado con una
clave particular</span></p>
<p>Este código imprimirá <code>{&quot;Blue&quot;: 25}</code>. El valor original de <code>10</code> ha sido
sobrescrito.</p>
<h4 id="solo-insertar-un-valor-si-la-clave-no-tiene-valor"><a class="header" href="#solo-insertar-un-valor-si-la-clave-no-tiene-valor">Solo insertar un valor si la clave no tiene valor</a></h4>
<p>Es común verificar si una clave en particular tiene un valor y, si no lo
tiene, insertar un valor para ella. Los mapas hash tienen una API especial
para esta llamada <code>entry</code> que toma la clave que desea verificar como
parámetro. El valor de retorno del método <code>entry</code> es una enumeración llamada
<code>Entry</code> que representa un valor que podría existir o no. Digamos que
queremos verificar si la clave del equipo amarillo tiene un valor asociado.
Si no es así, queremos insertar el valor 50, y lo mismo para el equipo azul.
Usando la API <code>entry</code>, el código se ve como el Listado 8-25.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-25: Usando el método <code>entry</code> para insertar
solo si la clave ya no tiene un valor</span></p>
<p>El método <code>or_insert</code> en <code>Entry</code> se define para devolver una referencia
mutable al valor de la tecla <code>Entry</code> correspondiente si esa clave existe, y
si no, inserta el parámetro como el nuevo valor para esta clave y devuelve
una referencia mutable al nuevo valor. Esta técnica es mucho más limpia que
escribir la lógica nosotros mismos y, además, juega mejor con el comprobador
de préstamos.</p>
<p>Al ejecutar el código en el Listado 8-25 se imprimirá
<code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. La primera llamada a <code>entry</code> insertará la
clave para el equipo Amarillo con el valor 50 porque el equipo Amarillo ya no
tiene un valor. La segunda llamada a <code>entry</code> no cambiará el <em>hash map</em>
(<em>mapa hash</em>) porque el equipo azul ya tiene el valor 10.</p>
<h4 id="actualización-de-un-valor-basado-en-el-valor-anterior"><a class="header" href="#actualización-de-un-valor-basado-en-el-valor-anterior">Actualización de un valor basado en el valor anterior</a></h4>
<p>Otro caso de uso común para los mapas hash es buscar el valor de una clave y
luego actualizarla en función del valor anterior. Por ejemplo, el Listado
8-26 muestra un código que cuenta cuántas veces aparece cada palabra en algún
texto. Usamos un mapa hash con las palabras como teclas e incrementamos el
valor para realizar un seguimiento de cuántas veces hemos visto esa palabra.
Si es la primera vez que vemos una palabra, primero insertamos el valor 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-26: Recuento de ocurrencias de palabras
usando un mapa hash que almacena palabras y cuenta</span></p>
<p>Este código imprimirá <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. El método
<code>or_insert</code> en realidad devuelve una referencia mutable (<code>&amp;mut V</code>) al valor
de esta clave. Aquí almacenamos esa referencia mutable en la variable <code>count</code>,por lo que para asignar a ese valor, primero debemos eliminar la referencia
<code>count</code> utilizando el asterisco (<code>*</code>). La referencia mutable sale del alcance
al final del ciclo <code>for</code>, por lo que todos estos cambios son seguros y están
permitidos por las reglas de préstamo.</p>
<h3 id="funciones-hash"><a class="header" href="#funciones-hash">Funciones <em>hash</em></a></h3>
<p>Por defecto, <code>HashMap</code> utiliza una función hashing criptográficamente segura
que puede proporcionar resistencia a los ataques de denegación de servicio
(DoS). Este no es el algoritmo de hashing más rápido disponible, pero vale la
pena la compensación para una mejor seguridad que viene con la caída en el
rendimiento. Si perfila su código y descubre que la función hash
predeterminada es demasiado lenta para sus propósitos, puede cambiar a otra
función especificando un <em>hasher</em> diferente. Un <em>hasher</em> es un tipo que
implementa el <em>trait</em> <code>BuildHasher</code>. Hablaremos sobre los <em>trait</em> y cómo
implementarlos en el Capítulo 10. No necesariamente tiene que implementar su
propio hasher desde cero; [crates.io] (https://crates.io) tiene bibliotecas
compartidas por otros usuarios de Rust que proporcionan <em>hashers</em> que
implementan muchos algoritmos <em>hash</em> comunes.</p>
<h2 id="resumen-6"><a class="header" href="#resumen-6">Resumen</a></h2>
<p>Los vectores, <em>string</em> y <em>hash maps</em> proporcionarán una gran cantidad de
funcionalidad necesaria en los programas cuando necesite almacenar, acceder y
modificar datos. Aquí hay algunos ejercicios que ahora debes estar preparado
para resolver:</p>
<ul>
<li>Dada una lista de enteros, usa un vector y regresa la media (el valor
promedio), la media (cuando se clasifica, el valor en la posición media) y el modo (el valor que ocurre con mayor frecuencia, un <em>hash maps</em> será útil aquí ) de la lista.</li>
<li>Convertir <em>strings to pig latin</em>. La primera consonante de cada palabra se
mueve al final de la palabra y se agrega “ay”, por lo que “first” se convierte en “irst-fay.” Las palabras que comienzan con una vocal tienen “hay”agregado al final (&quot;apple &quot;Se convierte en “apple-hay”). ¡Tenga en cuenta los detalles sobre la codificación UTF-8!</li>
<li>Utilizando un <em>hash maps</em> y vectores, cree una interfaz de texto para
permitir que un usuario agregue nombres de empleados a un departamento de una empresa. Por ejemplo, &quot;Agregar Sally a la ingeniería&quot; o &quot;Agregar Amir a las ventas&quot;. Luego, permita que el usuario obtenga una lista de todas las personas de un departamento o de todas las personas de la empresa por departamento, ordenados alfabéticamente.</li>
</ul>
<p>¡La documentación estándar de la API de la biblioteca describe los métodos
que los vectores, los <em>string</em> y los <em>hash maps</em> ¡Eso será útil para estos
ejercicios!</p>
<p>Estamos entrando en programas más complejos en los que las operaciones pueden
fallar, por lo tanto, es un momento perfecto para analizar el manejo de
errores. ¡Haremos eso en el próximo!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manejo-de-errores"><a class="header" href="#manejo-de-errores">Manejo de errores</a></h1>
<p>El compromiso de Rust con la confiabilidad se extiende al manejo de errores.
Los errores son un hecho de la vida en el software, por lo que Rust tiene una
serie de características para manejar situaciones en las que algo sale mal.
En muchos casos, Rust requiere que reconozcas la posibilidad de un error y
actúes antes de compilar el código. Este requisito hace que su programa sea
más robusto al garantizar que descubrirá los errores y los manejará
adecuadamente antes de implementar su código en producción.</p>
<p>Rust agrupa los errores en dos categorías principales: <em>recuperables</em> y
<em>errores irrecuperables</em>. Para un error recuperable, como un error de archivo
no encontrado, es razonable informar el problema al usuario y volver a
intentar la operación. Los errores irrecuperables son siempre síntomas de
errores, como intentar acceder a una ubicación más allá del final de una
matriz.</p>
<p>La mayoría de los lenguajes no distinguen entre estos dos tipos de errores y
manejan ambos de la misma manera, usando mecanismos como excepciones. Rust no
tiene excepciones. En cambio, tiene el tipo <code>Result &lt;T, E&gt;</code> para los errores
recuperables y la macro <code>panic!</code> Que detiene la ejecución cuando el programa
encuentra un error irrecuperable. Este capítulo cubre la invocación de
<code>panic!</code> Primero y luego habla sobre la devolución de los valores
<code>Result &lt;T, E&gt;</code>. Además, exploraremos consideraciones al decidir si
intentamos recuperarnos de un error o detener la ejecución.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errores-irrecuperables-con-pánico"><a class="header" href="#errores-irrecuperables-con-pánico">Errores irrecuperables con <code>¡pánico!</code></a></h2>
<p>Algunas veces suceden cosas malas en su código, y no hay nada que pueda hacer
al respecto. En estos casos, Rust tiene la macro <code>¡pánico!</code>. Cuando se
ejecuta la macro <code>panic!</code>, Su programa imprimirá un mensaje de error,
desenrollará y limpiará la pila, y luego saldrá. Esto ocurre más comúnmente
cuando se ha detectado un error de algún tipo y el programador no tiene claro
cómo manejar el error.</p>
<blockquote>
<h3 id="desenrollar-la-pila-o-abortar-en-respuesta-a-un-pánico"><a class="header" href="#desenrollar-la-pila-o-abortar-en-respuesta-a-un-pánico">Desenrollar la pila o abortar en respuesta a un pánico</a></h3>
<p>De forma predeterminada, cuando se produce un ataque de pánico, el programa
comienza <em>desenrollarse</em>, lo que significa que Rust vuelve a subir la pila y
limpia los datos de cada función que encuentra. Pero este caminar de regreso
y limpiar es mucho trabajo. La alternativa es <em>abortar</em> inmediatamente, que
finaliza el programa sin limpiar. La memoria que el programa estaba usando
tendrá que ser limpiada por el sistema operativo. Si en su proyecto necesita
hacer que el binario resultante sea lo más pequeño posible, puede cambiar de
desenrollar a abortar ante un ataque de pánico agregando <code>panic = 'abort'</code> a
las secciones apropiadas <code>[profile]</code> en su <em>Cargo.toml</em> archivo. Por
ejemplo, si desea cancelar en pánico en el modo de lanzamiento, agregue
esto:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Tratemos de llamar &quot;panic!&quot; En un programa simple:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>Cuando ejecutas el programa, verás algo como esto:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>La llamada a <code>¡pánico!</code> Causa el mensaje de error contenido en las últimas
dos líneas. La primera línea muestra nuestro mensaje de pánico y el lugar en
nuestro código fuente donde ocurrió el pánico: <em>src/main.rs:2:4</em> indica que
es el segundo carácter de la segunda línea de nuestro archivo <em>src/main.rs</em>.</p>
<p>En este caso, la línea indicada es parte de nuestro código, y si vamos a esa
línea, vemos la llamada a macro <code>panic!</code>. En otros casos, la llamada
<code>¡pánico!</code> Podría estar en el código que llama nuestro código, y el nombre
del archivo y número de línea reportados por el mensaje de error será el
código de otra persona donde se llama la macro <code>¡pánico!</code>, No la línea código
que finalmente llevó a la llamada <code>¡pánico!</code>. Podemos usar la traza inversa
de las funciones de las que salió la llamada <code>panic!</code> Para descubrir la
parte de nuestro código que está causando el problema. Discutiremos lo que es
una traza inversa en más detalle a continuación.</p>
<h3 id="usando-un-panic-backtrace"><a class="header" href="#usando-un-panic-backtrace">Usando un <code>panic!</code> Backtrace</a></h3>
<p>Veamos otro ejemplo para ver cómo es cuando una llamada <code>panic!</code> Viene de una
biblioteca debido a un error en nuestro código en lugar de a un código que
llama directamente a la macro. El listado 9-1 tiene algún código que intenta
acceder a un elemento por índice en un vector.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Listing 9-1: Intentando acceder a un elemento más allá
del final de un vector, lo que provocará una llamada a <code>panic!</code></span></p>
<p>Aquí, estamos intentando acceder al centésimo elemento de nuestro vector (que
está en el índice 99 porque la indexación comienza en cero), pero solo tiene
3 elementos. En esta situación, Rust entrará en pánico. Se supone que el uso
de <code>[]</code> devuelve un elemento, pero si pasa un índice inválido, no hay ningún
elemento que Rust pueda devolver aquí que sea correcto.</p>
<p>Otros lenguajes, como C, intentarán darte exactamente lo que pediste en esta
situación, aunque no sea lo que quieres: obtendrás lo que esté en la
ubicación en la memoria que correspondería a ese elemento en el vector,
aunque la memoria no pertenece al vector. Esto se conoce como
<em>buffer overread</em> y puede generar vulnerabilidades de seguridad si un
atacante puede manipular el índice de forma que pueda leer datos que no
deberían almacenarse después de la matriz.</p>
<p>Para proteger su programa de este tipo de vulnerabilidad, si intenta leer un
elemento en un índice que no existe, Rust detendrá la ejecución y se negará a
continuar. Probemos y veamos:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', /checkout/src/liballoc/vec.rs:1555:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Este error apunta a un archivo que no escribimos, <em>vec.rs</em>. Esa es la
implementación de <code>Vec &lt;T&gt;</code> en la biblioteca estándar. El código que se
ejecuta cuando usamos <code>[]</code> en nuestro vector <code>v</code> está en <em>vec.rs</em>, y ahí es
donde <code>panic!</code> Está realmente sucediendo.</p>
<p>La siguiente línea de notas nos dice que podemos establecer la variable de
entorno <code>RUST_BACKTRACE</code> para obtener un seguimiento de exactamente lo que
sucedió para causar el error. A <em>backtrace</em> es una lista de todas las
funciones que se han llamado para llegar a este punto. Los backtraces en Rust
funcionan como lo hacen en otros idiomas: la clave para leer el <em>backtrace</em> es
comenzar desde la parte superior y leer hasta que vea los archivos que
escribió. Ese es el lugar donde se originó el problema. Las líneas sobre las
líneas que mencionan sus archivos son códigos que su código llamó; las líneas
a continuación son código que llamó su código. Estas líneas pueden incluir el
código principal de Rust, el código de biblioteca estándar o las cajas que
está utilizando. Tratemos de obtener una traza inversa configurando la
variable de entorno <code>RUST_BACKTRACE</code> en cualquier valor excepto 0. El listado
9-2 muestra resultados similares a los que verá.</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at /checkout/src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at /checkout/src/libstd/sys_common/backtrace.rs:60
             at /checkout/src/libstd/panicking.rs:381
   3: std::panicking::default_hook
             at /checkout/src/libstd/panicking.rs:397
   4: std::panicking::rust_panic_with_hook
             at /checkout/src/libstd/panicking.rs:611
   5: std::panicking::begin_panic
             at /checkout/src/libstd/panicking.rs:572
   6: std::panicking::begin_panic_fmt
             at /checkout/src/libstd/panicking.rs:522
   7: rust_begin_unwind
             at /checkout/src/libstd/panicking.rs:498
   8: core::panicking::panic_fmt
             at /checkout/src/libcore/panicking.rs:71
   9: core::panicking::panic_bounds_check
             at /checkout/src/libcore/panicking.rs:58
  10: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;usize&gt;&gt;::index
             at /checkout/src/liballoc/vec.rs:1555
  11: panic::main
             at src/main.rs:4
  12: __rust_maybe_catch_panic
             at /checkout/src/libpanic_unwind/lib.rs:99
  13: std::rt::lang_start
             at /checkout/src/libstd/panicking.rs:459
             at /checkout/src/libstd/panic.rs:361
             at /checkout/src/libstd/rt.rs:61
  14: main
  15: __libc_start_main
  16: &lt;unknown&gt;
</code></pre>
<p><span class="caption">Listing 9-2: La <em>backtrace</em> generada por una llamada a
<code>panic!</code> que se muestra cuando se establece la variable de entorno
<code>RUST_BACKTRACE</code></span></p>
<p>¡Eso es mucho rendimiento! La salida exacta que ve puede ser diferente
dependiendo de su sistema operativo y la versión de Rust. Para obtener
retrocesos con esta información, los símbolos de depuración deben estar
habilitados. Los símbolos de depuración están habilitados por defecto cuando
se usa <code>cargo build</code> o <code>cargo run</code> sin el indicador <code>--release</code>, como lo
tenemos aquí.</p>
<p>En la salida del Listado 9-2, la línea 11 del backtrace apunta a la línea en
nuestro proyecto que está causando el problema: línea 4 de <em>src/main.rs</em>. Si
no queremos que nuestro programa entre en pánico, la ubicación a la que
apunta la primera línea que menciona un archivo que escribimos es donde
deberíamos comenzar a investigar. En el listado 9-1, donde deliberadamente
escribimos un código que entraría en pánico para demostrar cómo usar trazas
inversas, la forma de solucionar el pánico es no solicitar un elemento en el
índice 99 a partir de un vector que solo contenga 3 elementos. Cuando su
código entre en pánico en el futuro, necesitará averiguar qué acción está
tomando el código con qué valores causar el pánico y qué debe hacer el código
en su lugar.</p>
<p>¡Volveremos a entrar en <code>panic!</code> y cuando deberíamos y no deberíamos usar
<code>panic!</code> Para manejar las condiciones de error en la sección “To <code>panic!</code> or
Not to <code>panic!</code>” Más adelante en este capítulo. A continuación, veremos cómo recuperarse de un error usando <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errores-recuperables-con-result"><a class="header" href="#errores-recuperables-con-result">Errores recuperables con <code>Result</code></a></h2>
<p>La mayoría de los errores no son lo suficientemente graves como para requerir
que el programa se detenga por completo. A veces, cuando una función falla,
es por una razón que puede interpretar y responder fácilmente. Por ejemplo,
si intenta abrir un archivo y esa operación falla porque el archivo no existe
es posible que desee crear el archivo en lugar de finalizar el proceso.</p>
<p>Recuerde “<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">Manejo de la falla potencial con el tipo <code>Result</code></a> <!-- ignore -->” en el Capítulo 2 que la enumeración <code>Result</code> se define como que tiene dos variantes, <code>Ok</code> y <code>Err</code>, como sigue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>El <code>T</code> y <code>E</code> son parámetros de tipo genérico: discutiremos los genéricos con
más detalle en el Capítulo 10. Lo que necesita saber ahora es que <code>T</code>
representa el tipo del valor que se devolverá en un éxito caso dentro de la
variante <code>Ok</code>, y <code>E</code> representa el tipo de error que se devolverá en un caso
de falla dentro de la variante <code>Err</code>. Como <code>Result</code> tiene estos parámetros de
tipo genérico, podemos utilizar el tipo <code>Result</code> y las funciones que la
biblioteca estándar ha definido en él en muchas situaciones diferentes en las
que el valor correcto y el valor de error que queremos devolver pueden
diferir.</p>
<p>Llamemos a una función que devuelve un valor <code>Result</code> porque la función
podría fallar. En el Listado 9-3 tratamos de abrir un archivo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: Apertura de un archivo</span></p>
<p>¿Cómo sabemos que <code>File::open</code> devuelve un <code>Result</code>? ¡Podríamos mirar la
documentación estándar de la API de la biblioteca, o podríamos preguntarle al
compilador! Si le damos a <code>f</code> una anotación de tipo que sabemos que es <em>no</em> el tipo de retorno de la función y luego tratamos de compilar el código, el compilador nos dirá que los tipos no coinciden. El mensaje de error nos dirá
qué tipo de <code>f</code> <em>es</em>. ¡Vamos a intentarlo! Sabemos que el tipo de devolución
de <code>File::open</code> no es del tipo <code>u32</code>, así que cambiemos la declaración <code>let f</code> a esto:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Intentar compilar ahora nos da el siguiente resultado:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>Esto nos dice que el tipo de retorno de la función <code>File::open</code> es
<code>Result &lt;T, E&gt;</code>. El parámetro genérico <code>T</code> se ha rellenado aquí con el tipo
de valor de éxito,<code>std::fs::File</code>, que es un manejador de archivo. El tipo de
<code>E</code> utilizado en el valor de error es <code>std::io::Error</code>.</p>
<p>Este tipo de devolución significa que la llamada a <code>File::open</code> puede tener
éxito y devolver un manejador de archivo que podemos leer o escribir en. La
llamada a la función también puede fallar: por ejemplo, es posible que el
archivo no exista o que no tengamos permiso para acceder al archivo. La
función <code>File::open</code> necesita tener una forma de decirnos si tuvo éxito o no,
y al mismo tiempo proporcionarnos el identificador del archivo o la
información del error. Esta información es exactamente lo que transmite el
enum de <code>Result</code>.</p>
<p>En el caso donde <code>File::open</code> tiene éxito, el valor en la variable <code>f</code> será
una instancia de <code>Ok</code> que contiene un manejador de archivo. En el caso donde
falla, el valor en <code>f</code> será una instancia de <code>Err</code> que contiene más
información sobre el tipo de error que ocurrió.</p>
<p>Necesitamos agregar al código en el Listado 9-3 para tomar diferentes
acciones dependiendo del valor <code>File: open</code> returns. El Listado 9-4 muestra
una forma de manejar el <code>Result</code> utilizando una herramienta básica, la
expresión <code>match</code> que analizamos en el Capítulo 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-4: Usar una expresión <code>match</code> para manejar las variantes <code>Result</code> que pueden ser devueltas</span></p>
<p>Tenga en cuenta que, al igual que la enumeración <code>Option</code>, el enum <code>Result</code> y
sus variantes se han importado en el preludio, por lo que no es necesario que
especifique <code>Result::</code> antes de las variantes <code>Ok</code> y <code>Err</code> en los brazos del <code>match</code>.</p>
<p>Aquí le decimos a Rust que cuando el resultado es <code>Ok</code>, devuelve el valor
<code>file</code> interno de la variante <code>Ok</code>, y luego asignamos ese valor de manejo de
archivo a la variable <code>f</code>. Después del <code>match</code>, podemos usar el manejador del
archivo para leer o escribir.</p>
<p>El otro brazo del <code>match</code> maneja el caso donde obtenemos un valor <code>Err</code> de
<code>File::open</code>. En este ejemplo, hemos elegido llamar a la macro <code>panic!</code>. Si
no hay un archivo llamado <em>hello.txt</em> en nuestro directorio actual y
ejecutamos este código, veremos el siguiente resultado de la macro <code>panic!</code>:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>Como de costumbre, este resultado nos dice exactamente qué salió mal.</p>
<h3 id="coincidencia-en-diferentes-errores"><a class="header" href="#coincidencia-en-diferentes-errores">Coincidencia en diferentes errores</a></h3>
<p>El código en el Listado 9-4 entrará en <code>panic!</code>. No importa por qué
<code>File::open</code> falló. Lo que queremos hacer en su lugar es tomar diferentes
acciones por diferentes motivos de falla: si <code>File::open</code> falló porque el
archivo no existe, queremos crear el archivo y devolver el manejador al nuevo
archivo. Si <code>File::open</code> falló por alguna otra razón, por ejemplo, porque no
teníamos permiso para abrir el archivo, aún queremos que el código se <code>panic!</code> de la misma manera que en el Listado 9-4 . Mire el Listado 9-5, que agrega otro brazo al <code>match</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore esta prueba porque de lo contrario crea hello.txt que causa
que otras pruebas fallen lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listing 9-5: Manejando diferentes tipos de errores de
diferentes maneras</span></p>
<p>El tipo del valor que <code>File::open</code> devuelve dentro de la variante <code>Err</code> es
<code>io::Error</code>, que es una estructura proporcionada por la biblioteca estándar.
Esta estructura tiene un método <code>kind</code> al que podemos llamar para obtener un
valor <code>io::ErrorKind</code>. La enumeración <code>io::ErrorKind</code> es proporcionado por la
biblioteca estándar y tiene variantes que representa los diferentes tipos de
errores que pueden resultar de un <code>io</code> operación. La variante que
queremos usar es <code>ErrorKind::NotFound</code>, que indica el archivo que intentamos abrir aún no existe.</p>
<p>La condición <code>if error.kind() == ErrorKind::NotFound</code> se llama
<em>match guard</em>: es una condición adicional en un brazo de <code>match</code> que refina
aún más el patrón <em>brazos</em>. Esta condición debe ser verdadera para que se
ejecute el código de ese brazo; de otra manera, la coincidencia de patrones se moverá para considerar el próximo brazo en el <code>match</code>. los
<code>ref</code> en el patrón es necesario para que <code>error</code> no se mueva a la condición
de guardia pero simplemente es referenciado por él. La razón por la que usas
<code>ref</code> para crear una referencia en un patrón en lugar de <code>&amp;</code> se tratará en
detalle en el Capítulo 18. En resumen, en el contexto de un patrón, <code>&amp;</code>
coincide con una referencia y le da su valor, pero <code>ref</code> coincide con un
valor y le da una referencia.</p>
<p>La condición que queremos verificar en el guarda <em>match</em> es si el valor devueltopor <code>error.kind()</code> es la variante <code>NotFound</code> de la enumeración
<code>ErrorKind</code>. Si esto es, intentamos crear el archivo con <code>File::create</code>.
Sin embargo, como <code>File:: reate</code> también podría fallar, también necesitamos
agregar una declaración de interna al <code>match</code>. Cuando el archivo no se puede abrir, se imprimirá un mensaje de error diferente. El último brazo del
<code>match</code> externa permanece igual, por lo que el programa entra en pánico por
cualquier error además de el error de archivo faltante.</p>
<h3 id="atajos-para-pánico-en-caso-de-error-unwrap-y-expect"><a class="header" href="#atajos-para-pánico-en-caso-de-error-unwrap-y-expect">Atajos para pánico en caso de error: <code>unwrap</code> y<code> expect</code></a></h3>
<p>Usar <code>match</code> funciona bastante bien, pero puede ser un poco detallado y no
siempre comunica bien el intento. El tipo <code>Result &lt;T, E&gt;</code> tiene muchos
métodos auxiliares definidos para realizar diversas tareas. Uno de esos
métodos, llamado <code>unwrap</code>, es un método abreviado que se implementa como la
declaración <code>match</code> que escribimos en el Listado 9-4. Si el valor <code>Result</code> es
la variante <code>Ok</code>, <code>unwrap</code> devolverá el valor dentro del <code>Ok</code>. Si el <code>Result</code>
es la variante <code>Err</code>, <code>unwrap</code> llamará a la macro <code>panic!</code> para nosotros.
Aquí hay un ejemplo de <code>unwrap</code> en acción:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Si ejecutamos este código sin un archivo <em>hello.txt</em>, veremos un mensaje de
error de la llamada <code>panic!</code> que el método <code>unwrap</code> hace:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Otro método, <code>expect</code>, que es similar a <code>unwrap</code>, nos permite elegir el
mensaje de error <code>panic!</code>. Usar <code>expect</code> en lugar de <code>unwrap</code> y proporcionar
buenos mensajes de error puede transmitir su intención y facilitar el rastreo
del origen de un ataque de pánico. La sintaxis de <code>expect</code> se ve así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p>Usamos <code>expect</code> de la misma manera que <code>unwrap</code>: para devolver el manejador
de archivo o llamar a la macro <code>panic!</code>. El mensaje de error utilizado por
<code>expect</code> en su llamada a <code>panic!</code> será el parámetro que pasamos a <code>expect</code>,
en lugar del mensaje <code>panic!</code> Predeterminado que <code>unwrap</code> usa. Esto es lo que
parece:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>Como este mensaje de error comienza con el texto que especificamos, <code>Failed to open hello.txt</code>, será más fácil encontrar el origen del código en el que
se origina este mensaje de error. Si usamos <code>unwrap</code> en varios lugares, puede
llevar más tiempo averiguar exactamente qué <code>unwrap</code> está causando el pánico,ya que todas las llamadas <code>unwrap</code> que entran en pánico imprimen el mismo
mensaje.</p>
<h3 id="propagación-de-errores"><a class="header" href="#propagación-de-errores">Propagación de errores</a></h3>
<p>Cuando está escribiendo una función cuya implementación llama a algo que
puede fallar, en lugar de manejar el error dentro de esta función, puede
devolver el error al código de llamada para que pueda decidir qué hacer. Esto
se conoce como <em>propagar</em> el error y le da más control al código de llamada,donde podría haber más información o lógica que dicte cómo se debe manejar el
error que lo que tiene disponible en el contexto de su código.</p>
<p>Por ejemplo, el Listado 9-6 muestra una función que lee un nombre de usuario
de un archivo. Si el archivo no existe o no se puede leer, esta función
devolverá esos errores al código que llamó a esta función.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-6: Una función que devuelve errores al código
de llamada con <code>match</code></span></p>
<p>Mire primero el tipo de retorno de la función:
<code>Resultado &lt;String, io::Error&gt;</code>. Esto significa que la función devuelve un
valor del tipo <code>Result &lt;T, E&gt;</code> donde el parámetro genérico <code>T</code> se ha
rellenado con el tipo concreto <code>String</code> y el tipo genérico <code>E</code> se ha
rellenado con el tipo concreto <code>io::Error</code>. Si esta función tiene éxito sin
ningún problema, el código que llama a esta función recibirá un valor <code>Ok</code> que contiene una <code>String</code>, el nombre de usuario que esta función lee del
archivo. Si esta función encuentra algún problema, el código que llama a esta
función recibirá un valor <code>Err</code> que contiene una instancia de <code>io::Error</code> que
contiene más información sobre cuáles fueron los problemas. Elegimos
<code>io::Error</code> como el tipo de retorno de esta función porque ese es el tipo del
valor de error devuelto por las dos operaciones que estamos llamando en el
cuerpo de esta función que puede fallar: la función <code>File::open</code> y el método
<code>read_to_string</code>.</p>
<p>El cuerpo de la función comienza llamando a la función <code>File::open</code>. Entonces
nosotros manejamos el valor <code>Result</code> devuelto con un <code>match</code> similar al
<code>match</code> en Listado 9-4, solo en lugar de llamar <code>panic!</code> En el caso de <code>Err</code>,
retornamos temprano de esta función y pasamos el valor de error de
<code>File::open</code> vuelve al código de llamada como el valor de error de esta
función. Si <code>File::open</code> tiene éxito, almacenamos el archivo maneja en la
variable <code>f</code> y continúa.</p>
<p>Luego creamos un nuevo <code>String</code> en la variable <code>s</code> y llamamos <code>read_to_string</code>
método en el manejador de archivo en <code>f</code> para leer el contenido del archivo
en<code>s</code>. El método <code>read_to_string</code> también devuelve un <code>Result</code> porque puede
fallar, incluso aunque <code>File::open</code> tenga éxito. Entonces, necesitamos otro
<code>match</code> para manejar eso <code>Result</code>: si <code>read_to_string</code> tiene éxito, entonces nuestra función ha tenido éxito, y nosotros devuelve el nombre de usuario del
archivo que ahora está en <code>s</code> envuelto en un <code>Ok</code>. Si <code>read_to_string</code> falla,
devolvemos el valor de error de la misma manera que devolvió el valor del
error en el <code>match</code> que manejaba el valor de retorno de <code>File::open</code>.
Sin embargo, no necesitamos decir explícitamente <code>return</code>, porque esto
es la última expresión en la función.</p>
<p>El código que llama a este código manejará obtener un valor <code>Ok</code>
que contiene un nombre de usuario o un valor <code>Err</code> que contiene un
<code>io::Error</code>. Nosotros no sabemos qué hará el código de llamada con esos
valores. Si el código de llamada obtiene un valor <code>Err</code>, podría llamar <code>panic!</code> y bloquear el programa, usar un nombre de usuario predeterminado, o
busque el nombre de usuario desde otro lugar que no sea un archivo, por
ejemplo. No tenemos suficiente información sobre lo que el código de llamada
realmente intenta hacer, por lo que propagamos toda la información de éxito o
error hacia arriba para que se maneje adecuadamente.</p>
<p>Este patrón de errores de propagación es tan común en Rust que Rust
proporciona el operador de signo de interrogación <code>?</code> para hacer esto más
fácil.</p>
<h4 id="un-atajo-para-propagar-errores-el-operador-"><a class="header" href="#un-atajo-para-propagar-errores-el-operador-">Un atajo para propagar errores: el operador <code>?</code></a></h4>
<p>El Listado 9-7 muestra una implementación de <code>read_username_from_file</code> que
tiene la misma funcionalidad que tenía en el listado 9-6, pero esta
implementación usa el operador <code>?</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-7: Una función que devuelve errores al código de llamada utilizando el operador <code>?</code></span></p>
<p>El <code>?</code> colocado después de que se haya definido un valor de <code>Result</code> funciona
casi de la misma manera que las expresiones <code>match</code> que definimos para
manejar los valores <code>Result</code> en el Listado 9-6. Si el valor del <code>Result</code> es
un <code>Ok</code>, el valor dentro de <code>Ok</code> se devolverá a partir de esta expresión, y el programa continuará. Si el valor es un <code>Err</code>, el valor dentro de <code>Err</code> se devolverá de la función completa como si hubiéramos usado la palabra clave <code>return</code> para que el valor de error se propague al código de llamada.</p>
<p>Hay una diferencia entre lo que hacen la expresión <code>match</code> del Listado 9-6 y
lo que hace el operador <code>?</code>: los valores de error utilizados con <code>?</code> Pasan
por la función <code>from</code>, definida en el <em>trair</em> <code>From</code> en la biblioteca
estándar, que se usa para convertir errores de un tipo a otro. Cuando el
operador <code>?</code> llama a la función <code>from</code>, el tipo de error recibido se
convierte al tipo de error definido en el tipo de retorno de la función
actual. Esto es útil cuando una función devuelve un tipo de error para
representar todas las formas en que una función puede fallar, incluso si las
partes pueden fallar por muchas razones diferentes. Siempre que cada tipo de
error implemente la función <code>from</code> para definir cómo convertirse al tipo de
error devuelto, el operador <code>?</code> se ocupará de la conversión automáticamente.</p>
<p>En el contexto del Listado 9-7, el <code>?</code> al final de la llamada <code>File::open</code>
devolverá el valor dentro de un <code>Ok</code> a la variable <code>f</code>. Si ocurre un error,
el operador <code>?</code> saldrá temprano de toda la función y dará cualquier valor
<code>Err</code> al código de llamada. Lo mismo se aplica al operador <code>?</code> al final de la
llamada <code>read_to_string</code>.</p>
<p>El operador <code>?</code> Elimina una gran cantidad de texto repetitivo y simplifica la
implementación de esta función. Incluso podríamos acortar este código aún más
mediante el encadenamiento de llamadas de método inmediatamente después del
<code>?</code>, Como se muestra en el Listado 9-8.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 9-8: Llamadas al método de encadenamiento
después del operador <code>?</code></span></p>
<p>Hemos movido la creación del nuevo <code>String</code> en <code>s</code> al comienzo de la función;
esa parte no ha cambiado. En lugar de crear una variable <code>f</code>, hemos
encadenado la llamada a <code>read_to_string</code> directamente en el resultado de
<code>File::open(&quot;hello.txt&quot;)?</code>. Todavía tenemos un <code>?</code> al final de la llamada
<code>read_to_string</code>, y aún devolvemos un valor <code>Ok</code> que contiene el nombre de
usuario en <code>s</code> cuando tanto <code>File::open</code> como <code>read_to_string</code> tienen éxito en lugar de devolver errores. La funcionalidad es nuevamente la misma que en el Listado 9-6 y el Listado 9-7; esta es solo una forma diferente y más ergonómica de escribirlo.</p>
<h4 id="el-operador--solo-se-puede-usar-en-funciones-que-devuelven-result"><a class="header" href="#el-operador--solo-se-puede-usar-en-funciones-que-devuelven-result">El operador <code>?</code> solo se puede usar en funciones que devuelven <code>Result</code></a></h4>
<p>El operador <code>?</code> solo puede usarse en funciones que tienen un tipo de retorno
de <code>Result</code>, porque está definido para funcionar de la misma manera que la
expresión <code>match</code> que definimos en el Listado 9-6. La parte del <code>match</code> que
requiere un tipo de devolución de <code>Result</code> es <code>return Err(e)</code>, por lo que el
tipo de devolución de la función debe ser un <code>Result</code> para que sea compatible
con este <code>return</code>.</p>
<p>Veamos qué pasa si usamos el operador <code>?</code> en la función <code>main</code>, que recordará que tiene un tipo de retorno de <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>Cuando compilamos este código, recibimos el siguiente mensaje de error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `(): std::ops::Try` is not satisfied
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             the `?` operator can only be used in a function that returns
  `Result` (or another type that implements `std::ops::Try`)
  |             in this macro invocation
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>Este error indica que solo podemos usar el operador <code>?</code> en una función que
devuelve <code>Result</code>. En las funciones que no devuelven <code>Result</code>, cuando llama a
otras funciones que devuelven <code>Result</code>, necesitará usar <code>match</code> o uno de los
métodos <code>Result</code> para manejar <code>Result</code> en lugar de usar el operador <code>?</code> para
propagar potencialmente el error al código de llamada.</p>
<p>Ahora que hemos discutido los detalles de llamar <code>panic!</code> o devolver
<code>Result</code>, volvamos al tema de cómo decidir en qué casos cuál es el adecuado.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="to-panic-or-not-to-panic"><a class="header" href="#to-panic-or-not-to-panic">To <code>panic!</code> or Not to <code>panic!</code></a></h2>
<p>Entonces, ¿cómo decides cuándo debes llamar <code>panic!</code> Y cuándo debes devolver
el <code>Result</code>?. Cuando el código entra en pánico, no hay forma de recuperarlo.
Puede llamar <code>panic!</code> por cualquier situación de error, ya sea que haya una
forma posible de recuperación o no, pero luego está tomando la decisión en
nombre del código llamando a su código de que una situación es irrecuperable. Cuando elige devolver un valor de <code>Result</code>, le da las opciones de código de
llamada en lugar de tomar una decisión al respecto. El código de llamada
podría optar por intentar la recuperación de una manera apropiada para su
situación, o podría decidir que un valor <code>Err</code> en este caso es irrecuperable,
por lo que puede llamar <code>¡pánico!</code> y convertir su error recuperable en uno
irrecuperable. Por lo tanto, devolver <code>Result</code> es una buena opción
predeterminada cuando se define una función que podría fallar.</p>
<p>En situaciones excepcionales, es más apropiado escribir un código que entra
en pánico en lugar de devolver un <code>Result</code>. Analicemos por qué es apropiado
entrar en pánico en ejemplos, códigos de prototipos y pruebas. Luego
discutiremos las situaciones en las que el compilador no puede decir que la
falla es imposible, pero usted, como ser humano, puede hacerlo. El capítulo
concluirá con algunas pautas generales sobre cómo decidir si entrar en pánico
en el código de la biblioteca.</p>
<h3 id="ejemplos-código-de-prototipo-y-pruebas"><a class="header" href="#ejemplos-código-de-prototipo-y-pruebas">Ejemplos, código de prototipo y pruebas</a></h3>
<p>Cuando está escribiendo un ejemplo para ilustrar algún concepto, tener un
código robusto de manejo de errores en el ejemplo también puede hacer que el
ejemplo sea menos claro. En los ejemplos, se entiende que una llamada a un
método como <code>unwrap</code> que podría entrar en pánico significa un marcador de
posición para la forma en que desearía que su aplicación manejara los errores,que pueden diferir en función de lo que haga el resto del código.</p>
<p>Del mismo modo, los métodos <code>unwrap</code> y <code>expect</code> son muy útiles al crear
prototipos, antes de que esté listo para decidir cómo manejar los errores.
Dejan marcas claras en su código para cuando esté listo para hacer que su
programa sea más robusto.</p>
<p>Si falla una llamada al método en una prueba, querría que fallara toda la
prueba, incluso si ese método no es la funcionalidad bajo prueba. Debido a
que <code>¡pánico!</code> Es la forma en que una prueba se marca como una falla, llamar
<code>unwrap</code> o <code>expect</code> es exactamente lo que debería suceder.</p>
<h3 id="casos-en-los-que-tiene-más-información-que-el-compilador"><a class="header" href="#casos-en-los-que-tiene-más-información-que-el-compilador">Casos en los que tiene más información que el compilador</a></h3>
<p>También sería apropiado llamar a <code>unwrap</code> cuando tenga alguna otra lógica que
asegure que <code>Result</code> tendrá un valor <code>Ok</code>, pero la lógica no es algo que el
compilador entienda. Todavía tendrá un valor de <code>Result</code> que debe manejar:
cualquier operación que llame todavía tiene la posibilidad de fallar en
general, aunque sea lógicamente imposible en su situación particular. Si
puede asegurarse al inspeccionar manualmente el código que nunca tendrá una
variante <code>Err</code>, es perfectamente aceptable llamar a <code>unwrap</code>. Aquí hay un
ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Estamos creando una instancia <code>IpAddr</code> al analizar una cadena codificada.
Podemos ver que <code>127.0.0.1</code> es una dirección IP válida, por lo que es
aceptable usar <code>unwrap</code> aquí. Sin embargo, tener un string codificado y
válido no cambia el tipo de retorno del método <code>parse</code>: todavía obtenemos un
valor <code>Result</code>, y el compilador todavía nos hará manejar el <code>Result</code> como si
fuera la variante <code>Err</code> es una posibilidad porque el compilador no es lo
suficientemente inteligente como para ver que esta cadena siempre es una
dirección IP válida. Si la cadena de dirección IP proviene de un usuario en
lugar de estar codificada en el programa y, por lo tanto, <em>sí</em> tiene una
posibilidad de falla, definitivamente queremos manejar el <code>Result</code> de una
manera más robusta.</p>
<h3 id="pautas-para-el-manejo-de-errores"><a class="header" href="#pautas-para-el-manejo-de-errores">Pautas para el manejo de errores</a></h3>
<p>Es aconsejable que su código entre en pánico cuando es posible que su código
termine en mal estado. En este contexto, un <em>mal estado</em> es cuando se han
roto algunas suposiciones, garantías, contratos o invariantes, como cuando se
pasan valores no válidos, valores contradictorios o valores perdidos a su
código, más uno o más de los siguientes:</p>
<ul>
<li>El mal estado no es algo <em>esperado</em> que ocurra ocasionalmente.</li>
<li>Su código después de este punto necesita confiar en no estar en este mal
estado.</li>
<li>No hay una buena manera de codificar esta información en los tipos que usa.</li>
</ul>
<p>Si alguien llama a su código y le envía valores que no tienen sentido, la
mejor opción podría ser invocar <code>panic!</code> Y alertar a la persona que utiliza
su biblioteca sobre el error en su código para que puedan solucionarlo
durante el desarrollo. De manera similar, <code>panic!</code> Es a menudo apropiado si
está llamando un código externo que está fuera de su control y devuelve un
estado no válido que no tiene forma de solucionar.</p>
<p>Cuando se alcanza un mal estado, pero se espera que suceda sin importar lo
bien que escribe tu código, aún es más apropiado devolver un <code>Result</code> en
lugar de hacer una llamada <code>pánico!</code> los ejemplos incluyen un analizador que
recibe datos malformados o una solicitud HTTP que devuelve un estado que
indica que ha alcanzado un límite de velocidad. En estos casos, debe indicar que la falla es una posibilidad esperada por devolver un <code>Result</code> para
propagar estos estados incorrectos hacia arriba para que el código de llamada
puede decidir cómo manejar el problema. ¡Llamar a <code>panic!</code>! No sería la mejor
manera para manejar estos casos.</p>
<p>Cuando su código realiza operaciones con valores, su código debe verificar que
los valores son válidos primero y el pánico si los valores no son válidos.
Esto es principalmente para razones de seguridad: intentar operar con datos
no válidos puede exponer su código a vulnerabilidades Esta es la razón
principal por la que la biblioteca estándar llamará <code>¡pánico!</code> si intenta
acceder a la memoria fuera de límites: tratando de acceder a la memoria
que no pertenece a la estructura de datos actual es un problema de seguridad
común. Las funciones a menudo tienen <em>contratos</em>: su comportamiento solo está
garantizado si las entradas cumplen requisitos particulares. Presa del pánico
cuando se viola el contrato tiene sentido porque una violación del contrato
siempre indica un error del lado de la persona que llama y no es un tipo de error que desea que el código de llamada tenga que explícitamente encargarse de. De hecho, no hay una forma razonable de invocar el código para recuperar;
los <em>programadores</em> que llaman necesitan arreglar el código. Contratos para una función, especialmente cuando una violación causará pánico, debe explicarse en la API de documentación para la función.</p>
<p>Sin embargo, tener muchos controles de errores en todas sus funciones sería
verbose y molesto. Afortunadamente, puede usar el sistema de tipos de Rust
(y, por lo tanto, el tipo de verificación que hace el compilador) para hacer
muchos de los controles por usted. Si su función tiene un tipo particular
como parámetro, puede continuar con la lógica de su código sabiendo que el
compilador ya se ha asegurado de que tiene un valor válido. Por ejemplo, si
tiene un tipo en lugar de una <code>Opción</code>, su programa espera tener <em>algo</em> en lugar de <em>nada</em>. Entonces, su código no tiene que manejar dos casos para las
variantes <code>Some</code> y <code>None</code>: solo tendrá un caso para definitivamente tener un
valor. El código que intenta no pasarle nada a tu función ni siquiera
compilará, por lo que tu función no tiene que verificar ese caso en el tiempo
de ejecución. Otro ejemplo es el uso de un tipo de entero sin signo como
<code>u32</code>, que asegura que el parámetro nunca sea negativo.</p>
<h3 id="crear-tipos-personalizados-para-validación"><a class="header" href="#crear-tipos-personalizados-para-validación">Crear tipos personalizados para validación</a></h3>
<p>Tomemos la idea de usar el sistema de tipos de Rust para garantizar que
tengamos un valor válido un paso más allá y busquemos la creación de un tipo
personalizado para la validación. Recuerde el juego de adivinanzas en el
Capítulo 2 en el cual nuestro código le pedía al usuario que adivinara un
número entre 1 y 100. Nunca validamos que la conjetura del usuario estuviera
entre esos números antes de verificarlo contra nuestro número secreto; solo
validamos que la suposición fue positiva. En este caso, las consecuencias no
fueron muy graves: nuestra salida de “Demasiado alto” o “Demasiado bajo”
seguiría siendo correcta. Pero sería una mejora útil para guiar al usuario
hacia conjeturas válidas y tener un comportamiento diferente cuando un
usuario adivina un número que está fuera de rango frente a cuando un usuario
escribe, por ejemplo, letras en su lugar.</p>
<p>Una forma de hacer esto sería analizar la conjetura como un <code>i32</code> en lugar de
solo un <code>u32</code> para permitir números potencialmente negativos, y luego agregar
un <em>check</em> para que el número esté dentro del rango, así:</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<p>La expresión <code>if</code> verifica si nuestro valor está fuera de rango, le dice al
usuario sobre el problema y llama a <code>continue</code> para comenzar la siguiente
iteración del ciclo y pedir otra aproximación. Después de la expresión <code>if</code>, podemos proceder con las comparaciones entre <code>guess</code> y el número secreto
sabiendo que <code>guess</code> está entre 1 y 100.</p>
<p>Sin embargo, esta no es una solución ideal: si era absolutamente crítico que
el programa solo operara con valores entre 1 y 100, y tenía muchas funciones
con este requisito, tener un check como este en cada función sería tedioso
(y podría afectar actuación).</p>
<p>En cambio, podemos hacer un nuevo tipo y poner las validaciones en una
función para crear una instancia del tipo en lugar de repetir las
validaciones en todas partes. De esta forma, es seguro para las funciones
usar el nuevo tipo en sus firmas y usar con confianza los valores que
reciben. El Listado 9-9 muestra una forma de definir un tipo <code>Guess</code> que solo
creará una instancia de <code>Guess</code> si la función <code>new</code> recibe un valor entre 1 y
100.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-9: Un tipo <code>Guess</code> que solo continuará con
valores entre 1 y 100</span></p>
<p>Primero, definimos una estructura llamada <code>Guess</code> que tiene un campo llamado
<code>value</code> que contiene un <code>u32</code>. Aquí es donde se almacenará el número.</p>
<p>Luego implementamos una función asociada llamada <code>new</code> en <code>Guess</code> que crea
instancias de valores <code>Guess</code>. La función <code>new</code> se define para tener un
parámetro llamado <code>value</code> de tipo <code>u32</code> y para devolver un <code>Guess</code>. El código
en el cuerpo de la función <code>new</code> prueba <code>value</code> para asegurarse de que esté
entre 1 y 100. Si <code>value</code> no pasa esta prueba, hacemos una llamada <code>panic!</code>,
Que alertará al programador quién está escribiendo el código de llamada que
tienen un error que necesitan corregir, porque la creación de un <code>Guess</code> con
un <code>value</code> fuera de este rango violaría el contrato en el que <code>Guess::new</code>
se basa. Las condiciones en las cuales <code>Guess::new</code> podría entrar en pánico
deberían discutirse en su documentación pública de API; cubriremos las
convenciones de documentación que indican la posibilidad de un <code>panic!</code> en la documentación de la API que usted crea en el Capítulo 14. Si <code>value</code> pasa la prueba, creamos un nuevo <code>Guess</code> con su campo <code>value</code> establecido en el parámetro <code>value</code> y devuelve el <code>Guess</code>.</p>
<p>A continuación, implementamos un método llamado <code>value</code> que toma prestado
<code>self</code>, no tiene ningún otro parámetro y devuelve un <code>u32</code>. Este tipo de
método a veces se llama <em>getter</em>, porque su propósito es obtener algunos
datos de sus campos y devolverlos. Este método público es necesario porque el
campo <code>value</code> de la estructura <code>Guess</code> es privado. Es importante que el campo
<code>value</code> sea privado para que el código que utiliza la estructura <code>Guess</code> no
permita establecer <code>value</code> directamente: el código fuera del módulo <em>debe</em>
usar la función <code>Guess::new</code> para crear una instancia de <code>Guess</code>, lo que
garantiza que no haya forma de que <code>Guess</code> tenga un <code>value</code> que no haya sido
verificado por las condiciones en la función <code>Guess::new</code>.</p>
<p>Una función que tiene un parámetro o devuelve solo números entre 1 y 100
podría entonces declarar en su firma que toma o devuelve un <code>Guess</code> en lugar
de un <code>u32</code> y no necesitaría hacer ninguna comprobación adicional en su
cuerpo.</p>
<h2 id="resumen-7"><a class="header" href="#resumen-7">Resumen</a></h2>
<p>Las funciones de manejo de errores de Rust están diseñadas para ayudarte a
escribir códigos más sólidos. La macro <code>panic!</code> indica que su programa está
en un estado que no puede manejar y le permite decirle al proceso que se
detenga en lugar de tratar de proceder con valores inválidos o incorrectos.
La enumeración <code>Result</code> usa el sistema de tipos de Rust para indicar que las
operaciones pueden fallar de una manera que su código podría recuperarse.
Puede usar <code>Result</code> para indicarle al código que llama a su código que
necesita manejar el posible éxito o falla también. El uso de <code>panic!</code> Y
<code>Result</code> en las situaciones apropiadas hará que su código sea más confiable
frente a problemas inevitables.</p>
<p>Ahora que ha visto formas útiles de que la biblioteca estándar use genéricos
con las enumeraciones <code>Option</code> y <code>Result</code>, hablaremos sobre cómo funcionan
los genéricos y cómo puede usarlos en su código.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-genéricos-traits-y-lifetimes"><a class="header" href="#tipos-genéricos-traits-y-lifetimes">Tipos genéricos, <em>Traits</em>, y <em>Lifetimes</em></a></h1>
<p>Cada lenguaje de programación tiene herramientas para manejar con eficacia la
duplicación de conceptos. En Rust, una de esas herramientas es los
<em>genéricos</em>. Los genéricos son complementos abstractos para tipos de concreto
u otras propiedades. Cuando estamos escribiendo código, podemos expresar el
comportamiento de los genéricos o cómo se relacionan con otros genéricos sin
saber qué habrá en su lugar al compilar y ejecutar el código.</p>
<p>Similar a la forma en que una función toma parámetros con valores
desconocidos para ejecutar el mismo código en múltiples valores concretos,
las funciones pueden tomar parámetros de algún tipo genérico en lugar de un
tipo concreto, como <code>i32</code> o <code>String</code>. De hecho, ya hemos usado genéricos en
el Capítulo 6 con <code>Opción &lt;T&gt;</code>, Capítulo 8 con <code>Vec &lt;T&gt;</code> y <code>HashMap &lt;K, V&gt;</code>,
y Capítulo 9 con <code>Result &lt;T, E&gt;</code>. ¡En este capítulo, explorará cómo definir
sus propios tipos, funciones y métodos con genéricos!.</p>
<p>Primero, repasaremos cómo extraer una función para reducir la duplicación de
código. A continuación, utilizaremos la misma técnica para hacer una función
genérica a partir de dos funciones que difieren solo en los tipos de sus
parámetros. También explicaremos cómo usar los tipos genéricos en las
definiciones de estructura y enumeración.</p>
<p>Luego aprenderá cómo usar <em>trait</em> para definir el comportamiento de una
manera genérica. Puede combinar rasgos con tipos genéricos para restringir un
tipo genérico solo a aquellos tipos que tienen un comportamiento particular,
a diferencia de cualquier tipo.</p>
<p>Finalmente, estudiaremos <em>lifetimes</em>, una variedad de genéricos que brindan
al compilador información sobre cómo las referencias se relacionan entre sí.
Los tiempos de vida nos permiten tomar valores prestados en muchas
situaciones y al mismo tiempo permitir que el compilador verifique que las
referencias sean válidas.</p>
<h2 id="eliminar-la-duplicación-mediante-la-extracción-de-una-función"><a class="header" href="#eliminar-la-duplicación-mediante-la-extracción-de-una-función">Eliminar la duplicación mediante la extracción de una función</a></h2>
<p>Antes de sumergirse en la sintaxis de los genéricos, veamos primero cómo
eliminar la duplicación que no involucra tipos genéricos extrayendo una
función. ¡Entonces aplicaremos esta técnica para extraer una función
genérica! De la misma forma que reconoce el código duplicado para extraer en
una función, comenzará a reconocer el código duplicado que puede usar
genéricos.</p>
<p>Considere un programa corto que encuentre el número más grande en una lista,
como se muestra en el Listado 10-1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
<span class="boring"> assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">Listado 10-1: codigo para encontrar el número más grande en una lista de números</span></p>
<p>Este código almacena una lista de enteros en la variable <code>number_list</code> y
coloca el primer número en la lista en una variable llamada <code>largest</code>. Luego
itera a través de todos los números en la lista, y si el número actual es
mayor que el número almacenado en <code>largest</code>, reemplaza el número en esa
variable. Sin embargo, si el número actual es menor que el número más grande
visto hasta ahora, la variable no cambia y el código pasa al siguiente número
de la lista. Después de considerar todos los números en la lista, <code>largest</code>
debería contener el número más grande, que en este caso es 100.</p>
<p>Para encontrar el número más grande en dos listas diferentes de números,
podemos duplicar el código en el Listado 10-1 y usar la misma lógica en dos
lugares diferentes en el programa, como se muestra en el Listado 10-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Listado 10-2: codigo para encontrar el número más
grande en <em>dos</em> listas de números</span></p>
<p>Aunque este código funciona, la duplicación del código es tediosa y propensa
a errores. También tenemos que actualizar el código en varios lugares cuando
queremos cambiarlo.</p>
<p>Para eliminar esta duplicación, podemos crear una abstracción definiendo una
función que opera en cualquier lista de enteros que se le otorguen en un
parámetro. Esta solución hace que nuestro código sea más claro y nos permite
expresar el concepto de encontrar el número más grande en una lista de forma
abstracta.</p>
<p>En el Listado 10-3, extrajimos el código que encuentra el número más grande
en una función llamada <code>largest</code>. A diferencia del código en el listado 10-1,
que puede encontrar el número más grande en una sola lista en particular,
este programa puede encontrar el número más grande en dos listas diferentes.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 6000);
</span>}
</code></pre></pre>
<p><span class="caption">Listado 10-3: código resumido para encontrar el número más grande en dos listas</span></p>
<p>La función <code>largest</code> tiene un parámetro llamado <code>list</code>, que representa
cualquier porción concreta de valores <code>i32</code> que podríamos pasar a la función.
Como resultado, cuando llamamos a la función, el código se ejecuta en los
valores específicos que pasamos.</p>
<p>En resumen, aquí están los pasos que tomamos para cambiar el código del
Listado 10-2 al Listado 10-3:</p>
<ol>
<li>Identificar código duplicado.</li>
<li>Extraiga el código duplicado en el cuerpo de la función y especifique las
entradas y los valores de retorno de ese código en la firma de la función.</li>
<li>Actualice las dos instancias de código duplicado para llamar a la función
en su lugar.</li>
</ol>
<p>A continuación, utilizaremos estos mismos pasos con los genéricos para
reducir la duplicación de código de diferentes maneras. De la misma manera
que el cuerpo de la función puede operar en una &quot;lista&quot; abstracta en lugar de
valores específicos, los genéricos permiten que el código opere en tipos
abstractos.</p>
<p>Por ejemplo, supongamos que tenemos dos funciones: una que encuentra el
elemento más grande en una porción de valores <code>i32</code> y otra que encuentra el
elemento más grande en una porción de valores <code>char</code>. ¿Cómo eliminaríamos esa
duplicación? ¡Vamos a averiguar!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos-genéricos"><a class="header" href="#tipos-de-datos-genéricos">Tipos de datos genéricos</a></h2>
<p>Podemos usar genéricos para crear definiciones para elementos como firmas de
funciones o estructuras, que luego podemos usar con muchos tipos de datos
concretos diferentes. Primero veamos cómo definir funciones, estructuras,
enumeraciones y métodos usando genéricos. Luego discutiremos cómo los
genéricos afectan el rendimiento del código.</p>
<h3 id="en-definiciones-de-funciones"><a class="header" href="#en-definiciones-de-funciones">En Definiciones de funciones</a></h3>
<p>Al definir una función que usa genéricos, colocamos los genéricos en la firma
de la función en la que normalmente especificamos los tipos de datos de los
parámetros y el valor de retorno. Hacerlo hace que nuestro código sea más
flexible y proporciona más funcionalidad a los llamantes de nuestra función a
la vez que evita la duplicación de código.</p>
<p>Continuando con nuestra función <code>largest</code>, el Listado 10-4 muestra dos
funciones que encuentran el valor más grande en un <em>slice</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">   assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Listado 10-4: dos funciones que difieren solo en sus
nombres y los tipos en sus firmas</span></p>
<p>La función <code>largest_i32</code> es la que extrajimos en el Listado 10-3 que
encuentra el <code>i32</code> más grande en una porción. La función <code>largest_char</code>
encuentra el <code>char</code> más grande en una porción. Los cuerpos de función tienen
el mismo código, así que eliminemos la duplicación introduciendo un parámetro
de tipo genérico en una sola función.</p>
<p>Para parametrizar los tipos en la nueva función que definiremos, necesitamos
nombrar el parámetro tipo, tal como lo hacemos para los parámetros de valor
de una función. Puede usar cualquier identificador como nombre de parámetro
de tipo. Pero usaremos <code>T</code> porque, por convención, los nombres de los
parámetros en Rust son cortos, a menudo solo una letra, y la convención de
nombres de Rust es CamelCase. Abreviatura de &quot;tipo&quot;, <code>T</code> es la opción
predeterminada de la mayoría de los programadores de Rust.</p>
<p>Cuando usamos un parámetro en el cuerpo de la función, tenemos que declarar
el nombre del parámetro en la firma para que el compilador sepa lo que
significa ese nombre. De forma similar, cuando usamos un nombre de parámetro
de tipo en una firma de función, tenemos que declarar el nombre del parámetro
de tipo antes de usarlo. Para definir la función genérica <code>largest</code>,
coloque declaraciones de nombre de tipo dentro de corchetes angulares,<code>&lt;&gt;</code>,
entre el nombre de la función y la lista de parámetros, como esta:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Leemos esta definición como: la función <code>largest</code> es genérica sobre algún
tipo <code>T</code>. Esta función tiene un parámetro llamado <code>list</code>, que es un segmento
de valores de tipo <code>T</code>. La función <code>largest</code> devolverá un valor del mismo
tipo <code>T</code>.</p>
<p>El listado 10-5 muestra la definición de función &quot;más grande&quot; combinada que
utiliza el tipo de datos genéricos en su firma. La lista también muestra cómo
podemos llamar a la función con una porción de valores <code>i32</code> o <code>char</code>. Tenga
en cuenta que este código aún no se compilará, pero lo solucionaremos más
adelante en este capítulo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listado 10-5: Una definición de la función <code>largest</code>
que usa parámetros de tipo genérico pero aún no compila</span></p>
<p>Si compilamos este código ahora, obtendremos este error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>La nota menciona <code>std::cmp::PartialOrd</code>, que es un <em>trait</em>. Hablaremos sobre
los <em>trait</em> en la siguiente sección. Por ahora, este error indica que el
cuerpo de <code>largest</code> no funcionará para todos los tipos posibles que <code>T</code>
podría ser. Como queremos comparar valores del tipo <code>T</code> en el cuerpo, solo
podemos usar tipos cuyos valores se puedan ordenar. Para permitir las
comparaciones, la biblioteca estándar tiene el <em>trait</em> <code>std::cmp::PartialOrd</code>
que puede implementar en los tipos (consulte el Apéndice C para obtener más
información sobre este <em>trait</em>). Aprenderá cómo especificar que un tipo
genérico tiene un <em>trait</em> particular en la sección “Límites de
características”, pero primero exploremos otras maneras de usar parámetros
genéricos de tipo.</p>
<h3 id="en-las-definiciones-de-struct"><a class="header" href="#en-las-definiciones-de-struct">En las definiciones de <em>Struct</em></a></h3>
<p>También podemos definir estructuras para usar un parámetro de tipo genérico
en uno o más campos usando la sintaxis <code>&lt;&gt;</code>. El Listado 10-6 muestra cómo
definir una estructura <code>Point &lt;T&gt;</code> para contener valores de coordenadas <code>x</code>
y <code>y</code> de cualquier tipo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: Una estructura <code>Point &lt;T&gt;</code> que contiene los valores <code>x</code> y <code>y</code> de tipo <code>T</code></span></p>
<p>La sintaxis para usar genéricos en las definiciones de estructuras es similar a la utilizada en las definiciones de funciones. Primero, declaramos el nombre del parámetro tipo dentro de corchetes angulares justo después del nombre de la estructura. Entonces podemos usar el tipo genérico en la definición de estructura donde especificaríamos tipos de datos concretos.</p>
<p>Tenga en cuenta que debido a que hemos usado solo un tipo genérico para definir <code>Point &lt;T&gt;</code>, esta definición dice que la estructura <code>Point &lt;T&gt;</code> es genérica sobre algún tipo <code>T</code>, y los campos <code>x</code> y <code>y</code> son <em>ambos</em> del mismo tipo, cualquiera que sea ese tipo. Si creamos una instancia de un <code>Punto &lt;T&gt;</code> que tiene valores de diferentes tipos, como en el Listado 10-7, nuestro código no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listado 10-7: Los campos <code>x</code> y <code>y</code> deben ser del mismo
tipo porque ambos tienen el mismo tipo de datos genéricos <code>T</code>.</span></p>
<p>En este ejemplo, cuando asignamos el valor entero 5 a <code>x</code>, dejamos que el
compilador sepa que el tipo genérico <code>T</code> será un entero para esta instancia
de <code>Point &lt;T&gt;</code>. Luego, cuando especifiquemos 4.0 para <code>y</code>, que hemos definido
para que tenga el mismo tipo que <code>x</code>, obtendremos un error de desajuste de
tipo como este:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p>Para definir una estructura <code>Point</code> donde <code>x</code> y <code>y</code> son ambos genéricos pero
podrían tener diferentes tipos, podemos usar múltiples parámetros genéricos
de tipo. Por ejemplo, en el listado 10-8, podemos cambiar la definición de
<code>Point</code> para que sea genérica sobre los tipos<code> T</code> y <code>U</code> donde <code>x</code> es de tipo
<code>T</code> y <code>y</code> es de tipo <code>U</code> .</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listado 10-8: Un <code>Point &lt;T, U&gt;</code> genérico sobre dos
tipos para que <code>x</code> y <code>y</code> puedan ser valores de diferentes tipos</span></p>
<p>¡Ahora todas las instancias de <code>Point</code> se muestran permitidas! Puede usar
tantos parámetros de tipo genérico como desee en una definición, pero usar
más de unos pocos hace que su código sea difícil de leer. Cuando necesite
muchos tipos genéricos en su código, podría indicar que su código necesita
una reestructuración en piezas más pequeñas.</p>
<h3 id="en-enum-definiciones"><a class="header" href="#en-enum-definiciones">En Enum Definiciones</a></h3>
<p>Como hicimos con las estructuras, podemos definir las enumeraciones para
mantener los tipos de datos genéricos en sus variantes. Echemos otro vistazo
a la enumeración <code>Opción &lt;T&gt;</code> que proporciona la biblioteca estándar, que
usamos en el Capítulo 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta definición ahora debería tener más sentido para usted. Como puede ver,
<code>Option &lt;T&gt;</code> es una enumeración que es genérica sobre el tipo <code>T</code> y tiene dos
variantes: <code>Some</code>, que contiene un valor de tipo <code>T</code>, y una <code>None</code> variante
que no tiene ningún valor. Al utilizar la enumeración <code>Opción &lt;T&gt;</code>, podemos
expresar el concepto abstracto de tener un valor opcional, y como
<code>Opción &lt;T&gt;</code> es genérico, podemos usar esta abstracción sin importar el tipo
de valor opcional.</p>
<p>Los <em>enums</em> también pueden usar múltiples tipos genéricos. La definición de
la enumeración <code>Result</code> que utilizamos en el Capítulo 9 es un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>La enumeración <code>Result</code> es genérica sobre dos tipos, <code>T</code> y <code>E</code>, y tiene dos
variantes: <code>Ok</code>, que contiene un valor de tipo <code>T</code>, y <code>Err</code>, que contiene un
valor de tipo <code>E</code>. Esta definición hace que sea conveniente usar la
enumeración <code>Result</code> en cualquier lugar donde tengamos una operación que
pueda tener éxito (devuelva un valor de algún tipo <code>T</code>) o que falle
(devuelva un error de algún tipo <code>E</code>). De hecho, esto es lo que usamos para
abrir un archivo en el Listado 9-3, donde <code>T</code> se completó con el tipo
<code>std::fs::File</code> cuando el archivo se abrió correctamente y <code>E</code> se completó
con el tipo <code>std::io::Error</code> cuando hubo problemas al abrir el archivo.</p>
<p>Cuando reconoce situaciones en su código con múltiples definiciones <em>struct</em>
o <em>enum</em> que difieren solo en los tipos de los valores que contienen, puede
evitar la duplicación mediante el uso de tipos genéricos.</p>
<h3 id="en-definiciones-de-métodos"><a class="header" href="#en-definiciones-de-métodos">En definiciones de métodos</a></h3>
<p>Podemos implementar métodos en estructuras y enumeraciones (como lo hicimos
en el Capítulo 5) y también usar tipos genéricos en sus definiciones. El
Listado 10-9 muestra la estructura <code>Point &lt;T&gt;</code> que definimos en el Listado
10-6 con un método llamado <code>x</code> implementado en él.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listado 10-9: Implementando un método llamado <code>x</code> en la
estructura <code>Point &lt;T&gt;</code> que devolverá una referencia al campo <code>x</code> de tipo
<code>T</code></span></p>
<p>Aquí, hemos definido un método llamado <code>x</code> en <code>Point &lt;T&gt;</code> que devuelve una
referencia a los datos en el campo <code>x</code>.</p>
<p>Tenga en cuenta que tenemos que declarar <code>T</code> justo después de <code>impl</code> para que
podamos usarlo para especificar que estamos implementando métodos en el tipo
<code>Point &lt;T&gt;</code>. Al declarar <code>T</code> como un tipo genérico después de <code>impl</code>, Rust
puede identificar que el tipo en los paréntesis angulares en <code>Point</code> es un
tipo genérico en lugar de un tipo concreto.</p>
<p>Podríamos, por ejemplo, implementar métodos solo en instancias <code>Point &lt;f32&gt;</code>
en lugar de en instancias <code>Point &lt;T&gt;</code> con cualquier tipo genérico. En el
listado 10-10 usamos el tipo concreto <code>f32</code>, lo que significa que no
declaramos ningún tipo después de <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-10: Un bloque <code>impl</code> que solo se aplica a
una estructura con un tipo concreto para el parámetro de tipo
genérico <code>T</code></span></p>
<p>Este código significa que el tipo <code>Point &lt;f32&gt;</code> tendrá un método llamado
<code>distance_from_origin</code> y otras instancias de <code>Point &lt;T&gt;</code> donde <code>T</code> no es del
tipo <code>f32</code> no tendrá este método definido. El método mide qué tan lejos está
nuestro punto del punto en coordenadas (0.0, 0.0) y utiliza operaciones
matemáticas que están disponibles solo para tipos de coma flotante.</p>
<p>Los parámetros de tipo genérico en una definición de estructura no son
siempre los mismos que los que usa en las firmas de métodos de esa
estructura. Por ejemplo, el Listado 10-11 define el método <code>mixup</code> en la
estructura <code>Point &lt;T, U&gt;</code> del Listado 10-8. El método toma otro <code>Point</code> como
parámetro, que puede tener diferentes tipos que el <code>self</code> <code>Point</code> al que
llamamos <code>mixup</code>. El método crea una nueva instancia <code>Point</code> con el valor <code>x</code>
del <code>self</code> <code>Point</code> (de tipo <code>T</code>) y el valor <code>y</code> del <code>Point</code> pasado (de tipo <code>W</code>)</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listado 10-11: un método que usa diferentes tipos
genéricos que la definición de su estructura</span></p>
<p>En <code>main</code>, hemos definido un <code>Point</code> que tiene un <code>i32</code> para <code>x</code> (con valor
<code>5</code>) y un <code>f64</code> para <code>y</code> (con valor <code>10.4</code>). La variable <code>p2</code> es una
estructura <code>Point</code> que tiene un <em>string slice</em> para <code>x</code> (con valor <code>&quot;Hello&quot;</code>)
y <code>char</code> para <code>y</code> (con valor <code>c</code>). Llamar <code>mixup</code> en <code>p1</code> con el argumento
<code>p2</code> nos da <code>p3</code>, que tendrá un <code>i32</code> para <code>x</code>, porque <code>x</code> viene de <code>p1</code>. La
variable <code>p3</code> tendrá un <code>char</code> para <code>y</code>, porque <code>y</code> viene de <code>p2</code>. La llamada
a la macro <code>println!</code> Imprimirá <code>p3.x = 5, p3.y = c</code>.</p>
<p>El propósito de este ejemplo es demostrar una situación en la que algunos
parámetros genéricos se declaran con <code>impl</code> y algunos se declaran con la
definición del método. Aquí, los parámetros genéricos <code>T</code> y <code>U</code> se declaran
después de <code>impl</code>, porque van con la definición de estructura. Los parámetros
genéricos <code>V</code> y <code>W</code> se declaran después de <code>fn mixup</code>, porque solo son
relevantes para el método.</p>
<h3 id="rendimiento-del-código-usando-genéricos"><a class="header" href="#rendimiento-del-código-usando-genéricos">Rendimiento del código usando genéricos</a></h3>
<p>Es posible que se pregunte si hay un costo de tiempo de ejecución cuando usa
parámetros de tipo genérico. La buena noticia es que Rust implementa los
genéricos de tal manera que su código no se ralentiza con los tipos genéricos
más que con los tipos concretos.</p>
<p>Rust logra esto realizando la monomorfización del código que usa genéricos en
tiempo de compilación. <em>Monomorphization</em> es el proceso de convertir código
genérico en código específico completando los tipos concretos que se utilizan
cuando se compilan.</p>
<p>En este proceso, el compilador hace lo contrario de los pasos que usamos para
crear la función genérica en el Listado 10-5: el compilador observa todos los
lugares donde se llama el código genérico y genera código para los tipos
concretos con los que se llama el código genérico.</p>
<p>Veamos cómo funciona esto con un ejemplo que usa la enumeración <code>Option &lt;T&gt;</code>
de la biblioteca estándar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Cuando Rust compila este código, realiza la monomorfización. Durante ese
proceso, el compilador lee los valores que se han utilizado en las instancias
<code>Option &lt;T&gt;</code> e identifica dos tipos de <code>Option &lt;T&gt;</code>: uno es <code>i32</code> y el otro
es <code>f64</code>. Como tal, expande la definición genérica de <code>Opción &lt;T&gt;</code> en
<code>Opción_i32</code> y <code>Opción_f64</code>, reemplazando así la definición genérica por las
específicas.</p>
<p>La versión monomorfizada del código tiene el siguiente aspecto. La
<code>Opción &lt;T&gt;</code> genérica se reemplaza por las definiciones específicas creadas
por el compilador:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Debido a que Rust compila código genérico en código que especifica el tipo en
cada instancia, no pagamos costo de tiempo de ejecución por el uso de
genéricos. Cuando el código se ejecuta, funciona igual que si hubiéramos
duplicado cada definición a mano. El proceso de monomorfización hace que los
genéricos de Rust sean extremadamente eficientes en tiempo de ejecución.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traits-definición-de-comportamiento-compartido"><a class="header" href="#traits-definición-de-comportamiento-compartido">Traits: Definición de comportamiento compartido</a></h2>
<p>Un <em>trait</em> le dice al compilador Rust acerca de la funcionalidad que un tipo
en particular tiene y puede compartir con otros tipos. Podemos usar <em>trait</em>
para definir el comportamiento compartido de una manera abstracta. Podemos
usar límites de <em>trait</em> para especificar que un genérico puede ser de
cualquier tipo que tenga cierto comportamiento.</p>
<blockquote>
<p>Nota: Los <em>trait</em> son similares a una característica a menudo llamada
<em>interfaces</em> en otros lenguaje, aunque con algunas diferencias.</p>
</blockquote>
<h3 id="definiendo-un-trait"><a class="header" href="#definiendo-un-trait">Definiendo un Trait</a></h3>
<p>El comportamiento de un tipo consiste en los métodos que podemos invocar en
ese tipo. Los diferentes tipos comparten el mismo comportamiento si podemos
llamar a los mismos métodos en todos esos tipos. Las definiciones de <em>trait</em>
son una forma de agrupar las firmas de métodos para definir un conjunto de
comportamientos necesarios para lograr algún propósito.</p>
<p>Por ejemplo, supongamos que tenemos estructuras múltiples que contienen
varios tipos y cantidades de texto: una estructura <code>NewsArticle</code> que contiene
una historia de noticias presentada en una ubicación particular y un <code>Tweet</code>
que puede tener como máximo 280 caracteres junto con metadatos que indican si
fue un nuevo tweet, un retweet o una respuesta a otro tweet.</p>
<p>Queremos crear una biblioteca de agregadores de medios que pueda mostrar
resúmenes de datos que podrían almacenarse en una instancia de <code>NewsArticle</code>
o <code>Tweet</code>. Para hacer esto, necesitamos un resumen de cada tipo, y
necesitamos solicitar ese resumen llamando a un método <code>summarize</code> en una
instancia. El listado 10-12 muestra la definición de un <em>trait</em> <code>Summary</code> que
expresa este comportamiento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-12: Un <em>trait</em> <code>Resumen</code> que consiste en el comportamiento proporcionado por un método <code>summarize</code></span></p>
<p>Aquí, declaramos un <em>trait</em> usando la palabra clave <code>trait</code> y luego el nombre
del <em>trait</em>, que es <code>Summary</code>en este caso. Dentro de las llaves, declaramos
las firmas de métodos que describen los comportamientos de los tipos que
implementan este <em>trait</em>, que en este caso es
<code>fn summarize(&amp; self) -&gt; String</code>.</p>
<p>Después de la firma del método, en lugar de proporcionar una implementación
entre llaves, usamos un punto y coma. Cada tipo que implementa este <em>trait</em>
debe proporcionar su propio comportamiento personalizado para el cuerpo del
método. El compilador hará cumplir que cualquier tipo que tenga el <em>trait</em>
<code>Summary</code>tendrá el método <code>summarize</code> definido con esta firma exactamente.</p>
<p>Un <em>trait</em> puede tener múltiples métodos en su cuerpo: las firmas del método
se enumeran una por línea y cada línea termina en punto y coma.</p>
<h3 id="implementando-un-rasgo-en-un-tipo"><a class="header" href="#implementando-un-rasgo-en-un-tipo">Implementando un rasgo en un tipo</a></h3>
<p>Ahora que hemos definido el comportamiento deseado utilizando el <em>trait</em> <code>Summary</code>, podemos implementarlo en los tipos en nuestro agregador de medios.
El listado 10-13 muestra una implementación del <em>trait</em> <code>Summary</code> en la
estructura <code>NewsArticle</code> que usa el título, el autor y la ubicación para
crear el valor de retorno de <code>summarize</code>. Para la estructura <code>Tweet</code>,
definimos <code>summarize</code> como el nombre de usuario seguido por el texto completo
del tweet, suponiendo que el contenido del tweet ya está limitado a 280
caracteres.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-13: Implementando el <em>trait</em> <code>Summary</code> en los
tipos <code>NewsArticle</code> y <code>Tweet</code></span></p>
<p>La implementación de un <em>trait</em> en un tipo es similar a la implementación de
métodos regulares. La diferencia es que después de <code>impl</code>, ponemos el nombre
del <em>trait</em> que queremos implementar, luego usamos la palabra clave <code>for</code>, y
luego especificamos el nombre del tipo para el cual queremos implementar el
<em>trait</em>. Dentro del bloque <code>impl</code>, ponemos las firmas de método que ha
definido la definición de <em>trait</em>. En lugar de agregar un punto y coma
después de cada firma, usamos llaves y completamos el cuerpo del método
con el comportamiento específico que queremos que tengan los métodos del
<em>trait</em> para el tipo particular.</p>
<p>Después de implementar el <em>trait</em>, podemos llamar a los métodos en instancias
de <code>NewsArticle</code> y <code>Tweet</code> de la misma manera que llamamos a los métodos
regulares, como este:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>Este código imprime <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Tenga en cuenta que porque definimos el <em>trait</em> <code>Summary</code> y el <code>NewsArticle</code>
y tipos de <code>Tweet</code> en la misma <em>lib.rs</em> en el Listado 10-13, todos están en
el mismo alcance. Digamos que esto <em>lib.rs</em> es para un <em>create</em> que hemos llamado <code>aggregator</code> y alguien más quiere usar la funcionalidad de nuestro
<em>crate</em> para implementar el <code>Summary</code> <em>trait</em> en una estructura definida
dentro del alcance de su biblioteca. Tendrían que importar el <em>trait</em> en su alcance primero. Lo harían especificando
<code>use aggregator::Summary;</code>, que luego le permitiría implementar <code>Summary</code> para
su tipo. El <em>trait</em> <code>Summary</code> también necesitaría ser un <em>trait</em> público para
otra <em>create</em> para implementarlo, que es porque ponemos la palabra clave <code>pub</code>
antes de <em>trait</em> en el Listado 10-12.</p>
<p>Una restricción a tener en cuenta con las implementaciones de <em>traits</em> es que
podemos implementar un <em>trait</em> en un tipo solo si el <em>trait</em> o el tipo es
local para nuestro <em>crate</em>. Por ejemplo, podemos implementar <em>traits</em> de la biblioteca estándar como <code>Display</code> en un tipo personalizado como <code>Tweet</code> como
parte de nuestra funcionalidad <code>aggregator</code>, porque el tipo <code>Tweet</code> es local
a nuestro <em>crate</em> <code>aggregator</code>. También podemos implementar <code>Summary</code> en
<code>Vec &lt;T&gt;</code> en nuestro <em>crate</em> <code>aggregator</code>, porque el <em>trait</em> <code>Summary</code> es
local para nuestro <em>crate</em> <code>aggregator</code>.</p>
<p>Pero no podemos implementar <em>traits</em> externos en tipos externos. Por ejemplo,
no podemos implementar el <em>trait</em> <code>Display</code> en <code>Vec &lt;T&gt;</code> dentro de nuestro
<em>crate</em> <code>aggregator</code>, porque <code>Display</code> y<code> Vec &lt;T&gt;</code> están definidos en la
biblioteca estándar y no son local a nuestro <em>crate</em> <code>agregador</code> Esta
restricción es parte de una propiedad de programas llamados <em>coherencia</em>, y
más específicamente, la <em>regla huérfana</em>, llamada así porque el tipo
principal no está presente. Esta regla asegura que el código de otras
personas no puede romper su código y viceversa. Sin la regla, dos <em>crates</em>
podrían implementar el mismo <em>trait</em> para el mismo tipo, y Rust no sabría qué
implementación usar.</p>
<h3 id="implementaciones-predeterminadas"><a class="header" href="#implementaciones-predeterminadas">Implementaciones predeterminadas</a></h3>
<p>A veces es útil tener un comportamiento predeterminado para algunos o todos
los métodos en un <em>trait</em> en lugar de requerir implementaciones para todos
los métodos en cada tipo. Luego, a medida que implementamos el <em>trait</em> en un
tipo particular, podemos mantener o anular el comportamiento predeterminado
de cada método.</p>
<p>El Listado 10-14 muestra cómo especificar un <em>string</em> predeterminada para el
método <code>summarize</code> del <em>trait</em> <code>Summary</code> en lugar de solo definir la firma
del método, como hicimos en el Listado 10-12.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-14: Definición de un <em>trait</em> <code>Summary</code> con una implementación predeterminada del método <code>summarize</code></span></p>
<p>Para usar una implementación predeterminada para resumir instancias de
<code>NewsArticle</code> en lugar de definir una implementación personalizada,
especificamos un bloque <code>impl</code> vacío con <code>impl Summary for NewsArticle {}</code>.</p>
<p>Aunque ya no estamos definiendo el método <code>summarize</code> en <code>NewsArticle</code>
directamente, hemos proporcionado una implementación predeterminada y
especificamos que <code>NewsArticle</code> implementa el <em>trai</em> <code>Summary</code>. Como
resultado, todavía podemos llamar al método <code>summarize</code> en una instancia de
<code>NewsArticle</code>, así:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summarize());
</code></pre>
<p>Este código imprime <code>New article available! (Read more...)</code>.</p>
<p>Crear una implementación predeterminada para <code>summarize</code> no requiere que
cambiemos nada sobre la implementación de <code>Summary</code> en <code>Tweet</code> en el Listado
10-13. La razón es que la sintaxis para anular una implementación
predeterminada es la misma que la sintaxis para implementar un método de
<em>trait</em> que no tiene una implementación predeterminada.</p>
<p>Las implementaciones predeterminadas pueden llamar a otros métodos en el
mismo <em>trait</em>, incluso si esos otros métodos no tienen una implementación
predeterminada. De esta forma, un <em>trait</em> puede proporcionar una gran
cantidad de funcionalidades útiles y solo requiere que los implementadores
especifiquen una pequeña parte de él. Por ejemplo, podríamos definir el
<em>trait</em> <code>Summary</code> para tener un método <code>summarize_author</code> cuya implementación
es necesaria, y luego definir un método <code>summarize</code> que tenga una
implementación predeterminada que llame al método <code>summarize_author</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para usar esta versión de <code>Summary</code>, solo necesitamos definir
<code>summarize_author</code> cuando implementamos el <em>trait</em> en un tipo:</p>
<pre><code class="language-rust ignore">impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Después de definir <code>summarize_author</code>, podemos llamar <code>summarize</code> en las
instancias de la estructura <code>Tweet</code>, y la implementación predeterminada de
<code>summarize</code> llamará a la definición de <code>summarize_author</code> que hemos
proporcionado. Debido a que hemos implementado <code>summarize_author</code>, el
<em>trait</em> <code>Summary</code> nos ha dado el comportamiento del método <code>summarize</code> sin
necesidad de escribir más código.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>Este código imprime <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Tenga en cuenta que no es posible llamar a la implementación predeterminada
desde una implementación principal de ese mismo método.</p>
<h3 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h3>
<p>Ahora que sabe cómo definir <em>trait</em> e implementar esos <em>traits</em> en los tipos,
podemos explorar cómo usar los <em>traits</em> con los parámetros de tipo genérico.
Podemos usar <em>trait bounds</em> para restringir los tipos genéricos para
garantizar que el tipo se limitará a aquellos que implementan un <em>trait</em> y
comportamiento particular.</p>
<p>Por ejemplo, en el listado 10-13, implementamos el <em>trait</em> <code>Summary</code> en los
tipos <code>NewsArticle</code> y <code>Tweet</code>. Podemos definir una función <code>notify</code> que llama
al método <code>summarize</code> en su parámetro <code>item</code>, que es del tipo genérico <code>T</code>.
Para poder llamar <code>summarize</code> on <code>item</code> sin recibir un error que nos diga que
el tipo genérico <code>T</code> no implementa el método <code>summarize</code>, podemos usar
límites de <em>traits</em> en <code>T</code> para especificar ese <code>item</code> debe ser de un tipo
que implemente el <em>trait</em> <code>Summary</code>:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Colocamos límites de <em>trait</em> con la declaración del parámetro de tipo
genérico, después de dos puntos y dentro de corchetes angulares. Debido a la
característica de límite en <code>T</code>, podemos llamar a <code>notify</code> y pasar cualquier
instancia de <code>NewsArticle</code> o <code>Tweet</code>. El código que llama a la función con
cualquier otro tipo, como un <code>String</code> o un <code>i32</code>, no compilará, porque esos
tipos no implementan <code>Summary</code>.</p>
<p>Podemos especificar múltiples límites de <em>trait</em> en un tipo genérico usando
la sintaxis <code>+</code>. Por ejemplo, para usar el formato de visualización en el
tipo <code>T</code> en una función así como en el método <code>summarize</code>, podemos usar
<code>T: Summary + Display</code> para decir <code>T</code> puede ser cualquier tipo que implemente
<code>Summary</code> y <code>Display</code>.</p>
<p>Sin embargo, hay desventajas al uso de demasiados límites de <em>trait</em>. Cada
genérico tiene sus propios límites de <em>trait</em>, por lo que las funciones con
múltiples parámetros de tipo genérico pueden tener mucha información de
límite de caracteres entre el nombre de una función y su lista de parámetros,
lo que hace que la firma de la función sea difícil de leer. Por esta razón,
Rust tiene una sintaxis alternativa para especificar límites de <em>trait</em>
dentro de una cláusula <code>where</code> después de la firma de la función. Entonces,
en lugar de escribir esto:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>podemos usar una cláusula <code>where</code>, como esta:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>La firma de esta función es menos desordenada porque el nombre de la función,
la lista de parámetros y el tipo de retorno están muy juntos, de forma
similar a una función sin muchos límites de caracteres.</p>
<h3 id="reparar-la-función-largest-con-límites-de-trait"><a class="header" href="#reparar-la-función-largest-con-límites-de-trait">Reparar la función <code>largest</code> con límites de <em>Trait</em></a></h3>
<p>Ahora que sabe cómo especificar el comportamiento que desea usar utilizando
los límites del parámetro de tipo genérico, regresemos al Listado 10-5 para
corregir la definición de la función <code>largest</code> que usa un parámetro de
tipo genérico. La última vez que intentamos ejecutar ese código, recibimos
este error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>En el cuerpo de <code>largest</code> queríamos comparar dos valores de tipo <code>T</code> usando
el operador mayor que (<code>&gt;</code>). Debido a que ese operador se define como un
método predeterminado en el <em>trait</em> de la biblioteca estándar
<code>std::cmp::PartialOrd</code>, necesitamos especificar <code>PartialOrd</code> en los límites
de <em>trait</em> para <code>T</code>, de modo que la función <code>largest</code> puede funcionar en
sectores de cualquier tipo que podamos comparar no necesitamos traer
<code>PartialOrd</code> al alcance porque está en el preludio. Cambie la firma de
<code>largest</code> para que se vea así:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Esta vez, cuando compilamos el código, obtenemos un conjunto diferente de errores:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>La línea clave en este error es
<code>cannot move out of type [T], a non-copy slice</code>. Con nuestras versiones no
genéricas de la función <code>largest</code>, solo intentábamos encontrar el <code>i32</code> o
<code>char</code> más grande. Como se estudió en la sección “Datos apilados solo: copia”
en el Capítulo 4, los tipos como <code>i32</code> y <code>char</code> que tienen un tamaño conocido
se pueden almacenar en la pila (<em>stack</em>), por lo que implementan el <em>trait</em>
<code>Copy</code>. Pero cuando hicimos genérica la función <code>largest</code>, se hizo posible
que el parámetro <code>list</code> tuviera tipos que no implementan el <em>trait</em> <code>Copy</code>.
En consecuencia, no podríamos mover el valor fuera de <code>list[0]</code> y dentro de
la variable <code>largest</code>, lo que daría como resultado este error.</p>
<p>Para llamar a este código solo con aquellos tipos que implementan el <em>trait</em>
<code>Copy</code>, podemos agregar <code>Copy</code> a los límites de <em>trait</em> de <code>T</code>! El Listado
10-15 muestra el código completo de una función genérica <code>largest</code> que se
compilará siempre que los tipos de los valores en la porción que pasamos a la
función implementen los <em>trait</em> <code>PartialOrd</code> <em>y</em> <code>Copy</code>, como <code>i32</code> y <code>char</code>
hacen.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listing 10-15: Una definición trabajando de la función <code>largest</code> que funciona en cualquier tipo genérico que implemente los <em>traits</em> <code>PartialOrd</code> y <code>Copy</code></span></p>
<p>Si no queremos restringir la función <code>largest</code> a los tipos que implementan el
<em>trait</em> <code>Copy</code>, podríamos especificar que <code>T</code> tenga <em>trait bound</em> <code>Clone</code> en
lugar de <code>Copy</code>. Entonces podríamos clonar cada valor en el <em>slice</em> cuando
queremos que la función <code>largest</code> tenga propiedad. Usar la función <code>clone</code>
significa que potencialmente estamos haciendo más asignaciones de <em>heap</em> en
el caso de tipos que poseen datos de montículo (<em>heap</em>) como <code>String</code>, y las
asignaciones de <em>heap</em> pueden ser lentas si estamos trabajando con grandes
cantidades de datos.</p>
<p>Otra forma en que podríamos implementar <code>largest</code> es que la función devuelva
una referencia a un valor <code>T</code> en el <em>slice</em>. Si cambiamos el tipo de retorno
a <code>&amp; T</code> en lugar de <code>T</code>, cambiando así el cuerpo de la función para devolver
una referencia, no necesitaríamos los límites <em>trait</em> (<em>trait bounds</em>)
<code>Clone</code> o <code>Copy</code> y podríamos evitar las asignaciones de <em>heap</em>. ¡Intente implementar estas soluciones alternativas por su cuenta!</p>
<h3 id="usar-límites-de-trait-trait-bounds-para-implementar-métodos-condicionalmente"><a class="header" href="#usar-límites-de-trait-trait-bounds-para-implementar-métodos-condicionalmente">Usar límites de <em>trait</em> (<em>Trait Bounds</em>) para implementar métodos condicionalmente</a></h3>
<p>Al usar un <em>trait</em> vinculado con un bloque <code>impl</code> que usa parámetros de tipo
genérico, podemos implementar métodos condicionalmente para tipos que
implementan los <em>traits</em> especificados. Por ejemplo, el tipo <code>Pair &lt;T&gt;</code> en el
Listado 10-16 siempre implementa la función <code>new</code>. Pero <code>Pair &lt;T&gt;</code> solo
implementa el método <code>cmp_display</code> si su tipo interno <code>T</code> implementa el
<em>trait</em> <code>PartialOrd</code> que permite la comparación <em>y</em> el <em>trait</em> <code>Display</code> que
permite la impresión.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-16: Implementar métodos condicionalmente en
un tipo genérico dependiendo de los <em>trait bounds</em></span></p>
<p>También podemos implementar condicionalmente un <em>trait</em> para cualquier tipo
que implemente otro <em>trait</em>. Las implementaciones de un <em>trait</em> en cualquier
tipo que satisfaga los límites de <em>traits</em> se denominan
<em>blanket implementations</em> (<em>implementaciones generales</em>) y se usan ampliamente en la biblioteca estándar de Rust. Por
ejemplo, la biblioteca estándar implementa el <em>trait</em> <code>ToString</code> en cualquier
tipo que implemente el <em>trait</em> <code>Display</code>. El bloque <code>impl</code> en la biblioteca
estándar se ve similar a este código:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Debido a que la biblioteca estándar tiene esta implementación general,
podemos llamar al método <code>to_string</code> definido por el <em>trait</em> <code>ToString</code> en
cualquier tipo que implemente el <em>trait</em> <code>Display</code>. Por ejemplo, podemos
convertir enteros en sus correspondientes valores <code>String</code> como este porque
los enteros implementan <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Las implementaciones generales aparecen en la documentación del <em>trait</em> en la sección “Implementadores”.</p>
<p><em>Traits</em> and <em>trait bounds</em> nos permiten escribir código que usa parámetros
de tipo genérico para reducir la duplicación pero también especifica al
compilador que queremos que el tipo genérico tenga un comportamiento
particular. El compilador puede usar la información de <em>trait bound</em> para
verificar que todos los tipos concretos utilizados con nuestro código
proporcionen el comportamiento correcto. En lenguajes tipados dinámicamente,
obtendríamos un error en el tiempo de ejecución si llamamos a un método en un
tipo que el tipo no implementó. Pero Rust mueve estos errores en tiempo de
compilación, por lo que nos vemos obligados a solucionar los problemas antes
de que nuestro código pueda ejecutarse. Además, no tenemos que escribir
código que verifique el comportamiento en el tiempo de ejecución porque ya lo
hemos comprobado en tiempo de compilación. Al hacerlo, mejora el rendimiento
sin tener que renunciar a la flexibilidad de los genéricos.</p>
<p>Otro tipo de genérico que ya hemos estado usando se llama <em>lifetimes</em>. En
lugar de garantizar que un tipo tenga el comportamiento que queremos, los
tiempos de vida (<em>lifetimes</em>) garantizan que las referencias sean válidas siempre que lo necesitemos. Veamos cómo <em>lifetimes</em> hacen eso.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="validación-de-referencias-con-lifetimes"><a class="header" href="#validación-de-referencias-con-lifetimes">Validación de referencias con <em>Lifetimes</em></a></h2>
<p>Un detalle que no discutimos en la sección “Referencias y préstamos” en el
Capítulo 4 es que cada referencia en Rust tiene un <em>lifetime</em>, que es el
alcance para el cual esa referencia es válida. La mayoría de las veces, las
vidas son implícitas e inferidas, al igual que la mayoría de las veces, los
tipos son inferidos. Debemos anotar tipos cuando múltiples tipos son
posibles. De manera similar, debemos anotar las vidas cuando la vida de las
referencias se puede relacionar de diferentes maneras. Rust nos exige anotar
las relaciones utilizando parámetros genéricos de por vida para garantizar
que las referencias reales utilizadas en el tiempo de ejecución sean
definitivamente válidas.</p>
<p>El concepto de <em>tiempo de vida</em> (<em>lifetimes</em>) es algo diferente de las
herramientas en otros
lenguajes de programación, lo que podría decirse que hace que la
característica más distintiva de Rust sea la vida. Aunque no cubriremos las
vidas útiles en su totalidad en este capítulo, discutiremos las formas
comunes en que puede encontrar la sintaxis de por vida para que pueda
familiarizarse con los conceptos. Consulte la sección “Advanced Lifetimes” en
el Capítulo 19 para obtener información más detallada.</p>
<h3 id="previniendo-dangling-references-con-lifetimes"><a class="header" href="#previniendo-dangling-references-con-lifetimes">Previniendo <em>Dangling References</em> con <em>Lifetimes</em></a></h3>
<p>El objetivo principal de los <em>tiempos de vida</em> (<em>lifetimes</em>) es evitar las
referencias pendientes, que hacen que un programa haga referencia a datos
distintos de los datos a los que se pretende hacer referencia. Considere el
programa en el listado 10-17, que tiene un alcance externo y un alcance
interno.</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listado 10-17: un intento de usar una referencia cuyo
valor ha salido del alcance</span></p>
<blockquote>
<p>Nota: Los ejemplos en los listados 10-17, 10-18 y 10-24 declaran variables
sin darles un valor inicial, por lo que el nombre de la variable existe en
el ámbito externo. A primera vista, esto podría parecer en conflicto con que
Rust no tenga valores nulos. Sin embargo, si tratamos de usar una variable
antes de darle un valor, obtendremos un error en tiempo de compilación, que
muestra que Rust no permite valores nulos.</p>
</blockquote>
<p>El alcance externo declara una variable llamada <code>r</code> sin valor inicial, y el
alcance interno declara una variable llamada <code>x</code> con el valor inicial de 5.
Dentro del alcance interno, intentamos establecer el valor de <code>r</code> como
referencia a <code>x</code>. Luego, el alcance interno finaliza e intentamos imprimir el
valor en <code>r</code>. Este código no se compilará porque el valor <code>r</code> hace referencia
a que se ha salido del alcance antes de intentar usarlo. Aquí está el mensaje
de error:</p>
<pre><code class="language-text">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:5
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>La variable <code>x</code> no “vive lo suficiente”. La razón es que <code>x</code> estará fuera del
alcance cuando el alcance interno termine en la línea 7. Pero <code>r</code> sigue
siendo válido para el alcance externo; debido a que su alcance es mayor,
decimos que “vive más tiempo”. Si Rust permitía que este código funcionara,
<code>r</code> estaría haciendo referencia a la memoria que fue desasignada cuando <code>x</code>
salió del alcance, y todo lo que tratamos de hacer con <code>r</code> no funcionaría
correctamente. Entonces, ¿cómo determina Rust que este código no es válido?
utiliza un <em>comprobador de préstamos</em> (<em>borrow checker</em>).</p>
<h3 id="el-comprobador-de-préstamos-borrow-checker"><a class="header" href="#el-comprobador-de-préstamos-borrow-checker">El <em>comprobador de préstamos</em> (<em>Borrow Checker</em>)</a></h3>
<p>El compilador Rust tiene un <em>comprobador de préstamos</em> que compara los
ámbitos para determinar si todos los préstamos son válidos. El Listado 10-18
muestra el mismo código que el Listado 10-17 pero con anotaciones que
muestran la vida útil de las variables.</p>
<pre><code class="language-rust ignore">{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p><span class="caption">Listado 10-18: Anotaciones de los <em>lifetimes</em> de <code>r</code> y
<code>x</code>, llamadas <code>'a</code> y<code>'b</code>, respectivamente</span></p>
<p>Aquí, hemos anotado el <em>lifetime</em> de <code>r</code> con <code>'a</code> y la <em>lifetime</em> de <code>x</code>
con <code>'b</code>. Como puede ver, el bloque interno <code>'b</code> es mucho más pequeño que el
bloque de <em>lifetime</em> externo <code>'a</code>. En tiempo de compilación, Rust compara el tamaño
de los dos <em>lifetimes</em> y ve que <code>r</code> tiene un <em>lifetime</em> de <code>'a</code> pero que se refiere a la
memoria con un <em>lifetime</em> de <code>'b</code>. El programa se rechaza porque <code>'b</code> es más corto
que<code>'a</code>: el sujeto de la referencia no vive tanto tiempo como la referencia.</p>
<p>El Listado 10-19 corrige el código para que no tenga una referencia que cuelga y se compila sin ningún error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-19: Una referencia válida porque los datos
tienen una <em>lifetimes</em> más larga que la referencia</span></p>
<p>Aquí, <code>x</code> tiene la duración ``b<code>, que en este caso es más grande que </code>'a<code>. Esto significa que </code>r<code>puede hacer referencia a</code>x<code>porque Rust sabe que la referencia en</code>r<code>siempre será válida, mientras que</code>x` es válida.</p>
<p>Ahora que sabe dónde están los <em>lifetimes</em> de las referencias y cómo Rust
analiza los tiempos de vida para garantizar que las referencias siempre serán
válidas, exploremos los <em>lifetimes</em> genéricos de los parámetros y los
valores de retorno en el contexto de las funciones.</p>
<h3 id="generic-lifetimes-en-funciones"><a class="header" href="#generic-lifetimes-en-funciones"><em>Generic Lifetimes</em> en funciones</a></h3>
<p>Vamos a escribir una función que devuelva el mayor de dos <em>string slices</em>.
Esta función tomará dos <em>string slices</em> y devolverá un <em>string slice</em>.
Después de que hemos implementado la función <code>longest</code>, el código
en el Listado 10-20 debería imprimir
<code>The longest string is abcd</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listado 10-20: Una función <code>main</code> que llama a la
función <code>longest</code> para encontrar el más largo de dos <em>string slices</em></span></p>
<p>Tenga en cuenta que queremos que la función tome <em>string slices</em>, que son
referencias, porque no queremos que la función <code>longest</code> tome posesión de sus
parámetros. Queremos permitir que la función acepte <em>slices</em> de un <code>String</code>
(el tipo almacenado en la variable <code>string1</code>) así como de literales de
<em>string</em> (que es lo que contiene la variable <code>string2</code>).</p>
<p>Consulte la sección “<em>String Slices</em> como parámetros” en el Capítulo 4 para
obtener más información sobre por qué los parámetros que utilizamos en el
listado 10-20 son los que queremos.</p>
<p>Si tratamos de implementar la función <code>longest</code> como se muestra en el Listado
10-21, no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listado 10-21: una implementación de la función
<code>longest</code> que devuelve el mayor de dos <em>string slices</em> pero aún no
compila</span></p>
<p>En cambio, obtenemos el siguiente error que habla de <em>lifetimes</em>:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>El texto de ayuda revela que el tipo de devolución necesita un parámetro
genérico de <em>lifetimes</em> porque Rust no puede decir si la referencia que se
devuelve se refiere a <code>x</code> o <code>y</code>. En realidad, tampoco lo sabemos, porque el
bloque <code>if</code> en el cuerpo de esta función devuelve una referencia a <code>x</code> y el
bloque <code>else</code> devuelve una referencia a <code>y</code>!</p>
<p>Cuando estamos definiendo esta función, no conocemos los valores concretos
que se pasarán a esta función, por lo que no sabemos si se ejecutará el caso
<code>if</code> o el caso <code>else</code>. Tampoco conocemos los <em>lifetimes</em> concretos de las
referencias que se enviarán, por lo que no podemos mirar los ámbitos como lo hicimos en los listados 10-18 y 10-19 para determinar si la referencia que devolvemos siempre será válida. . El comprobador de préstamos tampoco puede determinar esto, porque no sabe cómo los <em>lifetimes</em> de <code>x</code> y <code>y</code> se relacionan con el <em>lifetimes</em> del valor de retorno. Para corregir este error, agregaremos parámetros genéricos de <em>lifetimes</em> que definan la relación entre las referencias para que el corrector de préstamos pueda realizar su análisis.</p>
<h3 id="lifetime-sintaxis-de-anotación"><a class="header" href="#lifetime-sintaxis-de-anotación"><em>Lifetime</em> sintaxis de anotación</a></h3>
<p>Las anotaciones de <em>lifetime</em> no cambian la duración de ninguna de las
referencias. Del mismo modo que las funciones pueden aceptar cualquier tipo
cuando la firma especifica un parámetro de tipo genérico, las funciones
pueden aceptar referencias de cualquier <em>lifetime</em> especificando un parámetro
genérico de <em>lifetime</em>. Las anotaciones de <em>lifetime</em> describen las relaciones de
<em>lifetime</em> de referencias múltiples entre sí sin afectar al <em>lifetimes</em>.</p>
<p>Las anotaciones de <em>lifetime</em> tienen una sintaxis levemente inusual: los
nombres de los parámetros de <em>lifetime</em> deben comenzar con un apóstrofo (<code>'</code>)
y generalmente son todos minúsculos y muy cortos, como los tipos genéricos.
La mayoría de las personas usa el nombre <code>'a</code>. Colocamos anotaciones de
parámetros de <em>lifetime</em> después de <code>&amp;</code> de una referencia, usando un espacio
para separar la anotación del tipo de referencia.</p>
<p>Aquí hay algunos ejemplos: una referencia a un <code>i32</code> sin un parámetro
<em>lifetime</em>, una referencia a un <code>i32</code> que tiene un parámetro de <em>lifetime</em>
llamado <code>'a</code>, y una referencia mutable a un <code>i32</code> que también tiene el
<em>lifetime</em> <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>Una anotación de por vida por sí misma no tiene mucho significado, porque las
anotaciones están destinadas a decirle a Rust cómo se relacionan entre sí los
parámetros genéricos de <em>lifetime</em> de las múltiples referencias. Por ejemplo,
supongamos que tenemos una función con el parámetro <code>first</code> que es una
referencia a <code>i32</code> con un valor de <em>lifetime</em> <code>'a</code>. La función también tiene
otro parámetro llamado <code>segundo</code> que es otra referencia a un <code>i32</code> que
también tiene el <em>lifetime</em> <code>'a</code>. Las anotaciones de <em>lifetime</em> indican que
las referencias <code>first</code> y <code>second</code> deben vivir tanto tiempo como el
<em>lifetime</em> genérico.</p>
<h3 id="anotaciones-lifetime-en-firmas-de-funciones"><a class="header" href="#anotaciones-lifetime-en-firmas-de-funciones">Anotaciones <em>Lifetime</em> en firmas de funciones</a></h3>
<p>Ahora examinemos las anotaciones de <em>lifetime</em> en el contexto de la función
<code>longest</code>. Al igual que con los parámetros de tipo genérico, debemos declarar
los parámetros genéricos de <em>lifetime</em> dentro de corchetes angulares entre el
nombre de la función y la lista de parámetros. La restricción que deseamos
expresar en esta firma es que todas las referencias en los parámetros y el
valor de retorno deben tener el mismo <em>lifetime</em>. Le asignaremos el nombre del
<em>lifetime</em> <code>'a</code> y luego lo agregaremos a cada referencia, como se muestra en
el listado 10-22.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-22: La definición de la función <code>longest</code>
que especifica que todas las referencias en la firma deben tener el mismo
<em>lifetime</em> <code>'a</code></span></p>
<p>Este código debe compilar y producir el resultado que queremos cuando lo
usamos con el función <code>main</code> en el listado 10-20.</p>
<p>La firma de la función ahora le dice a Rust que durante algún <em>lifetime</em> <code>'a</code>,la función toma dos parámetros, ambos son <em>string slice</em> que viven al menos
tanto como el <em>lifetime</em> <code>'a</code>. La firma de la función también le dice a Rust
que la <em>string slices</em> devuelta de la función vivirá al menos tanto como el
<em>lifetime</em> <code>'a</code>.
Estas restricciones son lo que queremos que Rust haga cumplir. Recuerde,
cuando especificamos los parámetros de <em>lifetime</em> en esta firma de función,
no estamos cambiando el <em>lifetime</em> de cualquier valor pasado o devuelto. Por
el contrario, estamos especificando que el comprobador de préstamos debería
rechazar cualquier valor que no se adhiera a estas restricciones. Tenga en cuenta que la función <code>longest</code> no necesita saber exactamente durante cuánto tiempo <code>x</code> y <code>y</code> van a vivir, solo que algún alcance puede ser sustituido
por <code>'a</code> que satisfará esta firma.</p>
<p>Al anotar <em>lifetimes</em> en funciones, las anotaciones van en la firma de
función, no en el cuerpo de la función.Rust puede analizar el código dentro
de la función sin ayuda. Sin embargo, cuando una función tiene referencias hacia o desde un código fuera de esa función, es casi imposible para Rust
calcular los <em>lifetimes</em> de los parámetros o valores de retorno por sí mismo.
Los <em>lifetimes</em> pueden ser diferentes cada vez que se llama a la función. Es
por eso que necesitamos anotar los <em>lifetimes</em> manualmente.</p>
<p>Cuando pasamos referencias concretas a <code>longest</code>, el <em>lifetimes</em> concreto es
sustituido por <code>'a</code> es la parte del alcance de <code>x</code> que se superpone con el
alcance de <code>y</code> En otras palabras, el <em>lifetimes</em> <code>'a</code> obtendrá el <em>lifetimes</em>
concreto que es igual a la más pequeña de los <em>lifetimes</em> de <code>x</code> y <code>y</code>.
Debido a que hemos anotado la referencia devuelta con el mismo parámetro de
<em>lifetimes</em> <code>'a</code>, la referencia devuelta también será válida para el
<em>lifetimes</em> de la menor de las vidas de <code>x</code> y <code>y</code>.</p>
<p>Veamos cómo las anotaciones de <em>lifetimes</em> restringen la función <code>longest</code>
pasando referencias que tienen diferentes <em>lifetimes</em> concretos. El listado
10-23 es un ejemplo directo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 10-23: Uso de la función <code>longest</code> con
referencias a valores <code>String</code> que tienen diferentes <em>lifetimes</em>
concretos</span></p>
<p>En este ejemplo, <code>string1</code> es válido hasta el final del alcance externo,
<code>string2</code> es válido hasta el final del alcance interno, y <code>result</code> hace
referencia a algo que es válido hasta el final del alcance interno. Ejecute
este código, y verá que el verificador de préstamos aprueba este código;
compilará e imprimirá
<code>The longest string is long string is long</code>.</p>
<p>A continuación, probemos con un ejemplo que muestra que el <em>lifetime</em> de la
referencia en <code>result</code> debe ser el menor <em>lifetime</em> de los dos argumentos.
Vamos a mover la declaración de la variable <code>result</code> fuera del alcance
interno, pero dejaremos la asignación del valor a la variable <code>result</code> dentro del alcance con <code>string2</code>. Luego moveremos el <code>println!</code> que usa <code>result</code>
fuera del alcance interno, después de que el alcance interno haya finalizado.
El código en el listado 10-24 no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-24: Intentar utilizar <code>result</code> después de
<code>string2</code> ha salido del alcance</span></p>
<p>Cuando intentemos compilar este código, obtendremos este error:</p>
<pre><code class="language-text">error[E0597]: `string2` does not live long enough
  --&gt; src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
15 |     }
   |     ^ `string2` dropped here while still borrowed
16 |     println!(&quot;The longest string is {}&quot;, result);
17 | }
   | - borrowed value needs to live until here
</code></pre>
<p>El error muestra que para que <code>result</code> sea válido para la instrucción
<code>println!</code>, <code>String2</code> debería ser válido hasta el final del alcance externo.
Rust lo sabe porque anotamos las <em>lifetimes</em> de los parámetros de función y los valores de retorno utilizando el mismo parámetro <em>lifetimes</em> <code>'a</code>.</p>
<p>Como humanos, podemos mirar este código y ver que <code>string1</code> es más largo que
<code>string2</code> y por lo tanto <code>result</code> contendrá una referencia a <code>string1</code>.
Debido a que <code>string1</code> no ha salido del ámbito, una referencia a <code>string1</code>
seguirá siendo válida para la instrucción <code>println!</code>. Sin embargo, el
compilador no puede ver que la referencia es válida en este caso. Le hemos
dicho a Rust que la <em>lifetime</em> de la referencia devuelta por la función
<code>longest</code> es la misma que la menor de las <em>lifetimes</em> de las referencias pasadas. Por lo tanto, el verificador de préstamos no permite el código en el Listado 10-24 como posiblemente tener una referencia inválida.</p>
<p>Intente diseñar más experimentos que varíen los valores y los <em>lifetimes</em> de
las referencias pasadas a la función <code>longest</code> y cómo se utiliza la
referencia devuelta. Haga hipótesis sobre si sus experimentos pasarán o no el
comprobador de préstamos antes de compilar; ¡luego verifica si tienes razón!</p>
<h3 id="pensando-en-términos-de-lifetimes"><a class="header" href="#pensando-en-términos-de-lifetimes">Pensando en términos de <em>Lifetimes</em></a></h3>
<p>La forma en que necesita especificar parámetros de <em>lifetime</em> depende de lo que esté haciendo su función. Por ejemplo, si cambiamos la implementación de la función <code>longest</code> para devolver siempre el primer parámetro en lugar del <em>string slice</em> más largo, no necesitaríamos especificar un <em>lifetime</em> en el parámetro <code>y</code>. El siguiente código se compilará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>En este ejemplo, hemos especificado un parámetro de <em>lifetime</em> <code>'a</code> para el
parámetro <code>x</code> y el tipo de retorno, pero no para el parámetro <code>y</code>, porque la
duración de <code>y</code> no tiene ninguna relación con la duración de <code>x</code> o el valor
de retorno.</p>
<p>Al devolver una referencia desde una función, el parámetro <em>lifetime</em> para el
tipo de retorno debe coincidir con el parámetro de duración de uno de los
parámetros. Si la referencia devuelta <em>no</em> hace referencia a uno de los
parámetros, debe hacer referencia a un valor creado dentro de esta función,
que sería una referencia colgante porque el valor saldrá del alcance al final
de la función. Considere esta implementación intentada de la función
<code>longest</code> que no compilará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Aquí, aunque hemos especificado un parámetro de <em>lifetime</em> <code>'a</code> para el tipo de devolución, esta implementación no podrá compilarse porque la duración del
valor de retorno no está relacionada con la duración de los parámetros. Aquí está el mensaje de error que obtenemos:</p>
<pre><code class="language-text">error[E0597]: `result` does not live long enough
 --&gt; src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the
function body at 1:1...
 --&gt; src/main.rs:1:1
  |
1 | / fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
2 | |     let result = String::from(&quot;really long string&quot;);
3 | |     result.as_str()
4 | | }
  | |_^
</code></pre>
<p>El problema es que <code>result</code> sale del alcance y se limpia al final de la
función <code>longest</code>. También estamos tratando de devolver una referencia al
<code>result</code> de la función. No hay forma de que podamos especificar parámetros
de <em>lifetime</em> que cambiarían la <em>referencia colgante</em> (<em>dangling reference</em>),y Rust no nos permitirá crear una referencia colgante. En este caso, la
mejor solución sería devolver un tipo de datos de propiedad en lugar de una
referencia, por lo que la función de llamada es responsable de limpiar el valor.</p>
<p>En última instancia, la sintaxis de <em>lifetime</em> trata de conectar los
<em>lifetimes</em> de varios parámetros y devolver valores de funciones. Una vez
que están conectados, Rust tiene suficiente información para permitir
operaciones de memoria segura y no permitir operaciones que podrían crear
punteros colgantes o violar la seguridad de la memoria.</p>
<h3 id="anotaciones-lifetime-en-las-definiciones-de-la-estructura"><a class="header" href="#anotaciones-lifetime-en-las-definiciones-de-la-estructura">Anotaciones <em>Lifetime</em> en las definiciones de la estructura</a></h3>
<p>Hasta ahora, solo hemos definido estructuras para mantener los tipos de
propiedad. Es posible que las estructuras tengan referencias, pero en ese
caso necesitaríamos agregar una anotación <em>lifetime</em> en cada referencia en
la definición de la estructura. El listado 10-25 tiene una estructura
llamada <code>ImportantExcerpt</code> que contiene un <em>string slice</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p><span class="caption">Listado 10-25: Una estructura que contiene una
referencia, por lo que su definición necesita una anotación de
<em>lifetime</em></span></p>
<p>Esta estructura tiene un campo, <code>part</code>, que contiene un <em>string slice</em>,
que es una referencia. Al igual que con los tipos de datos genéricos,
declaramos el nombre del parámetro genérico <em>lifetime</em> dentro de corchetes
angulares después del nombre de la estructura para que podamos usar el
parámetro de duración en el cuerpo de la definición de estructura. Esta
anotación significa que una instancia de <code>ImportantExcerpt</code> no puede
sobrevivir a la referencia que contiene en su campo <code>part</code>.</p>
<p>La función <code>main</code> aquí crea una instancia de la estructura
<code>ImportantExcerpt</code> que contiene una referencia a la primera <em>sentence</em> de
<code>String</code> propiedad de la variable <code>novel</code>. Los datos en <code>novel</code> existen
antes de que se cree la instancia <code>ImportantExcerpt</code>. Además, <code>novel</code> no
sale del alcance hasta que el <code>ImportantExcerpt</code> salga del ámbito, por lo
que la referencia en la instancia <code>ImportantExcerpt</code> es válida.</p>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision</a></h3>
<p>Aprendió que cada referencia tiene una <em>lifetime</em> y que necesita especificar
parámetros de <em>lifetime</em> para funciones o estructuras que usan referencias.
Sin embargo, en el Capítulo 4 teníamos una función en el Listado 4-9, que se
muestra nuevamente en el Listado 10-26, compilada sin anotaciones de
<em>lifetime</em>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 10-26: una función que definimos en el listado
4-9 que compilamos sin anotaciones de <em>lifetime</em>, aunque el parámetro y el
tipo de retorno son referencias</span></p>
<p>La razón por la que esta función se compila sin anotaciones de <em>lifetime</em> es
histórica: en las primeras versiones (anteriores a la 1.0) de Rust, este
código no se habría compilado porque cada referencia necesitaba una
<em>lifetime</em> explícita. En ese momento, la firma de la función se habría
escrito así:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Después de escribir mucho código de Rust, el equipo de Rust descubrió que
los programadores de Rust estaban ingresando las mismas anotaciones de
<em>lifetime</em> una y otra vez en situaciones particulares. Estas situaciones
eran predecibles y seguían algunos patrones deterministas. Los
desarrolladores programaron estos patrones en el código del compilador para
que el verificador de préstamos pudiera inferir los <em>lifetime</em> en estas
situaciones y no necesitara anotaciones explícitas.</p>
<p>Esta parte de la historia de Rust es relevante porque es posible que surjan patrones más deterministas y se agreguen al compilador. En el futuro, aún se necesitarán menos anotaciones de <em>lifetime</em>.</p>
<p>Los patrones programados en el análisis de referencias de Rust se llaman
<em>lifetime elision rules</em>. Estas no son reglas que los programadores deben
seguir; son un conjunto de casos particulares que el compilador considerará
y si su código se ajusta a estos casos, no necesita escribir los <em>lifetime</em>
de forma explícita.</p>
<p>Las reglas de <em>elisión</em> no proporcionan una inferencia completa. Si Rust
aplica las reglas de manera determinista pero todavía hay ambigüedad en
cuanto a los <em>lifetimes</em> que tienen las referencias, el compilador no
adivinará cuál debería ser el <em>lifetime</em> de las referencias restantes. En
este caso, en lugar de adivinar, el compilador le dará un error que puede
resolver agregando las anotaciones de <em>lifetimes</em> que especifican cómo se
relacionan las referencias entre sí.</p>
<p>Los periodos de <em>lifetime</em> de la función o los parámetros del método se
denominan <em>input lifetimes</em>, y los <em>lifetime</em> en los valores de retorno se
denominan <em>output lifetimes</em>.</p>
<p>El compilador utiliza tres reglas para determinar qué referencias de
<em>lifetime</em> tienen cuando no hay anotaciones explícitas. La primera regla se
aplica a los <em>lifetimes</em> de las entradas, y las reglas segunda y tercera se
aplican a los <em>lifetimes</em> de las salidas. Si el compilador llega al final de
las tres reglas y todavía hay referencias para las cuales no puede calcular
las duraciones, el compilador se detendrá con un error.</p>
<p>La primera regla es que cada parámetro que es una referencia obtiene su
propio parámetro de <em>lifetimes</em>. En otras palabras, una función con un
parámetro obtiene un parámetro de <em>lifetimes</em>: <code>fn foo &lt;'a&gt; (x: &amp;' a i32)</code>;
una función con dos parámetros obtiene dos parámetros de <em>lifetimes</em>
separados: <code>fn foo &lt;'a,' b&gt; (x: &amp; 'a i32, y: &amp;' b i32)</code>; y así.</p>
<p>La segunda regla es si hay exactamente un parámetro de <em>lifetime</em> útil de
entrada, ese tiempo de <em>lifetimes</em> está asignado a todos los parámetros de
<em>lifetimes</em> útil de salida: <code>fn foo &lt;'a&gt; (x: &amp;' a i32) -&gt; &amp; 'a i32</code>.</p>
<p>La tercera regla es si hay múltiples parámetros de <em>lifetimes</em> de entrada,
pero uno de ellos es <code>&amp;self</code> o <code>&amp;mut self</code> porque este es un método, el
<em>lifetime</em> de <code>self</code> se asigna a todos los parámetros de <em>lifetime</em> de
salida. Esta tercera regla hace que los métodos sean mucho más agradables de
leer y escribir porque son necesarios menos símbolos.</p>
<p>Hagamos como si fuéramos el compilador. Aplicaremos estas reglas para averiguar cuáles son las duraciones de las referencias en la firma de la función <code>first_word</code> en el listado 10-26. La firma comienza sin ningún <em>tiempo de vida</em> (<em>lifetimes</em>) asociado con las referencias:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Luego el compilador aplica la primera regla, que especifica que cada
parámetro obtiene su propia <em>lifetime</em>. Lo llamaremos <code>'a</code> como de costumbre
así que ahora la firma es esta:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>La segunda regla se aplica porque hay exactamente una <em>input lifetime</em>. La segunda regla especifica que el <em>lifetime</em> de un parámetro de entrada se asigna a la <em>output lifetime</em>, por lo que la firma es ahora la siguiente:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Ahora todas las referencias en esta firma de función tienen tiempos de vida,
y el compilador puede continuar su análisis sin necesidad de que el programador anote los <em>lifetimes</em> en esta firma de función.</p>
<p>Veamos otro ejemplo, esta vez usando la función <code>longest</code> que no tenía
parámetros de <em>lifetimes</em> cuando comenzamos a trabajar con ella en el Listado
10-21:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Vamos a aplicar la primera regla: cada parámetro tiene su propio <em>lifetime</em>.
Esta vez tenemos dos parámetros en lugar de uno, así que tenemos dos <em>lifetime</em>:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Puede ver que la segunda regla no se aplica porque hay más de un
<em>input lifetime</em>. La tercera regla tampoco se aplica porque <code>longest</code> es una
función en lugar de un método, por lo que ninguno de los parámetros es
<code>self</code>. Después de trabajar en las tres reglas, todavía no hemos descubierto
cuál es la duración del tipo de devolución. Esta es la razón por la cual
obtuvimos un error al tratar de compilar el código en el Listado 10-21: el
compilador trabajó a través de las reglas de <em>elisión</em> de <em>lifetime</em>, pero
aún no pudo determinar todos los <em>lifetimes</em> de las referencias en la firma.</p>
<p>Debido a que la tercera regla realmente solo se aplica a las firmas de
métodos, veremos los <em>lifetimes</em> en ese contexto al lado para ver por qué la
tercera regla significa que no tenemos que anotar <em>lifetime</em> en las firmas
de métodos muy a menudo.</p>
<h3 id="anotaciones-de-lifetime-en-las-definiciones-de-métodos"><a class="header" href="#anotaciones-de-lifetime-en-las-definiciones-de-métodos">Anotaciones de <em>Lifetime</em> en las definiciones de métodos</a></h3>
<p>Cuando implementamos métodos en una estructura con <em>lifetimes</em>, utilizamos
la misma sintaxis que la de los parámetros de tipo genérico que se muestran
en el Listado 10-11. Donde declaramos y usamos los parámetros de <em>lifetime</em>
depende de si están relacionados con los campos de estructura o los
parámetros de método y los valores de retorno.</p>
<p>Los nombres de <em>lifetime</em> para los campos de estructura siempre tienen que
declararse después de la palabra clave <code>impl</code> y luego usarse después del
nombre de la estructura, porque esos tiempos de <em>lifetime</em> son parte del
tipo de estructura.</p>
<p>En las firmas de métodos dentro del bloque <code>impl</code>, las referencias pueden
estar vinculadas a la duración de las referencias en los campos de la
estructura, o pueden ser independientes. Además, las reglas de <em>elisión</em> de
<em>lifetime</em> a menudo hacen que las anotaciones de <em>lifetime</em> no sean
necesarias en las firmas de métodos. Veamos algunos ejemplos usando la
estructura llamada <code>ImportantExcerpt</code> que definimos en el Listado 10-25.</p>
<p>Primero, usaremos un método llamado <code>level</code> cuyo único parámetro es una
referencia a <code>self</code> y cuyo valor de retorno es <code>i32</code>, que no es una
referencia a nada:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>La declaración del parámetro de <em>lifetime</em> después de <code>impl</code> y su uso
después del nombre del tipo es obligatoria, pero no es necesario que
anotemos el <em>lifetime</em> de la referencia a <code>self</code> debido a la primera regla
de <em>elisión</em>.</p>
<p>Aquí hay un ejemplo donde se aplica la tercera regla de <em>elisión</em> de <em>lifetime</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Hay dos <em>input lifetimes</em>, por lo que Rust aplica la primera regla de
<em>elisión lifetime</em> y otorga a ambos <code>&amp;self</code> y al <code>announcement</code> su propia
<em>lifetimes</em>. Entonces, debido a que uno de los parámetros es <code>&amp;self</code>, el
tipo de retorno obtiene el <em>lifetime</em> de <code>&amp;self</code>, y todos los <em>lifetimes</em>
han sido contabilizados.</p>
<h3 id="la-lifetime-estático"><a class="header" href="#la-lifetime-estático">La <em>Lifetime</em> estático</a></h3>
<p>Una <em>lifetime</em> especial que debemos analizar es <code>'estática</code>, que denota la
duración total del programa. Todos los literales de string tienen la
duración de <em>lifetime</em> <code>'static</code>, que podemos anotar de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>El texto de este <em>string</em> se almacena directamente en el binario de tu
programa, que siempre está disponible. Por lo tanto, el <em>lifetime</em> de todos
los literales de cadena es <code>'static</code>.</p>
<p>Es posible que vea sugerencias para utilizar el <em>lifetime</em> <code>'static</code> en los
mensajes de error. Pero antes de especificar <code>'static</code> como el <em>lifetime</em> de
una referencia, piense si la referencia en realidad la ha vivido durante
toda la vida de su programa o no. Puede considerar si desea que viva tanto
tiempo, incluso si pudiera. La mayoría de las veces, el problema es el
resultado de intentar crear una referencia colgante o un desajuste de los
<em>lifetimes</em> disponibles. En tales casos, la solución es solucionar esos
problemas, sin especificar el <em>lifetime</em> <code>'static</code>.</p>
<h2 id="parámetros-genéricos-de-tipo-trait-bounds-y-lifetime-juntos"><a class="header" href="#parámetros-genéricos-de-tipo-trait-bounds-y-lifetime-juntos">Parámetros genéricos de tipo, <em>Trait Bounds</em> y <em>Lifetime</em> juntos</a></h2>
<p>¡Veamos brevemente la sintaxis de especificar los parámetros de tipo
genérico, los <em>trait bounds</em> y los <em>lifetimes</em>, todo en una
función!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta es la función <code>longest</code> del Listado 10-22 que devuelve el mayor de dos
<em>string slices</em>. Pero ahora tiene un parámetro extra llamado <code>ann</code> del tipo
genérico <code>T</code>, que puede rellenarse por cualquier tipo que implemente el
rasgo <code>Display</code> como se especifica en la cláusula <code>where</code>. Este parámetro
adicional se imprimirá antes de que la función compare las longitudes de los
<em>string slices</em>, por lo que es necesario el <em>trait bound</em> <code>Display</code>. Como
los <em>lifetime</em> son un tipo de genérico, las declaraciones del parámetro de
<em>lifetime</em> <code>'a</code> y el parámetro de tipo genérico <code>T</code> van en la misma lista
dentro de los corchetes angulares después del nombre de la función.</p>
<h2 id="resumen-8"><a class="header" href="#resumen-8">Resumen</a></h2>
<p>¡Cubrimos mucho en este capítulo! Ahora que sabe acerca de los parámetros de
tipo genérico, los <em>traits</em> los <em>trait bounds</em>, y los parámetros genéricos
de <em>lifetime</em>, está listo para escribir código sin repetición que funcione
en muchas situaciones diferentes. Los parámetros genéricos de tipo le
permiten aplicar el código a diferentes tipos. Los <em>trait</em> y los <em>trait
bounds</em> aseguran que, aunque los tipos son genéricos, tendrán el
comportamiento que el código necesita. Aprendió a usar anotaciones de por
vida para asegurarse de que este código flexible no tenga referencias
colgantes. ¡Y todo este análisis ocurre en tiempo de compilación, lo que no
afecta el rendimiento del tiempo de ejecución!</p>
<p>Créalo o no, hay mucho más que aprender sobre los temas que estudiamos en
este capítulo: el Capítulo 17 muestra los objetos de <em>trait</em>, que son otra
forma de usar los <em>traits</em>. El Capítulo 19 cubre escenarios más complejos
que implican anotaciones de <em>lifetime</em>, así como algunas características
avanzadas del sistema de tipo. Pero a continuación, aprenderá cómo escribir
pruebas en Rust para asegurarse de que su código funcione como debería.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escribir-pruebas-automatizadas"><a class="header" href="#escribir-pruebas-automatizadas">Escribir pruebas automatizadas</a></h1>
<p>En su ensayo de 1972 “The Humble Programmer”, Edsger W. Dijkstra dijo que
“las pruebas del programa pueden ser una forma muy efectiva de mostrar la
presencia de errores, pero es irremediablemente inadecuado para mostrar su
ausencia”. ¡Eso no significa que no deberíamos intentar probar tanto como
podamos!</p>
<p>La corrección en nuestros programas es la medida en que nuestro código hace
lo que pensamos que haga. Rust está diseñado con un alto grado de
preocupación sobre la corrección de los programas, pero la corrección es
compleja y no es fácil de probar. El sistema de tipos de Rust soporta una
gran parte de esta carga, pero el sistema de tipos no puede detectar todo
tipo de incorrecciones. Como tal, Rust incluye soporte para escribir pruebas
automatizadas de software dentro del lenguaje.</p>
<p>Como ejemplo, digamos que escribimos una función llamada <code>add_two</code> que agrega
2 al número que se le pasa. La firma de esta función acepta un entero como
parámetro y devuelve un entero como resultado. Cuando implementamos y
compilamos esa función, Rust hace todo el chequeo de tipos y verificación de
préstamos que has aprendido hasta ahora para asegurarte de que, por ejemplo,
no estamos pasando un valor <code>String</code> o una referencia inválida a esta
función. Pero Rust <em>no puede</em> verificar que esta función hará exactamente lo
que pretendemos, que es devolver el parámetro más 2 en lugar de, digamos, el
parámetro más 10 o el parámetro menos 50. Ahí es donde entran las pruebas.</p>
<p>Podemos escribir pruebas que afirmen, por ejemplo, que cuando pasamos <code>3</code> a
la función <code>add_two</code>, el valor devuelto es <code>5</code>. Podemos ejecutar estas
pruebas cada vez que hagamos cambios a nuestro código para asegurarnos de que
ningún comportamiento correcto existente no haya cambiado.</p>
<p>Las pruebas son una habilidad compleja: aunque no podemos cubrir todos los
detalles sobre cómo escribir buenas pruebas en un capítulo, estudiaremos la
mecánica de las instalaciones de prueba de Rust. Hablaremos sobre las
anotaciones y macros disponibles para usted cuando escriba sus pruebas, el
comportamiento predeterminado y las opciones proporcionadas para ejecutar sus
pruebas, y cómo organizar las pruebas en pruebas unitarias y pruebas de
integración.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cómo-escribir-pruebas"><a class="header" href="#cómo-escribir-pruebas">Cómo escribir pruebas</a></h2>
<p>Las pruebas son funciones de Rust que verifican que el código que no es
prueba está funcionando de la manera esperada. Los cuerpos de las funciones
de prueba suelen realizar estas tres acciones:</p>
<ol>
<li>Configure cualquier información o estado necesario.</li>
<li>Ejecute el código que desea probar.</li>
<li>Afirma que los resultados son lo que esperas.</li>
</ol>
<p>Veamos las características que Rust proporciona específicamente para escribir
pruebas que toman estas acciones, que incluyen el atributo <code>test</code>, algunas
macros y el atributo <code>should_panic</code>.</p>
<h3 id="la-anatomía-de-una-función-de-prueba"><a class="header" href="#la-anatomía-de-una-función-de-prueba">La anatomía de una función de prueba</a></h3>
<p>En su forma más simple, una prueba en Rust es una función anotada con el
atributo <code>test</code>. Los atributos son metadatos sobre piezas de código Rust; un
ejemplo es el atributo <code>derive</code> que usamos con las estructuras en el
Capítulo 5. Para cambiar una función a una función de prueba, agregue
<code>#[test]</code> en la línea antes de <code>fn</code>. Cuando ejecuta sus pruebas con el
comando <code>cargo test</code>, Rust construye un binario ejecutable de prueba que
ejecuta las funciones anotadas con el atributo <code>test</code> e informa si cada
función de prueba pasa o falla.</p>
<p>En el Capítulo 7, vimos que cuando realizamos un nuevo proyecto de biblioteca
con Cargo, automáticamente se genera para nosotros un módulo de prueba con
una función de prueba. Este módulo le ayuda a comenzar a escribir sus pruebas
para que no tenga que buscar la estructura exacta y la sintaxis de las
funciones de prueba cada vez que inicia un nuevo proyecto. ¡Puede agregar
tantas funciones de prueba adicionales como tantos módulos de prueba como
desee!</p>
<p>Exploraremos algunos aspectos de cómo funcionan las pruebas experimentando
con la prueba de plantilla generada por nosotros sin probar realmente ningún
código. Luego, escribiremos algunas pruebas del mundo real que llaman a algún
código que hemos escrito y afirman que su comportamiento es correcto.</p>
<p>Vamos a crear un nuevo proyecto de biblioteca llamado <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>El contenido del archivo <em>src/lib.rs</em> en su biblioteca <code>adder</code> debe parecerse
al Listado 11-1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-1: el módulo de prueba y la función generada
automáticamente por <code>cargo new</code></span></p>
<p>Por ahora, ignoremos las dos líneas superiores y nos centraremos en la
función para ver cómo funciona. Tenga en cuenta la anotación <code>#[test]</code> antes
de la línea <code>fn</code>: este atributo indica que se trata de una función de prueba,
por lo que el ejecutable de prueba sabe que debe tratar esta función como una
prueba. También podríamos tener funciones que no sean de prueba en el módulo
<code>tests</code> para ayudar a configurar escenarios comunes o realizar operaciones
comunes, por lo que debemos indicar qué funciones son pruebas utilizando el
atributo <code>#[test]</code>.</p>
<p>El cuerpo de la función utiliza la macro <code>assert_eq!</code> Para afirmar que 2 + 2
es igual a 4. Esta afirmación sirve como un ejemplo del formato para una
prueba típica. Vamos a ejecutarlo para ver que pasa esta prueba.</p>
<p>El comando <code>cargo test</code> ejecuta todas las pruebas en nuestro proyecto, como
se muestra en el Listado 11-2.</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">Listado 11-2: El resultado de ejecutar la prueba
generada automáticamente</span></p>
<p>Cargo compilado y ejecutado la prueba. Después de las líneas <code>Compiling</code>,
<code>Finished</code>, y <code>Running</code> está la línea <code>running 1 test</code>. La siguiente línea
muestra el nombre de la función de prueba generada, llamada <code>it_works</code>, y el
resultado de ejecutar esa prueba, <code>ok</code>. El resumen general de la ejecución de
las pruebas aparece a continuación. El texto <code>test result: ok</code> significa que
pasaron todas las pruebas y que pasó la porción que dice <code>1 passed; 0 failed</code>
totaliza el número de pruebas que pasaron o fallaron.</p>
<p>Como no tenemos ninguna prueba que hayamos marcado como ignorada, el resumen
muestra <code>0 ignorado</code>. Tampoco hemos filtrado las pruebas que se están
ejecutando, por lo que el final del resumen muestra <code>0 filtered out</code>.
Hablaremos sobre ignorar y filtrar las pruebas en la siguiente sección,
“Controlar cómo se ejecutan las pruebas”.</p>
<p>La estadística <code>0 measured</code> es para <em>benchmark tests</em> que miden el
rendimiento. <em>Benchmark tests</em>, al momento de escribir este
documento, solo disponibles en Rust <em>nightly</em>. Ver
<a href="../../unstable-book/library-features/test.html">the documentation about benchmark tests</a> para aprender más.</p>
<p>La siguiente parte de la salida de prueba, que comienza con <code>Doc-tests adder</code>,
es para los resultados de cualquier prueba de documentación. Todavía no
tenemos pruebas de documentación, pero Rust puede compilar cualquier ejemplo
de código que aparezca en nuestra documentación API. ¡Esta característica nos
ayuda a mantener nuestros documentos y nuestro código sincronizados!
Discutiremos cómo escribir pruebas de documentación en la sección
“Comentarios de la documentación como pruebas” del Capítulo 14. Por ahora,
ignoraremos el resultado de <code>Doc-tests</code>.</p>
<p>Cambiemos el nombre de nuestra prueba para ver cómo eso cambia la salida de
la prueba. Cambie la función <code>it_works</code> a un nombre diferente, como
<code>exploration</code>, como sigue:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<p>Luego ejecute <code>cargo test</code> nuevamente. La salida ahora muestra <code>exploración</code> en lugar de <code>it_works</code>:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Agreguemos otra prueba, ¡pero esta vez haremos una prueba que falla! Las
pruebas fallan cuando algo en la función de prueba entra en pánico. Cada
prueba se ejecuta en un nuevo <em>hilo</em> (<em>thread</em>), y cuando el hilo principal
ve que un hilo de prueba ha muerto, la prueba se marca como fallida. Hablamos
sobre la forma más simple de causar pánico en el Capítulo 9, que es llamar a
la macro <code>panic!</code>. Ingrese la nueva prueba, <code>another</code>, para que su archivo
<em>src/lib.rs</em> se vea como el Listado 11-3.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-3: Agregar una segunda prueba que fallará
porque llamamos a la macro <code>panic!</code>o</span></p>
<p>Ejecute las pruebas nuevamente usando <code>cargo test</code>. La salida debería verse
como el Listado 11-4, que muestra que nuestra prueba <code>exploración</code> pasó y
<code>another</code> falló.</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed
</code></pre>
<p><span class="caption">Listado 11-4: resultados de la prueba cuando una prueba
pasa y una prueba falla</span></p>
<p>En lugar de <code>ok</code>, la línea <code>test tests::another</code> muestra <code>FAILED</code>. Aparecen
dos nuevas secciones entre los resultados individuales y el resumen: la
primera sección muestra el motivo detallado de cada falla de prueba. En este
caso, <code>another</code> falló porque <code>panicked at 'Make this test fail'</code>, que sucedió
en la línea 10 en el archivo <em>src/lib.rs</em>. La siguiente sección enumera solo
los nombres de todas las pruebas que fallan, lo cual es útil cuando hay
muchas pruebas y muchos resultados de pruebas fallidas detalladas. Podemos
usar el nombre de una prueba que falla para ejecutar solo esa prueba para
depurarla más fácilmente; hablaremos más sobre las formas de ejecutar pruebas
en la sección “Controlar cómo se ejecutan las pruebas”.</p>
<p>La línea de resumen se muestra al final: en general, el resultado de nuestra
prueba es <code>FAILED</code>. Tuvimos un pase de prueba y una prueba falló.</p>
<p>Ahora que ha visto cómo son los resultados de las pruebas en diferentes
escenarios, veamos algunas macros además de <code>panic!</code> Que son útiles en las
pruebas.</p>
<h3 id="comprobando-los-resultados-con-la-macro-assert"><a class="header" href="#comprobando-los-resultados-con-la-macro-assert">Comprobando los resultados con la macro <code>assert!</code></a></h3>
<p>La macro <code>assert!</code>, Provista por la biblioteca estándar, es útil cuando
quiere asegurarse de que alguna condición en una prueba se evalúe como
<code>true</code>. Le damos a la macro <code>assert!</code> Un argumento que evalúa a un booleano.
Si el valor es <code>true</code>,<code>assert!</code>No hace nada y la prueba pasa. Si el valor
es <code>false</code>, la macro <code>assert! </code>Llama a la macro <code>panic!</code>, Lo que hace que la
prueba falle. El uso de la macro <code>assert!</code> Nos ayuda a verificar que nuestro
código funcione de la manera que queremos.</p>
<p>En el Capítulo 5, Listado 5-15, usamos una estructura <code>Rectangle</code> y un método <code>can_hold</code>, que se repiten aquí en el Listado 11-5. Pongamos este código en el archivo <em>src/lib.rs</em> y escribamos algunas pruebas con la macro <code>assert!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-5: Usando la estructura <code>Rectangle</code> y su
método <code>can_hold</code> del Capítulo 5</span></p>
<p>El método <code>can_hold</code> devuelve un booleano, lo que significa que es un caso de
uso perfecto para la macro <code>assert! </code>. En el listado 11-6, escribimos una
prueba que ejerce el método <code>can_hold</code> creando una instancia <code>Rectangle</code> que
tiene una longitud de 8 y un ancho de 7 y afirma que puede contener otra
instancia <code>Rectangle</code> que tiene una longitud de 5 y un ancho de 1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-6: Una prueba para <code>can_hold</code> que verifica
si un rectángulo más grande puede contener un rectángulo más pequeño</span></p>
<p>Tenga en cuenta que hemos agregado una nueva línea dentro del módulo
<code>tests</code>: <code>use super::*;</code>. El módulo <code>tests</code> es un módulo regular que sigue
las reglas de visibilidad habituales que cubrimos en el Capítulo 7 en la
sección “Reglas de privacidad” . Como el módulo <code>tests</code> es un módulo interno,
debemos poner el código bajo prueba en el módulo externo dentro del alcance
del módulo interno. Aquí usamos un glob para que todo lo que definimos en el
módulo externo esté disponible para este módulo <code>tests</code>.</p>
<p>Hemos nombrado a nuestra prueba <code>larger_can_hold_smaller</code>, y hemos creado las
dos instancias <code>Rectangle</code> que necesitamos. Luego llamamos a la macro
<code>assert!</code> Y la pasamos como resultado de llamar
<code>larger.can_hold(&amp;smaller)</code>. Se supone que esta expresión devuelve <code>true</code>,
por lo que nuestra prueba debería pasar. ¡Vamos a averiguar!</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Pasa!, agreguemos otra prueba, esta vez afirmando que un rectángulo más
pequeño no puede contener un rectángulo más grande:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre></pre>
<p>Debido a que el resultado correcto de la función <code>can_hold</code> en este caso es
<code>false</code>, necesitamos negar ese resultado antes de pasarlo a la macro
<code>assert!</code>. Como resultado, nuestra prueba pasará si <code>can_hold</code> devuelve
<code>false</code>:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Dos pruebas que pasan! Ahora veamos qué sucede con los resultados de
nuestras pruebas cuando introducimos un error en nuestro código. Cambiemos la
implementación del método <code>can_hold</code> reemplazando el signo mayor que con un
signo menor que cuando se comparan las longitudes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub struct Rectangle {
</span><span class="boring">    length: u32,
</span><span class="boring">    width: u32,
</span><span class="boring">}
</span>// --snip--

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
</code></pre></pre>
<p>Ejecutar las pruebas ahora produce lo siguiente:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Nuestras pruebas captaron el error! Como <code>larger.length</code> es 8 y
<code>smaller.length</code> es 5, la comparación de las longitudes en <code>can_hold</code> ahora
devuelve <code>false</code>: 8 no es menor que 5.</p>
<h3 id="probando-la-igualdad-con-las-macros-assert_eq-y-assert_ne"><a class="header" href="#probando-la-igualdad-con-las-macros-assert_eq-y-assert_ne">Probando la igualdad con las macros <code>assert_eq!</code> Y <code>assert_ne!</code></a></h3>
<p>Una forma común de probar la funcionalidad es comparar el resultado del
código bajo prueba con el valor que espera que devuelva el código para
asegurarse de que son iguales. Puede hacer esto usando la macro <code>assert!</code> Y
pasarle una expresión usando el operador <code>==</code>. Sin embargo, esta es una
prueba tan común que la biblioteca estándar proporciona un par de macros:
<code>assert_eq!</code> y <code>assert_ne!</code> para realizar esta prueba de manera más
conveniente. Estas macros comparan dos argumentos para igualdad o desigualdad,
respectivamente. También imprimirán los dos valores si la afirmación falla,
lo que hace que sea más fácil ver <em>por qué</em> la prueba falló; por el contrario
la macro <code>assert!</code> solo indica que obtuvo un valor <code>false</code> para la expresión
<code>==</code>, no los valores que conducen al valor <code>false</code>.</p>
<p>En el listado 11-7, escribimos una función llamada <code>add_two</code> que agrega <code>2</code> a
su parámetro y devuelve el resultado. Luego probamos esta función usando la
macro <code>assert_eq!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-7: probando la función <code>add_two</code> usando la
macro <code>assert_eq!</code></span></p>
<p>¡Comprobemos que pase!</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>El primer argumento que le dimos a la macro <code>assert_eq!</code>, <code>4</code>, es igual al
resultado de invocar <code>add_two(2)</code>. La línea para esta prueba es
<code>test tests::it_adds_two ... ok</code>, y el texto <code>ok</code> indica que nuestra prueba
pasó.</p>
<p>Vamos a introducir un error en nuestro código para ver cómo funciona cuando
falla una prueba que usa <code>assert_eq!</code>. Cambie la implementación de la
función <code>add_two</code> para agregar <code>3</code> en su lugar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
</code></pre></pre>
<p>Ejecute las pruebas nuevamente:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
        thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Nuestra prueba captó el error! La prueba <code>it_adds_two</code> falló, mostrando el
mensaje <code>assertion failed: `(left == right)`</code> y mostrando que <code>left</code> era
<code>4</code> y <code>right</code> era <code>5</code>. Este mensaje es útil y nos ayuda a comenzar la
depuración: significa el argumento <code>left</code> para <code>assert_eq!</code> era <code>4</code> pero el
argumento <code>right</code>, donde tenía <code>add_two (2)</code>, era <code>5</code>.</p>
<p>Tenga en cuenta que en algunos lenguajes y marcos de prueba, los parámetros
de las funciones que afirman que dos valores son iguales se llaman
<code>expected</code> y <code>real</code>, y el orden en que especificamos los argumentos es
importante. Sin embargo, en Rust, se llaman <code>left</code> y <code>right</code>, y el orden en
que especificamos el valor esperamos y el valor que produce el código bajo
prueba no importa. Nosotros podría escribir la afirmación en esta prueba
como <code>assert_eq! (add_two (2), 4)</code>, que daría como resultado un mensaje de
error que muestra <code>assertion failed: `(left ==right)</code>  y que <code>left</code> era
<code>5</code> y <code>right</code> era <code>4</code>.</p>
<p>La macro <code>assert_ne!</code> Pasará si los dos valores que le damos no son iguales y
fallar si son iguales Esta macro es más útil para casos en los que no
estamos seguros qué valor <em>será</em>, pero sabemos cuál es el valor
definitivamente <em>no</em> será si nuestro el código está funcionando como
queremos. Por ejemplo, si estamos probando una función que está garantizado
para cambiar su entrada de alguna manera, pero la forma en que la entrada
se cambia depende del día de la semana en que realizamos nuestras pruebas,
lo mejor afirmar podría ser que la salida de la función no es igual a la
entrada.</p>
<p>Debajo de la superficie, las macros <code>assert_eq!</code> y <code>assert_ne!</code> Usan los
operadores <code>==</code> y <code>! =</code>, respectivamente. Cuando las aserciones fallan,
estas macros imprimen su argumentos que utilizan el formato de depuración,
lo que significa que los valores que se comparan deben implementar los
<em>trait</em> <code>PartialEq</code> y <code>Debug</code>. Todos los tipos primitivos y la mayoría
de los tipos de biblioteca estándar implementan estos <em>trait</em>. Para
estructuras y enumeraciones que defina, necesitará implementar <code>PartialEq</code>
para afirmar que los valores de esos tipos son iguales o no iguales.
Necesitarás implementar <code>Debug</code> para imprimir los valores cuando la
afirmación falla. Debido a que ambos <em>trait</em> son <em>trait</em> derivables,
como se menciona en el Listado 5-12 en el Capítulo 5, esto suele ser tan
sencillo como agregar la anotación <code>#[derive (PartialEq, Debug)]</code> a su
definición <em>struct</em> o <em>enum</em>. Ver el Apéndice C para más detalles sobre estos y otros <em>trait</em> derivables.</p>
<h3 id="agregar-mensajes-personalizados-de-fallo"><a class="header" href="#agregar-mensajes-personalizados-de-fallo">Agregar mensajes personalizados de fallo</a></h3>
<p>También puede agregar un mensaje personalizado para imprimir con el mensaje
de fallo como argumentos opcionales para las macros <code>assert!</code>, <code>Assert_eq!</code>,
y <code>assert_ne!</code>. Cualquier argumento especificado después de un argumento
requerido para <code>assert!</code> o los dos argumentos requeridos para <code>assert_eq!</code> y
<code>assert_ne!</code> se pasan a la macro <code>format!</code> (Estudiado en el Capítulo 8 en la
sección “Concatenación con el operador <code>+</code> o la Macro <code>format!</code>”), por lo
que puede pasar una cadena de formato que contenga <code>{}</code> marcadores de
posición y valores para ir en esos marcadores de posición. Los mensajes
personalizados son útiles para documentar lo que significa una afirmación;
cuando falla una prueba, tendrá una mejor idea de cuál es el problema con el
código.</p>
<p>Por ejemplo, supongamos que tenemos una función que saluda a las personas
por su nombre y queremos probar que el nombre que pasamos a la función
aparezca en el resultado:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre></pre>
<p>Los requisitos para este programa aún no se han acordado, y estamos bastante
seguros de que el texto <code>Hello</code> al comienzo del saludo cambiará. Decidimos
que no queremos tener que actualizar la prueba cuando cambian los requisitos
así que en lugar de verificar la igualdad exacta del valor devuelto por la
función <code>greeting</code>, simplemente afirmaremos que la salida contiene el texto
de la entrada parámetro.</p>
<p>Vamos a introducir un error en este código cambiando <code>greeting</code> para no
incluir <code>name</code> para ver cómo se ve esta falla en la prueba:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
</code></pre></pre>
<p>Ejecutar esta prueba produce lo siguiente:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains(&quot;Carol&quot;)', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>Este resultado simplemente indica que la aserción falló y en qué línea está
la aserción. Un mensaje de falla más útil en este caso imprimiría el valor
que obtenemos de la función <code>greeting</code>. Cambiemos la función de prueba,
dándole un mensaje de falla personalizado hecho de una cadena de formato con
un marcador de posición rellenado con el valor real que obtuvimos de la
función <code>greeting</code>:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>Ahora cuando ejecutamos la prueba, obtendremos un mensaje de error más informativo:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'Greeting did not
contain name, value was `Hello!`', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Podemos ver el valor que realmente obtuvimos en el resultado de la prueba,
lo que nos ayudaría a depurar lo que sucedió en lugar de lo que esperábamos
que sucediera.</p>
<h3 id="comprobación-de-pánicos-panics-con-should_panic"><a class="header" href="#comprobación-de-pánicos-panics-con-should_panic">Comprobación de <em>pánicos</em> (<em>Panics</em>) con <code>should_panic</code></a></h3>
<p>Además de verificar que nuestro código arroje los valores correctos que
esperamos, también es importante verificar que nuestro código maneje las
condiciones de error como esperamos. Por ejemplo, considere el tipo <code>Guess</code>
que creamos en el Capítulo 9, Listado 9-9. Otro código que usa <code>Guess</code>
depende de la garantía de que las instancias <code>Guess</code> contendrán solo valores
entre 1 y 100. Podemos escribir una prueba que asegure que intentar crear
una instancia <code>Guess</code> con un valor fuera de ese rango entra en pánico.</p>
<p>Hacemos esto agregando otro atributo, <code>should_panic</code>, a nuestra función de
prueba. Este atributo hace pasar una prueba si el código dentro de la
función entra en pánico; la prueba fallará si el código dentro de la función
no entra en pánico.</p>
<p>El listado 11-8 muestra una prueba que verifica que las condiciones de error
de <code>Guess::new</code> ocurran cuando esperamos que lo hagan.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-8: ¡Prueba que una condición causará un
<code>panic!</code></span></p>
<p>Colocamos el atributo <code>#[should_panic]</code> después del atributo <code>#[test]</code> y
antes de la función de prueba a la que se aplica. Miremos el resultado
cuando pase esta prueba:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Se ve bien! Ahora introduzcamos un error en nuestro código eliminando la
condición de que la función <code>new</code> entrará en pánico si el valor es mayor que
100:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
</code></pre></pre>
<p>Cuando ejecutamos la prueba en el listado 11-8, fallará:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>No obtenemos un mensaje muy útil en este caso, pero cuando miramos la
función de prueba, vemos que está anotada con <code>#[should_panic]</code>. El error
que obtuvimos significa que el código en la función de prueba no causó
pánico.</p>
<p>Las pruebas que usan <code>should_panic</code> pueden ser imprecisas porque solo
indican que el código ha causado cierto pánico. Una prueba <code>should_panic</code>
pasaría incluso si la prueba entra en pánico por una razón diferente a la
que esperábamos que sucediera. Para hacer las pruebas <code>should_panic</code> más
precisas, podemos agregar un parámetro <code>expected</code> opcional al atributo
<code>should_panic</code>. El arnés de prueba se asegurará de que el mensaje de falla
contenga el texto provisto. Por ejemplo, considere el código modificado para
<code>Guess</code> en el Listado 11-9 donde la función <code>new</code> entra en pánico con
diferentes mensajes dependiendo de si el valor es demasiado pequeño o
demasiado grande.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 11-9: ¡Prueba que una condición causará un
<code>panic!</code> Con un mensaje de pánico particular</span></p>
<p>Esta prueba pasará porque el valor que ponemos en el parámetro <code>expected</code>
del atributo <code>should_panic</code> es una subcadena del mensaje con el que entra en
juego la función <code>Guess::new</code>. Podríamos haber especificado todo el mensaje
de pánico que esperamos, que en este caso sería
<code>Guess value must be less than or equal to 100, got 200.</code>. Lo que elija especificar en el parámetro esperado para <code>should_panic</code> depende de cómo
gran parte del mensaje de pánico es único o dinámico y qué tan preciso
quiere que sea su prueba. En este caso, una subcadena del mensaje de pánico
es suficiente para garantizar que el código en la función de prueba ejecuta
el caso <code>else if value&gt; 100</code>.</p>
<p>Para ver qué sucede cuando falla una prueba <code>should_panic</code> con un mensaje
<code>expected</code>, volvamos a introducir un error en nuestro código intercambiando
los cuerpos de los bloques <code>if value &lt;1</code> y <code>else if value&gt; 100</code>:</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>Esta vez, cuando ejecutamos la prueba <code>should_panic</code>, fallará:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
        thread 'tests::greater_than_100' panicked at 'Guess value must be
greater than or equal to 1, got 200.', src/lib.rs:11:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>El mensaje de falla indica que esta prueba entró en pánico como esperábamos,
pero el mensaje de pánico no incluyó la cadena de texto esperada
<code>'Guess value must be less than or equal to 100'</code>. El mensaje de pánico que
obtuvimos en este caso fue
<code>Guess value must be greater than or equal to 1,got 200.</code>. ¡Ahora podemos
comenzar a descubrir dónde está nuestro error!.</p>
<p>Ahora que conoce varias formas de escribir pruebas, veamos qué está
sucediendo cuando ejecutemos nuestras pruebas y exploremos las diferentes
opciones que podemos usar con <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlar-cómo-se-ejecutan-las-pruebas"><a class="header" href="#controlar-cómo-se-ejecutan-las-pruebas">Controlar cómo se ejecutan las pruebas</a></h2>
<p>Así como <code>cargo run</code> compila su código y luego ejecuta el binario resultante,<code>cargo test</code> compila su código en modo de prueba y ejecuta el binario de
prueba resultante. Puede especificar opciones de línea de comando para
cambiar el comportamiento predeterminado de <code>cargo test</code>. Por ejemplo, el
comportamiento predeterminado del binario producido por <code>cargo test</code> es
ejecutar todas las pruebas en paralelo y capturar la salida generada durante
las pruebas, evitando que se muestre la salida y facilitando la lectura de
los resultados de las pruebas.</p>
<p>Algunas opciones de línea de comando van a <code>cargo test</code>, y algunas van al
binario de prueba resultante. Para separar estos dos tipos de argumentos,
enumere los argumentos que van a <code>cargo test</code> seguido por el separador<code>--</code> y
luego a los que van al examen binario. Ejecutando <code>cargo test --help</code> muestra
las opciones que puede usar con <code>cargo test</code>, y ejecutar
<code>cargo test - --help</code> muestra las opciones que puede usar después del
separador <code>--</code>.</p>
<h3 id="ejecutar-pruebas-en-paralelo-o-consecutivamente"><a class="header" href="#ejecutar-pruebas-en-paralelo-o-consecutivamente">Ejecutar Pruebas en Paralelo o Consecutivamente</a></h3>
<p>Cuando ejecuta pruebas múltiples, de forma predeterminada se ejecutan en
paralelo utilizando subprocesos. Esto significa que las pruebas terminarán de
ejecutarse más rápido para que pueda obtener retroalimentación más rápido
sobre si su código está funcionando o no. Debido a que las pruebas se están
ejecutando al mismo tiempo, asegúrese de que sus pruebas no dependan entre sí
ni en ningún estado compartido, incluido un entorno compartido, como el
directorio de trabajo actual o las variables de entorno.</p>
<p>Por ejemplo, supongamos que cada una de sus pruebas ejecuta algún código que
crea un archivo en el disco llamado <em>test-output.txt</em> y escribe algunos datos
en ese archivo. Luego, cada prueba lee los datos en ese archivo y afirma que
el archivo contiene un valor particular, que es diferente en cada prueba.
Debido a que las pruebas se ejecutan al mismo tiempo, una prueba puede
sobrescribir el archivo cuando otra prueba escribe y lee el archivo. La
segunda prueba fallará, no porque el código sea incorrecto, sino porque las
pruebas se han interferido entre sí mientras se ejecutaban en paralelo. Una
solución es asegurarse de que cada prueba escriba en un archivo diferente;
otra solución es ejecutar las pruebas de a una por vez.</p>
<p>Si no desea ejecutar las pruebas en paralelo o si desea un control más
preciso sobre el número de subprocesos utilizados, puede enviar el indicador
<code>--test-threads</code> y el número de subprocesos que desea utilizar para el
binario de prueba. Eche un vistazo al siguiente ejemplo:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>Establecemos el número de hilos de prueba en <code>1</code>, diciéndole al programa que
no use ningún paralelismo. Ejecutar las pruebas con un hilo llevará más
tiempo que ejecutarlas en paralelo, pero las pruebas no interferirán entre sí
si comparten el estado.</p>
<h3 id="mostrando-salida-de-la-función"><a class="header" href="#mostrando-salida-de-la-función">Mostrando salida de la función</a></h3>
<p>De forma predeterminada, si pasa una prueba, la biblioteca de pruebas de Rust
captura todo lo impreso en la salida estándar. Por ejemplo, si llamamos
<code>println!</code>. En una prueba y la prueba pasa, no veremos la salida <code>println!</code> En
la terminal; solo veremos la línea que indica que pasó la prueba. Si falla
una prueba, veremos todo lo que se imprimió en la salida estándar con el
resto del mensaje de falla.</p>
<p>Como ejemplo, el Listado 11-10 tiene una función tonta que imprime el valor
de su parámetro y devuelve 10, así como una prueba que pasa y una prueba que
falla.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 11-10: Pruebas para una función que llama a
<code>println!</code></span></p>
<p>Cuando ejecutamos estas pruebas con <code>cargo test</code>, veremos el siguiente
resultado:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Tenga en cuenta que en ninguna parte de esta salida vemos <code>I got the value 4</code>
que es lo que se imprime cuando se ejecuta la prueba que se ejecuta. Esa
salida ha sido capturada. La salida de la prueba que falló,
<code>I got the value 8</code>, aparece en la sección del resultado del resumen de la
prueba, que también muestra la causa de la falla de la prueba.</p>
<p>Si también queremos ver valores impresos para pasar pruebas, podemos
inhabilitar el comportamiento de captura de salida utilizando el indicador
<code>--nocapture</code>:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>Cuando ejecutamos nuevamente las pruebas en el Listado 11-10 con el indicador
<code>--nocapture</code>, vemos el siguiente resultado:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Tenga en cuenta que la salida de las pruebas y los resultados de la prueba
están intercalados; la razón es que las pruebas se ejecutan en paralelo, como
hablamos en la sección anterior. Intenta usar la opción
<code>--test-threads = 1</code> y el indicador <code>--nocapture</code>, ¡y mira a qué se parece la
salida.</p>
<h3 id="ejecutar-un-subconjunto-de-pruebas-por-nombre"><a class="header" href="#ejecutar-un-subconjunto-de-pruebas-por-nombre">Ejecutar un subconjunto de pruebas por nombre</a></h3>
<p>A veces, ejecutar un conjunto de prueba completo puede llevar mucho tiempo.
Si está trabajando en un código en un área particular, es posible que desee
ejecutar solo las pruebas correspondientes a ese código. Puede elegir qué
pruebas ejecutar pasando 'prueba de carga' el nombre o los nombres de la
prueba(s) que desea ejecutar como argumento.</p>
<p>Para demostrar cómo ejecutar un subconjunto de pruebas, crearemos tres
pruebas para nuestra función <code>add_two</code>, como se muestra en el Listado 11-11,
y elegiremos cuáles ejecutar.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 11-11: Tres pruebas con tres nombres
diferentes</span></p>
<p>Si ejecutamos las pruebas sin pasar ningún argumento, como vimos anteriormente, todas las pruebas se ejecutarán en paralelo:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h4 id="ejecución-de-pruebas-individuales"><a class="header" href="#ejecución-de-pruebas-individuales">Ejecución de pruebas individuales</a></h4>
<p>Podemos pasar el nombre de cualquier función de prueba a <code>cargo test</code> para ejecutar solo esa prueba:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Solo se ejecutó la prueba con el nombre <code>one_hundred</code>; las otras dos pruebas
no coinciden con ese nombre. El resultado de la prueba nos permite saber que
tuvimos más pruebas de las que ejecutaba este comando al mostrar
<code>2 filtradas</code> al final de la línea de resumen.</p>
<p>No podemos especificar los nombres de múltiples pruebas de esta manera; solo
se usará el primer valor dado a <code>cargo test</code>. Pero hay una forma de ejecutar múltiples pruebas.</p>
<h4 id="filtrado-para-ejecutar-múltiples-pruebas"><a class="header" href="#filtrado-para-ejecutar-múltiples-pruebas">Filtrado para ejecutar múltiples pruebas</a></h4>
<p>Podemos especificar parte del nombre de una prueba y se ejecutará cualquier
prueba cuyo nombre coincida con ese valor. Por ejemplo, debido a que dos de
los nombres de nuestras pruebas contienen <code>add</code>, podemos ejecutar esos dos
ejecutando <code>cargo test add</code>:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>Este comando ejecutó todas las pruebas con <code>add</code> en el nombre y filtró la
prueba llamada <code>one_hundred</code>. También tenga en cuenta que el módulo en el que
aparecen las pruebas se convierte en parte del nombre de la prueba, por lo
que podemos ejecutar todas las pruebas en un módulo filtrando el nombre del
módulo.</p>
<h3 id="ignorar-algunas-pruebas-a-menos-que-se-solicite-específicamente"><a class="header" href="#ignorar-algunas-pruebas-a-menos-que-se-solicite-específicamente">Ignorar algunas pruebas a menos que se solicite específicamente</a></h3>
<p>Algunas veces, ejecutar algunas pruebas específicas puede llevar mucho tiempo
por lo que es posible que desee excluirlas durante la mayoría de las
ejecuciones de <code>cargo test</code>. En lugar de enumerar como argumentos todas las
pruebas que desea ejecutar, puede anotar las pruebas que consumen tiempo
utilizando el atributo <code>ignore</code> para excluirlas, como se muestra aquí:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
<span class="boring">}
</span></code></pre></pre>
<p>Después de <code>#[prueba]</code>, agregamos la línea <code>#[ignore]</code> a la prueba que
queremos excluir. Ahora cuando ejecutamos nuestras pruebas, <code>it_works</code> se
ejecuta, pero <code>expensive_test</code> no:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>La función <code>expensive_test</code> se muestra como <code>ignored</code>. Si queremos ejecutar
solo las pruebas ignoradas, podemos usar <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>Al controlar qué pruebas se ejecutan, puede asegurarse de que los resultados
de su <code>cargo test</code> sean rápidos. Cuando estás en un punto en el que tiene
sentido comprobar los resultados de las pruebas <code>ignored</code> y tienes tiempo
para esperar los resultados, puedes ejecutar <code>cargo test -- --ignored</code>
en su lugar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="organización-de-prueba"><a class="header" href="#organización-de-prueba">Organización de prueba</a></h2>
<p>Como se mencionó al comienzo del capítulo, las pruebas son una disciplina
compleja, y diferentes personas usan terminología y organización diferentes.
La comunidad de Rust piensa en las pruebas en términos de dos categorías
principales: <em>pruebas unitarias</em> y <em>pruebas de integración</em>
(<em>unit tests</em> and <em>integration tests</em>). Las pruebas unitarias son pequeñas y
más enfocadas, probando un módulo por separado a la vez, y pueden probar
interfaces privadas. Las pruebas de integración son completamente externas a
su biblioteca y usan su código de la misma manera que cualquier otro código
externo, utilizando solo la interfaz pública y posiblemente ejerciendo
múltiples módulos por prueba.</p>
<p>Escribir ambos tipos de pruebas es importante para garantizar que las piezas
de su biblioteca estén haciendo lo que espera, por separado y juntas.</p>
<h3 id="pruebas-unitarias"><a class="header" href="#pruebas-unitarias">Pruebas unitarias</a></h3>
<p>El propósito de las pruebas unitarias es probar cada unidad de código
aisladamente del resto del código para identificar rápidamente dónde está el
código y qué no funciona como se espera. Colocará pruebas unitarias en el
directorio <em>src</em> de cada archivo con el código que están probando. La
convención es crear un módulo llamado <code>tests</code> en cada archivo para contener
las funciones de prueba y anotar el módulo con <code>cfg(test)</code>.</p>
<h4 id="el-módulo-de-pruebas-y-cfgprueba"><a class="header" href="#el-módulo-de-pruebas-y-cfgprueba">El Módulo de Pruebas y <code>#[cfg(prueba)]</code></a></h4>
<p>La anotación <code>#[cfg(prueba)]</code> en el módulo de pruebas le dice a Rust que
compile y ejecute el código de prueba solo cuando ejecuta <code>carga test</code>, no
cuando ejecuta <code>cargo build</code>. Esto ahorra tiempo de compilación cuando solo
desea construir la biblioteca y ahorra espacio en el artefacto compilado
resultante porque las pruebas no están incluidas. Verá que debido a que las
pruebas de integración van en un directorio diferente, no necesitan la
anotación <code>#[cfg(prueba)]</code>. Sin embargo, como las pruebas unitarias van en
los mismos archivos que el código, usará <code>#[cfg(prueba)]</code> para especificar
que no se deben incluir en el resultado compilado.</p>
<p>Recuerde que cuando generamos el nuevo proyecto <code>adder</code> en la primera sección
de este capítulo, Cargo generó este código para nosotros:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código es el módulo de prueba generado automáticamente. El atributo
<code>cfg</code> significa <em>configuración</em> y le dice a Rust que el siguiente ítem solo
debería incluirse dado una determinada opción de configuración. En este caso,
la opción de configuración es <code>test</code>, que es proporcionada por Rust para
compilar y ejecutar pruebas. Al utilizar el atributo <code>cfg</code>, Cargo compila
nuestro código de prueba solo si ejecutamos activamente las pruebas con
<code>cargo test</code>. Esto incluye cualquier función auxiliar que pueda estar dentro
de este módulo, además de las funciones anotadas con <code>#[test]</code>.</p>
<h4 id="prueba-de-funciones-privadas"><a class="header" href="#prueba-de-funciones-privadas">Prueba de funciones privadas</a></h4>
<p>Existe un debate dentro de la comunidad de pruebas sobre si las funciones
privadas deben o no evaluarse directamente, y otros idiomas dificultan o
imposibilitan la prueba de funciones privadas. Independientemente de la
ideología de prueba que adhiera, las reglas de privacidad de Rust le permiten
probar funciones privadas. Considere el código en el listado 11-12 con la
función privada <code>internal_adder</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 11-12: Prueba de una función privada</span></p>
<p>Tenga en cuenta que la función <code>internal_adder</code> no está marcada como <code>pub</code>,
pero como las pruebas son solo código Rust y el módulo <code>tests</code> es simplemente
otro módulo, puede importar y llamar <code>internal_adder</code> en una prueba bien.
Si no crees que se deben probar las funciones privadas, no hay nada en Rust
que te obligue a hacerlo.</p>
<h3 id="pruebas-de-integración"><a class="header" href="#pruebas-de-integración">Pruebas de integración</a></h3>
<p>En Rust, las pruebas de integración son completamente externas a tu
biblioteca. Utilizan su biblioteca de la misma manera que lo haría con
cualquier otro código, lo que significa que solo pueden llamar a funciones
que forman parte de la API pública de su biblioteca. Su propósito es probar
si muchas partes de su biblioteca funcionan juntas correctamente. Las
unidades de código que funcionan correctamente por sí mismas podrían tener
problemas cuando están integradas, por lo que la cobertura de prueba del
código integrado también es importante. Para crear pruebas de integración,
primero necesita un directorio <em>tests</em>.</p>
<h4 id="el-directorio-tests"><a class="header" href="#el-directorio-tests">El directorio <em>tests</em></a></h4>
<p>Creamos un directorio <em>tests</em> en el nivel superior de nuestro directorio de
proyectos, junto a <em>src</em>. Cargo sabe buscar archivos de prueba de integración
en este directorio. Entonces podemos hacer tantos archivos de prueba como
queramos en este directorio, y Cargo compilará cada uno de los archivos como
una caja individual.</p>
<p>Vamos a crear una prueba de integración. Con el código en el listado 11-12
todavía en el archivo <em>src/lib.rs</em>, cree un directorio <em>tests</em>, cree un nuevo
archivo llamado <em>tests/integration_test.rs</em>, e ingrese el código en el
listado 11-13.</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Una prueba de integración de una función
en el crate <code>adder</code></span></p>
<p>Hemos agregado <code>extern crate adder</code> en la parte superior del código, que no
necesitamos en las pruebas unitarias. La razón es que cada prueba en el
directorio <code>tests</code> es una caja separada, por lo que debemos importar nuestra
biblioteca a cada una de ellas.</p>
<p>No es necesario anotar ningún código en <em>tests/integration_test.rs</em> con
<code>#[cfg(prueba)]</code>. Cargo trata el directorio <code>tests</code> especialmente y compila
los archivos en este directorio solo cuando ejecutamos <code>cargo test</code>. Ejecute
<code>cargo test</code> ahora:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Las tres secciones de salida incluyen las pruebas unitarias, la prueba de
integración y las pruebas de doc. La primera sección para las pruebas
unitarias es la misma que hemos visto: una línea para cada prueba unitaria
(una llamada <code>internal</code> que agregamos en el Listado 11-12) y luego una línea
de resumen para las pruebas unitarias.</p>
<p>La sección de pruebas de integración comienza con la línea
<code>Running target/debug/deps/ integration test-ce99bcc2479f4607</code>
(el hash al final de su salida será diferente). A continuación, hay una línea
para cada función de prueba en esa prueba de integración y una línea de
resumen para los resultados de la prueba de integración justo antes de que
comience la sección <code>Doc-tests adder</code>.</p>
<p>De forma similar a cómo agregar más funciones de prueba unitarias agrega más
líneas de resultado a la sección de pruebas de la unidad, agregar más
funciones de prueba al archivo de prueba de integración agrega más líneas de
resultados a esta sección del archivo de prueba de integración. Cada archivo
de prueba de integración tiene su propia sección, por lo que si agregamos más
archivos en el directorio <em>tests</em>, habrá más secciones de prueba de integración.</p>
<p>Todavía podemos ejecutar una función de prueba de integración particular
especificando el nombre de la función de prueba como un argumento para
<code>cargo test</code>. Para ejecutar todas las pruebas en un archivo de prueba de
integración en particular, use el argumento <code>--test</code> de <code>cargo test</code> seguido
del nombre del archivo:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Este comando ejecuta solo las pruebas en el archivo
*tests/integration_test.rs *.</p>
<h4 id="submódulos-en-pruebas-de-integración"><a class="header" href="#submódulos-en-pruebas-de-integración">Submódulos en pruebas de integración</a></h4>
<p>A medida que agrega más pruebas de integración, es posible que desee crear
más de un archivo en el directorio <em>tests</em> para ayudar a organizarlos; por
ejemplo, puede agrupar las funciones de prueba por la funcionalidad que están
probando. Como se mencionó anteriormente, cada archivo en el directorio
<em>tests</em> se compila como su propio <em>crate</em> separado.</p>
<p>El tratamiento de cada archivo de prueba de integración como su propio
<em>crate</em> es útil para crear ámbitos separados que se parecen más a la forma en
que los usuarios finales usarán su <em>crate</em>. Sin embargo, esto significa que
los archivos en el directorio <em>tests</em> no comparten el mismo comportamiento
que los archivos en <em>src</em> hacen, como aprendió en el Capítulo 7 con respecto
a cómo separar el código en módulos y archivos.</p>
<p>El comportamiento diferente de los archivos en el directorio <em>tests</em> es más
notable cuando tiene un conjunto de funciones auxiliares que serían útiles en
múltiples archivos de prueba de integración e intenta seguir los pasos de la
sección “Mover módulos a otros archivos” del capítulo 7 para extraerlos en un módulo común. Por ejemplo, si creamos <em>tests/common.rs</em> y colocamos una
función llamada <code>setup</code>, podemos agregar un código a <code>setup</code> que queremos
llamar desde múltiples funciones de prueba en múltiples archivos de prueba:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // setup code specific to your library's tests would go here
}
<span class="boring">}
</span></code></pre></pre>
<p>Cuando ejecutemos las pruebas nuevamente, veremos una nueva sección en la
salida de prueba para el archivo <em>common.rs</em>, aunque este archivo no contenga
ninguna función de prueba ni llamemos a la función <code>setup</code> desde ningún lugar:</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>common</code> aparece en los resultados de la prueba con <code>running 0 tests</code> para
que no sea lo que queríamos. Solo queríamos compartir un código con los otros
archivos de prueba de integración.</p>
<p>Para evitar que aparezca <code>common</code> en la salida de prueba, en lugar de crear
<em>tests/common.rs</em>, crearemos <em>tests/common/mod.rs</em>. En la sección “Reglas de
los sistemas de archivos del módulo” del Capítulo 7, usamos la convención de
nomenclatura <em>nombre_módulo/mod.rs</em> para los archivos de los módulos que
tienen submódulos. No tenemos submódulos para 'comunes' aquí, pero nombrar el
archivo de esta manera le dice a Rust que no trate el módulo <code>common</code> como un
archivo de prueba de integración. Cuando movemos el código de la función
<code>setup</code> en <em>tests/common/mod.rs</em> y eliminamos el archivo <em>tests/common.rs</em>,
la sección en la salida de prueba ya no aparecerá. Los archivos en
subdirectorios del directorio <em>tests</em> no se compilan como <em>cretes</em> separadas
o tienen secciones en la salida de prueba.</p>
<p>Después de que hemos creado <em>tests/common/mod.rs</em>, podemos usarlo desde
cualquiera de los archivos de prueba de integración como un módulo. Aquí hay
un ejemplo de llamar a la función <code>setup</code> de la prueba <code>it_adds_two</code> en
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Tenga en cuenta que la declaración <code>mod common;</code> es la misma que las
declaraciones de módulo que demostramos en el listado 7-4. Luego, en la
función de prueba, podemos llamar a la función <code>common::setup ()</code>.</p>
<h4 id="pruebas-de-integración-para-binary-crates"><a class="header" href="#pruebas-de-integración-para-binary-crates">Pruebas de integración para <em>Binary Crates</em></a></h4>
<p>Si nuestro proyecto es una <em>binary crates</em> que solo contiene un archivo
<em>src/main.rs</em> y no tiene un archivo <em>src/lib.rs</em>, no podemos crear pruebas de
integración en el directorio <em>tests</em> y usar <code>extern crate</code> para importar
funciones definidas en el archivo *src/main.rs *. Solo los <em>crates</em> de la
biblioteca exponen funciones que otros <em>crates</em> pueden llamar y usar; los
<em>binary crates</em> se deben ejecutar por sí mismas.</p>
<p>Esta es una de las razones por las que los proyectos de Rust que proporcionan
un binario tienen un archivo <em>src/main.rs</em> sencillo que llama a la lógica que
vive en el archivo <em>src/lib.rs</em>. Usando esa estructura, las pruebas de
integración <em>pueden</em> probar el <em>crates</em> de la biblioteca usando
<code>extern crate</code> para ejercer la funcionalidad importante. Si la funcionalidad
importante funciona, la pequeña cantidad de código en el archivo
<em>src/main.rs</em> también funcionará, y esa pequeña cantidad de código no
necesita ser probada.</p>
<h2 id="resumen-9"><a class="header" href="#resumen-9">Resumen</a></h2>
<p>Las funciones de prueba de Rust proporcionan una manera de especificar cómo
debe funcionar el código para garantizar que continúe funcionando como espera
incluso cuando realice cambios. Las pruebas unitarias ejercitan diferentes
partes de una biblioteca por separado y pueden probar detalles privados de
implementación. Las pruebas de integración comprueban que muchas partes de la
biblioteca funcionen juntas correctamente, y usan la API pública de la
biblioteca para probar el código de la misma forma que el código externo lo
usará. A pesar de que el sistema de tipos y las reglas de propiedad de Rust
ayudan a prevenir algunos tipos de errores, las pruebas siguen siendo
importantes para reducir los errores de lógica que tienen que ver con la
forma en que se espera que su código se comporte.</p>
<p>¡Combinaremos el conocimiento que aprendió en este capítulo y en capítulos
anteriores para trabajar en un proyecto!.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="un-proyecto-de-io-creación-de-un-programa-de-línea-de-comando"><a class="header" href="#un-proyecto-de-io-creación-de-un-programa-de-línea-de-comando">Un proyecto de I/O: creación de un programa de línea de comando</a></h1>
<p>Este capítulo es un resumen de las muchas habilidades que ha aprendido hasta
ahora y una exploración de algunas características más de la biblioteca.
Desarrollaremos una herramienta de línea de comando que interactúa con la
entrada/salida de archivos y línea de comando para practicar algunos de los
conceptos de Rust que ahora tiene bajo su cinturón.</p>
<p>La velocidad, la seguridad, la salida binaria simple y el soporte
multiplataforma de Rust lo convierten en un lenguaje ideal para crear
herramientas de línea de comandos, por lo que para nuestro proyecto,
crearemos nuestra propia versión de la herramienta clásica de línea de
comandos <code>grep</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint).En el caso de uso más simple, <code>grep</code> busca un archivo específico
para un texto especificado. Para hacerlo, <code>grep</code> toma como argumentos un
nombre de archivo y un texto. Luego lee el archivo, busca las líneas en ese
archivo que contiene el argumento de texto e imprime esas líneas.</p>
<p>En el camino, mostraremos cómo hacer que nuestra herramienta de línea de
comandos use las características del terminal que usan muchas herramientas de
línea de comando. Leeremos el valor de una variable de entorno para permitir
al usuario configurar el comportamiento de nuestra herramienta. También
imprimiremos en la secuencia de error estándar de la consola (<code>stderr</code>) en
lugar de la salida estándar (<code>stdout</code>), por lo que, por ejemplo, el usuario
puede redirigir la salida exitosa a un archivo mientras sigue apareciendo
mensajes de error en la pantalla.</p>
<p>El miembro de la comunidad de Rust, Andrew Gallant, ya ha creado una versión
completa y muy rápida de <code>grep</code>, llamada <code>ripgrep</code>. En comparación, nuestra
versión de <code>grep</code> será bastante simple, pero este capítulo le dará algunos de
los conocimientos básicos que necesita para comprender un proyecto del mundo
real como <code>ripgrep</code>.</p>
<p>Nuestro proyecto <code>grep</code> combinará una cantidad de conceptos que has aprendido
hasta ahora:</p>
<ul>
<li>Código de organización (usando lo que aprendiste en los módulos, Capítulo 7)</li>
<li>Uso de vectores y <em>string</em> (colecciones, Capítulo 8)</li>
<li>Manejo de errores (Capítulo 9)</li>
<li>Usar <em>trait</em> y <em>lifetimes</em> cuando corresponda (Capítulo 10)</li>
<li>Pruebas de escritura (Capítulo 11)</li>
</ul>
<p>También presentaremos brevemente <em>closures</em>, <em>iterators</em>, y <em>trait objects</em>, que los Capítulos 13 y 17 cubrirán en detalle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="aceptando-argumentos-de-línea-de-comandos"><a class="header" href="#aceptando-argumentos-de-línea-de-comandos">Aceptando argumentos de línea de comandos</a></h2>
<p>Vamos a crear un nuevo proyecto con <code>cargo new</code>, como siempre. Llamaremos a
nuestro proyecto <code>minigrep</code> para distinguirlo de la herramienta <code>grep</code> que ya
puede tener en su sistema.</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>La primera tarea es hacer que <code>minigrep</code> acepte sus dos argumentos de línea
de comando: el nombre de archivo y una cadena para buscar. Es decir, queremos
poder ejecutar nuestro programa con <code>cargo run</code>, una cadena para buscar y una
ruta a un archivo para buscar, de esta forma:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>En este momento, el programa generado por <code>cargo new</code> no puede procesar los
argumentos que le damos. Algunas bibliotecas existentes en
<a href="https://crates.io/">Crates.io</a> pueden ayudarlo a escribir un programa que
acepte argumentos de línea de comando, pero debido a que recién está
aprendiendo este concepto, implementemos esta capacidad nosotros mismos.</p>
<h3 id="leyendo-los-valores-de-argumento"><a class="header" href="#leyendo-los-valores-de-argumento">Leyendo los valores de argumento</a></h3>
<p>Para permitir que <code>minigrep</code> lea los valores de los argumentos de línea de
comando que le pasamos, necesitaremos una función provista en la biblioteca
estándar de Rust, que es <code>std::env::args</code>. Esta función devuelve un
<em>iterador</em> de los argumentos de la línea de comandos que se le dieron a
<code>minigrep</code>. Todavía no hemos discutido los iteradores (los trataremos
completamente en el Capítulo 13), pero por ahora, solo necesita conocer dos
detalles sobre los iteradores: los iteradores producen una serie de valores,
y podemos llamar al método <code>collect</code> en un iterador para convertirlo en una
colección, como un vector, que contiene todos los elementos que produce el
iterador.</p>
<p>Use el código en el listado 12-1 para permitir que su programa <code>minigrep</code> lea
cualquier argumento de línea de comando que se le pase y luego recopile los
valores en un vector.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Listado 12-1: Recolectar los argumentos de la línea de
comando en un vector e imprimirlos</span></p>
<p>Primero, traemos el módulo <code>std::env</code> dentro del alcance con una declaración
<code>use</code> para que podamos usar su función <code>args</code>. Observe que la función
<code>std::env::args</code> está anidada en dos niveles de módulos. Como discutimos en
el Capítulo 7, en los casos en que la función deseada está anidada en más de
un módulo, es convencional llevar el módulo principal al alcance en lugar de
a la función. Al hacerlo, podemos usar fácilmente otras funciones de
<code>std::env</code>. También es menos ambiguo que agregar <code>use std::env::args</code> y
llamar a la función con <code>args</code>, porque <code>args</code> puede confundirse fácilmente
con una función que está definida en el módulo actual.</p>
<blockquote>
<h3 id="la-función-args-y-unicode-inválido"><a class="header" href="#la-función-args-y-unicode-inválido">La función <code>args</code> y Unicode inválido</a></h3>
<p>Tenga en cuenta que <code>std::env::args</code> entrará en pánico si algún argumento
contiene Unicode no válido. Si su programa necesita aceptar argumentos que
contengan Unicode no válido, usa <code>std::env::args_os</code> en su lugar. Esa
función devuelve un iterador que produce valores <code>OsString</code> en lugar de
valores <code>String</code>. Hemos elegido usar <code>std::env::args</code> aquí para simplificar
porque los valores <code>OsString</code> difieren según la plataforma y son más
complejos para trabajar que los valores <code>String</code>.</p>
</blockquote>
<p>En la primera línea de <code>main</code>, llamamos <code>env::args</code>, e inmediatamente usamos
<code>collect</code> para convertir el iterador en un vector que contiene todos los
valores producidos por el iterador. Podemos usar la función <code>collect</code> para
crear muchos tipos de colecciones, por lo que anotamos explícitamente el tipo
de <code>args</code> para especificar que queremos un vector de cadenas. Aunque muy
raramente necesitamos anotar tipos en Rust, <code>collect</code> es una función que a
menudo necesita anotar porque Rust no puede inferir el tipo de colección que
desea.</p>
<p>Finalmente, imprimimos el vector usando el formateador de depuración, <code>:?</code>.
Intentemos ejecutar el código primero sin argumentos y luego con dos
argumentos:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Tenga en cuenta que el primer valor en el vector es
<code>&quot;target/debug/minigrep &quot;</code>, que es el nombre de nuestro binario. Esto
coincide con el comportamiento de la lista de argumentos en C, permitiendo
que los programas usen el nombre con el que se invocaron en su ejecución. A
menudo es conveniente tener acceso al nombre del programa en caso de que
desee imprimirlo en mensajes o cambiar el comportamiento del programa en
función de qué alias de línea de comando se utilizó para invocar el programa.
Pero a los fines de este capítulo, lo ignoraremos y guardaremos solo los dos
argumentos que necesitamos.</p>
<h3 id="guardar-los-valores-de-argumento-en-variables"><a class="header" href="#guardar-los-valores-de-argumento-en-variables">Guardar los valores de argumento en variables</a></h3>
<p>Al imprimir el valor del vector de argumentos se ilustró que el programa
puede acceder a los valores especificados como argumentos de línea de
comando. Ahora necesitamos guardar los valores de los dos argumentos en
variables para poder usar los valores en el resto del programa. Hacemos eso
en el listado 12-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Listado 12-2: Creación de variables para contener el
argumento de consulta y el argumento de nombre de archivo</span></p>
<p>Como vimos cuando imprimimos el vector, el nombre del programa toma el primer
valor en el vector en <code>args[0]</code>, por lo que estamos comenzando en el índice
<code>1</code>. El primer argumento que toma <code>minigrep</code> es la cadena que estamos
buscando, por lo que ponemos una referencia al primer argumento en la
variable <code>query</code>. El segundo argumento será el nombre de archivo, por lo que
ponemos una referencia al segundo argumento en la variable <code>filename</code>.</p>
<p>Imprimimos temporalmente los valores de estas variables para probar que el
código está funcionando como queremos. Ejecutamos este programa nuevamente
con los argumentos <code>test</code> y <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>¡Genial, el programa está funcionando! Los valores de los argumentos que
necesitamos se guardan en las variables correctas. Más adelante, agregaremos
algún tipo de manejo de errores para tratar ciertas situaciones erróneas
potenciales, como cuando el usuario no proporciona ningún argumento; por
ahora, ignoraremos esa situación y trabajaremos en agregar capacidades de
lectura de archivos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="leyendo-un-archivo"><a class="header" href="#leyendo-un-archivo">Leyendo un archivo</a></h2>
<p>Ahora agregaremos funcionalidad para leer el archivo que se especifica en el
argumento de línea de comando <code>filename</code>. Primero, necesitamos un archivo de
muestra para probarlo: el mejor tipo de archivo para asegurarse de que
<code>minigrep</code> funcione es uno con una pequeña cantidad de texto en varias líneas
con algunas palabras repetidas. ¡El listado 12-3 tiene un poema de Emily
Dickinson que funcionará bien! Crea un archivo llamado <em>poem.txt</em> en el nivel
raíz de tu proyecto e ingresa el poema “I’m Nobody! Who are you?”</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listado 12-3: Un poema de Emily Dickinson es un buen
caso de prueba</span></p>
<p>Con el texto en su lugar, edite <em>src/main.rs</em> y agregue código para abrir el
archivo, como se muestra en el Listado 12-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let filename = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span>    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Listado 12-4: Lectura del contenido del archivo
especificado por el segundo argumento</span></p>
<p>Primero, agregamos algunas declaraciones <code>use</code> más para traer partes
relevantes de la biblioteca estándar: necesitamos <code>std::fs::File</code> para
manejar archivos, y <code>std::io::prelude::*</code> contiene varios <em>traits</em> útiles
para hacer E/S, incluida la E/S de archivos. De la misma manera que Rust
tiene un preludio general que pone ciertos tipos y funciones en el alcance
automáticamente, el módulo <code>std::io</code> tiene su propio preludio de los tipos y
funciones comunes que necesitará al trabajar con E/S. A diferencia del
preludio predeterminado, debemos agregar explícitamente una instrucción <code>use</code>
para el preludio de <code>std::io</code>.</p>
<p>En <code>main</code>, hemos agregado tres enunciados: primero, obtenemos un manejador
mutable al archivo llamando a la función <code>File::open</code> y pasándole el valor de
la variable <code>filename</code>. En segundo lugar, creamos una variable llamada
<code>contents</code> y la configuramos como mutable, vacía <code>String</code>. Esto mantendrá el
contenido del archivo después de que lo hayamos leído. En tercer lugar,
llamamos <code>read_to_string</code> en nuestro identificador de archivo y pasamos una
referencia mutable a <code>contents</code> como argumento.</p>
<p>Después de esas líneas, hemos agregado nuevamente una declaración temporal
<code>println!</code> Que imprime el valor de <code>contents</code> después de que se lee el
archivo, para que podamos verificar que el programa esté funcionando hasta el
momento.</p>
<p>Vamos a ejecutar este código con cualquier cadena como el primer argumento de
línea de comando (porque aún no hemos implementado la parte de búsqueda) y el
archivo <em>poem.txt</em> como segundo argumento:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>¡Estupendo! El código leyó y luego imprimió el contenido del archivo. Pero el
código tiene algunos defectos. La función <code>main</code> tiene múltiples
responsabilidades: generalmente, las funciones son más claras y fáciles de
mantener si cada función es responsable de una sola idea. El otro problema es
que no estamos manejando los errores tan bien como pudimos. El programa aún
es pequeño, por lo que estos defectos no son un gran problema, pero a medida
que el programa crezca, será más difícil solucionarlos de manera limpia. Es
una buena práctica comenzar a refactorizar al principio cuando se desarrolla
un programa, porque es mucho más fácil refactorizar cantidades más pequeñas
de código. Lo haremos a continuación.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refactorización-para-mejorar-la-modularidad-y-el-manejo-de-errores"><a class="header" href="#refactorización-para-mejorar-la-modularidad-y-el-manejo-de-errores">Refactorización para mejorar la modularidad y el manejo de errores</a></h2>
<p>Para mejorar nuestro programa, solucionaremos cuatro problemas que tienen que
ver con el estructura del programa y cómo maneja posibles errores.</p>
<p>Primero, nuestra función <code>main</code> ahora realiza dos tareas: analiza argumentos y
abre archivos para una función tan pequeña, este no es un problema
importante. Sin embargo, si continuamos haciendo crecer nuestro programa
dentro de <code>main</code>, aumentará la cantidad de tareas separadas que maneja la
función <code>main</code>. A medida que una función gana responsabilidades, se vuelve
más difícil razonar, más difícil de probar y más difícil de cambiar sin
romper una de sus partes. Lo mejor es separar la funcionalidad, por lo que
cada función es responsable de una tarea.</p>
<p>Este problema también se relaciona con el segundo problema: aunque <code>query</code>
y <code>filename</code> son variables de configuración para nuestro programa, variables
como <code>f</code> y <code>contents</code> se utilizan para realizar la lógica del programa.
Cuanto más largo sea el <code>main</code>, más variables que tendremos que llevar al
alcance; cuantas más variables tengamos en alcance, más difícil será hacer un
seguimiento del propósito de cada uno. Lo mejor es agrupar las variables de
configuración en una estructura para aclarar su propósito.</p>
<p>El tercer problema es que hemos utilizado <code>expect</code> para imprimir un mensaje
de error cuando abrir el archivo falla, pero el mensaje de error simplemente
imprime <code>file not found</code>. Abrir un archivo puede fallar de varias maneras
además del archivo que falta: por ejemplo, el archivo puede existir, pero es
posible que no tengamos permiso para abrirlo.
En este momento, si estamos en esa situación, imprimiríamos el error
<code>file not found</code> ¡mensaje, que le daría al usuario la información incorrecta!</p>
<p>En cuarto lugar, usamos <code>expect</code> repetidamente para manejar diferentes errores, y si el usuario ejecuta nuestro programa sin especificar suficientes
argumentos, obtendrán un <code>index out of bounds</code> error de Rust que no explica claramente el problema.Sería mejor si todos los códigos de manejo de errores
estuvieran en un solo lugar para que los futuros mantenedores solo tengan un
lugar para consultar en el código si la lógica de manejo de errores necesitara
un cambio. Tener todo el código de manejo de errores en un lugar también
asegurará que estamos imprimiendo mensajes que serán significativos para
nuestros usuarios finales.</p>
<p>Vamos a abordar estos cuatro problemas mediante la refactorización de nuestro
proyecto.</p>
<h3 id="separación-de-preocupaciones-para-proyectos-binarios"><a class="header" href="#separación-de-preocupaciones-para-proyectos-binarios">Separación de preocupaciones para proyectos binarios</a></h3>
<p>El problema organizativo de asignar la responsabilidad de tareas múltiples a
la función <code>main</code> es común a muchos proyectos binarios. Como resultado, la
comunidad de Rust ha desarrollado un proceso para utilizar como una guía para
dividir las preocupaciones por separado de un programa binario cuando <code>main</code>
comienza a hacerse grande. El proceso tiene los siguientes pasos:</p>
<ul>
<li>Divida su programa en <em>main.rs</em> y <em>lib.rs</em> y mueva la lógica de su programa
a *lib.rs *.</li>
<li>Siempre que su lógica de análisis de línea de comandos sea pequeña, puede
permanecer en <em>main.rs</em>.</li>
<li>Cuando la lógica de análisis de línea de comando comienza a complicarse,
extráigala de <em>main.rs</em> y muévala a <em>lib.rs</em>.</li>
</ul>
<p>Las responsabilidades que permanecen en la función <code>main</code> después de este
proceso deberían limitarse a lo siguiente:</p>
<ul>
<li>Llamar a la lógica de análisis de línea de comando con los valores de
argumento</li>
<li>Configuración de cualquier otra configuración</li>
<li>Llamar a una función <code>run</code> en <em>lib.rs</em></li>
<li>Manejando el error si <code>run</code> devuelve un error</li>
</ul>
<p>Este patrón trata de separar las preocupaciones: <em>main.rs</em>
maneja ejecutar el programa, y <em>lib.rs</em> maneja toda la lógica de la tarea en
cuestión. Como no puede probar la función <code>main</code> directamente, esta
estructura le permite probar toda la lógica de su programa moviéndola a
funciones en <em>lib.rs</em>. El único código que permanece en <em>main.rs</em> será lo
suficientemente pequeño para verificar su corrección al leerlo. Repasemos
nuestro programa siguiendo este proceso.</p>
<h4 id="extrayendo-el-analizador-de-argumentos"><a class="header" href="#extrayendo-el-analizador-de-argumentos">Extrayendo el analizador de argumentos</a></h4>
<p>Extraeremos la funcionalidad para analizar argumentos en una función a la que
<code>main</code> llamará para prepararse para mover la lógica de análisis de línea de
comando a *src/lib.rs *. El listado 12-5 muestra el nuevo inicio de <code>main</code>
que llama a una nueva función <code>parse_config</code>, que definiremos en
<em>src/main.rs</em> por el momento.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listado 12-5: Extrayendo una función <code>parse_config</code>
de <code>main</code></span></p>
<p>Todavía estamos recopilando los argumentos de la línea de comando en un
vector, pero en lugar de asignar el valor del argumento en el índice 1 a la
variable <code>query</code> y el valor del argumento en el índice 2 a la variable
<code>filename</code> dentro de la función <code>main</code>, pasa el vector completo a la función
<code>parse_config</code>. La función <code>parse_config</code> contiene la lógica que determina
qué argumento va en qué variable y pasa los valores a <code>main</code>. Seguimos
creando las variables <code>query</code> y <code>filename</code> en <code>main</code>, pero <code>main</code> ya no tiene
la responsabilidad de determinar cómo se corresponden los argumentos y las
variables de la línea de comando.</p>
<p>Este reproceso puede parecer excesivo para nuestro pequeño programa, pero
estamos refactorizando en pasos pequeños e incrementales. Después de hacer
este cambio, ejecute el programa nuevamente para verificar que el análisis
del argumento aún funcione. Es bueno verificar su progreso a menudo, para
ayudar a identificar la causa de los problemas cuando ocurren.</p>
<h4 id="agrupación-de-valores-de-configuración"><a class="header" href="#agrupación-de-valores-de-configuración">Agrupación de valores de configuración</a></h4>
<p>Podemos dar otro pequeño paso para mejorar aún más la función <code>parse_config</code>.
Por el momento, estamos devolviendo una tupla, pero luego inmediatamente
dividimos esa tupla en partes individuales nuevamente. Este es un signo de
que quizás todavía no tengamos la abstracción correcta.</p>
<p>Otro indicador que muestra que hay margen de mejora es la parte <code>config</code>
de <code>parse_config</code>, lo que implica que los dos valores que devolvemos están
relacionados y son ambos parte de un valor de configuración. Actualmente, no
transmitimos este significado en la estructura de los datos, salvo agrupando
los dos valores en una tupla; podríamos poner los dos valores en una
estructura y darle a cada uno de los campos de la estructura un nombre
significativo. Hacerlo hará que sea más fácil para los futuros mantenedores
de este código entender cómo los diferentes valores se relacionan entre sí y
cuál es su propósito.</p>
<blockquote>
<p>Nota: Algunas personas llaman a este anti-patrón de usar valores primitivos
cuando un tipo complejo sería más apropiado <em>obsesión primitiva</em>.</p>
</blockquote>
<p>El listado 12-6 muestra las mejoras a la función <code>parse_config</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listado 12-6: Refactorizando <code>parse_config</code> para
devolver una instancia de una estructura <code>Config</code></span></p>
<p>Hemos agregado una estructura llamada <code>Config</code> definida para tener campos
llamados <code>query</code> y <code>filename</code>. La firma de <code>parse_config</code> ahora indica que
devuelve un valor <code>Config</code>. En el cuerpo de <code>parse_config</code>, donde solíamos
devolver segmentos de <em>string</em> que hacen referencia a los valores de <code>String</code>
en <code>args</code>, ahora definimos <code>Config</code> para que contenga los valores <code>String</code>.
La variable <code>args</code> en<code> main</code> es el propietario de los valores del argumento y
solo permite que la función <code>parse_config</code> los tome prestados, lo que
significa que violaremos las reglas de préstamo de Rust si <code>Config</code> intenta
tomar posesión de los valores en <code>args</code>.</p>
<p>Podríamos administrar los datos de <code>String</code> de varias maneras diferentes,
pero la ruta más fácil, aunque algo ineficiente, es llamar al método <code>clone</code>
en los valores. Esto hará que una copia completa de los datos para la
instancia <code>Config</code> sea de su propiedad, lo que requiere más tiempo y memoria
que el almacenamiento de una referencia a los datos de <em>string</em>. Sin embargo,
la clonación de datos también hace que nuestro código sea muy sencillo porque
no tenemos que administrar el <em>lifetime</em> de las referencias; En esta
circunstancia, renunciar a un pequeño rendimiento para ganar simplicidad es
una valiosa compensación.</p>
<blockquote>
<h3 id="las-compensaciones-de-usar-clone"><a class="header" href="#las-compensaciones-de-usar-clone">Las compensaciones de usar <code>clone</code></a></h3>
<p>Existe una tendencia entre muchos Rustaceans de evitar el uso de <code>clone</code>
para corregir problemas de propiedad debido a su costo de tiempo de
ejecución. En el Capítulo 13, aprenderá cómo usar métodos más eficientes en
este tipo de situaciones. Pero, por ahora, está bien copiar algunos
<em>strings</em> para seguir avanzando porque harás estas copias solo una vez y tu
nombre de archivo y <em>string</em> de consulta serán muy pequeños. Es mejor tener
un programa que funcione que sea un poco ineficiente que tratar de
hiperoptimizar el código en su primer pase. A medida que tenga más
experiencia con Rust, será más fácil comenzar con la solución más eficiente,
pero por ahora, es perfectamente aceptable llamar <code>clone</code>.</p>
</blockquote>
<p>Hemos actualizado <code>main</code> para que coloque la instancia de <code>Config</code> devuelta
por <code>parse_config</code> en una variable llamada <code>config</code>, y actualizamos el código
que previamente usaba las variables separadas <code>query</code> y <code>filename</code> para que
ahora usa los campos en la estructura <code>Config</code> en su lugar.</p>
<p>Ahora nuestro código transmite más claramente que <code>query</code> y <code>filename</code> están
relacionados y que su propósito es configurar cómo funcionará el programa.
Cualquier código que use estos valores sabe para encontrarlos en la instancia
<code>config</code> en los campos nombrados para su propósito.</p>
<h4 id="creando-un-constructor-para-config"><a class="header" href="#creando-un-constructor-para-config">Creando un Constructor para <code>Config</code></a></h4>
<p>Hasta ahora, hemos extraído la lógica responsable de analizar los argumentos
de la línea de comando de <code>main</code> y lo colocamos en la función <code>parse_config</code>.
Al hacerlo, nos ayudó a ver que los valores <code>query</code> y <code>filename</code> estaban
relacionados y esa relación debería transmitirse en nuestro código. Luego
agregamos una estructura <code>Config</code> para nombrar el propósito relacionado de
<code>query</code> y <code>filename</code> y para poder devolver los nombres de los valores como
los nombres de los campos struct de la función <code>parse_config</code>.</p>
<p>Entonces ahora que el propósito de la función <code>parse_config</code> es crear una
instancia <code>Config</code>, podemos cambiar <code>parse_config</code> de una función simple a
una función llamada <code>new</code> que está asociada con la estructura <code>Config</code>.
Hacer este cambio hará que el código sea más idiomático. Podemos crear
instancias de tipos en la biblioteca estándar, como <code>String</code>, llamando a
<code>String::new</code>. Del mismo modo, al cambiar <code>parse_config</code> en una <code>new</code> función
asociada con <code>Config</code>, podremos crear instancias de <code>Config</code> llamando a <code>Config::new</code>. El listado 12-7 muestra los cambios que debemos hacer.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listado 12-7: Cambiar <code>parse_config</code> en
<code>Config::new</code></span></p>
<p>Hemos actualizado <code>main</code> donde llamamos <code>parse_config</code> para llamar a
<code>Config::new</code>. Cambiamos el nombre de <code>parse_config</code> a <code>new</code> y lo movimos
dentro de un bloque <code>impl</code>, que asocia la función <code>new</code> con <code>Config</code>. Intenta
compilar este código nuevamente para asegurarte de que funciona.</p>
<h3 id="reparar-el-manejo-de-errores"><a class="header" href="#reparar-el-manejo-de-errores">Reparar el manejo de errores</a></h3>
<p>Ahora trabajaremos en arreglar nuestro manejo de errores. Recuerde que
intentar acceder a los valores en el vector <code>args</code> en el índice 1 o en el
índice 2 hará que el programa entre en pánico si el vector contiene menos de
tres elementos. Intenta ejecutar el programa sin ningún argumento; se verá
así:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>El índice de la línea <code>index out of bounds: the len is 1 but the index is 1</code> es un mensaje de error destinado a los programadores. No ayudará a nuestros
usuarios finales a comprender qué sucedió y qué deberían hacer en su lugar.
Arreglemos eso ahora.</p>
<h4 id="mejorando-el-mensaje-de-error"><a class="header" href="#mejorando-el-mensaje-de-error">Mejorando el mensaje de error</a></h4>
<p>En el listado 12-8, agregamos un cheque en la función <code>new</code> que verificará
que el segmento sea lo suficientemente largo antes de acceder al índice 1
y 2. Si el segmento no es lo suficientemente largo, el programa entra en pánico
y muestra un mensaje de error mejor que el mensaje <code>index out of bounds</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listado 12-8: Agregar un control para la cantidad de
argumentos</span></p>
<p>Este código es similar a la función <code>Guess::new</code> que escribimos en el Listado
9-9, donde llamamos <code>panic!</code> Cuando el argumento <code>value</code> estaba fuera del
rango de valores válidos. En lugar de buscar un rango de valores aquí,
estamos comprobando que la longitud de <code>args</code> es al menos 3 y el resto de la
función puede operar bajo la suposición de que se ha cumplido esta condición.
Si <code>args</code> tiene menos de tres elementos, esta condición será verdadera, y
llamamos a la macro <code>panic!</code> para finalizar el programa de inmediato.</p>
<p>Con estas pocas líneas de código extra en <code>new</code>, ejecutemos el programa sin
ningún argumento nuevamente para ver cómo se ve el error ahora:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Este resultado es mejor: ahora tenemos un mensaje de error razonable. Sin
embargo, también tenemos información extraña que no queremos dar a nuestros
usuarios. Quizás usar la técnica que usamos en el Listado 9-9 no sea la mejor
para usar aquí: una llamada a <code>panic!</code> Es más apropiada para un problema de
programación que un problema de uso, como se discutió en el Capítulo 9. En su
lugar, podemos usar la otra técnica que aprendió en el Capítulo 9-devolviendo
un <code>Result</code> que indica éxito o un error.</p>
<h4 id="devolviendo-un-result-desde-new-en-lugar-de-llamar-panic"><a class="header" href="#devolviendo-un-result-desde-new-en-lugar-de-llamar-panic">Devolviendo un <code>Result</code> desde <code>new</code> en lugar de llamar <code>panic!</code></a></h4>
<p>En su lugar, podemos devolver un valor <code>Result</code> que contendrá una instancia
<code>Config</code> en el caso exitoso y describiremos el problema en el caso de error.
Cuando <code>Config::new</code> se está comunicando con <code>main</code>, podemos usar el tipo
<code>Result</code> para indicar que hubo un problema. Entonces podemos cambiar <code>main</code>
para convertir una variante <code>Err</code> en un error más práctico para nuestros
usuarios sin el texto circundante sobre <code>thread' main'</code> y <code>RUST_BACKTRACE</code>
que causa una llamada a <code>panic!</code>.</p>
<p>El listado 12-9 muestra los cambios que debemos hacer en el valor de retorno
de <code>Config::new</code> y el cuerpo de la función necesaria para devolver un
<code>Result</code>. Tenga en cuenta que esto no se compilará hasta que actualicemos
<code>main</code> también, lo cual haremos en la siguiente lista.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listado 12-9: Devolviendo un <code>Result</code> desde
<code>Config::new</code></span></p>
<p>Nuestra función <code>new</code> ahora devuelve un <code>Result</code> con una instancia <code>Config</code>
en el caso de éxito y un <code>&amp;'static str</code> en el caso de error. Recuerde de la
sección “The Static Lifetime” en el Capítulo 10 que <code>&amp;'static str</code> es el tipo
de <em>string literals</em>, que es nuestro tipo de mensaje de error por el momento.</p>
<p>Hemos realizado dos cambios en el cuerpo de la función <code>new</code>: en lugar de
invocar <code>panic!</code> cuando el usuario no pasa suficientes argumentos, ahora
devolvemos un valor <code>Err</code>, y hemos envuelto <code>Config</code> devolver el valor en un
<code>Ok</code>. Estos cambios hacen que la función se ajuste a su nueva firma de tipo.</p>
<p>Devolver un valor <code>Err</code> de <code>Config::new</code> permite que la función <code>main</code> maneje
el valor <code>Result</code> devuelto por la función <code>new</code> y salga del proceso más
limpiamente en el caso de error.</p>
<h4 id="llamar-a-confignew-y-manejo-de-errores"><a class="header" href="#llamar-a-confignew-y-manejo-de-errores">Llamar a 'Config::new` y manejo de errores</a></h4>
<p>Para manejar el caso de error e imprimir un mensaje fácil de usar,
necesitamos actualizar <code>main</code> para manejar el <code>Result</code> que devuelve
<code>Config:: new</code>, como se muestra en el Listado 12-10. También tomaremos la
responsabilidad de salir de la herramienta de línea de comandos con un código
de error distinto de cero de <code>panic!</code> e implementarlo a mano. Un estado de
salida distinto de cero es una convención para indicar al proceso que llamó a
nuestro programa que el programa salió con un estado de error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listado 12-10: Salir con un código de error si falla la
creación de una nueva <code>Config</code></span></p>
<p>En esta lista, hemos utilizado un método que no hemos cubierto anteriormente:
<code>unwrap_or_else</code>, que se define en <code>Result &lt;T, E&gt;</code> por la biblioteca estándar.
El uso de <code>unwrap_or_else</code> nos permite definir un manejo de error
personalizado, no <code>panic!</code>. Si el <code>Result</code> es un valor <code>Ok</code>, el
comportamiento de este método es similar para <code>unwrap</code>: devuelve el valor
interno <code>Ok</code> está envolviendo. Sin embargo, si el valor
es un valor <code>Err</code>, este método llama al código en <em>closure</em>, que es una
función anónima que definimos y pasamos como un argumento para
<code>unwrap_or_else</code>. Bien cubriremos los <em>closure</em> con más detalle en el
Capítulo 13. Por ahora, solo necesita saber que ese <code>unwrap_or_else</code> pasará
el valor interno del <code>Err</code>, que en este caso es el <em>string</em> estático
<code>no enough arguments</code> que agregamos en el listado 12-9,
a nuestro <em>closure</em> en el argumento <code>err</code> que aparece entre los
<em>pipes</em> (||)verticales. El código en el <em>closure</em> puede usar el valor <code>err</code>
cuando se ejecuta.</p>
<p>Hemos agregado una nueva línea <code>use</code> para importar <code>process</code> de la biblioteca
estándar. El código en el <em>closure</em>  se ejecutará en el caso de error, son
solo dos líneas: imprimimos el valor <code>err</code> y luego llamamos
<code>process::exit</code>. La función <code>process::exit</code> detendrá el programa
inmediatamente y devolverá el número que se pasó como código de estado de
salida. Esto es similar al manejo basado en <code>panic!</code> que utilizamos en el listado 12-8, pero ya no obtenemos todos los resultados adicionales.
Intentemos eso:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>¡Estupendo! Este resultado es mucho más amigable para nuestros usuarios.</p>
<h3 id="extrayendo-la-lógica-de-main"><a class="header" href="#extrayendo-la-lógica-de-main">Extrayendo la lógica de <code>main</code></a></h3>
<p>Ahora que hemos terminado de refactorizar el análisis de configuración,
veamos la lógica del programa. Como dijimos en “Separación de preocupaciones
para proyectos binarios”, vamos a extraer una función llamada <code>run</code> que
mantendrá toda la lógica actualmente en la función <code>main</code> que no está
relacionada con la configuración de la configuración o el manejo de errores.
Cuando hayamos terminado, <code>main</code> será conciso y fácil de verificar mediante
inspección, y podremos escribir pruebas para la otra lógica.</p>
<p>El listado 12-11 muestra la función extraída <code>run</code>. Por ahora, solo estamos
haciendo una mejora pequeña y gradual al extraer la función. Todavía estamos
definiendo la función en <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listado 12-11: Extracción de una función <code>run</code> que
contiene el resto de la lógica del programa</span></p>
<p>La función <code>run</code> ahora contiene toda la lógica restante de <code>main</code>, comenzando
por leer el archivo. La función <code>run</code> toma la instancia <code>Config</code> como un
argumento.</p>
<h4 id="devolución-de-errores-de-la-función-run"><a class="header" href="#devolución-de-errores-de-la-función-run">Devolución de errores de la función <code>run</code></a></h4>
<p>Con la lógica restante del programa separada en la función <code>run</code>, podemos
mejorar el manejo de errores, como hicimos con <code>Config::new</code> en el Listado
12-9. En lugar de permitir que el programa entre en pánico al llamar a
<code>expect</code>, la función <code>run</code> devolverá un <code>Result &lt;T, E&gt;</code> cuando algo sale mal.
Esto nos permitirá consolidar aún más en <code>main</code> la lógica en torno al manejo
de errores de una manera fácil de usar. El listado 12-12 muestra los cambios
que debemos realizar en la firma y el cuerpo de <code>run</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listado 12-12: Cambiar la función <code>run</code> para devolver
<code>Result</code></span></p>
<p>Hemos realizado tres cambios significativos aquí. Primero, cambiamos el tipo
de retorno de la función <code>run</code> a <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. Esta función
devolvió previamente el tipo de unidad, <code>()</code>, y lo mantenemos como el valor
devuelto en el caso <code>Ok</code>.</p>
<p>Para el tipo de error, utilizamos el objeto <em>trait</em> <code>Box &lt;Error&gt;</code> (y hemos
llevado <code>std::error::Error</code> al ámbito con una instrucción <code>use</code> en la parte
superior). Cubriremos los objetos <em>trait</em> en el Capítulo 17. Por ahora, solo
saber que <code>Box&lt;Error&gt;</code> significa que la función devolverá un tipo que
implementa el <em>trait</em> de <code>Error</code>, pero no tenemos que especificar de qué tipo
particular será el valor de retorno. Esto nos da flexibilidad para devolver
valores de error que pueden ser de diferentes tipos en diferentes casos de
error.</p>
<p>En segundo lugar, hemos eliminado las llamadas a <code>expect</code> a favor del
operador <code>?</code>, como hablamos en el Capítulo 9. En lugar de <code>panic!</code> En un
error, el operador <code>?</code> devolverá el valor de error de la función actual para
que la persona que llama pueda manejarlo.</p>
<p>En tercer lugar, la función <code>ejecutar</code> ahora devuelve un valor <code>Ok</code> en el
caso de éxito. Hemos declarado el tipo de éxito de la función <code>run</code> como <code>()</code>
en la firma, lo que significa que debemos ajustar el valor del tipo de unidad
en el valor <code>Ok</code>. Esta sintaxis <code>Ok (())</code> puede parecer un poco extraña al
principio, pero usar <code>()</code> como este es la manera idiomática de indicar que
estamos llamando <code>run</code> solo por sus efectos secundarios; no devuelve un valor
que necesitamos.</p>
<p>Cuando ejecuta este código, compilará pero mostrará una advertencia:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust nos dice que nuestro código ignoró el valor <code>Result</code> y que el valor
<code>Result</code> podría indicar que ocurrió un error. ¡Pero no estamos verificando
si hubo un error o no, y el compilador nos recuerda que es probable que tengamos aquí algún código de manejo de errores! Vamos a rectificar ese
problema ahora.</p>
<h4 id="manejo-de-errores-devueltos-por-run-en-main"><a class="header" href="#manejo-de-errores-devueltos-por-run-en-main">Manejo de errores devueltos por <code>run</code> en <code>main</code></a></h4>
<p>Comprobaremos si hay errores y los manejaremos usando una técnica similar a la que usamos con <code>Config::new</code> en el listado 12-10, pero con una ligera
diferencia:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>Usamos <code>if let</code> en lugar de <code>unwrap_or_else</code> para comprobar si <code>run</code>
devuelve un valor <code>Err</code> y llama a <code>process::exit(1)</code> si es así. La función
<code>run</code> no devuelve un valor que queremos <code>unwrap</code> de la misma manera que
<code>Config::new</code> devuelve la instancia <code>Config</code>. Debido a que <code>run</code> devuelve
<code>()</code> en el caso de éxito, solo nos importa detectar un error, por lo que no
necesitamos <code>unwrap_or_else</code> para devolver el valor desenvuelto porque solo
sería <code>()</code>.</p>
<p>Los cuerpos de las funciones <code>if let</code> y <code>unwrap_or_else</code> son iguales en
ambos casos: imprimimos el error y salimos.</p>
<h3 id="división-de-código-en-un-library-crate"><a class="header" href="#división-de-código-en-un-library-crate">División de código en un <em>Library Crate</em></a></h3>
<p>¡Nuestro proyecto <code>minigrep</code> se ve bien hasta ahora!. Ahora dividiremos el
archivo <em>src/main.rs</em> y colocaremos algún código en el archivo <em>src/lib.rs</em>
para que podamos probarlo y tener un archivo <em>src/main.rs</em> con menos
responsabilidades.</p>
<p>Vamos a mover todo el código que no es la función <code>main</code> de <em>src/main.rs</em> a
<em>src/lib.rs</em>:</p>
<ul>
<li>La definición de la función <code>run</code></li>
<li>Las declaraciones pertinentes de 'uso'</li>
<li>La definición de <code>Config</code></li>
<li>La definición de la función <code>Config :: new</code></li>
</ul>
<p>El contenido de <em>src/lib.rs</em> debe tener las firmas que se muestran en el
listado 12-13 (hemos omitido los cuerpos de las funciones para abreviar).
Tenga en cuenta que esto no se compilará hasta que modifiquemos
<em>src/main.rs</em> en el listado 12-14.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listado 12-13: Mover <code>Config</code> y <code>run</code> a
<em>src/lib.rs</em></span></p>
<p>Hemos hecho un uso liberal de la palabra clave <code>pub</code>: en <code>Config</code>, en sus
campos y en su método <code>new</code>, y en la función <code>run</code>. ¡Ahora tenemos un
<em>library crate</em> que tiene una API pública que podemos probar!</p>
<p>Ahora tenemos que llevar el código que cambiamos a <em>src/lib.rs</em> dentro del
alcance del <em>binary crate</em> en <em>src/main.rs</em>, como se muestra en el listado
12-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listado 12-14: Llevar el <em>crate</em> <code>minigrep</code> dentro del
alcance de <em>src/main.rs</em></span></p>
<p>Para traer el <em>library crate</em> a el <em>binary crate</em>, usamos
<code>extern crate minigrep</code>. Luego agregamos una línea <code>use minigrep::Config</code>
para poner el tipo <code>Config</code> en el alcance, y prefijamos la función <code>run</code> con
nuestro nombre del <em>crate</em>. Ahora toda la funcionalidad debe estar conectada
y debería funcionar. Ejecute el programa con <code>cargo run</code> y asegúrese de que
todo funcione correctamente.</p>
<p>¡Uf!. Eso fue mucho trabajo, pero nos hemos preparado para el éxito en el
futuro. Ahora es mucho más fácil manejar los errores y hemos hecho que el
código sea más modular. Casi todo nuestro trabajo se realizará en
<em>src/lib.rs</em> de aquí en adelante.</p>
<p>Aprovechemos esta nueva modularidad al hacer algo que hubiera sido difícil
con el código anterior, pero es fácil con el nuevo código: ¡escribiremos
algunas pruebas!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="desarrollar-la-funcionalidad-de-la-biblioteca-con-desarrollo-basado-en-pruebas-test-driven-development-tdd"><a class="header" href="#desarrollar-la-funcionalidad-de-la-biblioteca-con-desarrollo-basado-en-pruebas-test-driven-development-tdd">Desarrollar la funcionalidad de la biblioteca con desarrollo basado en pruebas (<em>Test-driven development (TDD)</em>)</a></h2>
<p>Ahora que hemos extraído la lógica en <em>src/lib.rs</em> y dejamos la recolección
de los argumentos y el manejo de errores en <em>src/main.rs</em>, es mucho más fácil
escribir pruebas para la funcionalidad central de nuestro código. Podemos
llamar funciones directamente con varios argumentos y verificar valores
devueltos sin tener que llamar a nuestro binario desde la línea de comando.
Siéntete libre de escribir algunas pruebas para la funcionalidad en las
funciones <code>Config::new</code> y <code>run</code> por su cuenta.</p>
<p>En esta sección, agregaremos la lógica de búsqueda al programa <code>minigrep</code> utilizando el proceso de <em>Test-driven development (TDD)</em>. Esta técnica de desarrollo de software sigue estos pasos:</p>
<ol>
<li>Escriba una prueba que falla y ejecútala para asegurarte de que falla por
el motivo que esperas.</li>
<li>Escriba o modifique el código justo para hacer pasar la nueva prueba.</li>
<li>Refactorice el código que acaba de agregar o cambiar y asegúrese de que
las pruebas continúen pasando.</li>
<li>¡Repite desde el paso 1!</li>
</ol>
<p>Este proceso es solo una de las muchas maneras de escribir software, pero TDD
también puede ayudar a impulsar el diseño del código. Escribir la prueba
antes de escribir el código que hace que pase la prueba ayuda a mantener una
cobertura de prueba alta durante todo el proceso.</p>
<p>Probará la implementación de la funcionalidad que realmente buscará el <em>string</em> de consulta en el contenido del archivo y generará una lista de
líneas que coincidan con la consulta. Agregaremos esta funcionalidad en una
función llamada <code>search</code>.</p>
<h3 id="escribir-una-prueba-fallida"><a class="header" href="#escribir-una-prueba-fallida">Escribir una prueba fallida</a></h3>
<p>Como ya no los necesitamos, eliminemos las sentencias <code>println!</code> de
<em>src/lib.rs</em> y <em>src/main.rs</em> que usamos para verificar el comportamiento del
programa. Luego, en <em>src/lib.rs</em>, agregaremos un módulo <code>test</code> con una
función de prueba, como hicimos en el Capítulo 11. La función de prueba
especifica el comportamiento que queremos que tenga la función <code>search</code>: lo
hará tome una consulta y el texto para buscar la consulta, y devolverá solo
las líneas del texto que contiene la consulta. El listado 12-15 muestra esta
prueba, que aún no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 12-15: Creando una prueba de falla para la
función <code>search</code> que deseamos tener</span></p>
<p>Esta prueba busca la cadena <code>&quot;duct&quot;</code>. El texto que estamos buscando tiene
tres líneas, de las cuales solo una contiene <code>&quot;duct&quot;</code>. Afirmamos que el valor
devuelto por la función <code>search</code> contiene solo la línea que esperamos.</p>
<p>No podemos ejecutar esta prueba y verla fallar porque la prueba ni siquiera
se compila: ¡la función <code>search</code> aún no existe! Así que ahora agregaremos
solo el código suficiente para hacer que la prueba se compile y ejecute al
agregar una definición de la función <code>search</code> que siempre devuelve un vector
vacío, como se muestra en el Listado 12-16. Entonces la prueba debería
compilarse y fallar porque un vector vacío no coincide con un vector que
contiene la línea <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 12-16: Definir lo suficiente de la función
<code>search</code> para que nuestra prueba compile</span></p>
<p>Tenga en cuenta que necesitamos un <em>lifetime</em> explícito <code>a'</code> definido en la
firma de <code>search</code> y utilizado con el argumento <code>contents</code> y el valor de
retorno. Recuerde en el Capítulo 10 que los parámetros de <em>lifetime</em>
especifican qué <em>lifetime</em> del argumento está conectada a el <em>lifetime</em> del
valor de retorno. En este caso, indicamos que el vector devuelto debe
contener <em>string slices</em> que hacen referencia a <em>slices</em> del argumento
<code>contents</code> (en lugar del argumento <code>query</code>).</p>
<p>En otras palabras, le decimos a Rust que los datos devueltos por la función
<code>search</code> vivirán mientras los datos pasen a la función <code>search</code> en el
argumento <code>contents</code>. ¡Esto es importante! Los datos a los que se hace
referencia <em>por</em> un <em>slice</em> deben ser válidos para que la referencia sea
válida; si el compilador asume que estamos haciendo <em>string slices</em> de
<code>query</code> en lugar de <code>contents</code>, hará su comprobación de seguridad de forma
incorrecta.</p>
<p>Si olvidamos las anotaciones de <em>lifetime</em> y tratamos de compilar esta
función, obtendremos este error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust no puede saber cuál de los dos argumentos necesitamos, así que tenemos
que contarlo. Debido a que <code>contents</code> es el argumento que contiene todo
nuestro texto y queremos devolver las partes de ese texto que coinciden,
sabemos <code>contents</code> es el argumento que debe conectarse al valor de retorno
utilizando la sintaxis de duración.</p>
<p>Otros lenguajes de programación no requieren que conecte argumentos para
devolver valores en la firma. Aunque esto pueda parecer extraño, será más
fácil con el tiempo. Es posible que desee comparar este ejemplo con la
sección “Validación de referencias con <em>Lifetimes</em>” en el Capítulo
10.</p>
<p>Ahora ejecutemos la prueba:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Genial, la prueba falla, exactamente como esperábamos. ¡Hagamos pasar la
prueba!</p>
<h3 id="escribir-código-para-pasar-la-prueba"><a class="header" href="#escribir-código-para-pasar-la-prueba">Escribir código para pasar la prueba</a></h3>
<p>Actualmente, nuestra prueba está fallando porque siempre devolvemos un vector
vacío. Para solucionar eso e implementar <code>search</code>, nuestro programa debe
seguir estos pasos:</p>
<ul>
<li>Iterar a través de cada línea de los contenidos.</li>
<li>Verifique si la línea contiene nuestro texto de consulta.</li>
<li>Si lo hace, agréguelo a la lista de valores que estamos devolviendo.</li>
<li>Si no es así, no hagas nada.</li>
<li>Devuelve la lista de resultados que coinciden.</li>
</ul>
<p>Vamos a trabajar en cada paso, comenzando con iterar a través de las líneas.</p>
<h4 id="iterar-a-través-de-las-líneas-con-el-método-lines"><a class="header" href="#iterar-a-través-de-las-líneas-con-el-método-lines">Iterar a través de las líneas con el método <code>lines</code></a></h4>
<p>Rust tiene un método útil para manejar la iteración línea por línea de
<em>string</em>, convenientemente llamadas <code>lines</code>, que funciona como se muestra en
el listado 12-17. Tenga en cuenta que esto aún no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">Listado 12-17: iteración a través de cada línea en
<code>contents</code></span></p>
<p>El método <code>lines</code> devuelve un iterador. Hablaremos sobre iteradores en
profundidad en el Capítulo 13, pero recuerde que vio esta forma de usar un
iterador en el Listado 3-5, donde usamos un bucle <code>for</code> con un iterador para
ejecutar un código en cada elemento de una colección.</p>
<h4 id="buscando-cada-línea-para-la-consulta"><a class="header" href="#buscando-cada-línea-para-la-consulta">Buscando cada línea para la consulta</a></h4>
<p>A continuación, comprobaremos si la línea actual contiene nuestro <em>sting</em> de
consulta. Afortunadamente, los <em>string</em> tienen un método útil llamado
<code>contains</code> que hace esto por nosotros. Agregue una llamada al método
<code>contains</code> en la función <code>search</code>, como se muestra en el Listado 12-18. Tenga
en cuenta que esto todavía no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listado 12-18: Agregar funcionalidad para ver si la
línea contiene el <em>string</em> en <code>query</code></span></p>
<h4 id="almacenamiento-de-líneas-coincidentes"><a class="header" href="#almacenamiento-de-líneas-coincidentes">Almacenamiento de líneas coincidentes</a></h4>
<p>También necesitamos una forma de almacenar las líneas que contienen nuestra
<em>string</em> de consulta. Para eso, podemos hacer un vector mutable antes del
bucle <code>for</code> y llamar al método <code>push</code> para almacenar una <code>line</code> en el vector.
Después del ciclo <code>for</code>, devolvemos el vector, como se muestra en el listado
12-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listado 12-19: Almacenando las líneas que coinciden
para que podamos devolverlas</span></p>
<p>Ahora la función <code>search</code> debería devolver solo las líneas que contienen
<code>query</code>, y nuestra prueba debería pasar. Vamos a ejecutar la prueba:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Nuestra prueba pasó, entonces sabemos que funciona!</p>
<p>En este punto, podríamos considerar oportunidades para refactorizar la
implementación de la función de búsqueda mientras se mantienen las pruebas
para mantener la misma funcionalidad. El código en la función de búsqueda no
es tan malo, pero no aprovecha algunas características útiles de los
iteradores. Volveremos a este ejemplo en el Capítulo 13, donde exploraremos
los iteradores en detalle y veremos cómo mejorarlo.</p>
<h4 id="usando-la-función-search-en-la-función-run"><a class="header" href="#usando-la-función-search-en-la-función-run">Usando la función <code>search</code> en la función <code>run</code></a></h4>
<p>Ahora que la función <code>search</code> está trabajando y probada, necesitamos llamar
<code>search</code> desde nuestra función <code>run</code>. Necesitamos pasar el valor
<code>config.query</code> y el <code>contents</code> que <code>run</code> lee desde el archivo a la función
<code>search</code>. Luego <code>run</code> imprimirá cada línea devuelta desde <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>Todavía estamos usando un bucle <code>for</code> para devolver cada línea de <code>search</code> e
imprimirla.</p>
<p>¡Ahora todo el programa debería funcionar! Probémoslo, primero con una
palabra que debería devolver exactamente una línea del poema de Emily Dickinson, “frog”:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>¡Guay!. Ahora intentemos una palabra que coincida con varias líneas, como
“body”:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Y finalmente, asegurémonos de no obtener ninguna línea cuando buscamos una
palabra que no esté en ningún lugar del poema, como “monomorphization”:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>¡Excelente! Creamos nuestra propia versión mini de una herramienta clásica y
aprendimos mucho sobre cómo estructurar las aplicaciones. También aprendimos
un poco sobre la entrada y salida de archivos, el <em>lifetimes</em>, las pruebas y
el análisis de línea de comando.</p>
<p>Para completar este proyecto, mostraremos brevemente cómo trabajar con
variables de entorno y cómo imprimir a error estándar, las cuales son útiles
cuando se escriben programas de línea de comando.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trabajando-con-variables-de-entorno"><a class="header" href="#trabajando-con-variables-de-entorno">Trabajando con variables de entorno</a></h2>
<p>Mejoraremos <code>minigrep</code> agregando una característica adicional: una opción
para la búsqueda de mayúsculas y minúsculas que el usuario puede activar a
través de una variable de entorno. Podríamos hacer que esta característica
sea una opción de línea de comando y requerir que los usuarios la ingresen
cada vez que quieran que se aplique, pero en su lugar usaremos una variable
de entorno. Hacerlo permite a nuestros usuarios establecer la variable de
entorno una vez y hacer que todas sus búsquedas sean insensibles a las
mayúsculas y minúsculas en esa sesión de terminal.</p>
<h3 id="escribir-una-prueba-de-falla-para-la-función-search-sensible-a-mayúsculas-y-minúsculas"><a class="header" href="#escribir-una-prueba-de-falla-para-la-función-search-sensible-a-mayúsculas-y-minúsculas">Escribir una prueba de falla para la función <code>search</code> sensible a mayúsculas y minúsculas</a></h3>
<p>Queremos agregar una nueva función <code>search_case_insensitive</code> a la que
llamaremos cuando la variable de entorno esté activada. Seguiremos siguiendo
el proceso TDD, por lo que el primer paso es volver a escribir una prueba
fallida. Añadiremos una nueva prueba para la nueva función
<code>search_case_insensitive</code> y cambiaremos el nombre de nuestra antigua prueba
de <code>one_result</code> a <code>case_sensitive</code> para aclarar las diferencias entre las dos
pruebas, como se muestra en el listado 12-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 12-20: Agregar una nueva prueba de falla para
la función sensible a mayúsculas y minúsculas que estamos a punto de
agregar</span></p>
<p>Tenga en cuenta que también hemos editado el <code>contents</code> de la prueba
anterior. Hemos agregado una nueva línea con el texto <code>&quot;Duct tape.&quot;</code> Usando
una D mayúscula que no debe coincidir con la consulta <code>&quot;duct&quot;</code> cuando estamos
buscando casos sensibles. Cambiar la prueba anterior de esta manera ayuda a
garantizar que no rompamos accidentalmente la funcionalidad de búsqueda
sensible a mayúsculas y minúsculas que ya hemos implementado. Esta prueba
debe pasar ahora y continuar pasando a medida que trabajamos en la búsqueda
sensible a mayúsculas y minúsculas.</p>
<p>La nueva prueba para la búsqueda <em>sensible</em> usa <code>&quot;rUsT&quot;</code> como consulta. En la
función <code>search_case_insensitive</code> que estamos a punto de agregar, la
consulta <code>&quot;rUsT&quot;</code> debe coincidir con la línea que contiene <code>&quot;Rust:&quot;</code>con una R
mayúscula y hacer coincidir la línea <code>&quot;Trust me.&quot;</code> aunque ambos tengan
carcasa diferente a la consulta. Esta es nuestra prueba de falla, y no
compilará porque aún no hemos definido la función <code>search_case_insensitive</code>.
Siéntase libre de agregar una implementación de esqueleto que siempre
devuelve un vector vacío, similar a la forma en que lo hicimos para la
función <code>search</code> en el listado 12-16 para ver la compilación de prueba y
fallar.</p>
<h3 id="implementando-la-función-search_case_insensitive"><a class="header" href="#implementando-la-función-search_case_insensitive">Implementando la función <code>search_case_insensitive</code></a></h3>
<p>La función <code>search_case_insensitive</code>, que se muestra en el listado 12-21,
será casi la misma que la función <code>search</code>. La única diferencia es que vamos
a escribir en minúscula la <code>query</code> y cada <code>líne</code>, así que cualquiera sea el
caso de los argumentos de entrada, serán el mismo caso cuando verifiquemos si
la línea contiene la consulta.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 12-21: Definir la función
<code>search_case_insensitive</code> para minúsculas de la consulta y la línea antes de
compararlas</span></p>
<p>Primero, minamos la cadena <code>query</code> y la almacenamos en una variable sombreada
con el mismo nombre. Llamar <code>to_lowercase</code> en la consulta es necesario así
que no importa si la consulta del usuario es <code>&quot;rust&quot;</code>,<code>&quot;RUST&quot;</code>,<code>&quot;Rust:&quot;</code>,
o <code>&quot;rUsT&quot;</code>, trataremos la consulta como si fuera <code>&quot;rust&quot;</code> y ser insensible al
asunto.</p>
<p>Tenga en cuenta que <code>query</code> ahora es un <code>String</code> en lugar de un
<em>string slice</em>, porque la invocación <code>to_lowercase</code> crea nuevos datos en
lugar de hacer referencia a los datos existentes. Digamos que la consulta es
<code>&quot;rUsT&quot;</code>, como un ejemplo: ese <em>string slice</em> no contiene <code>u</code> o <code>t</code>
minúsculas para que lo usemos, así que tenemos que asignar un nuevo <code>String</code>
que contenga <code>&quot;rust&quot;</code>. Cuando pasamos <code>query</code> como un argumento para el
método <code>contains</code> ahora, necesitamos agregar un <em>ampersand</em> ya que la firma
de <code>contains</code> está definida para tomar un <em>string slice</em>.</p>
<p>A continuación, agregamos una llamada a <code>to_lowercase</code> en cada <code>line</code> antes
de verificar si contiene <code>query</code> para minúsculas de todos los caracteres.
Ahora que convertimos <code>line</code> y <code>query</code> a minúsculas, encontraremos
coincidencias sin importar el caso de la consulta.</p>
<p>Veamos si esta implementación pasa las pruebas:</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>¡Estupendo! Ellas pasaron. Ahora, llamemos a la nueva función
<code>search_case_insensitive</code> de la función <code>run</code>. Primero, agregaremos una
opción de configuración a la estructura <code>Config</code> para cambiar entre búsqueda
sensible a mayúsculas y minúsculas. Agregar este campo provocará errores en
el compilador porque aún no estamos inicializando este campo en ninguna parte:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>Tenga en cuenta que agregamos el campo <code>case_sensitive</code> que contiene un
booleano. A continuación, necesitamos la función <code>run</code> para verificar el
valor del campo <code>case_sensitive</code> y usar eso para decidir si se llama a la
función <code>search</code> o a la función <code>search_case_insensitive</code>, como se muestra en
el Listado 12-22. Tenga en cuenta que esto todavía no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">
</span><span class="boring">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 12-22: Llamar a <code>search</code> o
<code>search_case_insensitive</code> en función del valor en <code>config.case_sensitive</code></span></p>
<p>Finalmente, necesitamos verificar la variable de entorno. Las funciones para
trabajar con variables de entorno se encuentran en el módulo <code>env</code> de la
biblioteca estándar, por lo que queremos poner ese módulo dentro del alcance
con una línea <code>use std::env;</code> en la parte superior de <em>src/lib.rs</em> . Luego
usaremos la función <code>var</code> del módulo <code>env</code> para buscar una variable de
entorno llamada <code>CASE_INSENSITIVE</code>, como se muestra en el listado 12-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;
<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span>
// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 12-23: Comprobación de una variable de entorno
llamada <code>CASE_INSENSITIVE</code></span></p>
<p>Aquí, creamos una nueva variable <code>case_sensitive</code>. Para establecer su valor,
llamamos a la función <code>env::var</code> y le pasamos el nombre de la variable de
entorno<code> CASE_INSENSITIVE</code>. La función <code>env::var</code> devuelve un <code>Result</code> que
será la variante exitosa <code>Ok</code> que contiene el valor de la variable de entorno
si se establece la variable de entorno. Devolverá la variante <code>Err</code> si la
variable de entorno no está configurada.</p>
<p>Estamos utilizando el método <code>is_err</code> en el <code>Result</code> para comprobar si se
trata de un error y, por lo tanto, no está configurado, lo que significa que
<em>debería</em> hacer una búsqueda sensible a mayúsculas y minúsculas. Si la
variable de entorno <code>CASE_INSENSITIVE</code> se configura en cualquier cosa,
<code>is_err</code> devolverá false y el programa realizará una búsqueda que no
distingue entre mayúsculas y minúsculas. No nos importa el <em>valor</em> de la
variable de entorno, solo si está configurada o no, así que estamos
verificando <code>is_err</code> en lugar de usar <code>unwrap</code>, <code>expect</code>, o cualquiera de los
otros métodos que tenemos visto en <code>Result</code>.</p>
<p>Pasamos el valor en la variable <code>case_sensitive</code> a la instancia <code>Config</code> para
que la función <code>run</code> pueda leer ese valor y decidir si se llama <code>search</code> o
<code>search_case_insensitive</code>, como implementamos en el listado 12-22.</p>
<p>¡Hagamos un intento! Primero, ejecutaremos nuestro programa sin la variable
de entorno establecida y con la consulta <code>to</code>, que debe coincidir con
cualquier línea que contenga la palabra “to” en minúsculas:</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>¡Parece que todavía funciona! Ahora, ejecutemos el programa con
<code>CASE_INSENSITIVE</code> establecido en <code>1</code> pero con la misma consulta <code>to</code>.</p>
<p>Si está usando PowerShell, necesitará establecer la variable de entorno y
ejecutar el programa en dos comandos en lugar de uno:</p>
<pre><code class="language-text">$ $env:CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>Deberíamos obtener líneas que contengan “to” que podrían tener letras
mayúsculas:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excelente, ¡también tenemos líneas que contienen “To”! Nuestro programa
<code>minigrep</code> ahora puede hacer búsquedas sensibles a mayúsculas y minúsculas
controladas por una variable de entorno. Ahora sabe cómo administrar las
opciones establecidas utilizando argumentos de línea de comando o variables
de entorno.</p>
<p>Algunos programas permiten argumentos <em>y</em> variables de entorno para la misma
configuración. En esos casos, los programas deciden que uno u otro tiene
prioridad. Para otro ejercicio por su cuenta, intente controlar la
sensibilidad de mayúsculas y minúsculas mediante un argumento de línea de
comando o una variable de entorno. Decida si el argumento de la línea de
comando o la variable de entorno debe tener prioridad si el programa se
ejecuta con un conjunto sensible a mayúsculas y minúsculas y un conjunto
de insensible a mayúsculas y minúsculas.</p>
<p>El módulo <code>std::env</code> contiene muchas más funciones útiles para tratar las
variables de entorno: consulte su documentación para ver qué hay disponible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="escribiendo-mensajes-de-error-en-standard-error-en-lugar-de-standard-output"><a class="header" href="#escribiendo-mensajes-de-error-en-standard-error-en-lugar-de-standard-output">Escribiendo Mensajes de Error en &quot;Standard Error&quot; en lugar de &quot;Standard Output&quot;</a></h2>
<p>Por el momento, estamos escribiendo toda nuestra salida al terminal usando la
función <code>println!</code>. La mayoría de los terminales proporcionan dos tipos de
resultados: <em>salida estándar</em> (<code>stdout</code>) para información general y
<em>error estándar</em> (<code>stderr</code>) para mensajes de error. Esta distinción permite a
los usuarios elegir dirigir la salida exitosa de un programa a un archivo
pero aún así imprimir mensajes de error en la pantalla.</p>
<p>La función <code>println!</code> solo es capaz de imprimir en salida estándar, por lo
que tenemos que usar algo más para imprimir a un a <em>error estándar</em>.</p>
<h3 id="comprobando-dónde-se-escriben-los-errores"><a class="header" href="#comprobando-dónde-se-escriben-los-errores">Comprobando dónde se escriben los errores</a></h3>
<p>Primero, observemos cómo el contenido impreso por <code>minigrep</code> se está
escribiendo actualmente en la salida estándar, incluyendo cualquier mensaje
de error que deseemos escribir en error estándar. Lo haremos redireccionando
la secuencia de salida estándar a un archivo y, a la vez, provocando un error
intencionalmente. No redirigiremos la secuencia de error estándar, por lo que
cualquier contenido enviado a un error estándar continuará apareciendo en la
pantalla.</p>
<p>Se espera que los programas de línea de comando envíen mensajes de error al
flujo de error estándar para que podamos ver los mensajes de error en la
pantalla incluso si redirigimos el flujo de salida estándar a un archivo.
Nuestro programa actualmente no se comporta bien: ¡estamos a punto de ver que
en su lugar, guarda el resultado del mensaje de error en un archivo!</p>
<p>La forma de demostrar este comportamiento es ejecutando el programa con <code>&gt;</code> y
el nombre de archivo, <em>output.txt</em>, al que queremos redirigir la secuencia de
salida estándar. No pasaremos ningún argumento, que debería causar un error:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>La sintaxis <code>&gt;</code> le dice al shell que escriba el contenido del resultado
estándar en <em>output.txt</em> en lugar de la pantalla. No vimos el mensaje de
error que esperábamos que se imprimiera en la pantalla, lo que significa que
debe haber terminado en el archivo. Esto es lo que <em>output.txt</em> contiene:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Sí, nuestro mensaje de error se está imprimiendo en la salida estándar. Es
mucho más útil que los mensajes de error como este se impriman en un error
estándar para que solo los datos de una ejecución exitosa terminen en el
archivo. Cambiaremos eso.</p>
<h3 id="impresión-de-errores-en-el-error-estándar"><a class="header" href="#impresión-de-errores-en-el-error-estándar">Impresión de errores en el error estándar</a></h3>
<p>Usaremos el código en el listado 12-24 para cambiar cómo se imprimen los
mensajes de error. Debido a la refactorización que hicimos anteriormente en
este capítulo, todo el código que imprime mensajes de error está en una
función, <code>main</code>. La biblioteca estándar proporciona la macro <code>eprintln!</code> Que
se imprime en la secuencia de error estándar, así que cambiemos los dos
lugares a los que estábamos llamando <code>println!</code> Para imprimir los errores
para usar <code>eprintln!</code> En su lugar.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listado 12-24: Escribir mensajes de error a error
estándar en lugar de salida estándar usando <code>eprintln!</code></span></p>
<p>Después de cambiar <code>println!</code> a <code>eprintln!</code>, Ejecutemos el programa
nuevamente de la misma manera, sin ningún argumento y redirigiendo la salida
estándar con <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Ahora vemos el error en pantalla y <em>output.txt</em> no contiene nada, que es el
comportamiento que esperamos de los programas de línea de comandos.</p>
<p>Ejecutamos el programa de nuevo con argumentos que no causan un error, pero
que redirigen la salida estándar a un archivo, de la siguiente manera:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>No veremos ningún resultado en el terminal, y <em>output.txt</em> contendrá nuestros
resultados:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Esto demuestra que ahora estamos usando salida estándar para salida exitosa y
error estándar para salida de error según corresponda.</p>
<h2 id="resumen-10"><a class="header" href="#resumen-10">Resumen</a></h2>
<p>Este capítulo resumió algunos de los principales conceptos que ha aprendido
hasta ahora y cubrió cómo realizar operaciones de E/S comunes en Rust. Al
usar argumentos de línea de comandos, archivos, variables de entorno y la
macro <code>eprintln!</code> Para errores de impresión, ahora está preparado para
escribir aplicaciones de línea de comandos. Al utilizar los conceptos de
capítulos anteriores, su código estará bien organizado, almacenará los datos
de manera efectiva en las estructuras de datos apropiadas, manejará los
errores de manera adecuada y se pondrá a prueba.</p>
<p>A continuación, exploraremos algunas características de Rust que se vieron
influenciadas por los lenguajes funcionales: cierres e iteradores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="características-del-lenguaje-funcional-iterators-y-closures"><a class="header" href="#características-del-lenguaje-funcional-iterators-y-closures">Características del lenguaje funcional: <em>Iterators</em> y <em>Closures</em></a></h1>
<p>El diseño de Rust se ha inspirado en muchos lenguajes y técnicas existentes,
y una influencia significativa es la <em>programación funcional</em>. La
programación en un estilo funcional a menudo incluye el uso de funciones como
valores pasándolos en argumentos, regresándolos de otras funciones,
asignándolos a variables para su posterior ejecución, y así sucesivamente.</p>
<p>En este capítulo, no debatiremos el tema de qué programación funcional es o
no será, sino que discutiremos algunas características de Rust que son
similares a las características en muchos lenguajes que a menudo se denominan
funcionales.</p>
<p>Más específicamente, cubriremos:</p>
<ul>
<li><em>Closures</em>, una construcción similar a una función que puedes almacenar en una variable</li>
<li><em>Iteradores</em>, una forma de procesar una serie de elementos</li>
<li>Cómo utilizar estas dos características para mejorar el proyecto de E/S en
el Capítulo 12</li>
<li>El rendimiento de estas dos características (alerta de spoiler: ¡son más
rápidos de lo que crees!)</li>
</ul>
<p>Otras características de Rust, como la <em>coincidencia de patrones</em>
(<em>pattern matching</em>) y las enumeraciones, que hemos cubierto en otros
capítulos, también están influenciadas por el estilo funcional. Dominar los
<em>Closures</em> y los <em>Iterators</em> (<em>Iteradores</em>) es una parte importante de la
redacción del código Rust idiomático y rápido, por lo que les dedicaremos
todo este capítulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="closures-funciones-anónimas-que-pueden-capturar-su-entorno"><a class="header" href="#closures-funciones-anónimas-que-pueden-capturar-su-entorno">Closures: Funciones anónimas que pueden capturar su entorno</a></h2>
<p>Los <em>closures</em> de Rust son funciones anónimas que puede guardar en una
variable o pasar como argumentos a otras funciones. Puede crear el <em>closures</em>
en un lugar y luego llamar al <em>closures</em> para evaluarlo en un contexto
diferente. A diferencia de las funciones, los <em>closures</em> pueden capturar
valores del ámbito en el que se llaman. Demostraremos cómo estas
características de <em>closures</em> permiten la reutilización del código y la
personalización del comportamiento.</p>
<h3 id="creando-una-abstracción-de-comportamiento-con-closures"><a class="header" href="#creando-una-abstracción-de-comportamiento-con-closures">Creando una abstracción de comportamiento con <em>Closures</em></a></h3>
<p>Vamos a trabajar en un ejemplo de una situación en la que es útil almacenar
un <em>closures</em> que se ejecutará más adelante. En el camino, hablaremos sobre
la sintaxis de los <em>closures</em>, la inferencia tipo y los <em>trait</em>.</p>
<p>Considere esta situación hipotética: trabajamos en una startup que está
creando una aplicación para generar planes de entrenamiento de ejercicios
personalizados. El backend está escrito en Rust y el algoritmo que genera el
plan de entrenamiento tiene en cuenta muchos factores, como la edad del
usuario de la aplicación, el índice de masa corporal, las preferencias de
ejercicio, entrenamientos recientes y un número de intensidad que
especifican. El algoritmo real utilizado no es importante en este ejemplo; lo
importante es que este cálculo demora unos segundos. Queremos llamar a este
algoritmo solo cuando lo necesitemos y solo llamarlo una vez para que el
usuario no espere más de lo necesario.</p>
<p>Simularemos llamar a este algoritmo hipotético con la función
<code>simulated_expensive_calculation</code> que se muestra en el listado 13-1, que
imprimirá <code>calculating slowly...</code>, esperará dos segundos y luego
devolverá el número que hayamos pasado.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-1: una función para sustituir un cálculo
hipotético que tarda unos 2 segundos en ejecutarse</span></p>
<p>Luego está la función <code>main</code>, que contiene las partes de la aplicación de
entrenamiento importantes para este ejemplo. Esta función representa el
código que la aplicación llamará cuando un usuario solicite un plan de
entrenamiento. Debido a que la interacción con la interfaz de la aplicación
no es relevante para el uso de <em>closures</em>, codificaremos los valores que
representan las entradas de nuestro programa e imprimiremos los resultados.</p>
<p>Las entradas requeridas son estas:</p>
<ul>
<li>Un número de intensidad del usuario, que se especifica cuando solicitan un
entrenamiento para indicar si desean un entrenamiento de baja intensidad o
un entrenamiento de alta intensidad</li>
<li>Un número aleatorio que generará cierta variedad en los planes de
entrenamiento</li>
</ul>
<p>El resultado será el plan de entrenamiento recomendado. El listado 13-2
muestra la función <code>main</code> que usaremos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
<span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span></code></pre></pre>
<p><span class="caption">Listado 13-2: Una función <code>main</code> con valores
codificados para simular la entrada del usuario y la generación de números
aleatorios</span></p>
<p>Hemos codificado la variable <code>simulated_user_specified_value</code> como 10 y la
variable <code>simulated_random_number</code> como 7 por simplicidad; en un programa
real, obtendríamos el número de intensidad de la interfaz de la aplicación, y
usaríamos la caja <code>rand</code> para generar un número aleatorio, como lo hicimos en
el ejemplo del juego Adivinar en el Capítulo 2. La función <code>main</code> llama a la
función <code>generate_workout</code> con los valores de entrada simulados.</p>
<p>Ahora que tenemos el contexto, vamos al algoritmo. La función
<code>generate_workout</code> en el Listado 13-3 contiene la lógica comercial de la
aplicación que más nos interesa en este ejemplo. El resto de los cambios de
código en este ejemplo se realizarán en esta función.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(num: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    num
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-3: La lógica de negocios que imprime los
planes de entrenamiento basados en las entradas y llamadas a la función
<code>simulated_expensive_calculation</code></span></p>
<p>El código en el Listado 13-3 tiene múltiples llamadas a la función de cálculo
lento. El primer bloque <code>if</code> invoca <code>simulated_expensive_calculation</code> dos
veces, el <code>if</code> dentro del <code>else</code> externo no lo llama en absoluto, y el código
dentro del segundo caso <code>else</code> lo llama una vez.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>El comportamiento deseado de la función <code>generate_workout</code> es verificar
primero si el usuario desea un entrenamiento de baja intensidad (indicado por
un número menor a 25) o un entrenamiento de alta intensidad (un número de 25
o más).</p>
<p>Los planes de entrenamiento de baja intensidad recomendarán una serie de
flexiones y sentadillas basadas en el complejo algoritmo que estamos
simulando.</p>
<p>Si el usuario desea un entrenamiento de alta intensidad, existe una lógica
adicional: si el valor del número aleatorio generado por la aplicación es 3,
la aplicación recomendará un descanso e hidratación. De lo contrario, el
usuario obtendrá una cantidad de minutos de ejecución basada en el complejo
algoritmo.</p>
<p>Este código funciona de la forma en que la empresa lo quiere ahora, pero
digamos que el equipo de ciencia de datos decide que tenemos que hacer
algunos cambios en la forma en que llamamos a la función
<code>simulated_expensive_calculation</code> en el futuro. Para simplificar la
actualización cuando ocurren esos cambios, queremos refactorizar este código
para que llame a la función <code>simulated_expensive_calculation</code> solo una vez.
También queremos reducir el lugar en el que estamos innecesariamente llamando
a la función dos veces sin agregar otras llamadas a esa función en el
proceso. Es decir, no queremos llamarlo si el resultado no es necesario y aún
así queremos llamarlo solo una vez.</p>
<h4 id="refactorización-mediante-funciones"><a class="header" href="#refactorización-mediante-funciones">Refactorización mediante funciones</a></h4>
<p>Podríamos reestructurar el programa de entrenamiento de muchas maneras.
Primero, intentaremos extraer la llamada duplicada a la función
<code>simulated_expensive_calculation</code> en una variable, como se muestra en el
Listado 13-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(num: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    num
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-4: Extrayendo las llamadas a
<code>simulated_expensive_calculation</code> a un lugar y almacenando el resultado en la
variable <code>expensive_result</code></span></p>
<p>Este cambio unifica todas las llamadas a <code>simulation_expensive_calculation</code> y
resuelve el problema del primer bloque <code>if</code> invocando innecesariamente la
función dos veces. Desafortunadamente, ahora estamos llamando a esta función
y esperando el resultado en todos los casos, que incluye el bloque <code>if</code>
interno que no usa el valor del resultado en absoluto.</p>
<p>Queremos definir el código en un lugar en nuestro programa, pero solo
<em>ejecutar</em> ese código donde realmente necesitamos el resultado. ¡Este es un
caso de uso para <em>closures</em>!</p>
<h4 id="refactorización-con-closures-para-almacenar-código"><a class="header" href="#refactorización-con-closures-para-almacenar-código">Refactorización con <em>Closures</em> para almacenar código</a></h4>
<p>En lugar de llamar siempre a la función <code>simulated_expensive_calculation</code>
antes de los bloques <code>if</code>, podemos definir un <em>closure</em> y almacenar <em>closure</em>
en una variable en lugar de almacenar el resultado de la llamada a la función
como se muestra en el Listado 13-5. Podemos mover todo el cuerpo de
<code>simulated_expensive_calculation</code> dentro del <em>closure</em> que estamos
presentando aquí.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">expensive_closure(5);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-5: Definir un <em>closure</em> y almacenarlo en la
variable <code>expensive_closure</code></span></p>
<p>La definición de <em>closure</em> viene después de <code>=</code> para asignarla a la variable
<code>expensive_closure</code>. Para definir un <em>closure</em>, comenzamos con un par de
verticales pipes (<code>|</code>), dentro de los cuales especificamos los parámetros
para el <em>closure</em>; esta sintaxis fue elegido debido a su similitud con las
definiciones de <em>closure</em> en Smalltalk y Ruby. Este <em>closure</em> tiene un
parámetro llamado <code>num</code>: si tuviéramos más de uno
parámetro, los separaríamos con comas, como <code>| param1, param2 |</code>.</p>
<p>Después de los parámetros, colocamos llaves que sostienen el cuerpo del
<em>closure</em>: estos son opcionales si el cuerpo del <em>closure</em> es una sola
expresión. El fin del <em>closure</em>, después de las llaves, necesita un punto y
coma para completar el <code>let</code> declaración. El valor devuelto desde la última
línea en el cuerpo del <em>closure</em> (<code>num</code>) será el valor devuelto por el
<em>closure</em> cuando se llame, porque esa línea no termina en punto y coma; al
igual que en los cuerpos funcionales.</p>
<p>Tenga en cuenta que esta declaración <code>let</code> significa <code>expensive_closure</code>
contiene el <em>definición</em> de una función anónima, no el <em>valor resultante</em> de
llamar al función anónima. Recuerde que estamos usando un <em>closure</em> porque
queremos definir el código para llamar en un punto, almacenar ese código y
llamarlo en un momento posterior;
el código que queremos llamar ahora está almacenado en <code>expensive_closure</code>.</p>
<p>Con el <em>closure</em> definido, podemos cambiar el código en los bloques <code>if</code> para
llamar al <em>closure</em> para ejecutar el código y obtener el valor resultante.
Llamamos a un <em>closure</em> como hacemos una función: especificamos el nombre de
la variable que contiene el <em>closure</em> definición y seguirlo con paréntesis
que contienen los valores del argumento que desea usar, como se muestra en el
listado 13-6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-6: Llamar al <code>expensive_closure</code> que hemos
definido</span></p>
<p>Ahora el costoso cálculo se realiza en un solo lugar, y solo estamos
ejecutando ese código donde necesitamos los resultados.</p>
<p>Sin embargo, hemos reintroducido uno de los problemas del Listado 13-3:
todavía estamos llamando al <em>closure</em> dos veces en el primer bloque <code>if</code>, que
llamará al código caro dos veces y hará que el usuario espere el doble del
tiempo que lo necesitan a. Podríamos solucionar este problema creando una
variable local para ese bloque <code>if</code> para contener el resultado de llamar al
<em>closure</em>, pero los <em>closures</em> nos proporcionan otra solución. Hablaremos de
esa solución en un momento. Pero primero hablemos sobre por qué no hay
anotaciones de tipo en la definición de <em>closure</em> y las características
involucradas con los <em>closures</em>.</p>
<h3 id="closure-tipo-de-inferencia-y-anotación"><a class="header" href="#closure-tipo-de-inferencia-y-anotación"><em>Closure</em> tipo de inferencia y anotación</a></h3>
<p>Los <em>closures</em> no requieren que anote los tipos de los parámetros o el valor
de retorno como lo hacen las funciones <code>fn</code>. Las anotaciones de tipo son
necesarias en las funciones porque son parte de una interfaz explícita
expuesta a sus usuarios. Definir esta interfaz de manera rígida es importante
para garantizar que todos estén de acuerdo con los tipos de valores que usa y
devuelve una función. Pero los <em>closures</em> no se usan en una interfaz expuesta
como esta: se almacenan en variables y se usan sin nombrarlas y exponerlas a
los usuarios de nuestra biblioteca.</p>
<p>Los <em>closures</em> generalmente son cortos y relevantes solo dentro de un
contexto estrecho en lugar de en cualquier escenario arbitrario. Dentro de
estos contextos limitados, el compilador puede inferir de manera confiable
los tipos de los parámetros y el tipo de retorno, de forma similar a cómo es
capaz de inferir los tipos de la mayoría de las variables.</p>
<p>Hacer que los programadores anoten los tipos en estas pequeñas funciones
anónimas sería molesto y en gran parte redundante con la información que el
compilador ya tiene disponible.</p>
<p>Al igual que con las variables, podemos agregar anotaciones de tipo si
queremos aumentar la claridad y la claridad a costa de ser más detallado de
lo estrictamente necesario. Anotar los tipos para el <em>closure</em> que definimos
en el listado 13-5 se parecería a la definición que se muestra en el listado
13-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-7: Adición de anotaciones de tipo
opcionales del parámetro y tipos de valor de retorno en el <em>closure</em></span></p>
<p>Con las anotaciones de tipo agregadas, la sintaxis de los <em>closures</em> se
parece más a la sintaxis de las funciones. La siguiente es una comparación
vertical de la sintaxis para la definición de una función que agrega 1 a su
parámetro y un <em>closure</em> que tiene el mismo comportamiento. Hemos agregado
algunos espacios para alinear las partes relevantes. Esto ilustra cómo la
sintaxis de <em>closure</em> es similar a la sintaxis de la función, excepto por el
uso de <em>pipes</em> y la cantidad de sintaxis que es opcional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>La primera línea muestra una definición de función, y la segunda línea
muestra una definición de <em>closure</em> completamente anotada. La tercera línea
elimina las anotaciones de tipo de la definición de <em>closure</em>, y la cuarta
línea elimina las llaves, que son opcionales porque el cuerpo de <em>closure</em>
tiene una sola expresión. Estas son todas las definiciones válidas que
producirán el mismo comportamiento cuando se llamen.</p>
<p>Las definiciones de <em>closure</em> tendrán un tipo concreto inferido para cada
uno de sus parámetros y para su valor de retorno. Por ejemplo, el Listado
13-8 muestra la definición de un <em>closure</em> corto que simplemente devuelve el
valor que recibe como parámetro. Este <em>closure</em> no es muy útil excepto para
los propósitos de este ejemplo. Tenga en cuenta que no hemos agregado
ninguna anotación de tipo a la definición: si tratamos de llamar al
<em>closure</em> dos veces, utilizando un <code>String</code> como argumento la primera vez y
un <code>u32</code> la segunda vez, obtendremos un error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">Listado 13-8: Intentar llamar a un cierre cuyos tipos
se infieren con dos tipos diferentes</span></p>
<p>El compilador nos da este error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<p>La primera vez que llamamos <code>example_closure</code> con el valor <code>String</code>, el
compilador deduce el tipo de <code>x</code> y el tipo de retorno del <em>closure</em> para
ser <code>String</code>. Esos tipos luego se bloquean en el <em>closure</em> en
<code>example_closure</code>, y obtenemos un tipo de error si tratamos de usar un tipo
diferente con el mismo <em>closure</em>.</p>
<h3 id="almacenamiento-de-closures-utilizando-parámetros-genéricos-y-los-fn-traits"><a class="header" href="#almacenamiento-de-closures-utilizando-parámetros-genéricos-y-los-fn-traits">Almacenamiento de <em>Closures</em> utilizando parámetros genéricos y los <code>Fn</code> <em>Traits</em></a></h3>
<p>Volvamos a nuestra aplicación de generación de entrenamiento. En el listado
13-6, nuestro código todavía estaba
llamando al costoso <em>closure</em> del cálculo más veces de las necesarias. Uno
opción para resolver este problema es guardar el resultado del <em>closure</em>
costoso en una variable para reutilizar y usar la variable en cada lugar
donde necesitamos el resultado, en lugar de llamar al <em>closure</em> nuevamente.
Sin embargo, este método podría resultar en una gran cantidad de código
repetido</p>
<p>Afortunadamente, otra solución está disponible para nosotros. Podemos crear
una estructura que mantendrá el <em>closure</em> y el valor resultante de llamar al
<em>closure</em>. los <em>struct</em> ejecutará el <em>closure</em> solo si necesitamos el valor
resultante, y almacenará en caché el valor resultante para que el resto de
nuestro código no tenga que ser responsable de guardar y reutilizar el
resultado. Puede conocer este patrón como <em>memoization</em> o <em>lazy evaluation</em>.</p>
<p>Para hacer una estructura que contenga un <em>closure</em>, necesitamos especificar
el tipo de <em>closure</em>, porque una definición de estructura necesita saber los
tipos de cada uno de sus campos. Cada instancia de <em>closure</em> tiene su propio
tipo anónimo único: es decir, incluso si dos <em>closure</em> tienen la misma firma
sus tipos aún se consideran diferente. Para definir estructuras,
enumeraciones o parámetros de funciones que usan <em>closure</em>,
usamos genéricos y <em>trait bounds</em>, como discutimos en el Capítulo 10.</p>
<p>Los <em>trait</em> <code>Fn</code> son proporcionados por la biblioteca estándar. Todos los
<em>closures</em> se implementan en
al menos uno de los <em>trait</em>: <code>Fn</code>,<code>FnMut</code>, o <code>FnOnce</code>. Discutiremos el
diferencia entre estos <em>trait</em> en “Capturando el entorno con <em>closures</em>” ;
en este ejemplo, podemos usar el <em>trait</em> <code>Fn</code>.</p>
<p>Agregamos tipos al <em>trait</em> <code>Fn</code> obligado a representar los tipos de los
parámetros y valores de retorno que los <em>closures</em> deben tener para
coincidir con este <em>trait</em> de <em>trait</em>. En este
caso, nuestro <em>closure</em> tiene un parámetro de tipo <code>u32</code> y devuelve un <code>u32</code>
por lo que
El <em>trait bounds</em> que especificamos es <code>Fn(u32) -&gt; u32</code>.</p>
<p>El listado 13-9 muestra la definición de la estructura <code>Cacher</code> que contiene
un <em>closure</em> y un valor de resultado opcional.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-9: Definición de una estructura <code>Cacher</code>
que contiene un <em>closure</em> en <code>calculation</code> y un resultado opcional en
<code>value</code></span></p>
<p>La estructura <code>Cacher</code> tiene un campo de <code>calculation</code> del tipo genérico <code>T</code>.
Los <em>trait bounds</em> en <code>T</code> especifican que es un <em>closure</em> utilizando el
<em>trait</em> <code>Fn</code>. Cualquier <em>closure</em> que deseemos almacenar en el campo
<code>calculation</code> debe tener un parámetro <code>u32</code> (especificado entre paréntesis
después de <code>Fn</code> y debe devolver un <code>u32</code> (especificado después de <code>-&gt;</code>).</p>
<blockquote>
<p>Nota: Las funciones implementan los tres <em>trait</em> <code>Fn</code> también. Si lo que
queremos hacer no requiere capturar un valor del entorno, podemos usar una
función en lugar de un <em>closure</em> donde necesitamos algo que implemente un
<em>trait</em> <code>Fn</code>.</p>
</blockquote>
<p>El campo <code>value</code> es del tipo <code>Option &lt;u32&gt;</code>. Antes de ejecutar el <em>closure</em>
<code>value</code> será <code>None</code>. Cuando el código que utiliza un <code>Cacher</code> solicita el
<em>resultado</em> del <em>closure</em>, el <code>Cacher</code> ejecutará el <em>closure</em> en ese momento
y almacenará el resultado dentro de una variante <code>Some</code> en el campo <code>value</code>.
Luego, si el código solicita nuevamente el resultado del <em>closure</em>, en lugar
de ejecutar nuevamente el <em>closure</em>, el <code>Cacher</code> devolverá el resultado que
se encuentra en la variante <code>Some</code>.</p>
<p>La lógica alrededor del campo <code>valor</code> que acabamos de describir se define en
el listado 13-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-10: The caching logic of <code>Cacher</code></span></p>
<p>Queremos que <code>Cacher</code> administre los valores de los campos struct en lugar
de permitir que el código de llamada cambie potencialmente los valores en
estos campos directamente, por lo que estos campos son privados.</p>
<p>La función <code>Cacher::new</code> toma un parámetro genérico <code>T</code>, que hemos definido
como que tiene el mismo <em>trait bound</em> que la estructura <code>Cacher</code>. Luego
<code>Cacher::new</code> devuelve una instancia <code>Cacher</code> que contiene el <em>closure</em>
especificado en el campo <code>calculation</code> y un valor <code>None</code> en el campo <code>value</code>
porque aún no hemos ejecutado el <em>closure</em>.</p>
<p>Cuando el código de llamada necesita el resultado de evaluar el <em>closure</em>,
en lugar de llamar al <em>closure</em> directamente, llamará al método <code>value</code>.
Este método verifica si ya tenemos un valor resultante en <code>self.value</code> en
un <code>Some</code>; si lo hacemos, devuelve el valor dentro del <code>Some</code> sin
ejecutar el <em>closure</em> nuevamente.</p>
<p>Si <code>self.value</code> es <code>None</code>, el código llama al <em>closure</em> almacenado en
<code>self.calculation</code>, guarda el resultado en <code>self.value</code> para uso futuro y
también devuelve el valor.</p>
<p>El listado 13-11 muestra cómo podemos usar esta estructura <code>Cacher</code> en la
función <code>generate_workout</code> del Listado 13-6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-11: Using <code>Cacher</code> in the
<code>generate_workout</code> function to abstract away the caching logic</span></p>
<p>En lugar de guardar el <em>closure</em> en una variable directamente, guardamos una
nueva instancia de <code>Cacher</code> que contiene el <em>closure</em>. Luego, en cada lugar
que queremos el resultado, llamamos al método <code>value</code> en la instancia
<code>Cacher</code>. Podemos llamar al método <code>value</code> tantas veces como queramos, o no
llamarlo en absoluto, y el costoso cálculo se ejecutará como máximo una vez.</p>
<p>Intente ejecutar este programa con la función <code>main</code> del Listado 13-2.
Cambie los valores en las variables <code>simulated_user_specified_value</code> y
<code>simulated_random_number</code> para verificar que en todos los casos en los diversos bloques <code>if</code> y <code>else</code>, <code>calculating slowly...</code> aparece solo una
vez y solo cuando es necesario. El <code>Cacher</code> se encarga de la lógica
necesaria para garantizar que no estamos llamando el cálculo caro más de lo
que necesitamos para que <code>generate_workout</code> pueda enfocarse en la lógica del
negocio.</p>
<h3 id="limitaciones-de-la-implementación-cacher"><a class="header" href="#limitaciones-de-la-implementación-cacher">Limitaciones de la implementación <code>Cacher</code></a></h3>
<p>Caching values is a generalmente son un comportamiento útil que podríamos
utilizar en otras partes de nuestro código con <em>closures</em> diferentes. Sin
embargo, hay dos problemas con la implementación actual de <code>Cacher</code> que
dificultaría su reutilización en diferentes contextos.</p>
<p>El primer problema es que una instancia <code>Cacher</code> supone que siempre obtendrá
el mismo valor para el parámetro <code>arg</code> que el método <code>value</code>. Es decir, esta
prueba de <code>Cacher</code> fallará:</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>Esta prueba crea una nueva instancia <code>Cacher</code> con un <em>closure</em> que devuelve
el valor pasado en él. Llamamos al método <code>value</code> en esta instancia <code>Cacher</code>
con un valor <code>arg</code> de 1 y luego un valor <code>arg</code> de 2, y esperamos que la
llamada a <code>value</code> con el valor <code>arg</code> de 2 para regresar 2.</p>
<p>Ejecute esta prueba con la implementación <code>Cacher</code> en el listado 13-9 y el
listado 13-10, y la prueba fallará en <code>assert_eq!</code> con este mensaje:</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<p>El problema es que la primera vez que llamamos a <code>c.value</code> con 1, la
instancia <code>Cacher</code> guarda <code>Some(1)</code> en <code>self.value</code>. A partir de entonces,
no importa lo que pasemos al método de <code>value</code>, siempre devolverá 1.</p>
<p>Intenta modificar <code>Cacher</code> para mantener un mapa hash en lugar de un solo
valor. Las claves del mapa hash serán los valores <code>arg</code> que se pasan, y los
valores del mapa hash serán el resultado de llamar al <em>closure</em> de esa
clave. En lugar de ver si <code>self.value</code> directamente tiene un valor <code>Some</code> o
<code>None</code>, la función <code>value</code> buscará el <code>arg</code> en el mapa hash y devolverá el
valor si está presente. Si no está presente, el <code>Cacher</code> llamará al
<em>closure</em> y guardará el valor resultante en el mapa hash asociado con su
valor <code>arg</code>.</p>
<p>El segundo problema con la implementación actual de <code>Cacher</code> es que solo
acepta <em>closure</em> que toman un parámetro de tipo <code>u32</code> y devuelven un <code>u32</code>.
Es posible que deseemos cache los resultados de los <em>closure</em> que toman un
<em>string slice</em> y devolver valores <code>usize</code>, por ejemplo. Para solucionar este
problema, intente introducir más parámetros genéricos para aumentar la
flexibilidad de la funcionalidad <code>Cacher</code>.</p>
<h3 id="capturando-el-entorno-con-closures"><a class="header" href="#capturando-el-entorno-con-closures">Capturando el entorno con <em>Closures</em></a></h3>
<p>En el ejemplo del generador de ejercicios, solo utilizamos <em>closures</em> como
funciones anónimas en línea. Sin embargo, los <em>closures</em> tienen una
capacidad adicional que las funciones no tienen: pueden capturar su entorno
y acceder a las variables desde el ámbito en el que están definidas.</p>
<p>El listado 13-12 tiene un ejemplo de un <em>closure</em> almacenado en la variable
<code>equal_to_x</code> que usa la variable <code>x</code> del entorno circundante del <em>closure</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Listado 13-12: Ejemplo de <em>closure</em> que se refiere a
una variable en su ámbito de aplicación</span></p>
<p>Aquí, aunque <code>x</code> no es uno de los parámetros de <code>equal_to_x</code>, el <em>closure</em>
<code>equal_to_x</code> puede usar la variable <code>x</code> que está definida en el mismo ámbito
en el que se define <code>equal_to_x</code>.</p>
<p>No podemos hacer lo mismo con las funciones; si intentamos con el siguiente
ejemplo, nuestro código no se compilará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>Recibimos un error:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>¡El compilador incluso nos recuerda que esto solo funciona con <em>closures</em>!</p>
<p>Cuando un <em>closure</em> captura un valor de su entorno, usa memoria para
almacenar los valores para usar en el cuerpo del <em>closure</em>. Este uso de la
memoria es una sobrecarga que no deseamos pagar en los casos más comunes en
los que queremos ejecutar código que no captura su entorno. Debido a que
nunca se permite que las funciones capturen su entorno, la definición y el
uso de funciones nunca incurrirán en esta sobrecarga.</p>
<p>Los <em>closures</em> pueden capturar los valores de su entorno de tres maneras,
que se relacionan directamente con las tres formas en que una función puede
tomar un parámetro: tomar posesión, pedir prestado de forma mutable y pedir
prestado de manera inmutable. Estos están codificados en los tres <em>trait</em>
<code>Fn</code> de la siguiente manera:</p>
<ul>
<li><code>FnOnce</code> consume las variables que captura de su ámbito adjunto, conocido
como <em>environment</em> del <em>closure</em>. Para consumir las variables capturadas,
el <em>closure</em> debe tomar posesión de estas variables y moverlas al <em>closure</em>
cuando se define. La parte <code>Once</code> del nombre representa el hecho de que el
<em>closure</em> no puede tomar posesión de las mismas variables más de una vez,
por lo que solo se puede llamar una vez.</li>
<li><code>FnMut</code> puede cambiar el entorno porque toma prestados valores de forma
mutable.</li>
<li><code>Fn</code> toma prestados valores del entorno inmutables.</li>
</ul>
<p>Cuando crea un <em>closure</em>, Rust infiere qué <em>trait</em> usar en función de cómo
utiliza el <em>closure</em> los valores del entorno. Todos los <em>closures</em>
implementan <code>FnOnce</code> porque todos se pueden llamar al menos una vez. Los
<em>closures</em> que no mueven las variables capturadas también implementan
<code>FnMut</code>, y los <em>closures</em> que no necesitan acceso mutable a las variables
capturadas también implementan <code>Fn</code>. En el listado 13-12, el <em>closure</em>
<code>equal_to_x</code> toma <code>x</code> inmutablemente (entonces <code>equal_to_x</code> tiene el <em>trait</em>
<code>Fn</code>) porque el cuerpo del <em>closure</em> solo necesita leer el valor en <code>x</code>.</p>
<p>Si desea obligar al <em>closure</em> a apropiarse de los valores que utiliza en el
entorno, puede utilizar la palabra clave <code>move</code> antes de la lista de
parámetros. Esta técnica es principalmente útil al pasar un <em>closure</em> a un
nuevo hilo para mover los datos de modo que sea propiedad del nuevo hilo.</p>
<p>Tendremos más ejemplos de <em>closures</em> <code>move</code> en el Capítulo 16 cuando hablamos de concurrencia. Por ahora, aquí está el código del listado 13-12 con la palabra clave <code>move</code> agregada a la definición de clausura y usando
vectores en lugar de enteros, porque los enteros pueden copiarse en lugar de
moverse; tenga en cuenta que este código aún no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>Recibimos el siguiente error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
</code></pre>
<p>El valor 'x' se mueve hacia el <em>closure</em> cuando se define el <em>closure</em>,
porque añadimos la palabra clave <code>mover</code>. El <em>closure</em> tiene la propiedad de
<code>x</code>, y <code>main</code> no puede usar <code>x</code> en la instrucción <code>println!</code>. Al eliminar
<code>println!</code> Se solucionará este ejemplo.</p>
<p>La mayoría de las veces al especificar uno de los <em>trait bounds</em> <code>Fn</code>, puede
comenzar con <code>Fn</code> y el compilador le dirá si necesita <code>FnMut</code> o <code>FnOnce</code>
según lo que ocurra en el cuerpo del <em>closure</em>.</p>
<p>Para ilustrar situaciones en las que los <em>closures</em> pueden capturar su
entorno son útiles como parámetros de función, pasemos a nuestro siguiente
tema: iteradores.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="procesamiento-de-una-serie-de-elementos-con-iteradores"><a class="header" href="#procesamiento-de-una-serie-de-elementos-con-iteradores">Procesamiento de una serie de elementos con iteradores</a></h2>
<p>El patrón de iterador le permite realizar una tarea en una secuencia de
elementos a su vez. Un iterador es responsable de la lógica de iterar sobre
cada elemento y determinar cuándo terminó la secuencia. Cuando usa iteradores
no tiene que volver a implementar esa lógica usted mismo.</p>
<p>En Rust, los iteradores son <em>lazy</em>, lo que significa que no tienen ningún
efecto hasta que llamas a los métodos que consumen el iterador para usarlo.
Por ejemplo, el código en el listado 13-13 crea un iterador sobre los
elementos en el vector <code>v1</code> llamando al método <code>iter</code> definido en <code>Vec &lt;T&gt;</code>.
Este código en sí mismo no hace nada útil.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-13: Creando un iterador</span></p>
<p>Una vez que hemos creado un iterador, podemos usarlo de varias maneras. En el
Listado 3-5 del Capítulo 3, usamos iteradores con bucles <code>for</code> para ejecutar
código en cada elemento, aunque pasamos por alto lo que hacía la llamada a
<code>iter</code> hasta ahora.</p>
<p>El ejemplo del listado 13-14 separa la creación del iterador del uso del
iterador en el bucle <code>for</code>. El iterador se almacena en la variable <code>v1_iter</code>,
y no tiene lugar ninguna iteración en ese momento. Cuando se llama al bucle
<code>for</code> utilizando el iterador en <code>v1_iter</code>, cada elemento en el iterador se
usa en una iteración del bucle, que imprime cada valor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-14: Uso de un iterador en un bucle
<code>for</code></span></p>
<p>En lenguajes que no tienen iteradores proporcionados por sus bibliotecas
estándar, es probable que escriba esta misma funcionalidad iniciando una
variable en el índice 0, usando esa variable para indexar en el vector para
obtener un valor e incrementando el valor de la variable en un bucle hasta
que alcanzó la cantidad total de elementos en el vector.</p>
<p>Los iteradores manejan toda esa lógica por usted, reduciendo el código
repetitivo que potencialmente podría arruinar. Los iteradores te dan más
flexibilidad para usar la misma lógica con muchos tipos diferentes de
secuencias, no solo estructuras de datos en las que puedes indexar, como
vectores. Examinemos cómo los iteradores hacen eso.</p>
<h3 id="el-trait-iterator-y-el-método-next"><a class="header" href="#el-trait-iterator-y-el-método-next">El trait <code>Iterator</code> y el método <code>next</code></a></h3>
<p>Todos los iteradores implementan un <em>trait</em> llamado <code>Iterator</code> que se define en la biblioteca estándar. La definición del <em>trait</em> se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe que esta definición usa alguna sintaxis nueva: <code>type Item</code> y
<code>Self::Item</code>, que definen un <em>tipo asociado</em> con este <em>trait</em>. Hablaremos
sobre los tipos asociados en profundidad en el Capítulo 19. Por ahora, todo
lo que necesita saber es que este código dice que implementar el <em>trait</em>
<code>Iterator</code> requiere que también defina un tipo <code>Item</code>, y este tipo <code>Item</code>
es utilizado en el tipo de devolución del método <code>next</code>. En otras palabras,
el tipo <code>Item</code> será el tipo devuelto por el iterador.</p>
<p>El <em>trait</em> <code>Iterator</code> solo requiere que los implementadores definan un
método: el método <code>next</code>, que devuelve un elemento del iterador a la vez
envuelto en <code>Some</code> y, cuando la iteración termina, devuelve <code>None</code>.</p>
<p>Podemos llamar directamente al método <code>next</code> en los iteradores; El listado
13-15 demuestra qué valores se devuelven de las llamadas repetidas a <code>next</code>
en el iterador creado a partir del vector.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-15: Llamar al método <code>next</code> en un
iterador</span></p>
<p>Tenga en cuenta que necesitamos hacer <code>v1_iter</code> mutable: al llamar al método
<code>next</code> en un iterador cambia el estado interno que el iterador usa para hacer
un seguimiento de dónde está en la secuencia. En otras palabras, este código
<em>consume</em>, o agota, el iterador. Cada llamada a <code>next</code> come un elemento del
iterador. No necesitábamos hacer <code>v1_iter</code> mutable cuando usamos un bucle
<code>for</code> porque el bucle tomó posesión de <code>v1_iter</code> y lo hizo mutable detrás de
las escenas.</p>
<p>También tenga en cuenta que los valores que obtenemos de las llamadas a
<code>next</code> son referencias inmutables a los valores en el vector. El método
<code>iter</code> produce un iterador sobre referencias inmutables. Si queremos crear un
iterador que tome posesión de <code>v1</code> y devuelva valores propios, podemos llamar
a <code>into_iter</code> en lugar de <code>iter</code>. De forma similar, si queremos iterar sobre
referencias mutables, podemos llamar <code>iter_mut</code> en lugar de <code>iter</code>.</p>
<h3 id="métodos-que-consumen-el-iterador"><a class="header" href="#métodos-que-consumen-el-iterador">Métodos que consumen el iterador</a></h3>
<p>El <em>trait</em> <code>Iterator</code> tiene varios métodos diferentes con implementaciones
predeterminadas proporcionadas por la biblioteca estándar; Puede averiguar
acerca de estos métodos buscando en la documentación de la API de la
biblioteca estándar el <em>trait</em> <code>Iterator</code>. Algunos de estos métodos llaman al
método <code>next</code> en su definición, por lo que debes implementar el método <code>next</code>
al implementar el <em>trait</em> <code>Iterator</code>.</p>
<p>Los métodos que llaman <code>next</code> se llaman <em>adaptadores de consumo</em>, porque al
invocarlos se utiliza el iterador. Un ejemplo es el método <code>sum</code>, que toma
posesión del iterador y recorre los ítems repetidamente llamando <code>next</code>,
consumiendo así el iterador. A medida que avanza, agrega cada elemento a un
total acumulado y devuelve el total cuando se completa la iteración. El
listado 13-16 tiene una prueba que ilustra el uso del método <code>sum</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-16: Llamar al método <code>sum</code> para obtener el
total de todos los elementos en el iterador</span></p>
<p>No se nos permite usar <code>v1_iter</code> después de la llamada a <code>sum</code> porque <code>sum</code>
toma posesión del iterador sobre el que lo llamamos.</p>
<h3 id="métodos-que-producen-otros-iteradores"><a class="header" href="#métodos-que-producen-otros-iteradores">Métodos que producen otros iteradores</a></h3>
<p>Otros métodos definidos en el <em>trait</em> <code>Iterator</code>, conocidos como
<em>iterator adaptors</em>, le permiten cambiar los iteradores en diferentes tipos
de iteradores. Puede encadenar múltiples llamadas a adaptadores de iterador
para realizar acciones complejas de forma legible. Pero como todos los
iteradores son flojos, debe llamar a uno de los métodos de adaptador de
consumo para obtener resultados de las llamadas a los adaptadores de iterador.</p>
<p>El listado 13-17 muestra un ejemplo de invocación del método del adaptador de
iterador <code>map</code>, que toma un cierre para llamar a cada elemento y producir un
nuevo iterador. El cierre aquí crea un nuevo iterador en el que cada elemento
del vector se ha incrementado en 1. Sin embargo, este código produce una
advertencia:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-17: Llamar al adaptador iterador <code>map</code> para
crear un nuevo iterador</span></p>
<p>La advertencia que recibimos es esta:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>El código en el listado 13-17 no hace nada; el <em>closure</em> que hemos
especificado nunca se llama. La advertencia nos recuerda por qué: los
adaptadores de iterador son flojos, y necesitamos consumir el iterador aquí.</p>
<p>Para arreglar esto y consumir el iterador, usaremos el método <code>collect</code>, que
usamos en el Capítulo 12 con <code>env::args</code> en el Listado 12-1. Este método
consume el iterador y recopila los valores resultantes en un tipo de datos de
colección.</p>
<p>En el listado 13-18, recogemos los resultados de la iteración sobre el
iterador que se devuelve de la llamada a <code>map</code> en un vector. Este vector
terminará conteniendo cada elemento del vector original incrementado en 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-18: Llamar al método <code>map</code> para crear un
nuevo iterador y luego llamar al método <code>collect</code> para consumir el nuevo
iterador y crear un vector</span></p>
<p>Debido a que <code>map</code> se <em>closure</em>, podemos especificar cualquier operación que
deseemos realizar en cada elemento. Este es un gran ejemplo de cómo los
<em>closures</em> le permiten personalizar un comportamiento mientras reutiliza el
comportamiento de iteración que proporciona el rasgo <code>Iterator</code>.</p>
<h3 id="uso-de-closures-que-capturan-su-entorno"><a class="header" href="#uso-de-closures-que-capturan-su-entorno">Uso de <em>Closures</em> que capturan su entorno</a></h3>
<p>Ahora que hemos introducido iteradores, podemos demostrar un uso común de
<em>closures</em> que capturan su entorno mediante el uso del adaptador de iterador
<code>filter</code>. El método <code>filter</code> en un iterador toma un <em>closure</em> que toma cada
elemento del iterador y devuelve un booleano. Si el <em>closure</em> devuelve
<code>true</code>, el valor se incluirá en el iterador producido por <code>filter</code>. Si
el <em>closure</em> devuelve <code>false</code>, el valor no se incluirá en el iterador
resultante.</p>
<p>En el listado 13-19, usamos <code>filter</code> con un cierre que captura la variable
<code>shoe_size</code> de su entorno para iterar sobre una colección de instancias de
estructura <code>Shoe</code>. Devolverá solo los zapatos que tengan el tamaño
especificado.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-19: Usando el método <code>filter</code> con un
<em>closure</em> que captura <code>shoe_size</code></span></p>
<p>La función <code>shoes_in_my_size</code> toma la propiedad de un vector de <em>shoes</em> y un
tamaño de <em>shoe</em> como parámetros. Devuelve un vector que contiene solo
<em>shoes</em> del tamaño especificado.</p>
<p>En el cuerpo de <code>shoes_in_my_size</code>, llamamos a <code>into_iter</code> para crear un
iterador que toma posesión del vector. Luego llamamos <code>filter</code> para adaptar
ese iterador a un nuevo iterador que solo contiene elementos para los cuales
el <em>closure</em> devuelve <code>true</code>.</p>
<p>El <em>closure</em> captura el parámetro <code>shoe_size</code> del entorno y compara el valor
con el tamaño de cada <em>shoe</em>, manteniendo solo los <em>shoes</em> del tamaño
especificado. Finalmente, al llamar <code>collect</code> se reúnen los valores devueltos
por el iterador adaptado en un vector devuelto por la función.</p>
<p>La prueba muestra que cuando llamamos <code>shoes_in_my_size</code>, recuperamos solo
<em>shoes</em> que tienen el mismo tamaño que el valor que especificamos.</p>
<h3 id="creando-nuestros-propios-iteradores-con-el-trait-iterator"><a class="header" href="#creando-nuestros-propios-iteradores-con-el-trait-iterator">Creando nuestros propios iteradores con el <em>Trait</em> <code>Iterator</code></a></h3>
<p>Hemos demostrado que puede crear un iterador llamando <code>iter</code>, <code>into_iter</code>, o
<code>iter_mut</code> en un vector. Puede crear iteradores a partir de los otros tipos
de colecciones en la biblioteca estándar, como el <em>hash map</em>. También puede
crear iteradores que hagan lo que quiera implementando el <em>trait</em> <code>Iterator</code>
en sus propios tipos. Como se mencionó anteriormente, el único método para el
que debe proporcionar una definición es el método <code>next</code>. Una vez que haya
hecho eso, puede usar todos los demás métodos que tengan implementaciones
predeterminadas proporcionadas por el <em>trait</em> <code>Iterator</code>.</p>
<p>Para demostrar, creemos un iterador que solo contará del 1 al 5. Primero,
crearemos una estructura para contener algunos valores. Luego, haremos de
esta estructura un iterador implementando el <em>trait</em> <code>Iterator</code> y utilizando
los valores en esa implementación.</p>
<p>El listado 13-20 tiene la definición de la estructura <code>Counter</code> y una
función <code>new</code> asociada para crear instancias de <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-20: Definición de la estructura <code>Counter</code> y
una función <code>new</code> que crea instancias de <code>Counter</code> con un valor inicial de 0
para <code>count</code></span></p>
<p>La estructura <code>Counter</code> tiene un campo llamado <code>count</code>. Este campo contiene
un valor <code>u32</code> que mantendrá un registro de dónde estamos en el proceso de
iteración de 1 a 5. El campo <code>count</code> es privado porque queremos que la
implementación de <code>Counter</code> administre su valor. La función <code>new</code> impone el
comportamiento de comenzar siempre nuevas instancias con un valor de 0 en el
campo <code>count</code>.</p>
<p>A continuación, implementaremos el <em>trait</em> <code>Iterator</code> para nuestro tipo
<code>Counter</code> definiendo el cuerpo del método <code>next</code> para especificar qué
queremos que suceda cuando se use este iterador, como se muestra en el
Listado 13-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-21: Implementando el <em>trait</em> <code>Iterator</code> en
nuestra estructura <code>Counter</code></span></p>
<p>Configuramos el tipo <code>Item</code> asociado para nuestro iterador en <code>u32</code>, lo que
significa que el iterador devolverá los valores <code>u32</code>. Nuevamente, no se
preocupe por los tipos asociados todavía, los cubriremos en el Capítulo 19.</p>
<p>Queremos que nuestro iterador agregue 1 al estado actual, por lo que
inicializamos <code>count</code> a 0 para que devuelva 1 primero. Si el valor de <code>count</code>
es menor que 6, <code>next</code> devolverá el valor actual envuelto en <code>Some</code>, pero si
<code>count</code> es 6 o superior, nuestro iterador devolverá <code>None</code>.</p>
<h4 id="usando-nuestro-iterators-método-counter-next"><a class="header" href="#usando-nuestro-iterators-método-counter-next">Usando nuestro <em>Iterator’s</em> método <code>Counter</code> <code>next</code></a></h4>
<p>Una vez que implementamos el <em>trait</em> <code>Iterator</code>, ¡tenemos un iterador! El
listado 13-22 muestra una prueba que demuestra que podemos usar la
funcionalidad de iterador de nuestra estructura <code>Counter</code> llamando
directamente al método <code>next</code>, tal como lo hicimos con el iterador creado a
partir de un vector en el listado 13-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        self.count += 1;
</span><span class="boring">
</span><span class="boring">        if self.count &lt; 6 {
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-22: Prueba de la funcionalidad de la
implementación del método <code>next</code></span></p>
<p>Esta prueba crea una nueva instancia <code>Counter</code> en la variable <code>counter</code> y
luego llama <code>next</code> repetidamente, verificando que hemos implementado el
comportamiento que queremos que tenga este iterador: devolviendo los valores
de 1 a 5.</p>
<h4 id="uso-de-otros-métodos-de-trait-iterador"><a class="header" href="#uso-de-otros-métodos-de-trait-iterador">Uso de otros métodos de <em>trait</em> <code>iterador</code></a></h4>
<p>Implementamos el <em>trait</em> <code>Iterator</code> definiendo el método <code>next</code>, por lo que
ahora podemos usar cualquier implementación predeterminada del método
<code>Iterator</code> según se define en la biblioteca estándar, ya que todos usan la
funcionalidad del método <code>next</code>.</p>
<p>Por ejemplo, si por algún motivo quisiéramos tomar los valores producidos por
una instancia de <code>Counter</code>, emparejarlos con los valores producidos por otra
instancia <code>Counter</code> después de omitir el primer valor, multiplicar cada par,
mantener solo los resultados que son divisible por 3, y agregue todos los
valores resultantes, podríamos hacerlo, como se muestra en la prueba en el
listado 13-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    // Our iterator will produce u32s
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        // increment our count. This is why we started at zero.
</span><span class="boring">        self.count += 1;
</span><span class="boring">
</span><span class="boring">        // check to see if we've finished counting or not.
</span><span class="boring">        if self.count &lt; 6 {
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 13-23: Usando una variedad de métodos del
<em>trait</em><code>Iterator</code> en nuestro iterador <code>Counter</code></span></p>
<p>Tenga en cuenta que <code>zip</code> produce solo cuatro pares; el quinto par teórico
<code>(5, None)</code> nunca se produce porque <code>zip</code> devuelve <code>None</code> cuando cualquiera
de sus iteradores de entrada devuelve <code>None</code>.</p>
<p>Todas estas llamadas a métodos son posibles porque especificamos cómo
funciona el método <code>next</code> y la biblioteca estándar proporciona
implementaciones predeterminadas para otros métodos que llaman <code>next</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mejorando-nuestro-proyecto-de-es"><a class="header" href="#mejorando-nuestro-proyecto-de-es">Mejorando nuestro proyecto de E/S</a></h2>
<p>Con este nuevo conocimiento sobre los iteradores, podemos mejorar el proyecto
de E/S en el Capítulo 12 mediante el uso de iteradores para hacer que los
lugares en el código sean más claros y concisos. Veamos cómo los iteradores
pueden mejorar nuestra implementación de la función <code>Config::new</code> y la
función <code>search</code>.</p>
<h3 id="eliminando-un-clone-usando-un-iterador"><a class="header" href="#eliminando-un-clone-usando-un-iterador">Eliminando un <code>clone</code> usando un iterador</a></h3>
<p>En el listado 12-6, agregamos un código que tomó una porción de valores
<code>String</code> y creó una instancia de la estructura <code>Config</code> indexando en el
sector y clonando los valores, permitiendo que la estructura <code>Config</code> sea
propietaria de esos valores. En el listado 13-24, hemos reproducido la
implementación de la función <code>Config::new</code> tal como estaba en el listado
12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<p><span class="caption">Listado 13-24: Reproducción de la función
<code>Config::new</code> del Listado 12-23</span></p>
<p>En ese momento, dijimos que no nos preocuparamos por las ineficientes
llamadas <code>clon</code> porque las eliminaríamos en el futuro. Bueno, ese momento es
ahora.</p>
<p>Necesitamos <code>clone</code> aquí porque tenemos un corte con elementos <code>String</code> en el
parámetro <code>args</code>, pero la función <code>new</code> no posee <code>args</code>. Para devolver la
propiedad de una instancia de <code>Config</code>, tuvimos que clonar los valores de los
campos <code>query</code> y <code>filename</code> de <code>Config</code> para que la instancia <code>Config</code> pueda
poseer sus valores.</p>
<p>Con nuestro nuevo conocimiento acerca de los iteradores, podemos cambiar la
función <code>new</code> para tomar posesión de un iterador como argumento en lugar de
tomar prestado un segmento. Utilizaremos la funcionalidad del iterador en
lugar del código que verifica la longitud del sector y los índices en
ubicaciones específicas. Esto aclarará lo que hace la función <code>Config::new</code>
porque el iterador tendrá acceso a los valores.</p>
<p>Una vez que <code>Config::new</code> toma posesión del iterador y deja de usar las
operaciones de indexación que toman prestado, podemos mover los valores
<code>String</code> del iterador a <code>Config</code> en lugar de llamar <code>clone</code> y hacer una nueva
asignación.</p>
<h4 id="uso-del-iterador-devuelto-directamente"><a class="header" href="#uso-del-iterador-devuelto-directamente">Uso del iterador devuelto directamente</a></h4>
<p>Abra el archivo <em>src/main.rs</em> del proyecto de E/S, que debería verse
así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p>Cambiaremos el inicio de la función <code>main</code> que teníamos en el Listado 12-24
al código del Listado 13-25. Esto no se compilará hasta que actualicemos
<code>Config::new</code> también.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p><span class="caption">Listado 13-25: Pasando el valor de retorno de
<code>env::args</code> a <code>Config::new</code></span></p>
<p>La función <code>env::args</code> devuelve un iterador. En lugar de recopilar los valores del iterador en un vector y luego pasar un <em>slice</em> a <code>Config::new</code>, ahora estamos pasando la propiedad del iterador devuelto <code>env::args</code> a
<code>Config::new</code> directamente.</p>
<p>A continuación, debemos actualizar la definición de <code>Config::new</code>. En el
archivo <em>src/lib.rs</em> de su proyecto de E/S, cambiemos la firma de
<code>Config::new</code> para que parezca el Listado 13-26. Esto aún no se compilará
porque necesitamos actualizar el cuerpo de la función.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<p><span class="caption">Listado 13-26: Actualizando la firma de <code>Config::new</code>
para esperar un iterador</span></p>
<p>La documentación de la biblioteca estándar para la función <code>env::args</code>
muestra que el tipo de iterador que devuelve es <code>std::env::Args</code>. Hemos
actualizado la firma de la función <code>Config::new</code> para que el parámetro
<code>args</code> tenga el tipo <code>std::env::Args</code> en lugar de <code>&amp;[String]</code>. Como tomamos
posesión de <code>args</code> y vamos a mutar <code>args</code> al iterar sobre él, podemos agregar
la palabra clave <code>mut</code> en la especificación del parámetro <code>args</code> para hacerlo
mutable.</p>
<h4 id="usar-métodos-de-trait-iterator-en-lugar-de-indexar"><a class="header" href="#usar-métodos-de-trait-iterator-en-lugar-de-indexar">Usar métodos de <em>trait</em> <code>Iterator</code> en lugar de indexar</a></h4>
<p>A continuación, corregiremos el cuerpo de <code>Config::new</code>. La documentación de
la biblioteca estándar también menciona que <code>std::env::Args</code> implementa el
<em>trait</em> <code>Iterator</code>, ¡así que sabemos que podemos llamar al método <code>next</code> en
él! El listado 13-27 actualiza el código del listado 12-23 para usar el
método <code>next</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">use std::env;
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre></pre>
<p><span class="caption">Listado 13-27: Cambiar el cuerpo de <code>Config::new</code>
para usar los métodos de iterador</span></p>
<p>Recuerde que el primer valor en el valor de retorno de <code>env::args</code> es el
nombre del programa. Queremos ignorar eso y llegar al siguiente valor, así
que primero llamamos <code>next</code> y no hacemos nada con el valor de retorno.
Segundo, llamamos a <code>next</code> para obtener el valor que queremos poner en el
campo <code>query</code> de <code>Config</code>. Si <code>next</code> devuelve <code>Some</code>, usamos <code>match</code> para
extraer el valor. Si devuelve <code>None</code>, significa que no se dieron suficientes
argumentos y que regresamos temprano con un valor <code>Err</code>. Hacemos lo mismo
para el valor <code>filename</code>.</p>
<h3 id="hacer-código-más-claro-con-adaptadores-de-iterador"><a class="header" href="#hacer-código-más-claro-con-adaptadores-de-iterador">Hacer código más claro con adaptadores de iterador</a></h3>
<p>También podemos aprovechar los iteradores en la función <code>search</code> en nuestro
proyecto de E/S, que se reproduce aquí en el listado 13-28 como en el listado
12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listado 13-28: La implementación de la función
<code>search</code> del Listado 12-19</span></p>
<p>Podemos escribir este código de una manera más concisa utilizando los métodos
del adaptador de iterador. Hacerlo también nos permite evitar tener un vector
intermedio <code>results</code> mutable. El estilo de programación funcional prefiere
minimizar la cantidad de estado mutable para hacer que el código sea más
claro. La eliminación del estado mutable podría permitir una mejora futura
para hacer que la búsqueda se realice en paralelo, ya que no tendríamos que
gestionar el acceso simultáneo al vector <code>results</code>. El listado 13-29 muestra
este cambio:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">Listado 13-29: Usar métodos de adaptador de iterador en
la implementación de la función <code>search</code></span></p>
<p>Recuerde que el propósito de la función <code>search</code> es devolver todas las líneas
en <code>contents</code> que contienen <code>query</code>. Similar al ejemplo <code>filter</code> en el
listado 13-19, este código usa el adaptador <code>filter</code> para mantener solo las
líneas que <code>line.contains(query)</code> devuelve <code>true</code>. Luego recogemos las líneas
correspondientes en otro vector con <code>collect</code>. ¡Mucho más simple! Siéntase
libre de hacer el mismo cambio para usar los métodos del iterador en la
función <code>search_case_insensitive</code> también.</p>
<p>La siguiente pregunta lógica es qué estilo debe elegir en su propio código y
por qué: la implementación original en el listado 13-28 o la versión que usa
iteradores en el listado 13-29. La mayoría de los programadores de Rust
prefieren usar el estilo de iterador. Es un poco más difícil controlarlo al
principio, pero una vez que te haces una idea de los diversos adaptadores de
iterador y lo que hacen, los iteradores pueden ser más fáciles de entender.
En lugar de jugar con los diversos bits de bucle y construir nuevos vectores,
el código se centra en el objetivo de alto nivel del bucle. Esto abstrae
parte del código común para que sea más fácil ver los conceptos que son
exclusivos de este código, como la condición de filtrado que debe pasar cada
elemento en el iterador.</p>
<p>Pero, ¿son las dos implementaciones verdaderamente equivalentes? La
suposición intuitiva podría ser que cuanto más bajo sea el ciclo será más
rápido. Hablemos de rendimiento.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comparación-del-rendimiento-bucles-contra-iteradores"><a class="header" href="#comparación-del-rendimiento-bucles-contra-iteradores">Comparación del rendimiento: bucles contra iteradores</a></h2>
<p>Para determinar si se deben usar bucles o iteradores, se necesita saber qué
versión de nuestras funciones de <code>search</code> es más rápida: la versión con un
bucle <code>for</code> explícito o la versión con iteradores.</p>
<p>Ejecutamos un punto de referencia cargando todo el contenido de
<em>Las aventuras de Sherlock Holmes</em> de Sir Arthur Conan Doyle en un <code>String</code> y
buscando la palabra <em>the</em> en los contenidos. Aquí están los resultados del
<em>benchmark</em> en la versión de <code>search</code> usando el bucle <code>for</code> y la versión que
usa iteradores:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>¡La versión del iterador fue ligeramente más rápida! Aquí no explicaremos el
código de referencia, porque el objetivo no es probar que las dos versiones
son equivalentes, sino obtener una idea general de cómo estas dos
implementaciones se comparan en términos de rendimiento.</p>
<p>Para obtener un punto de referencia más completo, debe verificar el uso de
varios textos de varios tamaños como los <code>contents</code>, diferentes palabras y
palabras de diferentes longitudes como la <code>query</code> y todo tipo de otras
variaciones. El punto es este: los iteradores, a pesar de ser una abstracción
de alto nivel, se compilan aproximadamente en el mismo código como si
hubieras escrito tú mismo el código de nivel inferior. Los iteradores son una
de las <em>abstracciones de costo cero</em> de Rust, con lo cual nos referimos a que
el uso de la abstracción no impone una sobrecarga de tiempo de ejecución
adicional. Esto es análogo a cómo Bjarne Stroustrup, el diseñador original e
implementador de C ++, define <em>zero-overhead</em> en “Foundations of C++” (2012):</p>
<blockquote>
<p>En general, las implementaciones de C ++ obedecen al principio de cero
gastos: lo que no se usa, no se paga. Y más: lo que sí utilizas, no podrías
codificar mejor.</p>
</blockquote>
<p>Como otro ejemplo, el siguiente código se toma de un decodificador de audio.
El algoritmo de decodificación utiliza la operación matemática de predicción
lineal para estimar los valores futuros en función de una función lineal de
las muestras anteriores. Este código usa una cadena de iteradores para hacer
algunas operaciones matemáticas en tres variables en el alcance: una porción
de datos <code>buffer</code>, una matriz de 12 <code>coefficients</code>, y una cantidad por la
cual se cambian los datos en <code>qlp_shift</code>. Hemos declarado las variables
dentro de este ejemplo pero no les hemos dado ningún valor; aunque este
código no tiene mucho significado fuera de su contexto, sigue siendo un
ejemplo conciso y real de cómo Rust traduce las ideas de alto nivel al código
de bajo nivel.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>Para calcular el valor de <code>prediction</code>, este código recorre cada uno de los
12 valores en <code>coefficients</code> y utiliza el método <code>zip</code> para emparejar los
valores de los coeficientes con los 12 valores anteriores en <code>buffer</code>. Luego,
para cada par, multiplicamos los valores juntos, sumamos todos los resultados
y cambiamos los bits en la suma de los bits <code>qlp_shift</code> a la derecha.</p>
<p>Los cálculos en aplicaciones como los decodificadores de audio a menudo
priorizan el rendimiento más altamente. Aquí, estamos creando un iterador,
usando dos adaptadores y luego consumiendo el valor. ¿Qué código de
ensamblado compilará este código Rust? Bueno, a partir de este escrito, se
compila en la misma asamblea que escribirías a mano. No hay ningún bucle
correspondiente a la iteración sobre los valores en <code>coefficients</code>: Rust sabe
que hay 12 iteraciones, por lo que “desenrolla” el bucle. <em>Desenrollar</em>
(<em>Unrolling</em>) es una optimización que elimina la sobrecarga del código de
control de bucle y en su lugar genera código repetitivo para cada iteración
del bucle.</p>
<p>Todos los coeficientes se almacenan en registros, lo que significa que el
acceso a los valores es muy rápido. No hay límites de verificación en el
acceso a la matriz en tiempo de ejecución. Todas estas optimizaciones que
Rust puede aplicar hacen que el código resultante sea extremadamente
eficiente. ¡Ahora que sabes esto, puedes usar iteradores y <em>closures</em> sin
miedo! Hacen que el código parezca tener un nivel más alto pero no imponen
una penalización en el rendimiento en tiempo de ejecución por hacerlo.</p>
<h2 id="resumen-11"><a class="header" href="#resumen-11">Resumen</a></h2>
<p>Los <em>closures</em> e iteradores son funciones de Rust inspiradas en ideas de
lenguaje de programación funcional. Contribuyen a la capacidad de Rust para
expresar claramente ideas de alto nivel en el desempeño de bajo nivel. Las
implementaciones de <em>closures</em> e iteradores son tales que el rendimiento del
tiempo de ejecución no se ve afectado. Esto es parte del objetivo de Rust de
esforzarse por proporcionar <em>abstracciones de costo cero</em>.</p>
<p>Ahora que hemos mejorado la expresividad de nuestro proyecto de E/S, veamos
algunas características más de <code>cargo</code> que nos ayudarán a compartir el
proyecto con el mundo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="más-sobre-cargo-y-cratesio"><a class="header" href="#más-sobre-cargo-y-cratesio">Más sobre Cargo y Crates.io</a></h1>
<p>Hasta ahora solo hemos utilizado las funciones más básicas de Cargo para
construir, ejecutar y probar nuestro código, pero puede hacer mucho más. En
este capítulo, analizaremos algunas de sus otras funciones más avanzadas para
mostrarle cómo hacer lo siguiente:</p>
<ul>
<li>Personaliza tu compilación a través de los perfiles de lanzamiento</li>
<li>Publicar bibliotecas en [crates.io] (https://crates.io) <!-- ignore --></li>
<li>Organiza grandes proyectos con espacios de trabajo</li>
<li>Instalar binarios desde [crates.io] (https://crates.io) <!-- ignore --></li>
<li>Extender carga utilizando comandos personalizados</li>
</ul>
<p>Cargo puede hacer incluso más de lo que cubrimos en este capítulo, así que para una explicación completa de todas sus características, vea
<a href="https://doc.rust-lang.org/cargo/">itsdocumentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="personalizar-compilaciones-con-release-profiles"><a class="header" href="#personalizar-compilaciones-con-release-profiles">Personalizar compilaciones con <em>Release Profiles</em></a></h2>
<p>En Rust, <em>release profiles</em> son perfiles predefinidos y personalizables con
diferentes configuraciones que permiten a un programador tener más control
sobre varias opciones para compilar el código. Cada perfil está configurado
independientemente de los demás.</p>
<p>Cargo tiene dos perfiles principales: el perfil <code>dev</code> que Cargo utiliza cuando ejecuta <code>cargo build</code> y el perfil<code>release</code> que Cargo utiliza cuando
ejecuta <code>cargo build --release</code>. El perfil <code>dev</code> se define con buenos valores
por defecto para el desarrollo, y el perfil <code>release</code> tiene buenos valores
por defecto para las compilaciones de versiones.</p>
<p>Estos nombres de perfil pueden ser conocidos a partir de la salida de sus
compilaciones:</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>El <code>dev</code> y <code>release</code> que se muestran en este resultado de compilación indican
que el compilador usa diferentes perfiles.</p>
<p>Cargo tiene configuraciones predeterminadas para cada uno de los perfiles que
se aplican cuando no hay secciones <code>[profile.*]</code> en el archivo <em>Cargo.toml</em>
del proyecto. Al agregar secciones <code>[profile.*]</code> para cualquier perfil que
desee personalizar, puede anular cualquier subconjunto de la configuración
predeterminada. Por ejemplo, aquí están los valores predeterminados para la
configuración <code>opt-level</code> para los perfiles <code>dev</code> y <code>release</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>La configuración <code>opt-level</code> controla el número de optimizaciones que Rust
aplicará a su código, con un rango de 0 a 3. Aplicar más optimizaciones
extiende el tiempo de compilación, por lo que si está en desarrollo y
compilando su código con frecuencia, desea una compilación más rápida incluso
si el código resultante se ejecuta más despacio. Esa es la razón por la cual
el <code>opt-level</code> predeterminado para <code>dev</code> es <code>0</code>. Cuando esté listo para
lanzar su código, es mejor dedicar más tiempo a la compilación. Solo
compilará en modo de lanzamiento una vez, pero ejecutará el programa
compilado muchas veces, por lo que el modo de lanzamiento intercambia tiempo
de compilación más largo para el código que se ejecuta más rápido. Es por eso
que el <code>opt-level</code> predeterminado para el perfil <code>release</code> es <code>3</code>.</p>
<p>Puede anular cualquier configuración predeterminada agregando un valor
diferente en <em>Cargo.toml</em>. Por ejemplo, si queremos usar el nivel de
optimización 1 en el perfil de desarrollo, podemos agregar estas dos líneas
al archivo <em>Cargo.toml</em> de nuestro proyecto:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Este código anula la configuración predeterminada de <code>0</code>. Ahora cuando
ejecutamos <code>cargo build</code>, Cargo utilizará los valores predeterminados para el
perfil <code>dev</code> más nuestra personalización para <code>opt-level</code>. Debido a que
establecemos <code>opt-level</code> en <code>1</code>, Cargo aplicará más optimizaciones que las
predeterminadas, pero no tantas como en una versión de lanzamiento.</p>
<p>Para ver la lista completa de opciones de configuración y valores
predeterminados para cada perfil, consulte
<a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="publicando-una-crate-en-cratesio"><a class="header" href="#publicando-una-crate-en-cratesio">Publicando una Crate en Crates.io</a></h2>
<p>Hemos utilizado paquetes de <a href="https://crates.io">crates.io</a> <!-- ignore -->
como dependencias de nuestro proyecto, pero también puede compartir su código
con otras personas publicando sus propios paquetes. El registro de <em>crate</em> en
<a href="https://crates.io">crates.io</a> <!-- ignore --> distribuye el código fuente de
sus paquetes, por lo que principalmente aloja código que es de código abierto.</p>
<p>Rust y Cargo tiene características que ayudan a que el paquete publicado sea
más fácil de usar y de encontrar para la gente en primer lugar. Luego
hablaremos de algunas de estas características y luego explicaremos cómo
publicar un paquete.</p>
<h3 id="hacer-comentarios-útiles-sobre-la-documentación"><a class="header" href="#hacer-comentarios-útiles-sobre-la-documentación">Hacer comentarios útiles sobre la documentación</a></h3>
<p>Documentar con precisión sus paquetes ayudará a otros usuarios a saber cómo y
cuándo usarlos, por lo que vale la pena invertir el tiempo para escribir la
documentación. En el Capítulo 3, discutimos cómo comentar el código de Rust
usando dos barras, <code>//</code>. Rust también tiene un tipo particular de comentario
para la documentación, conocido convenientemente como un <em>comentario de
documentación</em>, que generará documentación en HTML. El HTML muestra el
contenido de los comentarios de la documentación para los elementos API
públicos destinados a los programadores interesados en saber cómo usar
<em>su</em> <em>crate</em> en lugar de cómo se implementa el <em>crate</em>.</p>
<p>Los comentarios de documentación utilizan tres barras inclinadas, <code>///</code>, en
lugar de dos y admiten la notación de reducción para formatear el texto.
Coloque los comentarios de documentación justo antes del artículo que están
documentando. El listado 14-1 muestra los comentarios de la documentación
para una función <code>add_one</code> en una <em>crate</em> llamada <code>my_crate</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Listado 14-1: un comentario de documentación para una
función</span></p>
<p>Aquí, damos una descripción de lo que hace la función <code>add_one</code>, comenzamos
una sección con el encabezado <code>Examples</code>, y luego proporcionamos un código
que demuestra cómo usar la función <code>add_one</code>. Podemos generar la
documentación HTML a partir de este comentario de documentación ejecutando
<code>cargo doc</code>. Este comando ejecuta la herramienta <code>rustdoc</code> distribuida con
Rust y coloca la documentación HTML generada en el directorio <em>target/doc</em>.</p>
<p>Para mayor comodidad, ejecutar <code>cargo doc --open</code> creará el HTML para la
documentación de su <em>crate</em> actual (así como la documentación de todas las
dependencias de su <em>crate</em>) y abrirá el resultado en un navegador web.
Navegue a la función <code>add_one</code> y verá cómo se representa el texto en los
comentarios de la documentación, como se muestra en la Figura 14-1:</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figura 14-1: documentación HTML para la función
<code>add_one</code></span></p>
<h4 id="secciones-de-uso-común"><a class="header" href="#secciones-de-uso-común">Secciones de uso común</a></h4>
<p>Usamos el encabezado Markdown <code># Examples</code> en el listado 14-1 para crear una
sección en el HTML con el título “Examples”. Estas son algunas otras
secciones que los autores de <em>crate</em> usan comúnmente en su documentación:</p>
<ul>
<li><strong>Pánico</strong>: los escenarios en los que la función documentada podría entrar
en pánico. Los llamantes de la función que no desean que sus programas
entren en pánico deben asegurarse de que no llamen a la función en estas situaciones.</li>
<li><strong>Errores</strong>: si la función devuelve un <code>Result</code>, describir los tipos de
errores que pueden ocurrir y las condiciones que pueden provocar que se
devuelvan estos errores puede ser útil para las personas que llaman para que
puedan escribir código para manejar los diferentes tipos de errores de
diferentes maneras.</li>
<li><strong>Seguridad</strong>: si la función es <code>unsafe</code> para llamar (hablamos de
inseguridad en el Capítulo 19), debe haber una sección que explique por qué
la función no es segura y que cubra las invariantes que la función espera
que defiendan las personas que llaman.</li>
</ul>
<p>La mayoría de los comentarios de la documentación no necesitan todas estas secciones, pero esta es una buena lista de verificación para recordarle los aspectos de su código que las personas que llaman a su código estarán interesadas en conocer.</p>
<h4 id="comentarios-de-la-documentación-como-pruebas"><a class="header" href="#comentarios-de-la-documentación-como-pruebas">Comentarios de la documentación como pruebas</a></h4>
<p>Agregar bloques de código de ejemplo en los comentarios de su documentación
puede ayudar a demostrar cómo usar su biblioteca, y hacerlo tiene una ventaja
adicional: ejecutar <code>cargo test</code> ejecutará los ejemplos de código en su
documentación como pruebas. Nada es mejor que la documentación con ejemplos.
Pero nada es peor que los ejemplos que no funcionan porque el código ha
cambiado desde que se escribió la documentación. Si ejecutamos <code>cargo test</code>
con la documentación para la función <code>add_one</code> del Listado 14-1, veremos una
sección en los resultados de prueba de esta manera:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Ahora si cambiamos la función o el ejemplo para que <code>assert_eq!</code> En el
ejemplo pánico y ejecutemos <code>cargo test</code> nuevamente, veremos que las pruebas
de doc detectan que el ejemplo y el código no están sincronizados entre sí.</p>
<h4 id="comentar-los-elementos-contenidos"><a class="header" href="#comentar-los-elementos-contenidos">Comentar los elementos contenidos</a></h4>
<p>Otro estilo de comentario de documento, <code>//!</code>, agrega documentación al
elemento que contiene los comentarios en lugar de agregar documentación a los
elementos que siguen a los comentarios. Normalmente utilizamos estos
comentarios de documento dentro del archivo raíz del <em>crate</em> (<em>src/lib.rs</em>
por convención) o dentro de un módulo para documentar el <em>crate</em> o el módulo
como un todo.</p>
<p>Por ejemplo, si queremos agregar documentación que describa el propósito del
<em>crate</em> <code>my_crate</code> que contiene la función <code>add_one</code>, podemos agregar
comentarios de documentación que comiencen con <code>//!</code> Al comienzo de
<em>src/lib.rs</em> archivo, como se muestra en el listado 14-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
</code></pre>
<p><span class="caption">Listado 14-2: Documentación para el <em>crate</em> <code>my_crate</code>
como un todo</span></p>
<p>Observe que no hay ningún código después de la última línea que comienza con
<code>//!</code>. Como comenzamos los comentarios con <code>//!</code> en lugar de <code>///</code>, estamos
documentando el elemento que contiene este comentario en lugar de un elemento
que sigue a este comentario. En este caso, el elemento que contiene este
comentario es el archivo <em>src/lib.rs</em>, que es la raíz del <em>crate</em>. Estos
comentarios describen todo el <em>crate</em>.</p>
<p>Cuando ejecutamos <code>cargo doc --open</code>, estos comentarios se mostrarán en la
página principal de la documentación de <code>my_crate</code> sobre la lista de
elementos públicos en el <em>crate</em>, como se muestra en la Figura 14-2:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figura 14-2: documentación generada para <code>my_crate</code>,
incluido el comentario que describe el <em>crate</em> como un todo</span></p>
<p>Los comentarios de documentación dentro de los items son útiles para
describir <em>crates</em> y módulos especialmente. Úselos para explicar el propósito
general del contenedor para ayudar a los usuarios a entender la organización
del <em>crate</em>.</p>
<h3 id="exportación-de-una-api-pública-convenientemente-con-pub-use"><a class="header" href="#exportación-de-una-api-pública-convenientemente-con-pub-use">Exportación de una API pública convenientemente con <code>pub use</code></a></h3>
<p>En el Capítulo 7, cubrimos cómo organizar nuestro código en módulos usando la
palabra clave <code>mod</code>, cómo hacer que los elementos sean públicos usando la
palabra clave <code>pub</code>, y cómo incluir elementos en un ámbito con la palabra
clave <code>use</code>. Sin embargo, la estructura que tiene sentido para usted mientras
desarrolla un <em>crate</em> puede no ser muy conveniente para sus usuarios. Es
posible que desee organizar sus estructuras en una jerarquía que contenga
varios niveles, pero las personas que quieran usar un tipo que haya definido
en lo más profundo de la jerarquía pueden tener problemas para descubrir que
ese tipo existe. También pueden molestarse al tener que ingresar <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code> en lugar de <code>use</code>
<code>my_crate::UsefulType;</code>.</p>
<p>La estructura de su API pública es una consideración importante cuando se
publica un <em>crate</em>. Las personas que utilizan su <em>crate</em> están menos
familiarizadas con la estructura que usted y pueden tener dificultades para
encontrar las piezas que desean utilizar si su <em>crate</em> tiene una gran
jerarquía de módulos.</p>
<p>La buena noticia es que si la estructura <em>no es</em> conveniente para que otros
la utilicen en otra biblioteca, no tiene que reorganizar su organización
interna: en su lugar, puede volver a exportar elementos para crear una estructura pública diferente a la suya. estructura privada mediante el uso de
<code>pub</code>. La reexportación toma un elemento público en una ubicación y lo hace
público en otra ubicación, como si estuviera definido en la otra ubicación.</p>
<p>Por ejemplo, digamos que creamos una biblioteca llamada <code>art</code> para modelar
conceptos artísticos. Dentro de esta biblioteca hay dos módulos: un módulo
<code>clases</code> que contiene dos enumeraciones llamadas <code>PrimaryColor</code> y
<code>SecondaryColor</code> y un módulo <code>utils</code> que contiene una función llamada <code>mix</code>,
como se muestra en el Listado 14-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listado 14-3: Una biblioteca <code>art</code> con elementos
organizados en módulos <code>types</code> y <code>utils</code></span></p>
<p>La figura 14-3 muestra cómo se vería la página principal de la documentación
para esta caja generada por <code>cargo doc</code>:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figura 14-3: Front page de la documentación para
<code>art</code> que enumera los módulos <code>clases</code> y <code>utils</code></span></p>
<p>Tenga en cuenta que los tipos <code>PrimaryColor</code> y <code>SecondaryColor</code> no aparecen
en la página principal, ni tampoco la función <code>mix</code>. Tenemos que hacer clic
en <code>types</code> y <code>utils</code> para verlos.</p>
<p>Otro <em>crate</em> que depende de esta biblioteca necesitaría declaraciones <code>use</code>
que importen los elementos de <code>art</code>, especificando la estructura del módulo
que está actualmente definida. El listado 14-4 muestra un ejemplo de un
<em>crate</em> que usa los elementos <code>PrimaryColor</code> y <code>mix</code> de <code>art</code> crate:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Listado 14-4: Una <em>crate</em> que utiliza los items del <em>crate</em> <code>art</code> con su estructura interna exportada</span></p>
<p>El autor del código en el listado 14-4, que usa el <em>crate</em> <code>art</code>, tuvo que
descubrir que <code>PrimaryColor</code> está en el módulo <code>kinds</code> y <code>mix</code> está en el
módulo <code>utils</code>. La estructura del módulo del <em>crate</em> de <code>art</code> es más
relevante para los desarrolladores que trabajan en el <em>crate</em> <code>art</code> que para
los desarrolladores que usan el <em>crate</em> <code>art</code>. La estructura interna que
organiza las partes del <em>crate</em> en el módulo <code>kinds</code> y el módulo <code>utils</code> no
contiene ninguna información útil para alguien que intente comprender cómo
usar el <em>crate</em> <code>art</code>. En cambio, la estructura del módulo <code>art</code> crate causa
confusión porque los desarrolladores tienen que averiguar dónde mirar, y la
estructura es inconveniente porque los desarrolladores deben especificar los
nombres de los módulos en las declaraciones <code>use</code>.</p>
<p>Para eliminar la organización interna de la API pública, podemos modificar el
código del <em>crate</em> <code>art</code> en el Listado 14-3 para agregar las declaraciones
<code>pub use</code> para reexportar los elementos en el nivel superior, como se muestra
en el Listado 14-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<p><span class="caption">Listado 14-5: Agregar declaraciones <code>pub use</code> para
reexportar ítems</span></p>
<p>La documentación API que <code>cargo doc</code> genera para este <em>crate</em> ahora mostrará
una lista y vinculará las reexportaciones en la página principal, como se
muestra en la Figura 14-4, haciendo que los tipos <code>PrimaryColor</code> y
<code>SecondaryColor</code> y la función <code>mix</code> sean más fáciles encontrar.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Figura 14-4: La página principal de la documentación
para <code>art</code> que enumera las reexportaciones</span></p>
<p>Los usuarios de <code>art</code> <em>crate</em> pueden ver y usar la estructura interna del
Listado 14-3 como se muestra en el Listado 14-4, o pueden usar la estructura
más conveniente en el Listado 14-5, como se muestra en el Listado 14-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<p><span class="caption">Listado 14-6: Un programa que utiliza los elementos
reexportados del <em>crate</em> <code>art</code></span></p>
<p>En los casos en que hay muchos módulos anidados, la reexportación de los
tipos en el nivel superior con <code>uso de pub</code> puede marcar una diferencia
significativa en la experiencia de las personas que usan el <em>crate</em>.</p>
<p>Crear una estructura de API pública útil es más un arte que una ciencia, y
puede iterar para encontrar la API que funcione mejor para sus usuarios.
Elegir <code>pub use</code> le da flexibilidad en la forma de estructurar su <em>crate</em>
internamente y desacopla esa estructura interna de lo que presenta a sus
usuarios. Observe algunos de los códigos de <em>crates</em> que ha instalado para
ver si su estructura interna difiere de su API pública.</p>
<h3 id="configurando-una-cuenta-cratesio"><a class="header" href="#configurando-una-cuenta-cratesio">Configurando una cuenta Crates.io</a></h3>
<p>Antes de poder publicar cualquier <em>crate</em>, necesita crear una cuenta en
<a href="https://crates.io">crates.io</a><!-- ignore --> y obtener un token de API.
Para hacerlo, visite la página de inicio en
[crates.io](https://crates.io<!-- ignore --> e inicie sesión a través de una
cuenta de GitHub.
(La cuenta de GitHub es actualmente un requisito, pero el sitio podría
respaldar otras formas de crear una cuenta en el futuro). Una vez que haya
iniciado sesión, visite la configuración de su cuenta en
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> y recupere su
clave API. Luego ejecute el comando <code>cargo login</code> con su clave API, de esta
manera:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Este comando informará a Cargo de su token API y lo almacenará localmente en
<em>~/.carg/credentials</em>. Tenga en cuenta que este token es <em>secreto</em>: no lo
comparta con nadie más. Si lo comparte con alguien por cualquier motivo, debe
revocarlo y generar un nuevo token en
<a href="https://crates.io">crates.io</a><!-- ignore -->.</p>
<h3 id="agregar-metadatos-a-un-nuev-crate"><a class="header" href="#agregar-metadatos-a-un-nuev-crate">Agregar metadatos a un nuev <em>crate</em></a></h3>
<p>Ahora que tiene una cuenta, digamos que tiene un <em>crate</em> que desea publicar.
Antes de publicar, deberá agregar algunos metadatos a su <em>crate</em> agregándolos
a la sección <code>[package]</code> del archivo <em>Cargo.toml</em> del <em>crate</em>.</p>
<p>Su <em>crate</em> necesitará un nombre único. Mientras trabajas en un <em>crate</em>
localmente, puedes nombrar un <em>crate</em> como quieras. Sin embargo, los nombres
de los <em>crates</em> en <a href="https://crates.io">crates.io</a><!-- ignore --> se asignan
por orden de llegada. Una vez que se toma el nombre de una <em>crate</em>, nadie más
puede publicar un <em>crate</em> con ese nombre. Busque el nombre que desea utilizar
en el sitio para averiguar si se ha utilizado. Si no lo ha hecho, edite el
nombre en el archivo <em>Cargo.toml</em> debajo de <code>[package]</code> para usar el nombre
para publicar, así:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Incluso si ha elegido un nombre único, cuando ejecuta <code>cargo publish</code> para
publicar el <em>crate</em> en este punto, recibirá una advertencia y luego un error:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
--snip--
error: api errors: missing or empty metadata fields: description, license.
</code></pre>
<p>La razón es que falta información crucial: se requiere una descripción y una
licencia para que las personas sepan qué hace su <em>crate</em> y bajo qué términos
pueden usarla. Para rectificar este error, debe incluir esta información en
el archivo <em>Cargo.toml</em>.</p>
<p>Agregue una descripción que sea solo una oración o dos, porque aparecerá con
su <em>crate</em> en los resultados de búsqueda. Para el campo <code>license</code>, debe
proporcionar un <em>valor de identificador de licencia</em>
(<em>license identifier value</em>). El <a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data
Exchange (SPDX)</a> enumera los identificadores que puede usar para este valor. Por ejemplo, para especificar que ha licenciado su <em>crate</em> usando la
licencia MIT, agregue el identificador <code>MIT</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Si desea utilizar una licencia que no aparece en el SPDX, debe colocar el
texto de esa licencia en un archivo, incluir el archivo en su proyecto y
luego usar <code>license-file</code> para especificar el nombre de esa licencia. archivo
en lugar de usar la clave <code>license</code>.</p>
<p>La orientación sobre qué licencia es apropiada para su proyecto está más allá
del alcance de este libro. Muchas personas en la comunidad de Rust licencian
sus proyectos de la misma manera que Rust usando una licencia dual de
<code>MIT OR Apache-2.0</code>. Esta práctica demuestra que también puede especificar
múltiples identificadores de licencia separados por <code>OR</code> para tener múltiples
licencias para su proyecto.</p>
<p>Con un nombre único, la versión, el autor detalla que <code>cargo new</code> agregó
cuando creó el <em>crate</em>, su descripción y una licencia agregada, el archivo
<em>Cargo.toml</em> para un proyecto que está listo para publicar podría verse así:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describe otros
metadatos que puede especificar para asegurarse de que otros puedan descubrir
y usar su <em>crate</em> más fácilmente.</p>
<h3 id="publicando-en-cratesio"><a class="header" href="#publicando-en-cratesio">Publicando en Crates.io</a></h3>
<p>Ahora que ha creado una cuenta, ha guardado su token de API, ha elegido un
nombre para su <em>crate</em> y ha especificado los metadatos necesarios, ¡está
listo para publicar! al publicar un <em>crate</em>, se carga una versión específica
a <a href="https://crates.io">crates.io</a> <!-- ignore --> para que otros la usen.</p>
<p>Tenga cuidado al publicar un <em>crate</em> porque una publicación es <em>permanente</em>.
La versión nunca se puede sobrescribir, y el código no se puede eliminar. Uno
de los principales objetivos de <a href="https://crates.io">crates.io</a><!-- ignore -->
es actuar como un archivo permanente de código para que las construcciones de
todos los proyectos que dependen de los <em>crates</em> de
<a href="https://crates.io">crates.io </a> <!-- ignore --> continuará funcionando.
Permitir eliminaciones de versiones haría imposible cumplir ese objetivo. Sin
embargo, no hay límite para la cantidad de versiones de <em>crates</em> que puede
publicar.</p>
<p>Ejecute el comando <code>cargo publish</code> nuevamente. Debería tener éxito ahora:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>¡Felicitaciones! Ahora has compartido tu código con la comunidad Rust, y
cualquiera puede agregar fácilmente tu <em>crate</em> como una dependencia de su
proyecto.</p>
<h3 id="publicar-una-nueva-versión-de-un-crate-existente"><a class="header" href="#publicar-una-nueva-versión-de-un-crate-existente">Publicar una nueva versión de un <em>crate</em> existente</a></h3>
<p>Cuando haya realizado cambios en su <em>crate</em> y esté listo para lanzar una
nueva versión, usted cambiará el valor de <code>version</code> especificado en su
archivo <em>Cargo.toml</em> y volverá a publicar. Utilice las
<a href="http://semver.org/">Reglas de control de versiones semánticas</a> para decidir cuál es el
número de la próxima versión apropiada según los tipos de cambios que haya
realizado. Luego ejecute <code>cargo publish</code> para cargar la nueva versión.</p>
<h3 id="eliminando-versiones-de-cratesio-con-cargo-yank"><a class="header" href="#eliminando-versiones-de-cratesio-con-cargo-yank">Eliminando versiones de Crates.io con <code>cargo yank</code></a></h3>
<p>Aunque no puede eliminar versiones anteriores de un <em>crate</em>, puede evitar que
futuros proyectos las agreguen como una nueva dependencia. Esto es útil
cuando una versión de <em>crate</em> está rota por una razón u otra. En tales
situaciones, Cargo admite <em>yanking</em> una versión del <em>crate</em>.</p>
<p>El uso de una versión de Yankea impide que los proyectos nuevos comiencen a
depender de esa versión y permite que todos los proyectos existentes que
dependen de ella continúen descargándose y dependan de esa versión.
Esencialmente, un <em>yank</em> significa que todos los proyectos con un
<em>Cargo.lock</em> no se romperán, y cualquier futuro <em>Cargo.lock</em> generado no
usará la versión <em>yanked</em>.</p>
<p>Para <em>yank</em> una versión de un <em>crate</em>, ejecute <code>cargo yank</code> y especifique qué
versión para <em>yank</em>:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>Al agregar <code>--undo</code> al comando, también puede deshacer un <em>yank</em> y permitir
que los proyectos comiencen dependiendo de una versión nuevamente:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>Un <em>yank</em> <em>no</em> borra ningún código. Por ejemplo, la función <em>yank</em> no está
diseñada para borrar secretos cargados accidentalmente. Si eso sucede, debe
reajustar esos secretos de inmediato.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="espacios-de-trabajo-de-cargo"><a class="header" href="#espacios-de-trabajo-de-cargo">Espacios de trabajo de Cargo</a></h2>
<p>En el Capítulo 12, creamos un paquete que incluía un <em>binary crate</em> y una
<em>library crate</em>. A medida que se desarrolle su proyecto, es posible que
descubra que la <em>library crate</em> sigue creciendo y desea dividir su paquete
aún más en varias <em>library crate</em>. En esta situación, Cargo ofrece una
función llamada <em>workspaces</em> que puede ayudar a administrar múltiples
paquetes relacionados que se desarrollan en tándem.</p>
<h3 id="creando-un-espacio-de-trabajo"><a class="header" href="#creando-un-espacio-de-trabajo">Creando un espacio de trabajo</a></h3>
<p>Un <em>workspace</em> es un conjunto de paquetes que comparten el mismo
<em>Cargo.lock</em> y el directorio de salida. Hagamos un proyecto usando un espacio
de trabajo: usaremos un código trivial para poder concentrarnos en la
estructura del espacio de trabajo. Hay varias formas de estructurar un
espacio de trabajo; vamos a mostrar una forma común. Tendremos un espacio de
trabajo que contiene un binario y dos bibliotecas. El binario, que
proporcionará la funcionalidad principal, dependerá de las dos bibliotecas.
Una biblioteca proporcionará una función <code>add_one</code>, y una segunda biblioteca
una función <code>add_two</code>. Estas tres cajas formarán parte del mismo espacio de
trabajo. Comenzaremos por crear un nuevo directorio para el área de trabajo:</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<p>A continuación, en el directorio <em>add</em>, creamos el archivo <em>Cargo.toml</em> que
configurará todo el espacio de trabajo. Este archivo no tendrá una sección
<code>[package]</code> ni los metadatos que hemos visto en otros archivos
<em>Cargo.toml</em>. En cambio, comenzará con una sección <code>[workspace]</code> que nos
permitirá agregar miembros al espacio de trabajo al especificar la ruta a
nuestro <em>binary crate</em>; en este caso, esa ruta es <em>adder</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>A continuación, crearemos el <em>binary crate</em> <code>adder</code> ejecutando <code>cargo new</code>
dentro del directorio *add *:</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
</code></pre>
<p>En este punto, podemos construir el espacio de trabajo ejecutando
<code>cargo build</code>. Los archivos en su directorio *add  deberían verse así:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>El espacio de trabajo tiene un directorio <em>target</em> en el nivel superior para
que se coloquen los artefactos compilados; el <em>crate</em> <code>adder</code> no tiene su
propio directorio <em>target</em>. Incluso si tuviéramos que ejecutar
<code>cargo build</code> desde el directorio <em>adder</em>, los artefactos compilados
terminarían en <em>add/target</em> en lugar de <em>add/adder/target</em>. Cargo estructura
el directorio <em>target</em> en un espacio de trabajo como este porque los <em>crates</em>
en un espacio de trabajo dependen uno del otro. Si cada <em>crate</em> tuviera su
propio directorio <em>target</em>, cada <em>crate</em> tendría que recompilar cada una de
los otros <em>crates</em> en el espacio de trabajo para tener los artefactos en su
propio directorio <em>target</em>. Al compartir un directorio <em>target</em>, los <em>crates</em>
pueden evitar reconstrucciones innecesarias.</p>
<h3 id="crear-el-segundo-crate-en-el-espacio-de-trabajo"><a class="header" href="#crear-el-segundo-crate-en-el-espacio-de-trabajo">Crear el segundo <em>crate</em> en el espacio de trabajo</a></h3>
<p>Luego, creemos otro <em>crate</em> miembros en el espacio de trabajo y llámela
<code>add-one</code>. Cambie el nivel superior <em>Cargo.toml</em> para especificar la ruta
<em>add-one</em> en la lista <code>members</code>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>Luego genere un nuevo <em>library crate</em> llamada <code>add-one</code>:</p>
<pre><code class="language-text">$ cargo new add-one
     Created library `add-one` project
</code></pre>
<p>Su directorio <em>add</em> ahora debería tener estos directorios y archivos:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>En el archivo <em>add-one/src/lib.rs</em>, agreguemos una función <code>add_one</code>:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora que tenemos un <em>library crate</em> en el espacio de trabajo, podemos hacer
que la <em>binary crate</em> <code>adder</code> dependa de la <em>library crate</em> <code>add-one</code>.
Primero, necesitaremos agregar una dependencia de ruta en <code>add-one</code> a
<em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>Cargo no asume que los <em>crates</em> en un espacio de trabajo dependerán entre sí,
por lo que debemos ser explícitos sobre las relaciones de dependencia entre
los <em>crates</em>.</p>
<p>Luego, usemos la función <code>add_one</code> del <em>crate</em> <code>add-one</code> en el <em>crate</em>
<code>adder</code>. Abra el archivo <em>adder/src/main.rs</em> y agregue una línea
<code>extern crate</code> en la parte superior para poner el nuevo <em>library crate</em>
<code>add-one</code> en el alcance. Luego cambie la función <code>main</code> para llamar a la
función <code>add_one</code>, como en el Listado 14-7:</p>
<p><span class="filename">Filename: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p><span class="caption">Listado 14-7: Usando el <em>library crate</em> <code>add-one</code> del <em>crate</em> <code>adder</code></span></p>
<p>Construyamos el espacio de trabajo ejecutando <code>cargo build</code> en el directorio
<em>add</em> de nivel superior.</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p>Para ejecutar el <em>binary crate</em> desde el directorio <em>add</em>, necesitamos
especificar qué paquete en el área de trabajo queremos usar utilizando el
argumento <code>-p</code> y el nombre del paquete con <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>Esto ejecuta el código en <em>adder/src/main.rs</em>, que depende del <em>crate</em>
<code>add-one</code>.</p>
<h4 id="dependiendo-de-un-crate-externo-en-un-espacio-de-trabajo"><a class="header" href="#dependiendo-de-un-crate-externo-en-un-espacio-de-trabajo">Dependiendo de un <em>crate</em> externo en un espacio de trabajo</a></h4>
<p>Observe que el espacio de trabajo tiene solo un archivo <em>Cargo.lock</em> en el
nivel superior del espacio de trabajo en lugar de tener un <em>Cargo.lock</em> en el
directorio de cada <em>crate</em>. Esto asegura que todos los <em>crate</em> están usando
la misma versión de todas las dependencias. Si agregamos el <em>crate</em> <code>rand</code> a
los archivos <em>adder/Cargo.toml</em> y <em>add-one/Cargo.toml</em>, Cargo resolverá los
dos en una versión de <code>rand</code> y registrará en la una <em>Cargo.lock</em>. Hacer que
todos los <em>crate</em> en el espacio de trabajo usen las mismas dependencias
significa que los <em>crate</em> en el espacio de trabajo siempre serán compatibles
entre sí. Agreguemos el <em>crate</em> <code>rand</code> a la sección <code>[dependencies]</code> en el
archivo <em>add-one/Cargo.toml</em> para poder usar el <em>crate</em> <code>rand</code> en el <code>add-one</code>
<em>crate</em>:</p>
<p><span class="filename">Filename: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>Ahora podemos agregar <code>extern crate rand;</code> al archivo <em>add-one/src/lib.rs</em>,
y construir todo el espacio de trabajo ejecutando <code>cargo build</code> en el
directorio <em>add</em> traerá y compilará el <em>crate</em> <code>rand</code>:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p>El <em>Cargo.lock</em> de nivel superior ahora contiene información sobre la
dependencia de <code>add-one</code> en <code>rand</code>. Sin embargo, aunque <code>rand</code> se usa en
algún lugar del área de trabajo, no podemos usarlo en otros <em>crates</em> en el
área de trabajo a menos que agreguemos <code>rand</code> a sus archivos <em>Cargo.toml</em>
también. Por ejemplo, si agregamos <code>extern crate rand;</code> al archivo
<em>adder/src/main.rs</em> para el <em>crate</em> <code>adder</code>, obtendremos un error:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --&gt; adder/src/main.rs:1:1
  |
1 | extern crate rand;
</code></pre>
<p>Para arreglar esto, edite el archivo <em>Cargo.toml</em> para el <em>crate</em> <code>adder</code>
e indique que <code>rand</code> también es una dependencia para ese <em>crate</em>. Construir
el <em>crate</em> <code>adder</code> agregará <code>rand</code> a la lista de dependencias para <code>adder</code> en
<em>Cargo.lock</em>, pero no se descargarán copias adicionales de <code>rand</code>. Cargo ha
asegurado que cada <em>crate</em> en el espacio de trabajo que usa el <em>crate</em> <code>rand</code>
usará la misma versión. Usar la misma versión de <code>rand</code> en el espacio de
trabajo ahorra espacio porque no tendremos copias múltiples y asegura que los
<em>crates</em> en el espacio de trabajo serán compatibles entre sí.</p>
<h4 id="agregar-una-prueba-a-un-espacio-de-trabajo"><a class="header" href="#agregar-una-prueba-a-un-espacio-de-trabajo">Agregar una prueba a un espacio de trabajo</a></h4>
<p>Para otra mejora, agreguemos una prueba de la función <code>add_one::add_one</code>
dentro del <em>crate</em> <code>add_one</code>:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora ejecute <code>cargo test</code> en el directorio <em>add</em> de nivel superior:</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>La primera sección del resultado muestra que pasó la prueba <code>it_works</code> en el
<em>crate</em> <code>add-one</code>. La siguiente sección muestra que las pruebas de cero se
encontraron en el <em>crate</em> de <code>adder</code>, y luego la última sección muestra que
no se encontraron pruebas de documentación en el <em>crate</em> <code>add-one</code>. Al
ejecutar <code>cargo test</code> en un espacio de trabajo estructurado de esta manera,
se ejecutarán las pruebas de todos los <em>crates</em> en el área de trabajo.</p>
<p>También podemos ejecutar pruebas para un <em>crate</em> en particular en un espacio
de trabajo desde el directorio de nivel superior utilizando la bandera <code>-p</code> y
especificando el nombre del <em>crate</em> que queremos probar:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Este resultado muestra que <code>cargo test</code> solo ejecutó las pruebas para el
<em>crate</em> <code>add-one</code> y no ejecutó las pruebas de <em>crate</em> <code>adder</code>.</p>
<p>Si publica los <em>crates</em> en el espacio de trabajo en <em>https://crates.io/</em>,
cada <em>crate</em> en el espacio de trabajo deberá publicarse por separado. El
comando <code>cargo publish</code> no tiene un indicador <code>--all</code> ni un indicador <code>-p</code>, por lo que debe cambiar al directorio de cada <em>crate</em> y ejecutar
<code>cargo publish</code> en cada <em>crate</em> en el espacio de trabajo para publicar los
<em>crates</em>.</p>
<p>Para práctica adicional, agregue un <em>crate</em> <code>add-two</code> a este espacio de
trabajo de forma similar a el <em>crate</em> <code>add-one</code></p>
<p>A medida que su proyecto crezca, considere utilizar un espacio de trabajo: es
más fácil comprender componentes individuales más pequeños que una gran
cantidad de código. Además, mantener los <em>crates</em> en un espacio de trabajo
puede facilitar la coordinación entre ellas si a menudo se cambian al mismo
tiempo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalación-de-binarios-de-cratesio-con-cargo-install"><a class="header" href="#instalación-de-binarios-de-cratesio-con-cargo-install">Instalación de binarios de Crates.io con <code>cargo install</code></a></h2>
<p>El comando <code>cargo install</code> le permite instalar y usar <em>binary crates</em>
localmente. Esto no pretende reemplazar los paquetes del sistema; está
destinado a ser una forma conveniente para que los desarrolladores de Rust
instalen herramientas que otros compartieron en
<a href="https://crates.io">crates.io</a> <!-- ignore -->. Tenga en cuenta que solo
puede instalar paquetes que tienen <em>binary target</em>. Un <em>binary target</em>
es el programa ejecutable que se crea si el <em>crate</em> tiene un archivo
<em>src/main.rs</em> u otro archivo especificado como binario, a diferencia de un
<em>library target</em> que no se puede ejecutar por sí mismo, pero es adecuado para
incluir dentro de otros programas. Por lo general, los <em>crates</em> tienen
información en el archivo <em>README</em> sobre si un <em>crate</em> es una <em>library</em>, si
tiene un <em>binary target</em> o ambos.</p>
<p>Todos los binarios instalados con <code>cargo install</code> se almacenan en la carpeta
<em>bin</em> de la raíz de la instalación. Si instaló Rust usando <code>rustup</code> y no
tiene ninguna configuración personalizada, este directorio será
<em>$HOME/.cargo/bin</em>. Asegúrese de que el directorio esté en su <code>$PATH</code> para
poder ejecutar programas que haya instalado con <code>cargo install</code>.</p>
<p>Por ejemplo, en el Capítulo 12 mencionamos que hay una implementación de Rust
de la herramienta <code>grep</code> llamada <code>ripgrep</code> para buscar archivos. Si queremos
instalar <code>ripgrep</code>, podemos ejecutar lo siguiente:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>La última línea del resultado muestra la ubicación y el nombre del binario
instalado, que en el caso de <code>ripgrep</code> es <code>rg</code>. Siempre que el directorio de
instalación esté en su <code>$PATH</code>, como se mencionó anteriormente, puede
ejecutar <code>rg --help</code> y ¡comenzar a utilizar una herramienta más rápida y
segura para buscar archivos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extender-cargo-con-comandos-personalizados"><a class="header" href="#extender-cargo-con-comandos-personalizados">Extender <em>Cargo</em> con comandos personalizados</a></h2>
<p>Cargo está diseñado para que pueda ampliarlo con nuevos subcomandos sin tener
que modificar Cargo. Si un binario en su <code>$PATH</code> se llama <code>cargo-something</code>,
puede ejecutarlo como si fuera un subcomando Cargo ejecutando
<code>cargo something</code>. Los comandos personalizados como este también se enumeran
cuando ejecuta <code>cargo-list</code>. ¡Poder usar <code>cargo install</code> para instalar
extensiones y luego ejecutarlas al igual que las herramientas de Cargo
incorporadas es un beneficio súper conveniente del diseño de Cargo.</p>
<h2 id="resumen-12"><a class="header" href="#resumen-12">Resumen</a></h2>
<p>Compartir código con Cargo y <a href="https://crates.io">crates.io</a> <!-- ignore -->
es parte de lo que hace que el ecosistema de Rust sea útil para muchas tareas
diferentes. La biblioteca estándar de Rust es pequeña y estable, pero los
<em>crates</em> son fáciles de compartir, usar y mejorar en una línea de tiempo
diferente a la del lenguaje. No tenga miedo de compartir el código que le sea
útil en <a href="https://crates.io">crates.io</a> <!-- ignore -->; ¡es probable que
también sea útil para otra persona!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers-punteros-inteligentes"><a class="header" href="#smart-pointers-punteros-inteligentes"><em>Smart Pointers</em> (<em>Punteros inteligentes</em>)</a></h1>
<p>Un <em>puntero</em> es un concepto general para una variable que contiene una
dirección en la memoria. Esta dirección se refiere a, o “apunta a,” algunos
otros datos. El tipo de puntero más común en Rust es una referencia, que
aprendió en el Capítulo 4. Las referencias se indican con el símbolo <code>&amp;</code> y
toman prestado el valor al que apuntan. No tienen ninguna capacidad especial
que no sea referirse a los datos. Además, no tienen sobrecarga y son el tipo
de puntero que usamos con más frecuencia.</p>
<p>Los <em>punteros inteligentes</em> (<em>Smart Pointers</em>), por otro lado, son estructuras de
datos que no
solo actúan como un puntero sino que también tienen metadatos y capacidades
adicionales. El concepto de <em>punteros inteligentes</em> no es exclusivo de Rust:
los punteros inteligentes se originaron en C ++ y existen en otros lenguajes
también. En Rust, los diferentes <em>punteros inteligentes</em> definidos en la
biblioteca estándar proporcionan una funcionalidad más allá de la
proporcionada por las referencias. Un ejemplo que exploraremos en este
capítulo es el <em>conteo de referencias</em> un tipo de puntero inteligente. Este
puntero le permite tener múltiples propietarios de datos al hacer un
seguimiento del número de propietarios y, cuando no quedan propietarios,
limpiar los datos.</p>
<p>En Rust, que usa el concepto de propiedad y endeudamiento, una diferencia
adicional entre referencias y punteros inteligentes es que las referencias
son punteros que solo toman datos prestados; en cambio, en muchos casos, los
punteros inteligentes <em>poseen</em> los datos que señalan.</p>
<p>Ya hemos encontrado algunos punteros inteligentes en este libro, como
<code>String</code> y <code>Vec &lt;T&gt;</code> en el Capítulo 8, aunque no los llamamos punteros
inteligentes en ese momento. Ambos tipos cuentan como punteros inteligentes
porque poseen algo de memoria y te permiten manipularla. También tienen
metadatos (como su capacidad) y capacidades o garantías adicionales (como con
<code>String</code> que garantiza que sus datos siempre serán válidos para UTF-8).</p>
<p>Los punteros inteligentes generalmente se implementan usando estructuras. La
característica que distingue a un puntero inteligente de una estructura
ordinaria es que los punteros inteligentes implementan los <em>trait</em> <code>Deref</code>
y <code>Drop</code>. El trait <code>Deref</code> permite que una instancia de la estructura del
puntero inteligente se comporte como una referencia para que pueda escribir
código que funcione con referencias o punteros inteligentes. El <em>trait</em>
<code>Drop</code> le permite personalizar el código que se ejecuta cuando una instancia
del puntero inteligente sale del alcance. En este capítulo, discutiremos
ambos <em>trait</em> y demostraremos por qué son importantes para los indicadores
inteligentes.</p>
<p>Dado que el patrón de puntero inteligente es un patrón de diseño general que
se utiliza con frecuencia en Rust, este capítulo no cubrirá todos los
punteros inteligentes existentes. Muchas bibliotecas tienen sus propios
indicadores inteligentes, e incluso puede escribir el suyo. Cubriremos los
punteros inteligentes más comunes en la biblioteca estándar:</p>
<ul>
<li><code>Box &lt;T&gt;</code> para asignar valores en el montículo</li>
<li><code>Rc &lt;T&gt;</code>, un tipo de conteo de referencia que permite la propiedad múltiple</li>
<li><code>Ref &lt;T&gt;</code> y <code>RefMut &lt;T&gt;</code>, a los que se accede a través de <code>RefCell &lt;T&gt;</code>, un
tipo que impone las reglas de préstamo en tiempo de ejecución en lugar de
tiempo de compilación</li>
</ul>
<p>Además, cubriremos el patrón de <em>mutabilidad interior</em>
(<em>interior mutability</em>) donde un tipo
inmutable expone una API para mutar un valor interior. También discutiremos
<em>ciclos de referencia</em> (<em>reference cycles</em>): cómo pueden perder memoria y cómo prevenirlos.</p>
<p>¡Vamos a sumergirnos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usando-box-t-para-apuntar-a-los-datos-en-el-heap"><a class="header" href="#usando-box-t-para-apuntar-a-los-datos-en-el-heap">Usando <code>Box &lt;T&gt;</code> para apuntar a los datos en el Heap</a></h2>
<p>El puntero inteligente más sencillo es un <em>box</em>, cuyo tipo está escrito
<code>Box &lt;T&gt;</code>. Los <em>Boxes</em> le permiten almacenar datos en el montículo en lugar
de en la pila. Lo que queda en la pila es el puntero a los datos del
montículo. Consulte el Capítulo 4 para revisar la diferencia entre la pila y
el montículo.</p>
<p>Los <em>Boxes</em>  no tienen sobrecarga de rendimiento, aparte de almacenar sus
datos en el montículo en lugar de en la pila. Pero tampoco tienen muchas
capacidades adicionales. Los usarás más a menudo en estas situaciones:</p>
<ul>
<li>Cuando tiene un tipo cuyo tamaño no se puede conocer en el momento de la
compilación y desea usar un valor de ese tipo en un contexto que requiere un
tamaño exacto</li>
<li>Cuando tiene una gran cantidad de datos y desea transferir la propiedad,
pero asegúrese de que los datos no se copiarán cuando lo haga</li>
<li>Cuando desea poseer un valor y solo le importa que sea un tipo que
implemente un rasgo particular en lugar de ser de un tipo específico</li>
</ul>
<p>Demostraremos la primera situación en la sección “Habilitación de tipos
recursivos con <em>Boxes</em>”. En el segundo caso, transferir la propiedad de una
gran cantidad de datos puede llevar mucho tiempo porque los datos se copian
en la pila. Para mejorar el rendimiento en esta situación, podemos almacenar
la gran cantidad de datos en el montículo en una <em>box</em>. Luego, solo se copia
la pequeña cantidad de datos del puntero en la pila, mientras que los datos a
los que hace referencia permanecen en un lugar en el montículo. El tercer
caso se conoce como <em>trait object</em>, y el capítulo 17 dedica una sección
completa, “Usar <em>trait object</em> que permiten valores de diferentes tipos”,
solo para ese tema. ¡Entonces, lo que aprendes aquí lo aplicará nuevamente en
el Capítulo 17!.</p>
<h3 id="usando-un-boxt-para-almacenar-datos-en-el-montículo"><a class="header" href="#usando-un-boxt-para-almacenar-datos-en-el-montículo">Usando un <code>Box&lt;T&gt;</code> para almacenar datos en el montículo</a></h3>
<p>Antes de analizar este caso de uso para <code>Box &lt;T&gt;</code>, cubriremos la sintaxis y
cómo interactuar con los valores almacenados dentro de <code>Box &lt;T&gt;</code>.</p>
<p>El listado 15-1 muestra cómo usar un <em>box</em> para almacenar un valor <code>i32</code> en el montículo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listado 15-1: Almacenamiento de un valor <code>i32</code> en el
montículo usando un <em>box</em></span></p>
<p>Definimos la variable <code>b</code> para que tenga el valor de un <code>Box</code> que apunta al
valor <code>5</code>, que se asigna en el montículo. Este programa imprimirá <code>b = 5</code>; en
este caso, podemos acceder a los datos en el <em>box</em> de forma similar a como lo
haríamos si estos datos estuvieran en la pila. Al igual que cualquier valor
propio, cuando un <em>box</em> sale del alcance, como <code>b</code> lo hace al final de <code>main</code>
será desasignado. La desasignación ocurre para el <em>box</em> (almacenada en la
pila) y los datos a los que apunta (almacenados en el montículo).</p>
<p>Poner un solo valor en el montículo no es muy útil, por lo que no utilizará
los <em>boxes</em> por sí mismo de esta manera muy a menudo. Tener valores como un
solo <code>i32</code> en la pila, donde están almacenados por defecto, es más apropiado
en la mayoría de las situaciones. Veamos un caso en el que los <em>boxes</em> nos
permiten definir tipos que no se nos permitirían si no tuviéramos <em>boxes</em>.</p>
<h3 id="habilitación-de-tipos-recursivos-con-boxes"><a class="header" href="#habilitación-de-tipos-recursivos-con-boxes">Habilitación de tipos recursivos con <em>Boxes</em></a></h3>
<p>En tiempo de compilación, Rust necesita saber cuánto espacio ocupa un tipo.
Un tipo cuyo tamaño no se puede conocer en el momento de la compilación es un
<em>tipo recursivo</em>, donde un valor puede tener como parte de sí mismo otro
valor del mismo tipo. Debido a que este anidamiento de valores podría,
teóricamente, continuar infinitamente, Rust no sabe cuánto espacio necesita
un valor de tipo recursivo. Sin embargo, los <em>boxes</em> tienen un tamaño
conocido, por lo que al insertar un <em>box</em> en una definición de tipo recursivo
puede tener tipos recursivos.</p>
<p>Exploremos la <em>cons list</em>, que es un tipo de datos común en los lenguajes de
programación funcionales, como un ejemplo de tipo recursivo. El tipo <em>cons
list</em> que definiremos es sencillo excepto por la recursión; por lo tanto, los
conceptos en el ejemplo con el que trabajaremos serán útiles cada vez que
ingrese en situaciones más complejas que involucren tipos recursivos.</p>
<h4 id="más-información-sobre-el-cons-list"><a class="header" href="#más-información-sobre-el-cons-list">Más información sobre el <em>Cons List</em></a></h4>
<p>Un <em>cons list</em> es una estructura de datos que proviene del lenguaje de
programación Lisp y sus dialectos en Lisp, la función <code>cons</code>
(abreviatura de “construct function”)
construye un nuevo par a partir de sus dos argumentos, que generalmente son
un valor único y otro par estos pares que contienen pares forman una lista.</p>
<p>El concepto de <em>cons function</em> se ha convertido en una jerga de programación funcional más general: “to cons <em>x</em> onto <em>y</em>” informalmente significa
construir una nueva instancia de contenedor poniendo el elemento <em>x</em> al
comienzo de este nuevo contenedor, seguido por el contenedor <em>y</em>.</p>
<p>Cada elemento en una <em>cons list</em> contiene dos elementos: el valor del
elemento actual y el siguiente ítem. El último elemento de la lista contiene
solo un valor llamado <code>Nil</code> sin un siguiente artículo. Una <em>cons list</em>
se produce recursivamente llamando a la función <code>cons</code>. El nombre canónico
para denotar el caso base de la recursión es <code>Nil</code>.
Tenga en cuenta que esto no es lo mismo que el concepto “null” o “nil” en el
Capítulo 6, que es un valor inválido o ausente.</p>
<p>Aunque los lenguajes de programación funcionales usan <em>cons list</em>
frecuentemente, las <em>cons list</em> no eson una estructura de datos comúnmente
utilizada en Rust. La mayoría de las veces cuando tiene una lista de
elementos en Rust, <code>Vec &lt;T&gt;</code> es una mejor opción para usar. Otros tipos de
datos recursivos más complejos <em>son</em> útiles en diversas situaciones, pero
comenzando con la <em>cons list</em>, podemos explorar cómo los <em>boxes</em> nos permiten definir un tipo de datos recursivo sin mucha distracción.</p>
<p>El listado 15-2 contiene una definición enum para una <em>cons list</em>. Tenga en
cuenta que este código aún no se compilará porque el tipo <code>List</code> no tiene un
tamaño conocido, que demostraremos</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listado 15-2: El primer intento de definir una
enumeración para representar una estructura de datos de <em>cons list</em> de
valores <code>i32</code></span></p>
<blockquote>
<p>Nota: Estamos implementando una <em>cons list</em> que solo contiene valores <code>i32</code>
para los propósitos de este ejemplo. Podríamos haberlo implementado usando
genéricos, como discutimos en el Capítulo 10, para definir un tipo de
<em>cons list</em> que pudiera almacenar valores de cualquier tipo.</p>
</blockquote>
<p>Usar el tipo <code>List</code> para almacenar la lista <code>1, 2, 3</code> se vería como el código
en Listado 15-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listado 15-3: Usando la enumeración <code>List</code> para
almacenar la lista <code>1,2, 3</code></span></p>
<p>El primer valor de <code>Cons</code> tiene <code>1</code> y otro valor de <code>List</code>. Este valor de
<code>List</code> es otro valor <code>Cons</code> que contiene <code>2</code> y otro valor <code>List</code>. Este valor
de <code>List</code> es un valor más <code>Cons</code> que contiene <code>3</code> y un valor <code>List</code>, que
finalmente es <code>Nil</code>, la variante no recursiva que señala el final de la lista.</p>
<p>Si tratamos de compilar el código en el Listado 15-3, obtenemos el error que
se muestra en el Listado 15-4:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">Listado 15-4: El error que obtenemos al intentar
definir una enumeración recursiva</span></p>
<p>El error muestra que este tipo “tiene un tamaño infinito”. La razón es que
hemos definido <code>List</code> con una variante que es recursiva: tiene otro valor de
sí mismo directamente. Como resultado, Rust no puede determinar cuánto
espacio necesita para almacenar un valor de <code>List</code>. Analicemos por qué
tenemos este error un poco. Primero, veamos cómo Rust decide cuánto espacio
necesita para almacenar un valor de tipo no recursivo.</p>
<h4 id="calcular-el-tamaño-de-un-tipo-no-recursivo"><a class="header" href="#calcular-el-tamaño-de-un-tipo-no-recursivo">Calcular el tamaño de un tipo no recursivo</a></h4>
<p>Recuerde la enumeración <code>Message</code> que definimos en el Listado 6-2 cuando
discutimos las definiciones de enum en el Capítulo 6:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<p>Para determinar cuánto espacio asignar para un valor de <code>Message</code>, Rust
revisa cada una de las variantes para ver qué variante necesita más espacio.
Rust ve que <code>Message::Quit</code> no necesita ningún espacio, <code>Message::Move</code>
necesita suficiente espacio para almacenar dos valores <code>i32</code>, y así
sucesivamente. Debido a que solo se usará una variante, la mayor cantidad de
espacio que necesitará un valor de <code>Message</code> es el espacio que le llevaría
almacenar la mayor de sus variantes.</p>
<p>En contraste esto con lo que ocurre cuando Rust intenta determinar cuánto
espacio necesita un tipo recursivo como la enumeración <code>List</code> en el Listado
15-2. El compilador comienza mirando la variante <code>Cons</code>, que contiene un
valor de tipo <code>i32</code> y un valor de tipo <code>List</code>. Por lo tanto, <code>Cons</code> necesita
una cantidad de espacio igual al tamaño de un <code>i32</code> más el tamaño de una
<code>List</code>. Para averiguar cuánta memoria necesita el tipo <code>List</code>, el compilador
observa las variantes, comenzando con la variante <code>Cons</code>. La variante <code>Cons</code>
contiene un valor de tipo <code>i32</code> y un valor de tipo <code>List</code>, y este proceso
continúa infinitamente, como se muestra en la figura 15-1.</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 15-1: Una <code>List</code> infinita que consiste en
infinitas variantes <code>Cons</code></span></p>
<h4 id="usando-box-t-para-obtener-un-tipo-recursivo-con-un-tamaño-conocido"><a class="header" href="#usando-box-t-para-obtener-un-tipo-recursivo-con-un-tamaño-conocido">Usando <code>Box &lt;T&gt;</code> para obtener un tipo recursivo con un tamaño conocido</a></h4>
<p>Rust no puede determinar cuánto espacio asignar para los tipos definidos
recursivamente, por lo que el compilador da el error en el Listado 15-4. Pero
el error incluye esta útil sugerencia:</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p>En esta sugerencia, “indirection” significa que en lugar de almacenar un
valor directamente, cambiaremos la estructura de datos para almacenar el
valor indirectamente almacenando un puntero al valor en su lugar.</p>
<p>Debido a que <code>Box&lt;T&gt;</code> es un puntero, Rust siempre sabe cuánto espacio
necesita <code>Box&lt;T&gt;</code>: el tamaño de un puntero no cambia en función de la
cantidad de datos a los que apunta. Esto significa que podemos poner
<code>Box&lt;T&gt;</code> dentro de la variante <code>Cons</code> en lugar de otro <code>List</code> directamente.
El <code>Box &lt;T&gt;</code> apuntará al siguiente valor <code>List</code> que estará en el montículo en
lugar de dentro de la variante <code>Cons</code>. Conceptualmente, todavía tenemos una
lista, creada con listas que “sostienen” otras listas, pero esta
implementación ahora es más como colocar los elementos uno al lado del otro
en lugar de uno dentro del otro.</p>
<p>Podemos cambiar la definición de la enumeración <code>List</code> en el Listado 15-2 y
el uso de la <code>List</code> en el Listado 15-3 del código en el Listado 15-5, que
compilará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listado 15-5: Definición de <code>List</code> que usa
<code>Box&lt;T&gt;</code> para tener un tamaño conocido</span></p>
<p>La variante <code>Cons</code> necesitará el tamaño de un <code>i32</code> más el espacio para
almacenar los datos del puntero de la <em>box</em>. La variante <code>Nil</code> no almacena
valores, por lo que necesita menos espacio que la variante <code>Cons</code>. Ahora
sabemos que cualquier valor de <code>List</code> tomará el tamaño de un <code>i32</code> más el
tamaño de los datos del puntero de un <em>box</em>. Al usar una <em>box</em>, hemos roto la
cadena infinita y recursiva, por lo que el compilador puede calcular el
tamaño que necesita para almacenar un valor de <code>List</code>. La figura 15-2 muestra
cómo es la variante <code>Cons</code> ahora.</p>
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figura 15-2: Una  <code>List</code> que no tiene un tamaño
infinito porque <code>Cons</code> contiene un <code>Box</code></span></p>
<p>Las casillas solo proporcionan la asignación indirecta y del montículo; no
tienen otras capacidades especiales, como las que veremos con los otros tipos
de punteros inteligentes. Tampoco tienen ninguna sobrecarga de rendimiento en
la que incurran estas capacidades especiales, por lo que pueden ser útiles en
casos como la <em>cons list</em>, donde la indirección es la única característica
que necesitamos. Veremos más casos de uso para las <em>boxes</em> en el Capítulo 17,
también.</p>
<p>El tipo <code>Box&lt;T&gt;</code> es un puntero inteligente porque implementa el <em>trait</em>
<code>Deref</code>, que permite que los valores <code>Box&lt;T&gt;</code>sean tratados como referencias.
Cuando un valor <code>Box&lt;T&gt;</code> sale del alcance, los datos del montículo a los que
apunta el <em>box</em> también se limpian debido a la implementación del <em>trait</em>
<code>Drop</code>. Exploremos estos dos <em>traits</em> con más detalle. Estos dos <em>traits</em>
serán aún más importantes para la funcionalidad proporcionada por los otros
tipos de punteros inteligentes que discutiremos en el resto de este capítulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tratamiento-de-punteros-inteligentes-como-referencias-regulares-con-el-trait-deref"><a class="header" href="#tratamiento-de-punteros-inteligentes-como-referencias-regulares-con-el-trait-deref">Tratamiento de punteros inteligentes como referencias regulares con el <em>trait</em> <code>Deref</code></a></h2>
<p>La implementación del <em>trait</em> <code>Deref</code> le permite personalizar el
comportamiento del <em>operador de desreferencia</em>,<code>*</code>(en oposición al operador
de multiplicación u <em>glob operator</em>). Al implementar <code>Deref</code> de tal manera
que un puntero inteligente puede tratarse como una referencia regular, puede
escribir código que opera en referencias y usar ese código también con
punteros inteligentes.</p>
<p>Primero veamos cómo funciona el operador de desreferencia con referencias
regulares. Luego trataremos de definir un tipo personalizado que se comporte
como <code>Box &lt;T&gt;</code>, y veremos por qué el operador de desreferencia no funciona
como una referencia en nuestro tipo recién definido. Exploraremos cómo la
implementación del <em>trait</em> <code>Deref</code> hace posible que los punteros inteligentes
funcionen de manera similar a las referencias. A continuación, veremos la
función <em>coercción directa</em> (<em>deref coercion</em>) de Rust y cómo nos permite trabajar con
referencias o punteros inteligentes.</p>
<h3 id="seguir-el-puntero-hasta-el-valor-con-el-operador-de-desreferencia"><a class="header" href="#seguir-el-puntero-hasta-el-valor-con-el-operador-de-desreferencia">Seguir el puntero hasta el valor con el operador de desreferencia</a></h3>
<p>Una referencia regular es un tipo de puntero, y una forma de pensar en un
puntero es como una flecha hacia un valor almacenado en otro lugar. En el
Listado 15-6, creamos una referencia a un valor <code>i32</code> y luego usamos el
operador de referencia para seguir la referencia a los datos:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listado 15-6: Usar el operador de desreferencia para
seguir una referencia a un valor <code>i32</code></span></p>
<p>La variable <code>x</code> tiene un valor <code>i32</code>, <code>5</code>. Establecemos <code>y</code> igual a una
referencia a <code>x</code>. Podemos afirmar que <code>x</code> es igual a <code>5</code>. Sin embargo, si
queremos hacer una afirmación sobre el valor en <code>y</code>, tenemos que usar <code>*y</code>
para seguir la referencia al valor al que apunta (de ahí <em>desreferencia</em>).
Una vez que desreferenciamos <code>y</code>, tenemos acceso al valor entero <code>y</code> apunta a
que podemos comparar con <code>5</code>.</p>
<p>Si intentáramos escribir <code>assert_eq!(5, y);</code> en su lugar, obtendríamos este
error de compilación:</p>
<pre><code class="language-text">error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>No se permite comparar un número y una referencia a un número porque son
tipos diferentes. Debemos usar el operador de desreferencia para seguir la
referencia al valor al que apunta.</p>
<h3 id="usando-box-t-como-una-a-referencia"><a class="header" href="#usando-box-t-como-una-a-referencia">Usando <code>Box &lt;T&gt;</code> como una a referencia</a></h3>
<p>Podemos reescribir el código en el Listado 15-6 para usar un <code>Box&lt;T&gt;</code> en
lugar de una referencia; el operador de desreferencia funcionará como se
muestra en el Listado 15-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listado 15-7: Usar el operador de desreferencia en un
<code>Box&lt;i32&gt;</code></span></p>
<p>La única diferencia entre el Listado 15-7 y el Listado 15-6 es que aquí
establecemos que <code>y</code> sea una instancia de un <em>box</em> que apunta al valor en <code>x</code>
en lugar de una referencia que apunta al valor de <code>x</code>. En la última
afirmación, podemos usar el operador de desreferencia para seguir el puntero
del <em>box</em> de la misma manera que lo hacíamos cuando <code>y</code> era una referencia. A
continuación, exploraremos qué tiene de especial el <code>Box &lt;T&gt;</code> que nos permite
usar el operador de referencia al definir nuestro propio tipo de <em>box</em>.</p>
<h3 id="definiendo-nuestro-propio-puntero-inteligente"><a class="header" href="#definiendo-nuestro-propio-puntero-inteligente">Definiendo nuestro propio puntero inteligente</a></h3>
<p>Construyamos un puntero inteligente similar al tipo <code>Box&lt;T&gt;</code> provisto por la
biblioteca estándar para experimentar cómo los punteros inteligentes se
comportan de manera diferente a las referencias por defecto. Luego veremos
cómo agregar la capacidad de usar el operador de desreferencia.</p>
<p>El tipo <code>Box&lt;T&gt;</code> se define en última instancia como una estructura tupla con
un elemento, por lo que el Listado 15-8 define un tipo <code>MyBox&lt;T&gt;</code> de la misma
manera. También definiremos una función <code>new</code> para que coincida con la
función <code>new</code> definida en <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 15-8: Definiendo un tipo <code>MyBox&lt;T&gt;</code></span></p>
<p>Definimos una estructura llamada <code>MyBox</code> y declaramos un parámetro genérico
<code>T</code>, porque queremos que nuestro tipo contenga valores de cualquier tipo. El
tipo <code>MyBox</code> es una estructura tuple con un elemento de tipo <code>T</code>. La función
<code>MyBox::new</code> toma un parámetro de tipo <code>T</code> y devuelve una instancia <code>MyBox</code>
que mantiene el valor pasado.</p>
<p>Intentemos agregar la función <code>main</code> en el Listado 15-7 al Listado 15-8 y
cambiarla para usar el tipo <code>MyBox&lt;T&gt;</code> que hemos definido en lugar de
<code>Box&lt;T&gt; </code>. El código del listado 15-9 no se compilará porque Rust no sabe
cómo desreferenciar <code>MyBox</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listado 15-9: Intentando usar <code>MyBox&lt;T&gt;</code> de la misma
manera que utilizamos las referencias y <code>Box&lt;T&gt;</code></span></p>
<p>Aquí está el error de compilación resultante:</p>
<pre><code class="language-text">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p>Nuestro tipo <code>MyBox&lt;T&gt;</code> no puede ser desreferenciado porque no hemos
implementado esa capacidad en nuestro tipo. Para habilitar la
desreferenciación con el operador <code>*</code>, implementamos el <em>trait</em> <code>Deref</code>.</p>
<h3 id="tratar-un-tipo-como-una-referencia-mediante-la-implementación-del-trait-deref"><a class="header" href="#tratar-un-tipo-como-una-referencia-mediante-la-implementación-del-trait-deref">Tratar un tipo como una referencia mediante la implementación del <em>trait</em> <code>Deref</code></a></h3>
<p>Como se discutió en el Capítulo 10, para implementar un <em>trait</em>, necesitamos
proporcionar implementaciones para los métodos requeridos del <em>trait</em>. El
<em>trait</em> <code>Deref</code>, proporcionado por la biblioteca estándar, requiere que
implementemos un método llamado <code>deref</code> que toma <code>self</code> y devuelve una
referencia a los datos internos. El listado 15-10 contiene una implementación
de <code>Deref</code> para agregar a la definición de <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

<span class="boring">struct MyBox&lt;T&gt;(T);
</span>impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 15-10: Implementando <code>Deref</code> en
<code>MyBox&lt;T&gt;</code></span></p>
<p>La sintaxis <code>type Target = T;</code> define un tipo asociado para el <em>trait</em>
<code>Deref</code> a usar. Los tipos asociados son una manera ligeramente diferente de
declarar un parámetro genérico, pero no necesita preocuparse por ellos por el
momento; los cubriremos con más detalle en el Capítulo 19.</p>
<p>Completamos el cuerpo del método <code>deref</code> con <code>&amp;self.0</code> para que <code>deref</code>
devuelva una referencia al valor al que queremos acceder con el operador
<code>*</code>. La función <code>main</code> en el Listado 15-9 que llama a <code>*</code> en el valor
<code>MyBox&lt;T&gt;</code>ahora se compila, ¡y las aserciones pasan!</p>
<p>Sin el <em>trait</em> <code>Deref</code>, el compilador solo puede desreferenciar <code>&amp;</code>
referencias. El método <code>deref</code> le da al compilador la capacidad de tomar un
valor de cualquier tipo que implemente <code>Deref</code> y llame al método <code>deref</code> para
obtener una referencia <code>&amp;</code> que sepa cómo desreferencia.</p>
<p>Cuando ingresamos <code>*y</code> en el Listado 15-9, entre bastidores, Rust
realmente ejecutó este código:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust sustituye el operador <code>*</code> con una llamada al método <code>deref</code> y luego una
desreferencia simple para que no tengamos que pensar si debemos o no llamar
al método <code>deref</code>. Esta función Rust nos permite escribir código que funciona
de manera idéntica si tenemos una referencia regular o un tipo que implementa
<code>Deref</code>.</p>
<p>La razón por la cual el método <code>deref</code> devuelve una referencia a un valor y
que la desreferencia simple fuera de los paréntesis en <code>*(y.deref ())</code> aún
es necesaria es el sistema de propiedad. Si el método <code>deref</code> devolviera el
valor directamente en lugar de una referencia al valor, el valor se movería
fuera de <code>self</code>. No queremos tomar posesión del valor interno dentro de
<code>MyBox&lt;T&gt;</code> en este caso o en la mayoría de los casos donde utilizamos el
operador de desreferencia.</p>
<p>Tenga en cuenta que el operador <code>*</code> se reemplaza con una llamada al método
<code>deref</code> y luego una llamada al operador <code>*</code> solo una vez, cada vez que usemos
un <code>*</code> en nuestro código. Debido a que la sustitución del operador <code>*</code> no se
repite infinitamente, terminamos con datos del tipo <code>i32</code>, que coincide con
<code>5</code> en <code>assert_eq!</code> En el Listado 15-9.</p>
<h3 id="deref-coercions-implícitas-con-funciones-y-métodos"><a class="header" href="#deref-coercions-implícitas-con-funciones-y-métodos">Deref Coercions Implícitas con Funciones y Métodos</a></h3>
<p><em>Deref coercion</em> es una conveniencia que Rust realiza en argumentos a
funciones y métodos. <em>Deref</em> coercion convierte una referencia a un tipo que
implementa <code>Deref</code> en una referencia a un tipo al que <code>Deref</code> puede convertir
el tipo original. La coerción de <em>Deref</em> ocurre automáticamente cuando
pasamos una referencia al valor de un tipo particular como un argumento para
una función o método que no coincide con el tipo de parámetro en la
definición de función o método. Una secuencia de llamadas al método <code>deref</code>
convierte el tipo que proporcionamos en el tipo que el parámetro necesita.</p>
<p>La <em>deref coercion</em> se agregó a Rust para que los programadores que escriben
funciones y llamadas a métodos no necesiten agregar tantas referencias
explícitas y referencias con <code>&amp;</code> y <code>*</code>. La característica de <em>deref coercion</em>
también nos permite escribir más código que puede funcionar para referencias
o punteros inteligentes.</p>
<p>Para ver la <em>deref coercion</em> en acción, utilicemos el tipo <code>MyBox&lt;T&gt;</code> que
definimos en el Listado 15-8, así como la implementación de <code>Deref</code> que
agregamos en el Listado 15-10. El listado 15-11 muestra la definición de una
función que tiene un parámetro de <em>string slice</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 15-11: Una función <code>hello</code> que tiene el
parámetro <code>name</code> de tipo <code>&amp;str</code></span></p>
<p>Podemos llamar a la función <code>hello</code> con un <em>string slice</em> como argumento,
como <code>hello(&quot;Rust&quot;);</code>por ejemplo. La coerción de <em>Deref</em> hace posible llamar
a <code>hello</code> con una referencia a un valor de tipo <code>MyBox &lt;String&gt; </code>, como se
muestra en el Listado 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listado 15-12: Llamar a <code>hello</code> con una referencia a un
valor <code>MyBox&lt;String&gt;</code>, que funciona debido a la <em>deref coercion</em></span></p>
<p>Aquí llamamos a la función <code>hello</code> con el argumento <code>&amp;m</code>, que es una
referencia a un valor <code>MyBox&lt;String&gt;</code>. Debido a que implementamos el <em>trait</em> <code>Deref</code> en <code>MyBox&lt;T&gt;</code> en el Listado 15-10, Rust puede convertir
<code>&amp;MyBox&lt;String&gt;</code> en <code>&amp;String</code> llamando a <code>deref</code>. La biblioteca estándar
proporciona una implementación de <code>Deref</code> en <code>String</code> que devuelve un
<em>string slice</em>, y esto está en la documentación de API para <code>Deref</code>. Rust
llama <code>deref</code> nuevamente para convertir <code>&amp;String</code> en <code>&amp;str</code>, que coincide con
la definición de la función <code>hello</code>.</p>
<p>Si Rust no implementó la <em>deref coercion</em>, tendríamos que escribir el código
en el Listado 15-13 en lugar del código en el Listado 15-12 para llamar a
<code>hello</code> con un valor de tipo <code>&amp; MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listado 15-13: El código que deberíamos escribir si
Rust no tuviera <em>deref coercion</em></span></p>
<p>El <code>(*m)</code> elimina la referencia del <code>MyBox&lt;String&gt;</code> en un <code>String</code>. Luego,
los <code>&amp;</code> y <code>[..]</code> toman un <em>string slice</em> de <code>String</code> que es igual a toda el
<em>string</em> para que coincida con la firma de <code>hello</code>. El código sin
<em>deref coercion</em> es más difícil de leer, escribir y comprender con todos
estos símbolos involucrados. La <em>deref coercion</em> le permite a Rust manejar
estas conversiones automáticamente.</p>
<p>Cuando se define el <em>trait</em> <code>Deref</code> para los tipos involucrados, Rust
analizará los tipos y usará <code>Deref::deref</code> tantas veces como sea necesario
para obtener una referencia que coincida con el tipo del parámetro. ¡La
cantidad de veces que <code>Deref::deref</code> necesita insertarse se resuelve en
tiempo de compilación, por lo que no hay penalización de tiempo de ejecución
para aprovechar la <em>deref coercion</em>!</p>
<h3 id="cómo-deref-coercion-interactúa-con-la-mutabilidad"><a class="header" href="#cómo-deref-coercion-interactúa-con-la-mutabilidad">Cómo <em>Deref Coercion</em> interactúa con la mutabilidad</a></h3>
<p>De forma similar a cómo usa el <em>trait</em> <code>Deref</code> para anular el operador <code>*</code> en
referencias inmutables, puede usar el <em>trait</em> <code>DerefMut</code> para anular el
operador <code>*</code> en referencias mutables.</p>
<p>Rust hace <em>deref coercion</em> cuando encuentra tipos e implementaciones del
<em>trait</em> en tres casos:</p>
<ul>
<li>De <code>&amp;T</code> a <code>&amp;U</code> cuando <code>T: Deref&lt;Target=U&gt;</code></li>
<li>De <code>&amp;mut T</code> a <code>&amp;mut U</code> cuando <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>De <code>&amp;mut T</code> a <code>&amp;U</code> cuando <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Los primeros dos casos son iguales excepto para la mutabilidad. El primer
caso establece que si tiene un <code>&amp;T</code>, y <code>T</code> implementa <code>Deref</code> para algún
tipo <code>U</code>, puede obtener un <code>&amp;U</code> de forma transparente. El segundo caso indica
que la misma <em>deref coercion</em> ocurre para las referencias mutables.</p>
<p>El tercer caso es más complicado: Rust también forzará una referencia mutable
a una inmutable. Pero lo contrario <em>no</em> es posible: las referencias
inmutables nunca forzarán a las referencias mutables. Debido a las reglas de
préstamo, si tiene una referencia mutable, esa referencia mutable debe ser la
única referencia a esa información (de lo contrario, el programa no
compilaría). La conversión de una referencia mutable a una referencia
inmutable nunca romperá las reglas de endeudamiento. La conversión de una
referencia inmutable a una referencia mutable requeriría que haya solo una
referencia inmutable a esa información, y las reglas de endeudamiento no lo
garantizan. Por lo tanto, Rust no puede asumir que es posible convertir una
referencia inmutable en una referencia mutable.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ejecutando-código-de-limpieza-con-el-trait-drop"><a class="header" href="#ejecutando-código-de-limpieza-con-el-trait-drop">Ejecutando código de limpieza con el <em>trait</em> <code>Drop</code></a></h2>
<p>El segundo <em>trait</em> importante para el patrón de puntero inteligente es
<code>Drop</code>, que permite personalizar lo que sucede cuando un valor está a punto
de quedar fuera del alcance. Usted puede proporcionar una implementación para
el <em>trait</em> <code>Drop</code> en cualquier tipo, y el código que especifique se puede
usar para liberar recursos como archivos o conexiones de red. Estamos
introduciendo <code>Drop</code> en el contexto de punteros inteligentes porque la
funcionalidad del <em>trait</em> <code>Drop</code> casi siempre se usa cuando se implementa un
puntero inteligente. Por ejemplo, <code>Box&lt;T&gt;</code> personaliza <code>Drop</code> para desasignar
el espacio en el montículo al que apunta el <em>box</em>.</p>
<p>En algunos lenguajes, el programador debe llamar al código para liberar
memoria o recursos cada vez que terminan de usar una instancia de un puntero
inteligente. Si olvidan, el sistema puede sobrecargarse y bloquearse. En Rust puede especificar que un poco de código particular se ejecuta cada vez que un
valor sale del alcance, y el compilador insertará este código
automáticamente. Como resultado, no necesita tener cuidado con la colocación
del código de limpieza en todas partes de un programa que una instancia de un
tipo en particular haya finalizado, ¡de todas maneras no perderá recursos!.</p>
<p>Especifique el código que se ejecutará cuando un valor salga del alcance
implementando el <em>trait</em> <code>Drop</code>. El <em>trait</em> <code>Drop</code> requiere que implemente un
método llamado <code>drop</code> que toma una referencia mutable a <code>self</code>. Para ver
cuando Rust llama <code>drop</code>, implementemos <code>drop</code> con las sentencias
<code>println!</code> por ahora.</p>
<p>El listado 15-14 muestra una estructura <code>CustomSmartPointer</code> cuya única
funcionalidad personalizada es que imprimirá
<code>Dropping CustomSmartPointer!</code> cuando la instancia se salga del alcance. Este
ejemplo demuestra cuando Rust ejecuta la función <code>drop</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listado 15-14: Una estructura <code>CustomSmartPointer</code> que
implementa el <em>trait</em> <code>Drop</code> donde pondríamos nuestro código de
limpieza</span></p>
<p>El <em>trait</em> <code>Drop</code> está incluido en el preludio, por lo que no es necesario
importarlo. Implementamos el <em>trait</em> <code>Drop</code> en <code>CustomSmartPointer</code> y
proporcionamos una implementación para el método <code>drop</code> que llama
<code>println!</code>. El cuerpo de la función <code>drop</code> es donde colocaría cualquier
lógica que quisiera ejecutar cuando una instancia de su tipo saliera del
alcance. Estamos imprimiendo algunos textos aquí para demostrar cuándo Rust
llamará <code>drop</code>.</p>
<p>En <code>main</code>, creamos dos instancias de <code>CustomSmartPointer</code> y luego imprimimos
<code>CustomSmartPointers created</code>. Al final de <code>main</code>, nuestras instancias de
<code>CustomSmartPointer</code> saldrán del alcance, y Rust llamará al código que
colocamos en el método <code>drop</code>, imprimiendo nuestro mensaje final. Tenga en
cuenta que no necesitamos llamar al método <code>drop</code> explícitamente.</p>
<p>Cuando ejecutamos este programa, veremos el siguiente resultado:</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automáticamente nos llamó <code>drop</code> cuando nuestras instancias salieron del
alcance, llamando al código que especificamos. Las variables se eliminan en
el orden inverso de su creación, por lo que <code>d</code> se eliminó antes de <code>c</code>. Este
ejemplo le da una guía visual de cómo funciona el método <code>drop</code>; por lo
general, debe especificar el código de limpieza que debe ejecutar su tipo en
lugar de un mensaje de impresión.</p>
<h3 id="dropping-un-valor-temprano-con-stdmemdrop"><a class="header" href="#dropping-un-valor-temprano-con-stdmemdrop">Dropping un valor temprano con <code>std::mem::drop</code></a></h3>
<p>Desafortunadamente, no es fácil deshabilitar la funcionalidad automática de <code>drop</code>. Desactivar <code>drop</code> no suele ser necesario; el objetivo del <em>trait</em> <code>Drop</code> es que se soluciona automáticamente. Ocasionalmente, sin embargo, es
posible que desee limpiar un valor temprano. Un ejemplo es cuando se usan
punteros inteligentes que administran <em>locks</em>: es posible que desee forzar el
método <code>drop</code> que libera el <em>locks</em> para que otro código en el mismo alcance
pueda adquirir el <em>locks</em>. Rust no te permite llamar al método <code>drop</code> del
<em>trait</em> <code>Drop</code> de forma manual; en su lugar, debe llamar a la función
<code>std::mem::drop</code> proporcionada por la biblioteca estándar si desea forzar la
eliminación de un valor antes de que termine su ámbito.</p>
<p>Si tratamos de llamar manualmente el método <code>drop</code> del <em>trait</em> <code>Drop</code>
modificando la función <code>main</code> del Listado 15-14, como se muestra en el
Listado 15-15, obtendremos un error del compilador:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">Listado 15-15: Intentando llamar al método <code>drop</code> del
<em>trait</em> <code>Drop</code> manualmente para limpiar temprano</span></p>
<p>Cuando intentemos compilar este código, obtendremos este error:</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<p>Este mensaje de error indica que no podemos llamar <code>drop</code> explícitamente. El
mensaje de error utiliza el término <em>destructor</em>, que es el término de
programación general para una función que limpia una instancia. A
<em>destructor</em> es análogo a <em>constructor</em>, que crea una instancia. La función
<code>drop</code> en Rust es un destructor particular.</p>
<p>Rust no nos permite llamar <code>drop</code> explícitamente porque Rust todavía llamaría
automáticamente <code>drop</code> sobre el valor al final de <code>main</code>. Este sería un error
<em>double free</em> porque Rust estaría intentando limpiar el mismo valor dos veces.</p>
<p>No podemos deshabilitar la inserción automática de <code>drop</code> cuando un valor
está fuera del alcance, y no podemos llamar al método <code>drop</code> explícitamente.
Entonces, si necesitamos forzar que un valor se elimine temprano, podemos
usar la función <code>std::mem::drop</code>.</p>
<p>La función <code>std::mem::drop</code> es diferente del método <code>drop</code> en el <em>trait</em> <code>Drop</code>. Lo llamamos pasando el valor que queremos forzar para descartarlo
temprano como argumento. La función está en el preludio, por lo que podemos
modificar <code>main</code> en el Listado 15-15 para llamar a la función <code>drop</code>, como se
muestra en el Listado 15-16:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listado 15-16: Llamar a <code>std::mem::drop</code> para soltar
explícitamente un valor antes de que salga del alcance</span></p>
<p>Al ejecutar este código, se imprimirá lo siguiente:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>El texto <code>Quitando CustomSmartPointer con data` some data`! </code> Se imprime
entre el <code>CustomSmartPointer created</code> y <code>CustomSmartPointer drop before the end of main</code> texto, mostrando que se llama en al código del método <code>drop</code>
para soltar <code>c</code> en ese punto.</p>
<p>Puede usar el código especificado en una implementación del <em>trait</em> <code>Drop</code>
de muchas maneras para hacer la limpieza conveniente y segura: por ejemplo,
¡podría usarla para crear su propio asignador de memoria! Con el <em>trait</em>
<code>Drop</code> y el sistema de propiedad de Rust, no tienes que acordarte de limpiar
porque Rust lo hace automáticamente.</p>
<p>Tampoco tiene que preocuparse por los problemas que resultan de la limpieza
accidental de los valores que todavía están en uso: el sistema de propiedad
que asegura que las referencias sean siempre válidas también asegura que
<code>drop</code> se llame solo una vez cuando el valor ya no se use.</p>
<p>Ahora que hemos examinado <code>Box&lt;T&gt;</code> y algunas de las características de los
punteros inteligentes, veamos algunos otros punteros inteligentes definidos
en la biblioteca estándar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-the-reference-counted-smart-pointer"><a class="header" href="#rct-the-reference-counted-smart-pointer"><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></h2>
<p>En la mayoría de los casos, la propiedad es clara: usted sabe exactamente qué
variable posee un valor determinado. Sin embargo, hay casos en que un único
valor puede tener múltiples propietarios. Por ejemplo, en las estructuras de
datos de gráficos, los bordes múltiples pueden apuntar al mismo nodo, y ese
nodo es propiedad conceptual de todos los bordes que apuntan a él. No se debe
limpiar un nodo a menos que no tenga ningún borde apuntando hacia él.</p>
<p>Para habilitar la propiedad múltiple, Rust tiene un tipo llamado <code>Rc&lt;T&gt;</code>, que
es una abreviatura para <em>reference counting</em>. El tipo <code>Rc&lt;T&gt;</code> realiza un
seguimiento del número de referencias a un valor que determina si un valor
todavía está en uso o no. Si no hay referencias a un valor, el valor se puede
limpiar sin que las referencias se vuelvan inválidas.</p>
<p>Imagine <code>Rc&lt;T&gt;</code> como un televisor en una sala familiar. Cuando una persona
entra a ver televisión, la enciende. Otros pueden entrar a la habitación y
mirar la televisión. Cuando la última persona sale de la habitación, apagan
el televisor porque ya no se usa. Si alguien apaga el televisor mientras
otros todavía lo miran, ¡habrá un alboroto de los observadores de TV
restantes!.</p>
<p>Usamos el tipo <code>Rc&lt;T&gt;</code> cuando queremos asignar algunos datos en el montículo
para que se lean varias partes de nuestro programa y no podemos determinar en
tiempo de compilación qué parte terminará usando los datos al final. Si
supiéramos qué parte terminaría la última, podríamos simplemente convertir a
esa parte en el propietario de los datos, y las reglas de propiedad normales
aplicadas en tiempo de compilación entrarían en vigencia.</p>
<p>Tenga en cuenta que <code>Rc&lt;T&gt;</code> solo se usa en escenarios de subproceso único. Cuando analicemos la concurrencia en el Capítulo 16, cubriremos cómo hacer
recuento de referencias en programas <em>multithreaded</em>.</p>
<h3 id="usando-rc-t-para-compartir-datos"><a class="header" href="#usando-rc-t-para-compartir-datos">Usando <code>Rc &lt;T&gt;</code> para compartir datos</a></h3>
<p>Regresemos a nuestro ejemplo de lista de consensos en el listado 15-5.
Recuerde que lo definimos usando <code>Box&lt;T&gt;</code>. Esta vez, crearemos dos listas que
compartan la propiedad de una tercera lista. Conceptualmente, esto se parece
a la Figura 15-3:</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Figura 15-3: Dos listas, <code>b</code> y <code>c</code>, comparten la
propiedad de una tercera lista, <code>a</code></span></p>
<p>Crearemos la lista <code>a</code> que contiene 5 y luego 10. Luego haremos dos listas
más: <code>b</code> que comienza con 3 y <code>c</code> que comienza con 4. Ambas listas <code>b</code> y <code>c</code>
luego continúe con la primera lista <code>a</code> que contiene 5 y 10. En otras
palabras, ambas listas compartirán la primera lista que contiene 5 y 10.</p>
<p>Intentar implementar este escenario usando nuestra definición de <code>List</code> con
<code>Box&lt;T&gt;</code> no funcionará, como se muestra en el Listado 15-17:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listado 15-17: Demostrando que no podemos tener dos
listas usando <code>Box&lt;T&gt;</code> que intentan compartir la propiedad de una tercera
lista</span></p>
<p>Cuando compilamos este código, obtenemos este error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
</code></pre>
<p>Las variantes <code>Cons</code> poseen los datos que guardan, así que cuando creamos la
lista <code>b</code>, <code>a</code> se mueve a <code>b</code> y <code>b</code> posee <code>a</code>. Luego, cuando tratamos de usar
<code>a</code> nuevamente cuando creando <code>c</code>, no se nos permite porque <code>a</code> ha sido
movido.</p>
<p>Podríamos cambiar la definición de <code>Cons</code> para mantener referencias en su
lugar, pero luego tendríamos que especificar los parámetros de <em>lifetime</em>.
Al especificar los parámetros de <em>lifetime</em>, estaríamos especificando que
cada elemento de la lista vivirá al menos tanto como la lista completa.
El comprobador de préstamos no nos permitió compilar
<code>let a = Cons(10, &amp;Nil);</code> por ejemplo, porque el valor temporal <code>Nil</code>
será descartado antes de que <code>a</code> pueda tomar una referencia al mismo.</p>
<p>En cambio, cambiaremos nuestra definición de <code>List</code> para usar <code>Rc&lt;T&gt;</code> en
lugar de <code>Box&lt;T&gt;</code>, como se muestra en el Listado 15-18. Cada variante <code>Cons</code>
ahora tendrá un valor y un <code>Rc&lt;T&gt;</code> que apunta a una <code>List</code>. Cuando creamos
<code>b</code>, en lugar de tomar propiedad de <code>a</code>, clonaremos <code>Rc&lt;List&gt;</code> que <code>a</code> está
reteniendo, por lo tanto aumentando el número de referencias de uno a dos y
dejando <code>a</code> y <code>b</code> compartir la propiedad de los datos en ese <code>Rc&lt;List&gt;</code>.
También clonaremos <code>a</code> cuando creamos <code>c</code>, aumentando el número de
referencias de dos a tres. Cada vez llamamos <code>Rc::clone</code>, la cuenta de
referencia a los datos dentro de <code>Rc &lt;List&gt;</code> aumentar, y los datos no se
limpiarán a menos que haya cero referencias a ellos.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listado 15-18: Una definición de <code>List</code> que usa
<code>Rc&lt;T&gt;</code></span></p>
<p>Necesitamos agregar una instrucción <code>use</code> para poner <code>Rc&lt;T&gt;</code> en el alcance
porque no está en el preludio. En <code>main</code>, creamos la lista que contiene 5 y
10 y la almacenamos en un nuevo <code>Rc&lt;List&gt;</code> en <code>a</code>. Luego, cuando creamos <code>b</code>
y <code>c</code>, llamamos a la función <code>Rc::clone</code> y pasamos una referencia a
<code>Rc&lt;List&gt;</code> en <code>a</code> como argumento.</p>
<p>Podríamos haber llamado <code>a.clone()</code> en lugar de <code>Rc::clone(&amp;a)</code>, pero la
convención de Rust es usar <code>Rc::clone</code> en este caso. La implementación de
<code>Rc::clone</code> no hace una copia profunda de todos los datos como la mayoría de
las implementaciones de <code>clone</code>. La llamada a <code>Rc::clone</code> solo incrementa el
recuento de referencias, lo que no lleva mucho tiempo. Las copias profundas
de datos pueden llevar mucho tiempo. Al usar <code>Rc::clone</code> para el recuento de
referencias, podemos distinguir visualmente entre los tipos de clones de
copia profunda y los tipos de clones que aumentan el recuento de referencias.
Cuando buscamos problemas de rendimiento en el código, solo tenemos que
considerar los clones de copia profunda y podemos ignorar las llamadas a
<code>Rc::clone</code>.</p>
<h3 id="la-clonación-de-un-rct-aumenta-el-recuento-de-referencias"><a class="header" href="#la-clonación-de-un-rct-aumenta-el-recuento-de-referencias">La clonación de un <code>Rc&lt;T&gt;</code> aumenta el recuento de referencias</a></h3>
<p>Cambiemos nuestro ejemplo de trabajo en el listado 15-18 para que podamos ver
los recuentos de referencia cambiando a medida que creamos y soltamos
referencias al <code>Rc&lt;List&gt;</code> en <code>a</code>.</p>
<p>En el listado 15-19, cambiaremos <code>main</code> por lo que tiene un alcance interno
alrededor de la lista <code>c</code>; entonces podemos ver cómo cambia el recuento de
referencias cuando <code>c</code> sale del alcance.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listado 15-19: Imprimir el recuento de
referencias</span></p>
<p>En cada punto del programa donde cambia el recuento de referencias,
imprimimos el recuento de referencias, que podemos obtener llamando a la
función <code>Rc::strong_count</code>. Esta función se llama <code>strong_count</code> en lugar de
<code>count</code> porque el tipo <code>Rc&lt;T&gt;</code> también tiene un <code>weak_count</code>; veremos para
qué se usa <code>weak_count</code> en la sección “Prevención de ciclos de referencia”.</p>
<p>Este código imprime lo siguiente:</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Podemos ver que <code>Rc&lt;List&gt;</code> en <code>a</code> tiene un recuento de referencia inicial de
1; luego, cada vez que llamamos <code>clone</code>, el recuento aumenta en 1. Cuando <code>c</code>
sale del alcance, el recuento disminuye en 1. No tenemos que llamar a una
función para disminuir el recuento de referencias como tenemos que llame a
<code>Rc::clone</code> para aumentar el recuento de referencias: la implementación del
<em>trait</em> <code>Drop</code> disminuye el recuento de referencia automáticamente cuando un
valor <code>Rc&lt;T&gt;</code> sale del alcance.</p>
<p>Lo que no podemos ver en este ejemplo es que cuando <code>b</code> y luego <code>a</code> salen del
alcance al final de <code>main</code>, el conteo es entonces 0, y <code>Rc &lt;List&gt;</code> se limpia
completamente en ese punto. El uso de <code>Rc&lt;T&gt;</code> permite que un único valor
tenga múltiples propietarios, y el recuento asegura que el valor seguirá
siendo válido mientras que los propietarios sigan existiendo.</p>
<p>A través de referencias inmutables, <code>Rc&lt;T&gt;</code> le permite compartir datos entre
varias partes de su programa solo para lectura. Si <code>Rc&lt;T&gt;</code> le permitió tener
múltiples referencias mutables también, puede violar una de las reglas de
préstamo discutidas en el Capítulo 4: múltiples préstamos mutables en el
mismo lugar pueden causar <em>data races</em> e inconsistencias. ¡Pero ser capaz de
mutar datos es muy útil! En la siguiente sección, analizaremos el patrón de
mutabilidad interior y el tipo <code>RefCell &lt;T&gt;</code> que puede usar junto con un
<code>Rc&lt;T&gt;</code> para trabajar con esta restricción de inmutabilidad.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcell-t-y-el-patrón-de-mutabilidad-interior"><a class="header" href="#refcell-t-y-el-patrón-de-mutabilidad-interior"><code>RefCell &lt;T&gt;</code> y el patrón de mutabilidad interior</a></h2>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p><em>Interior mutability</em> es un patrón de diseño en Rust que le permite mutar
datos incluso cuando hay referencias inmutables a esos datos; normalmente,
esta acción no está permitida por las reglas de endeudamiento. Para mutar los
datos, el patrón usa el código <code>unsafe</code> dentro de una estructura de datos
para &quot;doblar&quot; las reglas habituales de Rust que rigen la mutación y el
préstamo. Todavía no hemos cubierto el código inseguro; lo haremos en el
Capítulo 19. Podemos usar tipos que usan el patrón de mutabilidad interior
cuando podemos asegurarnos de que se seguirán las reglas de endeudamiento en
el tiempo de ejecución, aunque el compilador no pueda garantizarlo. El código
<code>unsafe</code> involucrado se envuelve en una API segura, y el tipo externo sigue
siendo inmutable.</p>
<p>Exploremos este concepto mirando el tipo <code>RefCell &lt;T&gt;</code> que sigue el patrón de
mutabilidad interior.</p>
<h3 id="aplicación-de-las-reglas-de-préstamo-en-tiempo-de-ejecución-con-refcell-t"><a class="header" href="#aplicación-de-las-reglas-de-préstamo-en-tiempo-de-ejecución-con-refcell-t">Aplicación de las reglas de préstamo en tiempo de ejecución con <code>RefCell &lt;T&gt;</code></a></h3>
<p>A diferencia de <code>Rc&lt;T&gt;</code>, el tipo <code>RefCell&lt;T&gt;</code> representa propiedad única
sobre los datos que contiene. Entonces, ¿qué hace <code>RefCell&lt;T&gt;</code> diferente de
un tipo como <code>Box&lt;T&gt;</code>? Recuerde las reglas de préstamo que aprendió en el
Capítulo 4:</p>
<ul>
<li>En cualquier momento dado, puede tener <em>cualquiera</em> (pero no ambos) una
referencia mutable o cualquier número de referencias inmutables.</li>
<li>Las referencias siempre deben ser válidas.</li>
</ul>
<p>Con referencias y <code>Box&lt;T&gt;</code>, las invariantes de las reglas de préstamo se
aplican en tiempo de compilación. Con <code>RefCell&lt;T&gt;</code>, estas invariantes se
aplican <em>en tiempo de ejecución</em>. Con referencias, si rompe estas reglas,
obtendrá un error de compilación. Con <code>RefCell &lt;T&gt;</code>, si rompe estas reglas,
su programa entrará en pánico y saldrá.</p>
<p>Las ventajas de verificar las reglas de endeudamiento en tiempo de
compilación son que los errores se detectarán antes en el proceso de
desarrollo, y no hay impacto en el rendimiento del tiempo de ejecución porque
todo el análisis se completa de antemano. Por esas razones, verificar las
reglas de endeudamiento en el momento de la compilación es la mejor opción en
la mayoría de los casos, por lo que este es el valor predeterminado de Rust.</p>
<p>La ventaja de verificar las reglas de endeudamiento en tiempo de ejecución es
que ciertos escenarios seguros para la memoria están permitidos, mientras que
las verificaciones en tiempo de compilación no los permiten. El análisis
estático, como el compilador Rust, es intrínsecamente conservador. Algunas
propiedades del código son imposibles de detectar al analizar el código: el
ejemplo más famoso es el Problema de Detención, que está más allá del alcance
de este libro, pero es un tema interesante de investigar.</p>
<p>Debido a que algunos análisis son imposibles, si el compilador Rust no puede
estar seguro de que el código cumple con las reglas de propiedad, podría
rechazar un programa correcto; de esta manera, es conservador. Si Rust
aceptara un programa incorrecto, los usuarios no podrían confiar en las
garantías que Rust ofrece. Sin embargo, si Rust rechaza un programa correcto,
el programador tendrá inconvenientes, pero nada catastrófico puede ocurrir.
El tipo <code>RefCell&lt;T&gt;</code> es útil cuando estás seguro de que tu código sigue las
reglas de préstamo, pero el compilador no puede comprenderlo ni garantizarlo.</p>
<p>Similar para <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> solo se usa en escenarios de subproceso
único y le dará un error en tiempo de compilación si intenta usarlo en un
contexto multiproceso. Hablaremos sobre cómo obtener la funcionalidad de
<code>RefCell &lt;T&gt;</code> en un programa multiproceso en el Capítulo 16.</p>
<p>Aquí hay un resumen de las razones para elegir <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, o
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> permite múltiples propietarios de los mismos datos; <code>Box&lt;T&gt;</code> y
<code>RefCell &lt;T&gt;</code> tienen propietarios únicos.</li>
<li><code>Box &lt;T&gt;</code> permite tomar prestados inmutables o mutables en tiempo de
compilación; <code>Rc&lt;T&gt;</code> solo permite tomar prestados inmutables en tiempo de
compilación; <code>RefCell&lt;T&gt;</code> permite tomar prestados inmutables o mutables en
el tiempo de ejecución.</li>
<li>Debido a que <code>RefCell&lt;T&gt;</code> permite que los prestamos mutables se verifiquen
en el tiempo de ejecución, puede mutar el valor dentro de <code>RefCell&lt;T&gt;</code> incluso cuando <code>RefCell &lt;T&gt;</code> sea inmutable.</li>
</ul>
<p>La mutación del valor dentro de un valor inmutable es el patrón
<em>demutabilidad interior</em> (<em>interior mutability</em>). Veamos una situación en la
que la mutabilidad interior es útil y examinemos cómo es posible.</p>
<h3 id="mutabilidad-interior-un-préstamo-mutable-a-un-valor-inmutable"><a class="header" href="#mutabilidad-interior-un-préstamo-mutable-a-un-valor-inmutable">Mutabilidad interior: Un préstamo mutable a un valor inmutable</a></h3>
<p>Una consecuencia de las reglas de endeudamiento es que cuando tienes un valor
inmutable, no puedes tomarlo de forma mutable. Por ejemplo, este código no se
compilará:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>Si intentaste compilar este código, obtendrías el siguiente error:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<p>Sin embargo, hay situaciones en las que sería útil que un valor se mute en
sus métodos pero que parezca inmutable a otro código. El código fuera de los
métodos del valor no podría mutar el valor. El uso de <code>RefCell&lt;T&gt;</code> es una
forma de obtener la capacidad de tener mutabilidad interior. Pero
<code>RefCell&lt;T&gt;</code> no elude por completo las reglas de endeudamiento: el
verificador de préstamo en el compilador permite esta mutabilidad interior, y
las reglas de endeudamiento se verifican en tiempo de ejecución. Si infringe
las reglas, obtendrá un &quot;¡pánico!&quot; En lugar de un error de compilación.</p>
<p>Analicemos un ejemplo práctico donde podemos usar <code>RefCell&lt;T&gt;</code> para mutar un
valor inmutable y ver por qué es útil.</p>
<h4 id="un-caso-de-uso-para-la-mutación-interior-mock-objects"><a class="header" href="#un-caso-de-uso-para-la-mutación-interior-mock-objects">Un caso de uso para la mutación interior: <em>Mock Objects</em></a></h4>
<p>Un <em>test double</em> es el concepto de programación general para un tipo
utilizado en lugar de otro tipo durante la prueba. <em>Los objetos simulados</em>
(<em>Mock objects</em>) son tipos específicos para <em>test double</em> que registran lo
que sucede durante una prueba para que pueda afirmar que tuvieron lugar las
acciones correctas.</p>
<p>Rust no tiene objetos en el mismo sentido en que otros lenguajes tienen
objetos, y Rust no tiene una funcionalidad de objeto simulada incorporada en
la biblioteca estándar como lo hacen otros lenguajes. Sin embargo,
definitivamente puede crear una estructura que sirva los mismos propósitos
que un objeto simulado.</p>
<p>Este es el escenario que probaremos: crearemos una biblioteca que rastrea un
valor contra un valor máximo y envía mensajes en función de qué tan cerca
está el valor máximo del valor actual. Esta biblioteca podría usarse para
realizar un seguimiento de la cuota de un usuario para el número de llamadas
a la API que pueden hacer, por ejemplo.</p>
<p>Nuestra biblioteca solo brindará la funcionalidad de rastrear cuán cerca está
el máximo de un valor y cuáles deberían ser los mensajes en qué momento. Se
espera que las aplicaciones que usan nuestra biblioteca proporcionen el
mecanismo para enviar los mensajes: la aplicación podría poner un mensaje en
la aplicación, enviar un correo electrónico, enviar un mensaje de texto u
otra cosa. La biblioteca no necesita saber ese detalle. Todo lo que necesita
es algo que implemente un rasgo que proporcionaremos llamado <code>Messenger</code>. El
listado 15-20 muestra el código de la biblioteca:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 15-20: Una biblioteca para hacer un seguimiento
de cuán cerca está un valor de un valor máximo y advertir cuando el valor
está en ciertos niveles</span></p>
<p>Una parte importante de este código es que el <em>trait</em> <code>Messenger</code> tiene un
método llamado <code>send</code> que toma una referencia inmutable a <code>self</code> y al texto
del mensaje. Esta es la interfaz que nuestro <em>mock object</em> necesita tener.
La otra parte importante es que queremos probar el comportamiento del método
<code>set_value</code> en <code>LimitTracker</code>. Podemos cambiar lo que pasamos para el
parámetro <code>valor</code>, pero <code>set_value</code> no nos devuelve nada para hacer
afirmaciones. Queremos poder decir que si creamos un <code>LimitTracker</code> con algo
que implementa el <em>trait</em> <code>Messenger</code> y un valor particular para <code>max</code>,
cuando pasamos diferentes números para <code>value</code>, se le dice al mensajero que
envíe el mensaje apropiado .</p>
<p>Necesitamos un <em>mock object</em> que, en lugar de enviar un correo electrónico o
un mensaje de texto cuando llamemos a <code>send</code>, solo haga un seguimiento de los
mensajes que se le dice que envíe. Podemos crear una nueva instancia del
<em>mock object</em>, crear un <code>LimitTracker</code> que use el <em>mock object</em>, llamar al
método <code>set_value</code> en <code>LimitTracker</code>, y luego verificar que el <em>mock object</em>
tenga los mensajes que esperamos. El listado 15-21 muestra un intento de
implementar un <em>mock object</em> para hacer justamente eso, pero el <em>comprobador
de préstamos</em> (<em>borrow checker</em>) no lo permite:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 15-21: Un intento de implementar un
<code>MockMessenger</code> que no está permitido por el
<em>comprobador de préstamos</em> (<em>borrow checker</em>)</span></p>
<p>Este código de prueba define una estructura <code>MockMessenger</code> que tiene un
campo <code>send_messages</code> con valores <code>Vec</code> de <code>String</code> para hacer un seguimiento
de los mensajes que se le dice que envíe. También definimos una función
asociada <code>new</code> para que sea conveniente crear nuevos valores <code>MockMessenger</code>
que comiencen con una lista vacía de mensajes. Luego implementamos el <em>trait</em>
<code>Messenger</code> para <code>MockMessenger</code> para que podamos dar un <code>MockMessenger</code> a
<code>LimitTracker</code>. En la definición del método <code>send</code>, tomamos el mensaje pasado
como un parámetro y lo almacenamos en la lista <code>MockMessenger</code> de
<code>sent_messages</code>.</p>
<p>En la prueba, estamos probando qué sucede cuando se le dice al <code>LimitTracker</code>
que establezca <code>value</code> en algo que sea más del 75% del valor <code>max</code>. Primero,
creamos un nuevo <code>MockMessenger</code>, que comenzará con una lista vacía de
mensajes. Luego creamos un nuevo <code>LimitTracker</code> y le damos una referencia al
nuevo <code>MockMessenger</code> y un valor <code>max</code> de 100. Llamamos al método <code>set_value</code>
en <code>LimitTracker</code> con un valor de 80, que es más que 75 por ciento de 100.
Luego afirmamos que la lista de mensajes que el <code>MockMessenger</code> sigue de
cerca debería tener ahora un mensaje.</p>
<p>Sin embargo, hay un problema con esta prueba, como se muestra aquí:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<p>No podemos modificar el <code>MockMessenger</code> para realizar un seguimiento de los
mensajes, porque el método <code>send</code> toma una referencia inmutable a <code>self</code>.
Tampoco podemos tomar la sugerencia del texto de error para usar <code>&amp;mut self</code>
en su lugar, porque entonces la firma de <code>send</code> no coincidiría con la firma
en la definición de rasgo <code>Messenger</code> (no dude en probar y ver qué error
mensaje que obtienes).</p>
<p>¡Esta es una situación en la que la mutabilidad interior puede ayudar!
Almacenaremos <code>sent_messages</code> dentro de <code>RefCell&lt;T&gt;</code>, y luego el mensaje
<code>send</code> podrá modificar <code>send_messages</code> para almacenar los mensajes que hemos
visto. El listado 15-22 muestra cómo se ve:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">        limit_tracker.set_value(75);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 15-22: Usar <code>RefCell&lt;T&gt;</code> para mutar un valor
interno mientras que el valor externo se considera inmutable</span></p>
<p>El campo <code>sent_messages</code> ahora es de tipo<code> RefCell&lt;Vec&lt;String&gt;&gt;</code>en lugar de
<code>Vec&lt;String&gt;</code>. En la función <code>new</code>, creamos una nueva instancia 
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> alrededor del vector vacío.</p>
<p>Para la implementación del método <code>send</code>, el primer parámetro sigue siendo un
préstamo inmutable de <code>self</code>, que coincide con la definición del <em>trait</em>.
Llamamos <code>borrow_mut</code> en <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> en <code>self.sent_messages</code> para
obtener una referencia mutable al valor dentro de <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>,
que es el vector. Luego podemos llamar <code>push</code> en la referencia mutable al
vector para hacer un seguimiento de los mensajes enviados durante la prueba.</p>
<p>El último cambio que tenemos que hacer es la afirmación: para ver cuántos
elementos hay en el vector interno, llamamos <code>borrow</code> en
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>para obtener una referencia inmutable del vector.</p>
<p>Ahora que has visto cómo usar <code>RefCell&lt;T&gt;</code>, ¡profundizaremos en cómo funciona!</p>
<h4 id="mantener-el-seguimiento-de-los-préstamos-en-tiempo-de-ejecución-con-refcell-t"><a class="header" href="#mantener-el-seguimiento-de-los-préstamos-en-tiempo-de-ejecución-con-refcell-t">Mantener el seguimiento de los préstamos en tiempo de ejecución con <code>RefCell &lt;T&gt;</code></a></h4>
<p>Al crear referencias inmutables y mutables, usamos la sintaxis <code>&amp;</code> y <code>&amp;mut</code>,
respectivamente. Con <code>RefCell&lt;T&gt;</code>, usamos los métodos <code>borrow</code> y <code>borrow_mut</code>
que son parte de la API segura que pertenece a <code>RefCell&lt;T&gt;</code>. El método
<code>borrow</code> devuelve el tipo de puntero inteligente <code>Ref&lt;T&gt;</code>, y <code>borrow_mut</code>
devuelve el tipo de puntero inteligente <code>RefMut&lt;T&gt;</code>. Ambos tipos implementan
<code>Deref</code>, por lo que podemos tratarlos como referencias regulares.</p>
<p>El <code>RefCell&lt;T&gt;</code> realiza un seguimiento de cuántos punteros inteligentes
<code>Ref&lt;T&gt;</code> y <code>RefMut&lt;T&gt;</code> están actualmente activos. Cada vez que llamamos
<code>borrow</code>, <code>RefCell&lt;T&gt;</code> aumenta su cuenta de cuántos préstamos impagos están
activos. Cuando un valor <code>Ref&lt;T&gt;</code> sale del alcance, el recuento de préstamos
inmutables disminuye en uno. Al igual que las reglas de endeudamiento en
tiempo de compilación, <code>RefCell&lt;T&gt;</code> nos permite tener muchos préstamos
inmutables o un préstamo mutable en cualquier momento.</p>
<p>Si tratamos de violar estas reglas, en lugar de obtener un error de
compilación como lo haríamos con las referencias, la implementación de
<code>RefCell&lt;T&gt;</code> entrará en pánico en el tiempo de ejecución. El listado 15-23
muestra una modificación de la implementación de <code>send</code> en el listado 15-22.
Tratamos deliberadamente de crear dos préstamos mutables activos para el
mismo alcance para ilustrar que <code>RefCell&lt;T&gt;</code> nos impide hacer esto en tiempo
de ejecución.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<p><span class="caption">Listado 15-23: Creando dos referencias mutables en el
mismo ámbito para ver que <code>RefCell&lt;T&gt;</code> entrará en pánico</span></p>
<p>Creamos una variable <code>one_borrow</code> para el puntero inteligente
<code>RefMut&lt;T&gt;</code> devuelto por <code>borrow_mut</code>. Luego creamos otro préstamo mutable de
la misma manera en la variable <code>two_borrow</code>. Esto hace que dos referencias
mutables en el mismo ámbito, que no está permitido. Cuando ejecutamos las
pruebas para nuestra biblioteca, el código en el listado 15-23 compilará sin
ningún error, pero la prueba fallará:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Tenga en cuenta que el código entró en pánico con el mensaje
<code>already borrowed: BorrowMutError</code>. Así es como <code>RefCell&lt;T&gt;</code> maneja las
violaciones de las reglas de endeudamiento en tiempo de ejecución.</p>
<p>Capturar errores de préstamo en tiempo de ejecución en lugar de compilar
significa que encontrará un error en su código más adelante en el proceso de
desarrollo y posiblemente no hasta que su código se implemente en la
producción. Además, su código incurrirá en una pequeña penalización de
rendimiento en el tiempo de ejecución como resultado de realizar un
seguimiento de los préstamos en tiempo de ejecución en lugar de tiempo de
compilación. Sin embargo, el uso de <code>RefCell&lt;T&gt;</code> hace posible escribir un
objeto simulado que puede modificarse para llevar un registro de los mensajes
que ha visto mientras lo está usando en un contexto donde solo se permiten
valores inmutables. Puede usar <code>RefCell&lt;T&gt;</code> a pesar de sus compensaciones
para obtener más funcionalidad de la que proporcionan las referencias
regulares.</p>
<h3 id="tener-múltiples-propietarios-de-datos-mutables-mediante-la-combinación-de-rct-y-refcellt"><a class="header" href="#tener-múltiples-propietarios-de-datos-mutables-mediante-la-combinación-de-rct-y-refcellt">Tener múltiples propietarios de datos mutables mediante la combinación de <code>Rc&lt;T&gt;</code> y <code>RefCell&lt;T&gt;</code></a></h3>
<p>Una forma común de usar <code>RefCell&lt;T&gt;</code> es en combinación con <code>Rc&lt;T&gt;</code>. Recuerde
que <code>Rc&lt;T&gt;</code> te permite tener varios propietarios de algunos datos, pero solo
da acceso inmutable a esos datos. Si tiene un <code>Rc&lt;T&gt;</code> que contiene un
<code>RefCell &lt;T&gt;</code>, ¡puede obtener un valor que puede tener varios propietarios
<em>y</em> que puede mutar!</p>
<p>Por ejemplo, recuerde el ejemplo de la lista de contras en el listado 15-18
donde usamos <code>Rc&lt;T&gt;</code> para permitir que varias listas compartan la propiedad
de otra lista. Debido a que <code>Rc&lt;T&gt;</code> contiene solo valores inmutables, no
podemos cambiar ninguno de los valores en la lista una vez que los hemos
creado. Agreguemos <code>RefCell&lt;T&gt;</code> para obtener la capacidad de cambiar los
valores en las listas. El listado 15-24 muestra que al usar un <code>RefCell&lt;T&gt;</code>
en la definición <code>Cons</code>, podemos modificar el valor almacenado en todas las
listas:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listado 15-24: Usando <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> para crear
una <code>List</code> que podemos mutar</span></p>
<p>Creamos un valor que es una instancia de <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> y lo almacenamos
en una variable llamada <code>value</code> para que podamos acceder a él directamente
más tarde. Luego creamos una <code>List</code> en <code>a</code> con una variante <code>Cons</code> que
contiene <code>value</code>. Necesitamos clonar <code>value</code> para que tanto <code>a</code> como <code>value</code>
tengan la propiedad del valor interno <code>5</code> en lugar de transferir la propiedad
de <code>value</code> a <code>a</code> o pedir prestado <code>a</code> borrow de <code>value</code>.</p>
<p>Concluimos la lista <code>a</code> en <code>Rc&lt;T&gt;</code> así que cuando creamos las listas <code>b</code>
y <code>c</code>, ambos pueden referirse a <code>a</code>, que es lo que hicimos en el Listado
15-18.</p>
<p>Después de que hemos creado las listas en <code>a</code>, <code>b</code>, y <code>c</code>, agregamos 10 al
valor en <code>value</code>. Hacemos esto llamando <code>borrow_mut</code> en <code>value</code>, que usa la
función de eliminación de referencias automática que discutimos en el
Capítulo 5 (consulte la sección &quot;¿Dónde está el operador <code>-&gt;</code>?&quot;) Para
eliminar la referencia de <code>Rc&lt;T&gt;</code> al valor interno <code>RefCell&lt;T&gt;</code>. El método
<code>borrow_mut</code> devuelve un puntero inteligente <code>RefMut&lt;T&gt;</code>, y usamos el
operador de referencia en él y cambiamos el valor interno.</p>
<p>Cuando imprimimos <code>a</code>, <code>b</code>, y <code>c</code>, podemos ver que todos tienen el valor
modificado de 15 en lugar de 5:</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>¡Esta técnica es bastante ordenada! al usar <code>RefCell&lt;T&gt;</code>, tenemos un valor
<code>List</code> inmutable externamente. Pero podemos usar los métodos en <code>RefCell&lt;T&gt;</code>
que proporcionan acceso a su mutabilidad interior para que podamos modificar
nuestros datos cuando sea necesario. Los controles de tiempo de ejecución de
las reglas de préstamo nos protegen de las <em>carreras de datos</em> (<em>data races</em>)
y a veces vale la pena cambiar un poco la velocidad por esta flexibilidad en
nuestras estructuras de datos.</p>
<p>La biblioteca estándar tiene otros tipos que proporcionan mutabilidad
interior, como <code>Cell&lt;T&gt;</code>, que es similar excepto que en lugar de dar
referencias al valor interno, el valor se copia dentro y fuera de <code>Cell&lt;T&gt;</code>.
También hay <code>Mutex&lt;T&gt;</code>, que ofrece mutabilidad interior que es seguro para
usar en varios <em>hilos</em> (<em>threads</em>); discutiremos su uso en el Capítulo 16.
Consulte los documentos de la biblioteca estándar para obtener más detalles
sobre las diferencias entre estos tipos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="los-ciclos-de-referencia-pueden-perder-memoria"><a class="header" href="#los-ciclos-de-referencia-pueden-perder-memoria">Los ciclos de referencia pueden perder memoria</a></h2>
<p>Las garantías de seguridad de la memoria de Rust hacen que sea difícil, pero
no imposible, crear accidentalmente una memoria que nunca se limpia
(conocida como <em>pérdida/fuga de memoria</em> (<em>memory leak</em>). La prevención de
fugas de memoria por completo no es una de las garantías de Rust, del mismo
modo que no permite carreras de datos en tiempo de compilación, lo que
significa que las fugas de memoria son seguras para la memoria en Rust.
Podemos ver que Rust permite fugas de memoria usando <code>Rc&lt;T&gt;</code> y
<code>RefCell&lt;T&gt;</code>: es posible crear referencias donde los elementos se refieren
entre sí en un ciclo. Esto crea pérdidas de memoria porque el recuento de
referencias de cada elemento en el ciclo nunca llegará a 0, y los valores
nunca se descartarán.</p>
<h3 id="crear-un-ciclo-de-referencia"><a class="header" href="#crear-un-ciclo-de-referencia">Crear un ciclo de referencia</a></h3>
<p>Veamos cómo podría suceder un ciclo de referencia y cómo prevenirlo,
comenzando con la definición de la enumeración <code>List</code> y un método <code>tail</code>
en el Listado 15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listado 15-25: Una definición de lista de conscriptos
que contiene un <code>RefCell&lt;T&gt;</code> para que podamos modificar a qué se refiere una
variante <code>Cons</code></span></p>
<p>Estamos usando otra variación de la definición de <code>List</code> en el Listado 15-5.
El segundo elemento en la variante <code>Cons</code> ahora es <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, lo
que significa que en lugar de tener la capacidad de modificar el valor <code>i32</code>
como lo hicimos en el Listado 15-24, queremos modificar cual <code>List</code> value
está apuntando a una variante <code>Cons</code>. También estamos agregando un método de
<code>tail</code> para que sea conveniente para nosotros acceder al segundo elemento si
tenemos una variante <code>Cons</code>.</p>
<p>En el Listado 15-26, estamos agregando una función <code>main</code> que usa las
definiciones en el Listado 15-25. Este código crea una lista en <code>a</code> y una
lista en <code>b</code> que apunta a la lista en <code>a</code>. Luego modifica la lista en <code>a</code>
para apuntar a <code>b</code>, creando un ciclo de referencia. Hay declaraciones
<code>println!</code> A lo largo del camino para mostrar cuáles son los recuentos de
referencia en varios puntos de este proceso.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match *self {
</span><span class="boring">            Cons(_, ref item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Descomenta la siguiente línea para ver que tenemos un ciclo;
    // desbordará la pila
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listado 15-26: Creación de un ciclo de referencia de
dos valores <code>List</code> que apuntan el uno al otro</span></p>
<p>Creamos una instancia <code>Rc&lt;List&gt;</code> que contiene un valor <code>List</code> en la variable
<code>a</code> con una lista inicial de <code>5, Nil</code>. Luego creamos una instancia
<code>Rc&lt;List&gt;</code> que contiene otro valor <code>List</code> en la variable <code>b</code> que contiene el
valor 10 y apunta a la lista en <code>a</code>.</p>
<p>Modificamos <code>a</code> para que apunte a <code>b</code> en lugar de <code>Nil</code>, creando un ciclo.
Hacemos eso usando el método <code>tail</code> para obtener una referencia al
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> en <code>a</code>, que ponemos en la variable <code>link</code>. Luego usamos
el método <code>borrow_mut</code> en <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> para cambiar el valor dentro de
un <code>Rc&lt;List&gt;</code> que contiene un valor <code>Nil</code> al <code>Rc&lt;List&gt;</code> en <code>b</code>.</p>
<p>Cuando ejecutamos este código, manteniendo el último <code>println!</code>. Comentado por
el momento, obtendremos este resultado:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>El recuento de referencias de las instancias <code>Rc&lt;List&gt;</code> en <code>a</code> y <code>b</code> es 2
después de que cambiamos la lista en <code>a</code> para que apunte a <code>b</code>. Al final de
<code>main</code>, Rust intentará soltar <code>b</code> primero, lo que disminuirá el recuento en
cada una de las instancias <code>Rc&lt;List&gt;</code> en <code>a</code> y <code>b</code> en 1.</p>
<p>Sin embargo, debido a que <code>a</code> todavía hace referencia a <code>Rc&lt;List&gt;</code> que estaba
en <code>b</code>, ese <code>Rc&lt;List&gt;</code> tiene un recuento de 1 en lugar de 0, por lo que la
memoria <code>Rc&lt;List&gt;</code> tiene en el montículo no se eliminará. La memoria se quedará
allí con un conteo de 1, para siempre. Para visualizar este ciclo de
referencia, hemos creado un diagrama en la Figura 15-4.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figura 15-4: Un ciclo de referencia de listas <code>a</code> y <code>b</code>
que apuntan entre sí</span></p>
<p>Si elimina el último <code>println!</code> y ejecuta el programa, Rust intentará
imprimir este ciclo con <code>a</code> apuntando a <code>b</code> apuntando a <code>a</code> y así
sucesivamente hasta que desborda la pila.</p>
<p>En este caso, justo después de que creamos el ciclo de referencia, el programa finaliza. Las consecuencias de este ciclo no son muy graves. Sin
embargo, si un programa más complejo asignó mucha memoria en un ciclo y la retuvo durante mucho tiempo, el programa usaría más memoria de la necesaria y podría abrumar al sistema, haciendo que se quede sin memoria disponible.</p>
<p>Crear ciclos de referencia no se realiza fácilmente, pero tampoco es
imposible. Si tiene valores <code>RefCell&lt;T&gt;</code> que contienen valores <code>Rc&lt;T&gt;</code> o
anidados similares combinaciones de tipos con mutabilidad interior y recuento
de referencias, debe asegúrese de no crear ciclos; no puedes confiar en que
Rust los atrape. Crear un ciclo de referencia sería un error lógico en su
programa que debería utilizar pruebas automatizadas, revisiones de códigos y
otras prácticas de desarrollo de software para minimizar.</p>
<p>Otra solución para evitar ciclos de referencia es reorganizar sus datos
estructuras para que algunas referencias expresen propiedad y algunas
referencias no. Como resultado, puede tener ciclos formados por algunas
relaciones de propiedad y algunas relaciones que no son propiedad, y solo las
relaciones de propiedad afectan si se puede eliminar un valor o no en el
Listado 15-25, siempre queremos variantes <code>Cons</code> para poseer su lista, por lo
que no es posible reorganizar la estructura de datos. Veamos un ejemplo
utilizando gráficos formados por nodos principales y nodos secundarios
para ver cuándo las relaciones ajenas a la propiedad son una forma apropiada
de prevenir ciclos de referencia.</p>
<h3 id="evitar-ciclos-de-referencia-convertir-un-rct-en-un-weakt"><a class="header" href="#evitar-ciclos-de-referencia-convertir-un-rct-en-un-weakt">Evitar ciclos de referencia: Convertir un <code>Rc&lt;T&gt;</code> en un <code>Weak&lt;T&gt;</code></a></h3>
<p>Hasta ahora, hemos demostrado que llamar <code>Rc::clone</code> aumenta la
<code>strong_count</code> de una instancia <code>Rc&lt;T&gt;</code>, y una instancia <code>Rc &lt;T&gt;</code> solo se
limpia si su <code>strong_count</code> es 0. También puede crear una <em>referencia débil</em>
al valor dentro de una instancia <code>Rc&lt;T&gt;</code> invocando <code>Rc::downgrade</code> y pasando
una referencia a <code>Rc&lt;T&gt;</code>. Cuando llamas a <code>Rc::downgrade</code>, obtienes un
puntero inteligente del tipo <code>Weak&lt;T&gt;</code>. En lugar de aumentar el
<code>strong_count</code> en la instancia <code>Rc&lt;T&gt;</code> por 1, llamando <code>Rc::downgrade</code>
aumenta el <code>weak_count</code> por 1.
El tipo <code>Rc&lt;T&gt;</code> utiliza <code>weak_count</code> para realizar un seguimiento de cuántas
referencias <code>Weak&lt;T&gt;</code> existen, similares a <code>strong_count</code>. La diferencia es
<code>weak_count</code> no necesita ser 0 para que la instancia <code>Rc&lt;T&gt;</code> sea limpiada.</p>
<p>Las referencias fuertes son cómo puede compartir la propiedad de una instancia <code>Rc&lt;T&gt;</code>. Las referencias débiles no expresan una relación de propiedad. No provocarán un ciclo de referencia porque cualquier ciclo que
implique algunas referencias débiles se romperá una vez que el recuento
fuerte de referencias involucrado sea 0.</p>
<p>Debido a que el valor que las referencias de <code>Weak&lt;T&gt;</code> pueden haberse
descartado, para hacer cualquier cosa con el valor al que apunta <code>Weak&lt;T&gt;</code>,
debe asegurarse de que el valor aún exista. Haga esto llamando al método
<code>upgrade</code> en una instancia <code>Weak&lt;T&gt;</code>, que devolverá un <code>Option&lt;Rc&lt;T&gt;&gt;</code>.
Obtendrá un resultado de <code>Some</code> si el valor <code>Rc&lt;T&gt;</code> no se ha eliminado aún y
un resultado de <code>None</code> si se ha eliminado el valor <code>Rc&lt;T&gt;</code>. Como <code>upgrade</code>
devuelve un <code>Option&lt;T&gt;</code>, Rust se asegurará de que se manejen el caso <code>Some</code> y
el caso <code>None</code>, y que no habrá un puntero inválido.</p>
<p>Como ejemplo, en lugar de utilizar una lista cuyos elementos solo conozcan el
siguiente ítem, crearemos un árbol cuyos elementos conozcan sus elementos
secundarios <em>y</em> sus elementos principales.</p>
<h4 id="crear-una-estructura-tree-data-un-nodo-con-nodos-secundarios"><a class="header" href="#crear-una-estructura-tree-data-un-nodo-con-nodos-secundarios">Crear una estructura <em>Tree Data</em>: un <code>Nodo</code> con nodos secundarios</a></h4>
<p>Para empezar, construiremos un árbol con nodos que conozcan sus nodos
secundarios. Crearemos una estructura llamada <code>Node</code> que tenga su propio
valor <code>i32</code> y referencias a sus valores <code>Node</code> hijos:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Queremos un <code>Node</code> para poseer sus hijos, y queremos compartir esa propiedad
con variables para que podamos acceder a cada <code>Node</code> en el árbol
directamente. Para hacer esto, definimos los elementos <code>Vec&lt;T&gt;</code> para que
sean valores de tipo <code>Rc&lt;Node&gt;</code>. También queremos modificar qué nodos son
secundarios de otro nodo, por lo que tenemos un <code>RefCell&lt;T&gt;</code> en <code>children</code>
alrededor de <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>A continuación, usaremos nuestra definición de estructura y crearemos una
instancia <code>Node</code> llamada <code>leaf</code> con el valor 3 y no <em>children</em>, y otra
instancia llamada <code>branch</code> con el valor 5 y <code>leaf</code> como uno de sus hijos,
como se muestra en el listado 15-27:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">   children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listado 15-27: Creando un nodo <code>leaf</code> sin hijos y un
nodo <code>branch</code> con <code>leaf</code> como uno de sus hijos</span></p>
<p>Clonamos <code>Rc&lt;Node&gt;</code> en <code>leaf</code> y almacenamos eso en <code>branch</code>, lo que significa
que <code>Node</code> en <code>leaf</code> ahora tiene dos dueños: <code>leaf</code> y <code>branch</code>. Podemos pasar
de <code>branch</code> a<code> leaf</code> a <code>branch.children</code>, pero no hay forma de pasar de
<code>leaf</code> a <code>branch</code>. La razón es que <code>leaf</code> no hace referencia a <code>branch</code> y no
sabe que están relacionadas. Queremos que <code>leaf</code> sepa que <code>branch</code> es su
padre. Lo haremos a continuación.</p>
<h4 id="agregar-una-referencia-de-un-hijo-a-su-padre"><a class="header" href="#agregar-una-referencia-de-un-hijo-a-su-padre">Agregar una referencia de un hijo a su padre</a></h4>
<p>Para hacer que el nodo hijo esté al tanto de su elemento principal,
necesitamos agregar un campo <code>parent</code> a nuestra definición de estructura
<code>Node</code>. El problema está en decidir cuál debería ser el tipo de <code>parent</code>.
Sabemos que no puede contener un <code>Rc&lt;T&gt;</code>, porque eso crearía un ciclo de
referencia con <code>leaf.parent</code> apuntando a <code>branch</code> y <code>branch.children</code>
apuntando a <code>leaf</code>, lo que causaría su <code>strong_count</code> para nunca ser 0.</p>
<p>Al pensar en las relaciones de otra manera, un nodo padre debería ser dueño
de sus hijos: si se descarta un nodo padre, también se deben descartar sus
nodos secundarios. Sin embargo, un hijo no debería ser el propietario de su
padre: si eliminamos un nodo hijo, el padre debería existir. ¡Este es un caso
para referencias débiles!.</p>
<p>Entonces en lugar de <code>Rc&lt;T&gt;</code>, haremos que el tipo de <code>parent</code> use <code>Weak&lt;T&gt;</code>,
específicamente un <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Ahora nuestra definición de
estructura <code>Node</code> se ve así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Un nodo podrá hacer referencia a su nodo padre pero no posee su padre. En el
listado 15-28, actualizamos <code>main</code> para usar esta nueva definición para que
el nodo <code>leaf</code> tenga una manera de referirse a su elemento primario, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listado 15-28: Un nodo <code>leaf</code> con una referencia débil
a su <code>branch</code> nodo padre</span></p>
<p>La creación del nodo <code>leaf</code> es similar a la creación del nodo <code>leaf</code> en el
Listado 15-27 con la excepción del campo <code>parent</code>: <code>leaf</code> comienza sin un
padre, por lo que creamos una nueva <code>Weak&lt;Node&gt;</code> vacía instancia de
referencia.</p>
<p>En este punto, cuando tratamos de obtener una referencia al padre de <code>leaf</code>
utilizando el método <code>upgrade</code>, obtenemos un valor <code>None</code>. Vemos esto en el
resultado de la primera declaración <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Cuando creamos el nodo <code>branch</code>, también tendrá una nueva referencia
<code>Weak&lt;Node&gt;</code>en el campo <code>parent</code>, porque <code>branch</code> no tiene un nodo padre.
Todavía tenemos <code>leaf</code> como uno de los hijos de <code>branch</code>. Una vez que tenemos
la instancia <code>Node</code> en <code>branch</code>, podemos modificar <code>leaf</code> para darle una
referencia <code>Weak&lt;Node&gt;</code> a su padre. Usamos el método <code>borrow_mut</code> en
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> en el campo <code>parent</code> de <code>leaf</code>, y luego usamos la
función <code>Rc::downgrade</code> para crear <code>Weak&lt;Node&gt;</code> referencia a <code>branch</code> desde
<code>Rc&lt;Node&gt;</code> en <code>branch</code>.</p>
<p>Cuando imprimimos el padre de <code>leaf</code> nuevamente, esta vez obtendremos una
variante <code>Some</code> sosteniendo <code>branch</code>: ¡ahora <code>leaf</code> puede acceder a su padre!
Cuando imprimimos <code>leaf</code>, también evitamos el ciclo que finalmente terminó en
un desbordamiento de pila como el que teníamos en el Listado 15-26; las
referencias <code>Weak&lt;Node&gt;</code> se imprimen como <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>La falta de salida infinita indica que este código no creó un ciclo de
referencia. También podemos decir esto mirando los valores que obtenemos al
llamar <code>Rc::strong_count</code> y <code>Rc::weak_count</code>.</p>
<h4 id="visualización-de-cambios-en-strong_count-y-weak_count"><a class="header" href="#visualización-de-cambios-en-strong_count-y-weak_count">Visualización de cambios en <code>strong_count</code> y <code>weak_count</code></a></h4>
<p>Veamos cómo cambian los valores <code>strong_count</code> y <code>weak_count</code> de las
instancias <code>Rc&lt;Node&gt;</code> al crear un nuevo ámbito interno y mover la creación de
<code>branch</code> a ese ámbito. Al hacerlo, podemos ver qué sucede cuando <code>branch</code> se
crea y luego se descarta cuando sale del alcance. Las modificaciones se
muestran en el listado 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Listado 15-29: Crea <code>branch</code> en un ámbito interno y
examina los recuentos de referencia fuertes y débiles</span></p>
<p>Después de que se crea <code>leaf</code>, su <code>Rc &lt;Node&gt;</code> tiene un recuento fuerte de 1 y un recuento débil de 0. En el ámbito interno, creamos <code>branch</code> y lo asociamos
con <code>leaf</code>, en cuyo punto cuando imprimimos los conteos, <code>Rc&lt;Node&gt;</code> en
<code>branch</code> tendrá un recuento fuerte de 1 y un conteo débil de 1
(para el señalamiento <code>leaf.parent</code> a <code>branch</code> con un <code>Weak&lt;Node&gt;</code>). Cuando
imprimimos los recuentos en <code>leaf</code>, veremos tendrá una cuenta fuerte de 2,
porque <code>branch</code> ahora tiene un clon del <code>Rc&lt;Node&gt;</code> de <code>leaf</code> almacenado en
<code>branch.children</code>, pero aún tendrá un conteo débil de 0.</p>
<p>Cuando el alcance interno finaliza, <code>branch</code> sale del alcance y el recuento fuerte de el <code>Rc&lt;Node&gt;</code> disminuye a 0, por lo que su <code>Node</code> se elimina. El
conteo débil de 1 de <code>leaf.parent</code> no tiene relación con si <code>Node</code> se cae o
no, así que ¡así que no tenemos pérdidas de memoria!.</p>
<p>Si tratamos de acceder al padre de <code>leaf</code> después del final del alcance,
obtendremos <code>Nine</code> de nuevo. Al final del programa, <code>Rc&lt;Node&gt;</code> en <code>leaf</code>
tiene un recuento fuerte de 1 y un conteo débil de 0, porque la variable
<code>leaf</code> ahora es la única referencia al <code>Rc&lt;Node&gt;</code> de nuevo.</p>
<p>Toda la lógica que maneja los conteos y la caída de valor está integrada en
<code>Rc&lt;T&gt;</code> y <code>Weak&lt;T&gt;</code> y sus implementaciones del <em>trait</em> <code>Drop</code>. Por
especificando que la relación entre un hijo y su padre debe ser una
referencia <code>Weak&lt;T&gt;</code> en la definición de <code>Nodo</code>, puede hacer que los nodos principales apunten a nodos secundarios y viceversa sin crear un ciclo de referencia y pérdidas de memoria.</p>
<h2 id="resumen-13"><a class="header" href="#resumen-13">Resumen</a></h2>
<p>Este capítulo cubrió cómo usar punteros inteligentes para hacer diferentes
garantías y compensaciones de las que Rust fabrica por defecto con
referencias regulares. El tipo <code>Box&lt;T&gt;</code> tiene un tamaño conocido y apunta a
los datos asignados en el montículo. El tipo <code>Rc&lt;T&gt;</code> realiza un seguimiento
del número de referencias a los datos en el montículo para que los datos
puedan tener varios propietarios. El tipo <code>RefCell&lt;T&gt;</code> con su mutabilidad
interior nos da un tipo que podemos usar cuando necesitamos un tipo inmutable
pero necesitamos cambiar un valor interno de ese tipo; también aplica las
reglas de endeudamiento en tiempo de ejecución en lugar de en tiempo de
compilación.</p>
<p>También se discutieron los <em>trait</em> <code>Deref</code> y <code>Drop</code>, que permiten una gran
cantidad de la funcionalidad de punteros inteligentes. Exploramos los ciclos
de referencia que pueden causar pérdidas de memoria y cómo evitar que usen
<code>Weak&lt;T&gt;</code>.</p>
<p>Si este capítulo despertó su interés y desea implementar sus propios
indicadores inteligentes, consulte <a href="https://doc.rust-lang.org/stable/nomicon/">“The Rustonomicon”</a> para obtener más información útil.</p>
<p>A continuación, hablaremos de concurrencia en Rust. Incluso aprenderá sobre
algunos nuevos <em>punteros inteligentes</em> (<em>smart pointers</em>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency"><a class="header" href="#fearless-concurrency">Fearless Concurrency</a></h1>
<p>Manejar la programación concurrente de manera segura y eficiente es otro de
los principales objetivos de Rust. <em>La programación simultánea</em> (<em>Concurrent
programming</em>), donde las diferentes partes de un programa se ejecutan de
manera independiente, y la <em>programación paralela</em> (<em>parallel programming</em>),donde diferentes partes de un programa se ejecutan al mismo tiempo, son cada
vez más importantes a medida que más computadoras aprovechan sus múltiples
procesadores. Históricamente, la programación en estos contextos ha sido
difícil y propensa a errores: Rust espera cambiar eso.</p>
<p>Inicialmente, el equipo de Rust pensó que garantizar la seguridad de la
memoria y prevenir los problemas de concurrencia eran dos desafíos separados
que debían resolverse con diferentes métodos. Con el tiempo, el equipo
descubrió que los sistemas de propiedad y tipo son un poderoso conjunto de
herramientas para ayudar a administrar los problemas de simultaneidad de
seguridad <em>y</em> de la memoria. Al aprovechar la propiedad y la verificación de
tipos, muchos errores de concurrencia son errores de tiempo de compilación en
Rust en lugar de errores de tiempo de ejecución. Por lo tanto, en lugar de
hacerle perder mucho tiempo tratando de reproducir las circunstancias exactas
en las que se produce un error de simultaneidad de tiempo de ejecución, el
código incorrecto se negará a compilar y presentará un error explicando el
problema. Como resultado, puede corregir su código mientras está trabajando
en él, en lugar de hacerlo potencialmente después de que se haya enviado a
producción. Hemos apodado este aspecto de Rust <em>fearless</em> <em>concurrency</em>. La
concurrencia imprudente le permite escribir código libre de errores sutiles y
es fácil de refactorizar sin introducir nuevos errores.</p>
<blockquote>
<p>Nota: por simplicidad, nos referiremos a muchos de los problemas como
<em>concurrente</em> en lugar de ser más precisos diciendo
<em>concurrente y/o paralelo</em>. Si este libro tratase sobre concurrencia y/o
paralelismo, seríamos más específicos. Para este capítulo, sustituya
mentalmente <em>concurrente y/o paralelo</em> siempre que usemos <em>concurrente</em>.</p>
</blockquote>
<p>Muchos lenguajes son dogmáticos sobre las soluciones que ofrecen para manejar
problemas concurrentes. Por ejemplo, Erlang tiene una funcionalidad elegante
para la simultaneidad de paso de mensajes pero solo tiene formas oscuras de
compartir estado entre hilos. Respaldar solo un subconjunto de posibles
soluciones es una estrategia razonable para lenguajes de nivel superior,porque un lenguaje de nivel superior promete beneficios al ceder algún
control para obtener abstracciones. Sin embargo, se espera que los lenguajes
de nivel inferior proporcionen la solución con el mejor rendimiento en
cualquier situación dada y tengan menos abstracciones sobre el hardware. Por
lo tanto, Rust ofrece una variedad de herramientas para modelar problemas de
la manera que sea apropiada para su situación y sus requisitos.</p>
<p>Estos son los temas que trataremos en este capítulo:</p>
<ul>
<li>Cómo crear <em>hilos</em> (<em>threads</em>) para ejecutar múltiples piezas de código al mismo tiempo</li>
<li><em>Concurrencia de mensaje</em>, donde los canales envían mensajes entre <em>hilos</em>   (<em>threads</em>)</li>
<li><em>Concurrencia de estado compartido</em>, donde varios subprocesos tienen acceso
a algún dato</li>
<li>Los <em>trait</em> <code>Sync</code> y <code>Send</code>, que extienden las garantías de concurrencia de
Rust a los tipos definidos por el usuario, así como a los tipos proporcionados por la biblioteca estándar</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usar-hilos-threads-para-ejecutar-código-simultáneamente"><a class="header" href="#usar-hilos-threads-para-ejecutar-código-simultáneamente">Usar hilos <em>Threads</em> para ejecutar código simultáneamente</a></h2>
<p>En la mayoría de los sistemas operativos actuales, el código de un programa
ejecutado se ejecuta en <em>proceso</em> y el sistema operativo administra múltiples
procesos a la vez. Dentro de su programa, también puede tener partes
independientes que se ejecutan simultáneamente. Las características que
ejecutan estas partes independientes se llaman <em>hilos</em> (<em>threads</em>).</p>
<p>La división de la computación en su programa en múltiples hilos puede mejorar
el rendimiento porque el programa realiza múltiples tareas al mismo tiempo,
pero también agrega complejidad. Debido a que los hilos se pueden ejecutar
simultáneamente, no hay garantía inherente sobre el orden en que se
ejecutarán partes de su código en diferentes hilos. Esto puede ocasionar
problemas, como:</p>
<ul>
<li>Condiciones de carrera, donde los hilos están accediendo a los datos o
recursos en un orden inconsistente</li>
<li><em>Deadlocks</em>, donde dos subprocesos están esperando el uno al otro para
terminar usando un recurso que tiene el otro subproceso, evitando que ambos
subprocesos continúen</li>
<li>Errores que ocurren solo en ciertas situaciones y son difíciles de
reproducir y corregir confiablemente</li>
</ul>
<p>Rust intenta mitigar los efectos negativos del uso de hilos, pero
la programación en un contexto multiproceso todavía requiere una reflexión
cuidadosa y requiere una estructura de código que es diferente de la de los
programas que se ejecutan en un solo hilo.</p>
<p>Los lenguajes de programación implementan subprocesos de diferentes formas.
Muchos de los sistemas operativos proporcionan una API para crear nuevos
hilos. Este modelo donde un lenguaje llama a las API del sistema operativo
para crear subprocesos a veces se llama <em>1:1</em>, es decir, un hilo del sistema operativo por hilo de un lengunaje.</p>
<p>Muchos lenguajes de programación proporcionan su propia implementación
especial de hilos. Los hilos de programación proporcionados por el lebguaje
se conocen como hilos <em>verdes</em>, y los lenguajes que usan estos hilos verdes
los ejecutarán en el contexto de un diferente número de hilos del sistema
operativo. Por esta razón, el modelo de subproceso verde se llama modelo
<em>M:N</em> : hay <code>M</code> subprocesos verdes por <code>N</code> hilos del sistema operativo,
donde <code>M</code> y <code>N</code> no son necesariamente los mismos número.</p>
<p>Cada modelo tiene sus propias ventajas y desventajas, y la compensación más
importante para Rust es el soporte en tiempo de ejecución. <em>Runtime</em> es un término confuso y puede tener diferentes significados en diferentes contextos.</p>
<p>En este contexto, por <em>runtime</em> nos referimos al código que está incluido en
el lenguaje en cada binario este código puede ser grande o pequeño según el
lenguaje, pero cada lenguaje no ensamblado tendrá una cierta cantidad de
código de tiempo de ejecución. Por esa razón, coloquialmente cuando las
personas dicen que un lenguaje no tiene “tiempo de ejecución”, a menudo
significa “tiempo de ejecución pequeño” (<em>“small runtime.”</em>). Los tiempos de
ejecución más pequeños tienen menos funciones pero tienen el
ventaja de dar como resultado binarios más pequeños, que hacen que sea más
fácil combinar el lenguaje con otros lenguajes en más contextos. Aunque
muchos lenguajes están bien para aumentar el tamaño del tiempo de ejecución a
cambio de más características, Rust no necesita casi tiempo de ejecución y no
puede comprometerse a poder llamar a C para mantener el rendimiento.</p>
<p>El modelo <em>green-threading</em> M: N requiere un tiempo de ejecución de lenguaje
más grande para administrar <em>threads</em>. Como tal, la biblioteca estándar de
Rust solo proporciona una implementación de 1:1 <em>threading</em>. Debido a que
Rust es un lenguaje de bajo nivel, hay <em>crates</em> que implemente el <em>threading</em>
M:N
if you would rather trade overhead for aspects such as more control over
which threads run when and lower costs of context switching, for example.</p>
<p>Ahora que hemos definido los hilos en Rust, exploremos cómo usar el
API relacionada con hilos proporcionada por la biblioteca estándar.</p>
<h3 id="creando-un-nuevo-hilo-thread-con-spawn"><a class="header" href="#creando-un-nuevo-hilo-thread-con-spawn">Creando un nuevo hilo <em>Thread</em> con <code>spawn</code></a></h3>
<p>Para crear un nuevo hilo, llamamos a la función <code>thread::spawn</code> y le pasamos
un <em>closure</em> (hablamos de <em>closure</em> en el Capítulo 13) que contiene el código
que queremos ejecutar en el nuevo hilo. El ejemplo en el listado 16-1 imprime
un texto de un hilo principal y otro texto de un nuevo hilo:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Listado 16-1: Creando un nuevo hilo para imprimir una
cosa mientras el hilo principal imprime algo más</span></p>
<p>Tenga en cuenta que con esta función, el nuevo <em>thread</em> se detendrá cuando e
hilo principal finalice, haya terminado de ejecutarse o no. El resultado de
este programa puede ser un poco diferente cada vez, pero se verá de manera
similar a lo siguiente:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Las llamadas a <code>thread::sleep</code> obligan a un hilo a detener su ejecución
durante un breve período de tiempo, permitiendo la ejecución de un hilo
diferente. Los hilos probablemente se turnarán, pero eso no está garantizado:
depende de cómo el sistema operativo programa los hilos. En esta ejecución,
el hilo principal se imprimió primero, aunque la declaración de impresión del
hilo generado aparece primero en el código. Y a pesar de que le dijimos al
hilo generado que se imprimiera hasta que <code>i</code> sea 9, solo llegó a 5 antes de
que el hilo principal se apagara.</p>
<p>Si ejecuta este código y solo ve el resultado del hilo principal, o no ve
ninguna superposición, intente aumentar los números en los rangos para crear
más oportunidades para que el sistema operativo cambie entre los hilos.</p>
<h3 id="esperando-a-que-todos-los-hilos-terminen-usando-join-handles"><a class="header" href="#esperando-a-que-todos-los-hilos-terminen-usando-join-handles">Esperando a que todos los hilos terminen usando <code>join</code> <em>Handles</em></a></h3>
<p>El código en el listado 16-1 no solo detiene el subproceso <em>engendrado</em>
(<em>spawned</em>) prematuramente la mayor parte del tiempo debido al final del
subproceso principal, sino que tampoco puede garantizar que el subproceso
generado se ejecute en absoluto. ¡La razón es que no hay garantía sobre el
orden en que se ejecutan los hilos!</p>
<p>Podemos solucionar el problema de que el subproceso generado no se ejecute, o
no se ejecute por completo, al guardar el valor de retorno de
<code>thread::spawn</code> en una variable. El tipo de devolución de <code>thread::spawn</code> es
<code>JoinHandle</code>. Un <code>JoinHandle</code> es un valor propio que, cuando llamemos al
método <code>join</code>, esperará a que su subproceso termine. El listado 16-2 muestra
cómo usar el <code>JoinHandle</code> del hilo que creamos en el listado 16-1 y llamar
<code>join</code> para asegurarse de que el hilo generado termine antes de que <code>main</code>
salga:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listado 16-2: Guardar un <code>JoinHandle</code> de
<code>thread::spawn</code> para garantizar que el hilo se ejecuta hasta su
finalización</span></p>
<p>Llamar a <code>join</code> en el <em>handle</em> bloquea el hilo que se está ejecutando
actualmente hasta que termina el hilo representado por el <em>handle</em>.
<em>Bloquear</em> un hilo significa que el hilo no puede funcionar o salir.
Debido a que hemos llamado <code>join</code> después del ciclo <code>for</code> del hilo principal,
la ejecución del Listado 16-2 debería producir un resultado similar al siguiente:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Los dos hilos continúan alternando, pero el hilo principal espera debido a la
llamada a <code>handle.join()</code> y no termina hasta que finaliza el hilo generado.</p>
<p>Pero veamos qué sucede cuando movemos <code>handle.join()</code> antes del bucle <code>for</code>
en <code>main</code>, así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>El hilo principal esperará a que termine el hilo generado (spawned) y luego ejecutará su ciclo <code>for</code>, por lo que la salida ya no se intercalará, como se
muestra aquí:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Los pequeños detalles, como donde se llama a <code>join</code>, pueden afectar si sus
hilos se ejecutan al mismo tiempo o no.</p>
<h3 id="usar-move-closures-con-threads"><a class="header" href="#usar-move-closures-con-threads">Usar <code>move</code> <em>Closures</em> con <em>Threads</em></a></h3>
<p>El <code>move</code> <em>closure</em> se usa a menudo junto con <code>thread::spawn</code> porque le
permite usar datos de un hilo en otro hilo.</p>
<p>En el Capítulo 13, mencionamos que podemos usar la palabra clave <code>move</code> antes
de la lista de parámetros de un <em>closure</em> para forzar al <em>closure</em> a tomar
posesión de los valores que utiliza en el entorno. Esta técnica es
especialmente útil cuando se crean nuevos hilos para transferir la propiedad
de los valores de un hilo a otro.</p>
<p>Observe en el listado 16-1 que el <em>closure</em> que pasamos a <code>thread::spawn</code> no
toma argumentos: no estamos usando ningún dato del hilo principal en el
código del hilo generado. Para usar datos del hilo principal en el hilo
generado, el <em>closure</em> del hilo engendrado debe capturar los valores que
necesita. El listado 16-3 muestra un intento de crear un vector en el hilo
principal y usarlo en el hilo generado. Sin embargo, esto aún no funcionará,
como verá en un momento.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listado 16-3: Intentando usar un vector creado por el
hilo principal en otro hilo</span></p>
<p>El <em>closure</em> utiliza <code>v</code>, por lo que capturará <code>v</code> y lo convertirá en parte
del entorno del <em>closure</em>. Debido a que <code>thread::spawn</code> ejecuta este
<em>closure</em> en un nuevo hilo, deberíamos poder acceder a <code>v</code> dentro del nuevo
hilo. Pero cuando compilamos este ejemplo, obtenemos el siguiente error:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Rust <em>infiere</em> cómo capturar <code>v</code>, y porque <code>println!</code> solo necesita una
referencia a <code>v</code>, el <em>closure</em> intenta tomar prestado <code>v</code>. Sin embargo, hay
un problema: Rust no puede decir cuánto tiempo se ejecutará el subproceso
generado, por lo que no sabe si la referencia a <code>v</code> siempre será válida.</p>
<p>El listado 16-4 proporciona un escenario que es más probable que tenga una
referencia a <code>v</code> que no será válida:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listado 16-4: Un hilo con un <em>closure</em> que intenta
capturar una referencia a <code>v</code> de un hilo principal que suelta <code>v</code></span></p>
<p>Si se nos permitiera ejecutar este código, existe la posibilidad de que el
hilo generado se ponga inmediatamente en segundo plano sin ejecutar en
absoluto. El hilo generado tiene una referencia a <code>v</code> dentro, pero el hilo
principal cae inmediatamente <code>v</code>, usando la función <code>drop</code> que discutimos en
el Capítulo 15. Luego, cuando el hilo engendrado comienza a ejecutarse, <code>v</code>
ya no está válido, por lo que una referencia al mismo tampoco es válida. ¡Oh
no!</p>
<p>Para corregir el error del compilador en el listado 16-3, podemos usar los
consejos del mensaje de error:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Al agregar la palabra clave <code>mover</code> antes del <em>closure</em>, forzamos al
<em>closure</em> a tomar posesión de los valores que está usando en lugar de
permitir que Rust infiera que debe tomar prestados los valores. La
modificación del listado 16-3 que se muestra en el listado 16-5 se compilará
y ejecutará según lo que pretendemos:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listado 16-5: Usar la palabra clave <code>move</code> para forzar
a un <em>closure</em> a tomar posesión de los valores que usa</span></p>
<p>¿Qué pasaría con el código en el listado 16-4 donde el hilo principal llamado
<code>drop</code> si usamos un <em>closure</em> <code>move</code>?, ¿<code>move</code> arreglaría ese caso?.
Lamentablemente no; obtendríamos un error diferente porque lo que el listado
16-4 intenta hacer no está permitido por un motivo diferente. Si agregamos
<code>move</code> al <em>closure</em>, moveríamos <code>v</code> al entorno del <em>closure</em>, y ya no
podríamos llamar <code>drop</code> en el hilo principal. Obtendríamos este error de
compilación en su lugar:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>¡Las reglas de propiedad de Rust nos han salvado de nuevo! Obtuvimos un error
del código en el listado 16-3 porque Rust estaba siendo conservador y solo
pedía prestado <code>v</code> para el hilo, lo que significaba que el hilo principal
podría invalidar teóricamente la referencia del hilo generado. Al decirle a
Rust que mueva la propiedad de <code>v</code> al hilo generado, le garantizamos a Rust
que el hilo principal ya no usará <code>v</code>. Si cambiamos el Listado 16-4 de la
misma manera, entonces estamos violando las reglas de propiedad cuando
tratamos de usar <code>v</code> en el hilo principal. La palabra clave <code>move</code> anula el
valor predeterminado de préstamo de Rust; no nos permite violar las reglas de
propiedad.</p>
<p>Con una comprensión básica de los hilos y la API del hilo, veamos qué podemos
<em>hacer</em> con los hilos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="uso-message-passing-para-transferir-datos-entre-hilos"><a class="header" href="#uso-message-passing-para-transferir-datos-entre-hilos">Uso <em>Message Passing</em> para transferir datos entre hilos</a></h2>
<p>Un enfoque cada vez más popular para garantizar la concurrencia segura es
<em>message passing</em>, donde los hilos o actores se comunican enviándose mensajes
que contienen datos. Aquí está la idea en un lema de
<a href="http://golang.org/doc/effective_go.html">the Go language documentation</a>:  &quot;Do not communicate by sharing memory; instead, share memory by communicating&quot;.</p>
<p>Una herramienta importante que Rust tiene para lograr la concurrencia deenvío de mensajes es el <em>channel</em>, un concepto de programación que la biblioteca
estándar de Rust proporciona implementación de. Puedes imaginar un canal en
la programación como algo así como un canal de agua, como un arroyo o un río.
Si pones algo así como pato de goma o barco en una corriente, viajará río
abajo hasta el final de la camino acuático.</p>
<p>Un canal en programación tiene dos mitades: un transmisor y un receptor. los
La mitad del transmisor es la ubicación aguas arriba donde se colocan patos
de goma en el río, y la mitad del receptor es donde el pato de goma termina
río abajo. Uno parte de su código llama métodos en el transmisor con los
datos que desea enviar, y otra parte verifica el destinatario para los
mensajes que llegan. Se dice que el canal está <em>cerrado</em> si la mitad del transmisor o del receptor está caído.</p>
<p>Aquí, trabajaremos en un programa que tiene un hilo para generar valores y
enviarlos por un canal, y otro hilo que recibirá los valores y
imprimirlos. Vamos a enviar valores simples entre hilos usando un canal
para ilustrar la característica. Una vez que esté familiarizado con la
técnica, podría usa canales para implementar un sistema de chat o un sistema
donde se realizan muchos subprocesos partes de un cálculo y enviar las partes
a un hilo que agrega el resultados.</p>
<p>Primero, en el listado 16-6, crearemos un canal pero no haremos nada con él.
Tenga en cuenta que esto aún no se compilará porque Rust no puede decir qué
tipo de valores quiero enviar por el canal.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
<span class="boring">    tx.send(()).unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">Listado 16-6: Creando un canal y asignando las dos
mitades a <code>tx</code> y <code>rx</code></span></p>
<p>Creamos un nuevo canal usando la función <code>mpsc::channel</code>; <code>mpsc</code> significa
<em>productor múltiple, consumidor único</em>
(<em>multiple producer, single consumer</em>). En resumen, la forma en que la
biblioteca estándar de Rust implementa canales significa que un canal puede
tener múltiples <em>envíos</em> finales que producen valores pero solo un
<em>receptor</em> final que consume esos valores. Imagina que varias corrientes
fluyen juntas en un gran río: todo lo que se envíe a través de cualquiera de
las corrientes terminará en un río al final. Comenzaremos con un solo
productor por ahora, pero agregaremos varios productores cuando este ejemplo
funcione.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>La función <code>mpsc::channel</code> devuelve una tupla, cuyo primer elemento es el
extremo que envía y el segundo elemento es el extremo receptor. Las
abreviaturas <code>tx</code> y <code>rx</code> se usan tradicionalmente en muchos campos para
<em>transmisor</em> y <em>receptor</em> respectivamente, por lo que nombramos nuestras
variables como tales para indicar cada extremo. Estamos usando una
declaración <code>let</code> con un patrón que destruye las tuplas; discutiremos el uso
de patrones en sentencias <code>let</code> y la desestructuración en el Capítulo 18.
Usar una declaración <code>let</code> de esta manera es un enfoque conveniente para
extraer las piezas de la tupla devuelta por <code>mpsc::channel</code>.</p>
<p>Movamos el extremo transmisor a un hilo generado y hagamos que envíe una
cadena para que el hilo engendrado se comunique con el hilo principal, como
se muestra en el Listado 16-7. Esto es como poner un pato de goma en el río
río arriba o enviar un mensaje de chat de un hilo a otro.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Listado 16-7: Mover <code>tx</code> a un hilo generado y enviar
“hi”</span></p>
<p>De nuevo, estamos usando <code>thread::spawn</code> para crear un nuevo hilo y luego
usando <code>move</code> para mover <code>tx</code> al <em>closure</em> para que el hilo generado tenga
<code>tx</code>. El subproceso generado necesita poseer el extremo de transmisión del
canal para poder enviar mensajes a través del canal.</p>
<p>El extremo transmisor tiene un método de <code>send</code> que toma el valor que
queremos enviar. El método <code>send</code> devuelve un tipo <code>Result &lt;T, E&gt;</code>, por lo
que si el extremo receptor ya se ha eliminado y no hay ningún lugar para
enviar un valor, la operación de envío devolverá un error. En este ejemplo,
llamamos <code>unwrap</code> al pánico en caso de error. Pero en una aplicación real, lo
manejaríamos correctamente: regrese al Capítulo 9 para revisar estrategias
para el manejo correcto de errores.</p>
<p>En el listado 16-8, obtendremos el valor del extremo receptor del canal en el
hilo principal. Esto es como recuperar el pato de goma del agua al final del
río o como recibir un mensaje de chat.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Listado 16-8: Recibir el valor “hi” en el hilo
principal e imprimirlo</span></p>
<p>El extremo receptor de un canal tiene dos métodos útiles: <code>recv</code> y
<code>try_recv</code>. Estamos usando <code>recv</code>, abreviatura de <em>receive</em>, que bloqueará la
ejecución del hilo principal y esperará hasta que se envíe un valor por el
canal. Una vez que se envía un valor, <code>recv</code> lo devolverá en un
<code>Result &lt;T, E&gt;</code>. Cuando el extremo emisor del canal se cierra, <code>recv</code>
devolverá un error para indicar que no vendrán más valores.</p>
<p>El método <code>try_recv</code> no bloquea, sino que devuelve inmediatamente un
<code>Result &lt;T, E&gt;</code>: un valor <code>Ok</code> que contiene un mensaje si hay uno disponible
y un valor <code>Err</code> si no hay ningún mensaje esta vez. El uso de <code>try_recv</code> es
útil si este hilo tiene otro trabajo pendiente mientras se esperan mensajes:
podríamos escribir un ciclo que llame <code>try_recv</code> de vez en cuando, maneje un
mensaje si hay uno disponible y haga otro trabajo por un tiempo hasta que
vuelva a verificar.</p>
<p>Hemos usado <code>recv</code> en este ejemplo por simplicidad; no tenemos otro trabajo
para el hilo principal que no sea esperar mensajes, por lo que es apropiado
bloquear el hilo principal.</p>
<p>Cuando ejecutamos el código en el listado 16-8, veremos el valor impreso
desde el hilo principal:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>¡Perfecto!</p>
<h3 id="canales-y-transferencia-de-propiedad"><a class="header" href="#canales-y-transferencia-de-propiedad">Canales y transferencia de propiedad</a></h3>
<p>Las reglas de <em>propiedad</em> (<em>ownership</em>) juegan un papel vital en el envío de
mensajes porque lo ayudan a escribir código seguro y simultáneo. La
prevención de errores en la programación concurrente es la ventaja de pensar
sobre la propiedad en todos sus programas de Rust. Hagamos un experimento
para mostrar cómo los canales y la propiedad trabajan juntos para evitar
problemas: trataremos de usar un valor <code>val</code> en el hilo generado <em>después</em> de
que lo hayamos enviado por el canal. Intente compilar el código en el listado
16-9 para ver por qué este código no está permitido:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Listado 16-9: Intentando usar <code>val</code> después de enviarlo
por el canal</span></p>
<p>Aquí, tratamos de imprimir <code>val</code> después de enviarlo por el canal a través
de <code>tx.send</code>. Permitir esto sería una mala idea: una vez que el valor ha sido
enviado a otro hilo, ese hilo podría modificarlo o soltarlo antes de intentar
usar el valor nuevamente. Potencialmente, las modificaciones del otro
subproceso podrían causar errores o resultados inesperados debido a datos
inconsistentes o inexistentes. Sin embargo, Rust nos da un error si tratamos
de compilar el código en el Listado 16-9:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<p>Nuestro error de concurrencia ha causado un error de tiempo de compilación.
La función <code>send</code> toma posesión de su parámetro, y cuando se mueve el valor,
el receptor se apropia de él. Esto nos impide volver a usar accidentalmente
el valor después de enviarlo; el sistema de propiedad comprueba que todo está
bien.</p>
<h3 id="enviar-múltiples-valores-y-ver-el-receptor-esperando"><a class="header" href="#enviar-múltiples-valores-y-ver-el-receptor-esperando">Enviar múltiples valores y ver el receptor esperando</a></h3>
<p>El código en el listado 16-8 se compiló y ejecutó, pero no nos mostró
claramente que dos hilos separados estaban hablando entre sí a través del
canal. En el listado 16-10 hicimos algunas modificaciones que demostrarán que
el código en el listado 16-8 se está ejecutando simultáneamente: el hilo
generado ahora enviará múltiples mensajes y se detendrá por un segundo entre
cada mensaje.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 16-10: Envío de mensajes múltiples y pausas
entre cada uno</span></p>
<p>Esta vez, el hilo generado tiene un vector de <em>strings</em> que queremos enviar
al hilo principal. Realizamos iteraciones sobre ellos, enviando cada uno
individualmente, y hacemos una pausa entre cada uno llamando a la función
<code>thread::sleep</code> con un valor <code>Duration</code> de 1 segundo.</p>
<p>En el hilo principal, no estamos llamando a la función <code>recv</code> explícitamente
más: en su lugar, estamos tratando <code>rx</code> como un iterador. Para cada valor
recibido, lo estamos imprimiendo. Cuando el canal está cerrado, la iteración
finalizará.</p>
<p>Al ejecutar el código en el listado 16-10, debería ver el siguiente resultado
con una pausa de 1 segundo entre cada línea:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Debido a que no tenemos ningún código que haga una pausa o se retrase en el
ciclo <code>for</code> en el hilo principal, podemos decir que el hilo principal está
esperando recibir los valores del hilo generado.</p>
<h3 id="creando-múltiples-productores-clonando-el-transmisor"><a class="header" href="#creando-múltiples-productores-clonando-el-transmisor">Creando múltiples productores clonando el transmisor</a></h3>
<p>Anteriormente mencionamos que <code>mpsc</code> era un acrónimo de
<em>productor múltiple, consumidor único</em>
(<em>multiple producer, single consumer</em>). Pongamos <code>mpsc</code> para usar y expandir
el código en el Listado 16-10 para crear múltiples hilos que envíen valores
al mismo receptor. Podemos hacerlo clonando la mitad transmisora del canal,
como se muestra en el listado 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 16-11: Envío de múltiples mensajes de múltiples
productores</span></p>
<p>Esta vez, antes de crear el primer hilo generado, llamamos <code>clone</code> en el
extremo de envío del canal. Esto nos dará un nuevo identificador de envío que
podemos pasar al primer hilo generado. Pasamos el final de envío original del
canal a un segundo hilo generado. Esto nos da dos hilos, cada uno enviando
mensajes diferentes al extremo receptor del canal.</p>
<p>Cuando ejecuta el código, su resultado debería verse más o menos así:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Puede ver los valores en otro orden; depende de tu sistema. Esto es lo que
hace que la concurrencia sea interesante y difícil. Si experimentas con
<code>thread::sleep</code>, dándole varios valores en los diferentes hilos, cada
ejecución será más no determinista y creará resultados diferentes cada vez.</p>
<p>Ahora que hemos analizado cómo funcionan los canales, veamos un método
diferente de concurrencia.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencia-de-estado-compartido"><a class="header" href="#concurrencia-de-estado-compartido">Concurrencia de estado compartido</a></h2>
<p>La transmisión de mensajes es una buena forma de manejar la concurrencia,
pero no es la única. Considere de nuevo esta parte del lema de la
documentación del lenguaje Go: &quot;comunicarse compartiendo memoria&quot;.</p>
<p>¿Cómo se vería la comunicación al compartir la memoria? Además, ¿por qué los
entusiastas que pasan mensajes no lo usan y hacen todo lo contrario?</p>
<p>En cierto modo, los canales en cualquier lenguaje de programación son
similares a la propiedad única, porque una vez que transfiere un valor a un
canal, ya no debe usar ese valor. La concurrencia de memoria compartida es
como propiedad múltiple: varios subprocesos pueden acceder a la misma
ubicación de memoria al mismo tiempo. Como vimos en el Capítulo 15, donde los
punteros inteligentes hicieron posible la propiedad múltiple, la propiedad
múltiple puede agregar complejidad porque estos diferentes propietarios
necesitan administrarla. Las reglas de propiedad y el sistema de tipos de
Rust ayudan a que esta gestión sea correcta. Por ejemplo, veamos <em>mutexes</em>,
una de las primitivas de concurrencia más comunes para la memoria compartida.</p>
<h3 id="usar-mutexes-para-permitir-el-acceso-a-los-datos-de-un-hilo-a-la-vez"><a class="header" href="#usar-mutexes-para-permitir-el-acceso-a-los-datos-de-un-hilo-a-la-vez">Usar mutexes para permitir el acceso a los datos de un hilo a la vez</a></h3>
<p><em>Mutex</em> es una abreviatura de <em>exclusión mutua</em>
(<em>mutual exclusion</em>), como en, un <em>mutex</em> permite solo
un hilo para acceder a algunos datos en un momento dado. Para acceder a los
datos en un <em>mutex</em>, un hilo debe indicar primero que quiere acceso pidiendo
adquirir el <em>lock</em> (<em>bloqueo</em>) del <em>mutex</em> el bloqueo es una estructura de
datos que es parte del <em>mutex</em> que realiza un seguimiento de quién tiene
acceso exclusivo a los datos en este momento. Por lo tanto, el <em>mutex</em> se
describe como <em>protector</em> de los datos que contiene a través del sistema de
bloqueo.</p>
<p>Los <em>mutex</em> tienen una reputación de ser difíciles de usar porque tienes que
recuerda dos reglas:</p>
<ul>
<li>Debe intentar adquirir el bloqueo antes de usar los datos.</li>
<li>Cuando haya terminado con los datos que guardas mutex, debe desbloquear el
datos para que otros hilos puedan adquirir el bloqueo.</li>
</ul>
<p>Para una metáfora del mundo real para un <em>mutex</em>, imagine un panel de
discusión en una conferencia con solo un micrófono. Antes de que un panelista
pueda hablar, tienen que pregunta o indica que quieren usar el micrófono.
Cuando obtienen el micrófono, pueden hablar todo el tiempo que quieran y
luego entregar el micrófono al siguiente panelista que solicita hablar. Si un
panelista se olvida de quitar el micrófono cuando hayan terminado, nadie más
puede hablar. Si la administración del micrófono compartido falla, el panel
no funcionará ¡como se planeó!.</p>
<p>El manejo de <em>mutexes</em> puede ser increíblemente difícil de acertar, razón por
la cual muchas personas están entusiasmadas con los canales. Sin embargo,
gracias al sistema de tipos y las reglas de propiedad de Rust, no puedes
bloquear y desbloquear incorrectamente.</p>
<h4 id="la-api-de-mutext"><a class="header" href="#la-api-de-mutext">La API de <code>Mutex&lt;T&gt;</code></a></h4>
<p>Como ejemplo de cómo usar un mutex, comencemos utilizando un <em>mutex</em> en un
contexto de <em>single-threaded</em>, como se muestra en el listado 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Listado 16-12: Exploración de la API de <code>Mutex &lt;T&gt;</code> en
un contexto de single-threaded único para simplificar</span></p>
<p>Al igual que con muchos tipos, creamos un <code>Mutex&lt;T&gt;</code> utilizando la función
asociada <code>new</code>. Para acceder a los datos dentro del <em>mutex</em>, usamos el método
<code>lock</code> para adquirir el <em>lock</em>. Esta llamada bloqueará el hilo actual por lo
que no puede hacer ningún trabajo mientras sea nuestro turno de tener el
candado.</p>
<p>La llamada a <code>lock</code> fallaría si otro hilo que mantiene el <em>lock</em> entrara en
pánico. En ese caso, nadie podría conseguir el <em>lock</em>, así que hemos elegido
<code>unwrap</code> y pánico en este hilo si estamos en esa situación.</p>
<p>Después de que hayamos adquirido el <em>lock</em>, podemos tratar el valor de
retorno, llamado <code>num</code> en este caso, como una referencia mutable a los datos
dentro. El sistema de tipo asegura que adquirimos un <em>lock</em> antes de usar el
valor en <code>m</code>:<code>Mutex&lt;i32&gt;</code> no es un <code>i32</code>, entonces <em>debemos</em> adquirir el
<em>lock</em> para poder usar el valor <code>i32</code>. Nosotros no puedo olvidar; el sistema
de tipo no nos permitirá acceder al <code>i32</code> interno en caso contrario.</p>
<p>Como podría sospechar, <code>Mutex &lt;T&gt;</code> es un puntero inteligente. Más exactamente
la llamada <code>lock</code> <em>devuelve</em> un puntero inteligente llamado <code>MutexGuard</code>.
Este puntero inteligente implementa <code>Deref</code> para señalar nuestros datos
internos; el puntero inteligente también tiene una implementación <code>Drop</code> que
libera el <em>lock</em> automáticamente cuando un <code>MutexGuard</code>
sale del alcance, lo que ocurre al final del alcance interno en el Listado
16-12. Como resultado, no nos arriesgamos a olvidar liberar el <em>lock</em> y
<em>lock</em> el uso de mutex por otros <em>threads</em> porque la liberación del <em>lock</em>
ocurre automáticamente.</p>
<p>Después de soltar el <em>lock</em>, podemos imprimir el valor <em>mutex</em> y ver que
pudimos para cambiar el <code>i32</code> interno a 6.</p>
<h4 id="compartir-un-mutex-t-entre-varios-hilos"><a class="header" href="#compartir-un-mutex-t-entre-varios-hilos">Compartir un <code>Mutex &lt;T&gt;</code> entre varios hilos</a></h4>
<p>Ahora, intentemos compartir un valor entre múltiples hilos utilizando
<code>Mutex&lt;T&gt;</code>. Desarrollaremos 10 subprocesos y cada uno de ellos incrementará
el valor de un contador en 1, por lo que el contador pasará de 0 a 10. Tenga
en cuenta que los siguientes ejemplos tendrán errores de compilación, y los
usaremos para obtener más información sobre cómo usarlos. <code>Mutex&lt;T&gt;</code> y cómo
Rust nos ayuda a usarlo correctamente. El listado 16-13 tiene nuestro ejemplo
inicial:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listado 16-13: Diez <em>threads</em> cada incremento un
contador protegido por un <code>Mutex&lt;T&gt;</code></span></p>
<p>Creamos una variable <code>counter</code> para mantener un <code>i32</code> dentro de un
<code>Mutex&lt;T&gt;</code>, como hicimos en el Listado 16-12. A continuación, creamos 10
hilos iterando sobre un <em>trait</em> de números. Usamos <code>thread::spawn</code> y le damos
a todos los hilos el mismo <em>closure</em>, uno que mueve el contador al hilo,
adquiere un bloqueo en <code>Mutex&lt;T&gt;</code> llamando al método <code>lock</code>, y luego agrega 1
a el valor en el <em>mutex</em> cuando un hilo termina de ejecutar su cierre, <code>num</code>
saldrá del alcance y liberará el bloqueo para que otro hilo pueda adquirirlo.</p>
<p>En el hilo principal, recogemos todos los <em>join handles</em>. Luego, como hicimos
en el listado 16-2, llamamos a <code>join</code> en cada <em>handle</em> para asegurarnos de
que todos los hilos terminen. En ese punto, el hilo principal adquirirá el
bloqueo e imprimirá el resultado de este programa.</p>
<p>Insinuamos que este ejemplo no se compilaría. ¡Ahora descubramos por qué!.</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>El mensaje de error indica que el valor <code>counter</code> se mueve al <em>closure</em> y
luego se captura cuando llamamos <code>lock</code>. Esa descripción suena como lo que
queríamos, ¡pero no está permitido!</p>
<p>Vamos a resolver esto simplificando el programa. En lugar de hacer 10 hilos
en un bucle 'for', hagamos dos hilos sin un bucle y veamos qué pasa.
Reemplace el primer bucle <code>for</code> en el Listado 16-13 con este código:</p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();

        *num += 1;
    });
    handles.push(handle);

    let handle2 = thread::spawn(move || {
        let mut num2 = counter.lock().unwrap();

        *num2 += 1;
    });
    handles.push(handle2);

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p>Hacemos dos hilos y cambiamos los nombres de variable usados con el segundo
hilo a <code>handle2</code> y <code>num2</code>. Cuando ejecutamos el código esta vez, compilar nos
da lo siguiente:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>Aha! El primer mensaje de error indica que <code>counter</code> se mueve al <em>closure</em>
para el hilo asociado con <code>handle</code>. Ese movimiento nos impide capturar
<code>contador</code> cuando intentamos llamar <code>lock</code> y almacenar el resultado en <code>num2</code>
en el segundo hilo. Entonces, Rust nos está diciendo que no podemos mover la
propiedad de <code>contador</code> en múltiples hilos. Esto era difícil de ver antes
porque nuestros hilos estaban en un bucle, y Rust no puede señalar diferentes
hilos en diferentes iteraciones del ciclo. Arreglemos el error del compilador
con un método de propiedad múltiple que discutimos en el Capítulo 15.</p>
<h4 id="propiedad-múltiple-con-múltiples-hilos"><a class="header" href="#propiedad-múltiple-con-múltiples-hilos">Propiedad múltiple con múltiples hilos</a></h4>
<p>En el Capítulo 15, dimos un valor de varios propietarios usando el puntero
inteligente <code>Rc&lt;T&gt;</code> para crear un valor contado de referencia. Hagamos lo
mismo aquí y veamos qué pasa. Vamos a envolver el <code>Mutex&lt;T&gt;</code> en <code>Rc&lt;T&gt;</code> en el
Listado 16-14 y clonar el <code>Rc&lt;T&gt;</code> antes de mover la propiedad al hilo. Ahora
que hemos visto los errores, también volveremos a usar el ciclo <code>for</code>, y
mantendremos la palabra clave <code>move</code> con el closure.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listado 16-14: Intentando usar <code>Rc&lt;T&gt;</code> para permitir
que varios hilos sean propietarios del <code>Mutex&lt;T&gt;</code></span></p>
<p>Una vez más, compilamos y obtenemos ... ¡diferentes errores! el compilador
nos está enseñando mucho.</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>¡Guau, ese mensaje de error es muy prolijo! aquí hay algunas partes
importantes para enfocarse: el primer error en línea dice
```std::rc::Rc&lt;std::sync::Mutex<i32>&gt;<code>cannotbe sent between threads safely``. La razón para esto es en la siguiente parte importante para enfocarse, el mensaje de error. El mensaje de error destilado dice ``the trait bound</code>Send<code>is not satisfied``. Hablaremos de</code>Send` en la
próxima sección: es uno de los <em>trait</em> que asegura que los tipos que usamos
con los hilos están destinados a ser utilizados en situaciones concurrentes.</p>
<p>Desafortunadamente, <code>Rc&lt;T&gt;</code> no es seguro para compartir a través de
<em>threads</em>. Cuando <code>Rc&lt;T&gt;</code> administra el recuento de referencias, se suma al
conteo de cada llamada a <code>clon</code> y resta del recuento cuando se descarta cada
clon. Pero no usa ninguna primitiva de concurrencia para asegurarse de que
los cambios al conteo no puedan ser interrumpidos por otro hilo. Esto podría
llevar a recuentos incorrectos, errores sutiles que a su vez podrían provocar
pérdidas de memoria o un valor que se descarta antes de que terminemos con
él. Lo que necesitamos es un tipo exactamente como <code>Rc&lt;T&gt;</code> pero que haga
cambios en el recuento de referencias de una manera segura para hilos.</p>
<h4 id="recuento-de-referencia-atómica-con-arc-t"><a class="header" href="#recuento-de-referencia-atómica-con-arc-t">Recuento de referencia atómica con <code>Arc &lt;T&gt;</code></a></h4>
<p>Afortunadamente, <code>Arc&lt;T&gt;</code> <em>es</em> un tipo como <code>Rc&lt;T&gt;</code> que es seguro de usar en
situaciones concurrentes. La <em>a</em> significa <em>atomic</em>, lo que significa que es
un <em>tipo de referencia atómica</em>. Atomics es un tipo adicional de primitiva de
concurrencia que no cubriremos en detalle aquí: consulte la documentación
estándar de la biblioteca para <code>std::sync::atomic</code> para obtener más detalles.
En este punto, solo necesita saber que los atómicos funcionan como tipos
primitivos pero que es seguro compartirlos a través de <em>threads</em>.</p>
<p>A continuación, puede preguntarse por qué todos los tipos primitivos no son
atómicos y por qué los tipos de biblioteca estándar no están implementados
para usar <code>Arc&lt;T&gt;</code> de forma predeterminada. La razón es que la seguridad de
<em>threads</em> viene con una penalización de rendimiento que solo quieres pagar
cuando realmente lo necesitas. Si solo está realizando operaciones en valores
dentro de un solo hilo, su código puede ejecutarse más rápido si no tiene que
hacer cumplir las garantías que brindan los atómicos.</p>
<p>Volvamos a nuestro ejemplo: <code>Arc&lt;T&gt;</code> y <code>Rc&lt;T&gt;</code> tienen la misma API, por lo
que reparamos nuestro programa cambiando la línea <code>use</code>, la llamada a <code>new</code> y
la llamada a <code>clon</code>. El código en el listado 16-15 finalmente se compilará y ejecutará:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Listado 16-15: Usar un <code>Arc&lt;T&gt;</code> para envolver el
<code>Mutex&lt;T&gt;</code> para poder compartir la propiedad entre múltiples hilos</span></p>
<p>Este código imprimirá lo siguiente:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>¡Lo hicimos! Contamos de 0 a 10, lo que puede no parecer muy impresionante,
pero sí nos enseñó mucho sobre <code>Mutex&lt;T&gt;</code> y <em>thread safety</em>. También puede
usar la estructura de este programa para realizar operaciones más complicadas
que simplemente incrementar un contador. Usando esta estrategia, puedes
dividir un cálculo en partes independientes, dividir esas partes entre los
hilos, y luego usar un <code>Mutex&lt;T&gt;</code> para que cada hilo actualice el resultado
final con su parte.</p>
<h3 id="similitudes-entre-refcell-t--rc-t-y-mutex-t--arc-t"><a class="header" href="#similitudes-entre-refcell-t--rc-t-y-mutex-t--arc-t">Similitudes entre <code>RefCell &lt;T&gt;</code> / <code>Rc &lt;T&gt;</code> y <code>Mutex &lt;T&gt;</code> / <code>Arc &lt;T&gt;</code></a></h3>
<p>Es posible que haya notado que <code>counter</code> es inmutable, pero podríamos obtener
una referencia mutable al valor que contiene; esto significa <code>Mutex&lt;T&gt;</code>
proporciona mutabilidad interior, como lo hace la familia <code>Cell</code>. De la misma
manera que utilizamos <code>RefCell&lt;T&gt;</code> en el Capítulo 15 para permitirnos mutar
contenidos dentro de un <code>Rc&lt;T&gt;</code>, usamos <code>Mutex&lt;T&gt;</code> para mutar contenidos
dentro de un <code>Arc&lt;T&gt;</code>.</p>
<p>Otro detalle a tener en cuenta es que Rust no puede protegerte de todo tipo
de errores lógicos cuando usas <code>Mutex&lt;T&gt;</code>. Recuerde en el Capítulo 15 que
usar <code>Rc&lt;T&gt;</code> conlleva el riesgo de crear ciclos de referencia, donde dos
valores <code>Rc&lt;T&gt;</code> se refieren entre sí, causando pérdidas de memoria. Del mismo
modo, <code>Mutex&lt;T&gt;</code> tiene el riesgo de crear <em>deadlocks</em>. Esto ocurre cuando una
operación necesita bloquear dos recursos y dos hilos han adquirido uno de los
bloqueos, lo que hace que esperen el uno al otro para siempre. Si le
interesan los bloqueos, intente crear un programa de Rust que tenga un
<em>deadlocks</em>; luego investigue las estrategias de mitigación de interbloqueo
para <em>mutexes</em> en cualquier lenguaje y aprenda a implementarlas en Rust. La
documentación API de la biblioteca estándar para <code>Mutex&lt;T&gt;</code> y <code>MutexGuard</code>
ofrece información útil.</p>
<p>Completaremos este capítulo hablando de los <em>trait</em> <code>Send</code> y <code>Sync</code> y cómo
podemos usarlos con tipos personalizados.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencia-extensible-con-los-trait-sync-y-send"><a class="header" href="#concurrencia-extensible-con-los-trait-sync-y-send">Concurrencia extensible con los <em>trait</em> <code>Sync</code> y <code>Send</code></a></h2>
<p>Curiosamente, el lenguaje Rust tiene <em>muy</em> pocas características de
<em>concurrencia</em> (<em>concurrency</em>). Casi todas las características de
concurrencia de las que hemos hablado hasta ahora en este capítulo han sido
parte de la biblioteca estándar, no del lenguaje. Sus opciones para controlar
la concurrencia no están limitadas al lenguaje o la biblioteca estándar;
puede escribir sus propias características de simultaneidad o usar las escritas por otros.</p>
<p>Sin embargo, dos conceptos de concurrencia están incrustados en el lenguaje: los <em>traits</em> <code>std::marker</code>, <code>Sync</code> y <code>Send</code>.</p>
<h3 id="permitir-la-transferencia-de-propiedad-entre-hilos-con-send"><a class="header" href="#permitir-la-transferencia-de-propiedad-entre-hilos-con-send">Permitir la transferencia de propiedad entre hilos con <code>Send</code></a></h3>
<p>El <em>trait</em> del marcador <code>Send</code> indica que la propiedad del tipo que
implementa <code>Send</code> se puede transferir entre hilos. Casi todos los tipos de
Rust son <code>Send</code>, pero hay algunas excepciones, como <code>Rc&lt;T&gt; </code>: no puede ser
<code>Send</code> porque si clonó un valor <code>Rc&lt;T&gt;</code> e intentó transferir la propiedad del
clon a otro subproceso, ambos subprocesos pueden actualizar el recuento de
referencia al mismo tiempo. Por este motivo, <code>Rc&lt;T&gt;</code> se implementa para usar
en situaciones de subproceso único en las que no desea pagar la penalización
de rendimiento de subprocesos.</p>
<p>Por lo tanto, el sistema de tipos y los límites de rasgos de Rust aseguran
que nunca se pueda enviar accidentalmente un valor <code>Rc&lt;T&gt;</code> a través de los
hilos de forma insegura. Cuando tratamos de hacer esto en el listado 16-14,
obtuvimos el error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>.
Cuando cambiamos a <code>Arc&lt;T&gt;</code>, que es <code>Send</code>, el código compilado.</p>
<p>Cualquier tipo compuesto enteramente de tipos <code>Send</code> también se marca
automáticamente como <code>Send</code>. Casi todos los tipos primitivos son <code>Send</code>,
además de los <em>raw pointers</em>, que veremos en el Capítulo 19.</p>
<h3 id="permitir-acceso-desde-múltiples-hilos-con-sync"><a class="header" href="#permitir-acceso-desde-múltiples-hilos-con-sync">Permitir acceso desde múltiples hilos con <code>Sync</code></a></h3>
<p>El <em>trait</em> del marcador <code>Sync</code> indica que es seguro para el tipo que
implementa <code>Sync</code> que se haga referencia desde múltiples hilos. En otras
palabras, cualquier tipo <code>T</code> es <code>Sync</code> si <code>&amp;T</code> (una referencia a <code>T</code>) es
<code>Send</code>, lo que significa que la referencia se puede enviar de forma segura a
otro hilo. Similar a <code>Send</code>, los tipos primitivos son <code>Sync</code>, y los tipos
compuestos completamente por tipos que son <code>Sync</code> también son <code>Sync</code>.</p>
<p>El puntero inteligente <code>Rc&lt;T&gt;</code> tampoco es <code>Sync</code> por las mismas razones por
las que no es <code>Send</code>. El tipo <code>RefCell&lt;T&gt;</code> (del que hablamos en el Capítulo
15) y la familia de tipos relacionados <code>Cell&lt;T&gt;</code> no son <code>Sync</code>. La implementación de la comprobación de préstamos que <code>RefCell&lt;T&gt;</code> hace en tiempo de ejecución no es seguro <em>thread-safe</em>. El puntero inteligente
<code>Mutex&lt;T&gt;</code> es <code>Sync</code> y se puede usar para compartir el acceso con múltiples
hilos como se vio en la sección “Compartir un <code>Mutex&lt;T&gt;</code> entre varios hilos”.</p>
<h3 id="implementar-send-y-sync-manualmente-es-inseguro"><a class="header" href="#implementar-send-y-sync-manualmente-es-inseguro">Implementar <code>Send</code> y <code>Sync</code> Manualmente es inseguro</a></h3>
<p>Como los tipos que están compuestos por los <em>traits</em> <code>Enviar</code> y <code>Sincronizar</code>
también son automáticamente <code>Enviar</code> y <code>Sincronizar</code>, no tenemos que
implementar esos <em>traits</em> manualmente. Como <em>traits</em> de marcador, ni siquiera
tienen ningún método para implementar. Solo son útiles para aplicar
invariantes relacionados con la concurrencia.</p>
<p>La implementación manual de estos <em>traits</em> implica implementar código de Rust
inseguro. Hablaremos sobre el uso de un código de Rust inseguro en el
Capítulo 19; por ahora, la información importante es que construir nuevos
tipos simultáneos que no estén compuestos por las partes <code>Enviar</code> y
<code>Sincronizar</code> requiere una cuidadosa reflexión para mantener las garantías de
seguridad. <a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon</a> tiene más información sobre estas garantías y
cómo mantenerlas.</p>
<h2 id="resumen-14"><a class="header" href="#resumen-14">Resumen</a></h2>
<p>Esta no es la última vez que verá concurrencia en este libro: el proyecto del
Capítulo 20 utilizará los conceptos de este capítulo en una situación más
realista que los ejemplos más pequeños que se tratan aquí.</p>
<p>Como se mencionó anteriormente, debido a que muy poco de cómo Rust maneja la
concurrencia es parte del lenguaje, muchas soluciones de concurrencia se
implementan como cajas. Éstos evolucionan más rápido que la biblioteca
estándar, así que asegúrese de buscar en línea las cajas actuales y de última
generación para usar en situaciones multiproceso.</p>
<p>La biblioteca estándar de Rust proporciona canales para el paso de mensajes y
tipos de punteros inteligentes, como <code>Mutex&lt;T&gt;</code> y <code>Arc&lt;T&gt;</code>, que son seguros
de usar en contextos concurrentes. El sistema de tipos y el comprobador de
préstamos garantizan que el código que utiliza estas soluciones no termine
con carreras de datos o referencias no válidas. Una vez que obtenga su código
para compilar, puede estar seguro de que se ejecutará felizmente en varios
subprocesos sin los tipos de errores difíciles de localizar comunes en otros
lenguajes. La programación concurrente ya no es un concepto al que temer:
¡avance y convierta sus programas en concurrentes, sin miedo!.</p>
<p>A continuación, hablaremos sobre formas idiomáticas de modelar problemas y
estructurar soluciones a medida que sus programas de Rust crecen. Además,
discutiremos cómo los modismos de Rust se relacionan con aquellos con los que
podrías estar familiarizado con la programación orientada a objetos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="características-de-programación-orientadas-a-objetos-de-rust"><a class="header" href="#características-de-programación-orientadas-a-objetos-de-rust">Características de programación orientadas a objetos de Rust</a></h1>
<p>La programación orientada a objetos (OOP) es una forma de modelar programas.
Los objetos vinieron de Simula en la década de 1960. Esos objetos influyeron
en la arquitectura de programación de Alan Kay en la que los objetos se
transmiten mensajes entre sí. Él acuñó el término <em>programación orientada a objetos</em> en 1967 para describir esta arquitectura. Muchas definiciones
competitivas describen qué OOP es; algunas definiciones clasificaron a Rust
como orientado a objetos, pero otras definiciones no lo harían. En este
capítulo, exploraremos ciertas características que comúnmente se consideran
orientadas a objetos y cómo esas características se traducen en Rust
idiomático. Luego le mostraremos cómo implementar un patrón de diseño
orientado a objetos en Rust y discutiremos las ventajas y desventajas de
hacerlo en lugar de implementar una solución utilizando algunas de las
fortalezas de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="características-de-los-lenguajes-orientados-a-objetos"><a class="header" href="#características-de-los-lenguajes-orientados-a-objetos">Características de los lenguajes orientados a objetos</a></h2>
<p>No hay consenso en la comunidad de programación sobre qué características
debe tener un lenguaje para ser considerado orientado a objetos. Rust está
influenciado por muchos paradigmas de programación, incluido OOP; por ejemplo
exploramos las características que provienen de la programación funcional en
el Capítulo 13. Podría decirse que los lenguajes OOP comparten ciertas
características comunes, a saber, objetos, encapsulación y herencia. Veamos
qué significa cada una de esas características y si Rust lo admite.</p>
<h3 id="los-objetos-contienen-datos-y-comportamiento"><a class="header" href="#los-objetos-contienen-datos-y-comportamiento">Los objetos contienen datos y comportamiento</a></h3>
<p>El libro <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>
(<em>Patrones de diseño: Elementos del software reutilizable orientado a
objetos</em>) por Enoch Gamma, Richard Helm, Ralph Johnson y John Vlissides
(Addison-Wesley Professional, 1994) conocido coloquialmente como el libro
<em>The Gang of Four</em>
(<em>Banda de los Cuatro</em>), es un catálogo de patrones de diseño orientados a
objetos. Define OOP de esta manera:</p>
<blockquote>
<p>Los programas orientados a objetos están formados por objetos. Un <em>objeto</em> &gt; empaqueta ambos
los datos y los procedimientos que operan en esos datos. Los procedimientos
son
típicamente llamados <em>métodos</em> o <em>operaciones</em>.</p>
</blockquote>
<p>Usando esta definición, Rust está orientado a objetos: las estructuras y las
enumeraciones tienen datos, y los bloques <code>impl</code> proporcionan métodos en las
estructuras y las enumeraciones. A pesar de que las estructuras y las
enumeraciones con métodos no se <em>llaman</em> objetos, proporcionan la misma
funcionalidad, de acuerdo con la definición de objetos de la Banda de los
Cuatro.</p>
<h3 id="encapsulación-que-oculta-los-detalles-de-implementación"><a class="header" href="#encapsulación-que-oculta-los-detalles-de-implementación">Encapsulación que oculta los detalles de implementación</a></h3>
<p>Otro aspecto comúnmente asociado con OOP es la idea de <em>encapsulation</em>, lo
que significa que los detalles de implementación de un objeto no son
accesibles para codificar utilizando ese objeto. Por lo tanto, la única forma
de interactuar con un objeto es a través de su API pública; el código que
utiliza el objeto no debería poder acceder a las partes internas del objeto y
cambiar los datos o el comportamiento directamente. Esto permite al
programador cambiar y refactorizar las partes internas de un objeto sin
necesidad de cambiar el código que usa el objeto.</p>
<p>Discutimos cómo controlar la encapsulación en el Capítulo 7: podemos usar la
palabra clave <code>pub</code> para decidir qué módulos, tipos, funciones y métodos en
nuestro código deberían ser públicos, y por defecto todo lo demás es privado.
Por ejemplo, podemos definir una estructura <code>AveragedCollection</code> que tiene un
campo que contiene un vector de valores <code>i32</code>. La estructura también puede
tener un campo que contiene el promedio de los valores en el vector, lo que
significa que el promedio no tiene que calcularse a pedido siempre que
alguien lo necesite. En otras palabras, <code>AveragedCollection</code> almacenará en
caché el promedio calculado para nosotros. El listado 17-1 tiene la
definición de la estructura <code>AveragedCollection</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-1: una estructura <code>AveragedCollection</code> que
mantiene una lista de enteros y el promedio de los elementos en la
colección</span></p>
<p>La estructura está marcada como <code>pub</code> para que otros códigos puedan usarla,
pero los campos dentro de la estructura permanecen privados. Esto es
importante en este caso porque queremos asegurarnos de que cada vez que se
agregue o elimine un valor de la lista, el promedio también se actualice.
Hacemos esto implementando los métodos <code>add</code>, <code>remove</code> y <code>average</code> en la
estructura, como se muestra en el Listado 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-2: Implementaciones de los métodos públicos
<code>add</code>, <code>remove</code>, y <code>average</code> en <code>AveragedCollection</code></span></p>
<p>Los métodos públicos <code>add</code>, <code>remove</code> y <code>average</code> son las únicas formas de
modificar una instancia de <code>AveragedCollection</code>. Cuando un elemento se agrega
a <code>list</code> usando el método <code>add</code> o eliminado con el método <code>remove</code>, las
implementaciones de cada llama al método privado <code>update_average</code> que maneja
la actualización del <code>average</code> campo también.</p>
<p>Dejamos los campos <code>list</code> y <code>average</code> en privado, por lo que no hay forma de
código externo para agregar o eliminar elementos directamente al campo <code>list</code>
de otra manera, el campo <code>average</code> podría perder su sincronización cuando
cambie la <code>list</code>.El método <code>average</code> devuelve el valor en el campo
<code>average</code>, lo que permite código para leer el <code>average</code> pero no modificarlo.</p>
<p>Porque hemos encapsulado los detalles de implementación de la estructura
<code>AveragedCollection</code>, podemos cambiar fácilmente aspectos, como la estructura
de datos, en el futuro. Por ejemplo, podríamos usar un <code>HashSet&lt;i32&gt;</code> en
lugar de un <code>Vec&lt;i32&gt;</code> para el campo <code>list</code>. Siempre y cuando las firmas del
<code>add</code>, los métodos públicos <code>remove</code>, y <code>average</code> permanecen igual, código
usando <code>AveragedCollection</code> no necesitaría cambiar. Si hiciéramos público
<code>list</code>, esto no sería necesariamente el caso: <code>HashSet&lt;i32&gt;</code> y <code>Vec&lt;i32&gt;</code>
tienen diferentes métodos para agregar y eliminar elementos, por lo que el
código externo probablemente tenga que cambiar si modificara <code>list</code>
directamente.</p>
<p>Si la encapsulación es un aspecto requerido para que un lenguaje se considere
objeto orientado, entonces Rust cumple con ese requisito. La opción de usar
<code>pub</code> o no para diferentes partes de código permiten la encapsulación de
detalles de implementación.</p>
<h3 id="herencia-como-un-sistema-tipo-y-como-código-compartido"><a class="header" href="#herencia-como-un-sistema-tipo-y-como-código-compartido">Herencia como un sistema tipo y como código compartido</a></h3>
<p><em>Inheritance</em> (<em>Herencia</em>) es un mecanismo mediante el cual un objeto puede
heredar de otro definición del objeto, obteniendo así los datos y el
comportamiento del objeto padre sin tienes que definirlos de nuevo.</p>
<p>Si un lenguaje debe tener herencia para ser un lenguaje orientado a objetos,
entonces Rust no es uno. No hay forma de definir una estructura que herede del
padre los campos de struct y las implementaciones de métodos. Sin embargo, si
estás acostumbrado a tener herencia en su caja de herramientas de
programación, puede usar otras soluciones en Rust, dependiendo de su razón
para alcanzar la herencia en primer lugar.</p>
<p>Usted elige la herencia por dos razones principales. Una es para reutilizar
el código: puedes implementar un comportamiento particular para un tipo, y la
herencia le permite reutilizar esa implementación para un tipo diferente.
Puedes compartir el código de Rust usando implementaciones de método de
<em>trait</em> predeterminado, que viste en el Listado 10-14
cuando agregamos una implementación predeterminada del método <code>summarize</code> en
el <em>trait</em> <code>Summary</code>. Cualquier tipo que implemente el <em>trait</em> <code>Summary</code>
tendría el método <code>summarize</code> disponible sin ningún otro código. Esto es
similar a una clase padre que tiene una implementación de un método y un
hijo heredera clase también teniendo la implementación del método. También
podemos anular el implementación predeterminada del método <code>summarize</code> cuando
implementamos el <em>trait</em> <code>Summary</code>, que es similar a una clase secundaria que
anula la implementación de un método heredado de una clase padre.</p>
<p>La otra razón para usar la herencia se relaciona con el sistema de tipo: para
habilitar un tipo de hijo para ser utilizado en los mismos lugares que el
tipo principal. Esto es también llamado <em>polimorfismo</em>, lo que significa que
puede sustituir varios objetos entre sí en tiempo de ejecución si comparten
ciertas características.</p>
<blockquote>
<h3 id="polimorfismo"><a class="header" href="#polimorfismo">Polimorfismo</a></h3>
<p>Para muchas personas, el polimorfismo es sinónimo de herencia. Pero en
realidad es un concepto más general que se refiere a un código que puede
funcionar con datos de múltiples tipos. Para la herencia, esos tipos son
generalmente subclases.</p>
<p>En su lugar, Rust utiliza genéricos para abstraer sobre diferentes tipos
posibles y límites de <em>trait</em> para imponer restricciones sobre lo que
dichos tipos deben proporcionar. Esto a veces se llama
<em>bounded parametric polymorphism</em> (<em>polimorfismo paramétrico limitado</em>).</p>
</blockquote>
<p>La herencia ha caído en desuso recientemente como una solución de diseño de
programación en muchos lenguajes de programación porque a menudo corre el
riesgo de compartir más código de lo necesario. Las subclases no siempre
deben compartir todas las características de su clase principal, pero lo
harán con la herencia. Esto puede hacer que el diseño de un programa sea
menos flexible. También introduce la posibilidad de llamar a métodos en
subclases que no tienen sentido o que causan errores porque los métodos no se
aplican a la subclase. Además, algunos idiomas solo permitirán que una
subclase herede de una clase, restringiendo aún más la flexibilidad del
diseño de un programa.</p>
<p>Por estas razones, Rust toma un enfoque diferente, usando <em>trait objects</em> en
lugar de herencia. Veamos cómo los <em>trait objects</em> permiten el polimorfismo
en Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usar-trait-objects-que-permiten-valores-de-diferentes-tipos"><a class="header" href="#usar-trait-objects-que-permiten-valores-de-diferentes-tipos">Usar <em>Trait Objects</em> que permiten valores de diferentes tipos</a></h2>
<p>En el Capítulo 8, mencionamos que una limitación de los vectores es que pueden
almacenar elementos de un solo tipo. Creamos una solución en el Listado 8-10
donde definimos una enumeración <code>SpreadsheetCell</code> que tenía variantes para
contener enteros, flotantes, y texto Esto significaba que podíamos almacenar
diferentes tipos de datos en cada celda y todavía tiene un vector que
representa una fila de celdas. Esto es perfectamente buena solución cuando
nuestros artículos intercambiables son un conjunto fijo de tipos que conocemos
cuando nuestro código es compilado</p>
<p>Sin embargo, a veces queremos que nuestro usuario de la biblioteca pueda
ampliar el conjunto de tipos que son válidos en una situación particular.
Para mostrar cómo podemos lograr esto, crearemos una herramienta de ejemplo
de interfaz gráfica de usuario (GUI) que itera a través de una lista de
artículos, llamando a un método de 'dibujar' en cada uno para dibujarlo en el
pantalla: una técnica común para herramientas GUI. Crearemos un <em>library crate</em> llamada <code>gui</code> que contiene la estructura de una biblioteca GUI. Este
<em>crate</em> puede incluir algunos tipos que las personas pueden usar, como <code>Button</code> o <code>TextField</code>. En adición, los usuarios de <code>gui</code> querrán crear sus
propios tipos que puedan dibujarse: para ejemplo, un programador podría
agregar una <code>Imagen</code> y otro podría agregar un <code>SelectBox</code>.</p>
<p>No implementaremos una biblioteca de GUI completamente desarrollada para este
ejemplo, pero mostraremos cómo las piezas encajarían juntas en el momento de
escribir la biblioteca, no podemos conocer y definir todos los tipos que
otros programadores pueden querer crear. Pero sí sabemos que <code>gui</code> necesita
hacer un seguimiento de muchos valores de diferentes tipos, y necesita llamar
a un método <code>draw</code> en cada uno de estos valores de tipos diferentes. No es
necesario saber exactamente qué sucederá cuando llamemos al método <code>draw</code>,
solo que el valor tendrá ese método disponible para llamar.</p>
<p>Para hacer esto en un lenguaje con herencia, podríamos definir una clase
llamada <code>Component</code> que tiene un método llamado <code>draw</code> en él. Las otras
clases, como <code>Button</code>, <code>Image</code>, y <code>SelectBox</code>, heredarían de <code>Component</code> y
por lo tanto heredar el método <code>draw</code>. Cada uno podría anular el método
<code>draw</code> para definir su comportamiento personalizado, pero el framework podría
tratar todos los tipos como si fueran instancias <code>Component</code> y llamar <code>draw</code>
sobre ellos. Pero como Rust no tiene herencia, necesitamos otra forma de
estructurar la biblioteca <code>gui</code> para permitir a los usuarios ampliarla con
nuevos tipos.</p>
<h3 id="definición-de-un-trait-para-el-comportamiento-común"><a class="header" href="#definición-de-un-trait-para-el-comportamiento-común">Definición de un <em>trait</em> para el comportamiento común</a></h3>
<p>Para implementar el comportamiento que queremos que tenga <code>gui</code>, definiremos
un <em>trait</em> llamado <code>Draw</code> que tendrá un método llamado <code>draw</code>. Entonces
podemos definir un vector que toma un <em>trait object</em>. Un <em>trait object</em>
apunta a una instancia de un tipo que implementa el <em>trait</em> que especificamos.
Creamos un <em>trait object</em> especificando algunos tipo de puntero, como una
referencia <code>&amp;</code> o un puntero inteligente <code>Box&lt;T&gt;</code>, y luego
especificando el <em>trait</em> relevante. (Hablaremos sobre la razón por la cual
los objetos de <em>trait</em> deben usar un puntero en el Capítulo 19 en la sección
“Dynamically Sized Types &amp; Sized”).
Podemos usar <em>trait object</em> en lugar de un tipo genérico o concreto. Donde
sea que nosotros usar un <em>trait object</em>, el sistema de tipos de Rust
asegurará en tiempo de compilación que cualquier el valor utilizado en ese
contexto implementará el <em>trait</em> del <em>trait object</em>.
En consecuencia, no necesitamos saber todos los tipos posibles en tiempo de
compilación.</p>
<p>Hemos mencionado que en Rust, nos abstenemos de llamar a estructuras y
enumeraciones “objects” para distinguirlos de los objetos de otros lenguajes.
En una estructura o enum, los datos en los campos struct y el comportamiento
en bloques <code>impl</code> son separados, mientras que en otros lenguajes, los datos y
el comportamiento combinados en un concepto a menudo se etiquetan como un
objeto. Sin embargo, los <em>trait object</em> <em>son</em> más como objetos en otros
lenguajes en el sentido de que combinan datos y comportamiento.
Pero los <em>trait object</em> difieren de los objetos tradicionales en que no
podemos agregar datos a un <em>trait object</em>. Los <em>trait object</em> no son tan
útiles en general como los objetos en otros lenguajes: su propósito
específico es permitir la abstracción a través del comportamiento común.</p>
<p>El listado 17-3 muestra cómo definir un <em>trait</em> llamado <code>Draw</code> con un método
llamado <code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-3: Definición del <em>trait</em> <code>Draw</code></span></p>
<p>Esta sintaxis debería ser familiar a partir de nuestras discusiones sobre
cómo definir <em>trait</em> en el Capítulo 10. Luego viene una nueva sintaxis: el
Listado 17-4 define una estructura llamada <code>Screen</code> que contiene un vector
llamado <code>components</code>. Este vector es del tipo <code>Box&lt;Draw&gt;</code>, que es un
<em>trait object</em>; es un sustituto para cualquier tipo dentro de un <code>Box</code> que implementa el <em>trait</em> <code>Draw</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-4: Definición de la estructura <code>Screen</code> con
un campo <code>components</code> que contiene un vector de <em>trait objects</em> que
implementan el <em>trait</em> <code>Draw</code></span></p>
<p>En la estructura <code>Screen</code>, definiremos un método llamado <code>run</code> que llamará al
método <code>draw</code> en cada uno de sus <code>components</code>, como se muestra en el Listado
17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-5: Un método <code>run</code> en <code>Screen</code> que llama al
método <code>draw</code> en cada componente</span></p>
<p>Esto funciona de manera diferente a la definición de una estructura que usa
un parámetro de tipo genérico con <em>trait bounds</em>. Un parámetro de tipo
genérico solo puede ser sustituido por un tipo concreto a la vez, mientras
que los <em>trait objects</em> permiten que múltiples tipos concretos rellenen el
<em>trait objects</em> en el tiempo de ejecución. Por ejemplo, podríamos haber
definido la estructura <code>Screen</code> usando un tipo genérico y un <em>trait bounds</em>
como en el Listado 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-6: Una implementación alternativa de la
estructura <code>Screen</code> y su método <code>run</code> usando genéricos y
<em>trait bounds</em></span></p>
<p>Esto nos restringe a una instancia de <code>Screen</code> que tiene una lista de
componentes, todos de tipo <code>Button</code> o todos de tipo <code>TextField</code>. Si solo
tiene colecciones homogéneas, es preferible usar genéricos y <em>trait bounds</em>
porque las definiciones se monomorfizarán en el momento de la compilación
para usar los tipos concretos.</p>
<p>Por otro lado, con el método que usa <em>trait objects</em>, una instancia de
<code>Screen</code> puede contener un <code>Vec&lt;T&gt;</code> que contiene un <code>Box&lt;Botón&gt;</code> así como un
<code>Box&lt;TextField&gt;</code>. Veamos cómo funciona esto, y luego hablaremos sobre las
implicaciones de rendimiento en el tiempo de ejecución.</p>
<h3 id="implementando-el-trait"><a class="header" href="#implementando-el-trait">Implementando el <em>Trait</em></a></h3>
<p>Ahora agregaremos algunos tipos que implementan el <em>trait</em> <code>Draw</code>.
Proporcionaremos el tipo <code>Button</code>. Nuevamente, la implementación de una
biblioteca GUI está más allá del alcance de este libro, por lo que el método
<code>draw</code> no tendrá ninguna implementación útil en su cuerpo. Para imaginar cómo
se vería la implementación, una estructura <code>Button</code> podría tener campos para
<code>width</code>, <code>height</code> y <code>label</code>, como se muestra en el Listado 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-7: Una estructura <code>Button</code> que implementa el
<em>trait</em> <code>Draw</code></span></p>
<p>Los campos <code>width</code>, <code>height</code>, y <code>label</code> en <code>Button</code> diferirán de los campos
en otros componentes, como el tipo <code>TextField</code>, que podría tener esos campos
más un campo <code>placeholder</code> en su lugar. Cada uno de los tipos que queremos
dibujar en la pantalla implementará el <em>trait</em> <code>Draw</code> pero usará un código
diferente en el método <code>draw</code> para definir cómo dibujar ese tipo particular,
como <code>Button</code> tiene aquí (sin el código GUI real) , que está más allá del
alcance de este capítulo). El tipo <code>Button</code>, por ejemplo, podría tener un
bloque <code>impl</code> adicional que contenga métodos relacionados con lo que sucede
cuando un usuario hace clic en el botón. Este tipo de métodos no se aplicará
a tipos como <code>TextField</code>.</p>
<p>Si alguien que utiliza nuestra biblioteca decide implementar una estructura
<code>SelectBox</code> que tenga los campos <code>width</code>, <code>height</code>, y <code>options</code>, implementará
también el <em>trait</em> <code>Draw</code> en el tipo <code>SelectBox</code>, como se muestra en el
Listado 17 -8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">Listado 17-8: Otro <em>crate</em> usando <code>gui</code> e implementando
el <em>trait</em> <code>Draw</code> en una estructura <code>SelectBox</code></span></p>
<p>El usuario de nuestra biblioteca ahora puede escribir su función <code>main</code> para
crear una instancia <code>Screen</code>. Para la instancia de <code>Screen</code>, pueden agregar
un <code>SelectBox</code> y un <code>Button</code> poniendo cada uno en <code>Box&lt;T&gt;</code> para convertirse
en un <em>trait object</em>. Luego pueden llamar al método <code>run</code> en la instancia
<code>Screen</code>, que llamará <code>draw</code> en cada uno de los componentes. El listado 17-9 muestra esta implementación:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listado 17-9: Usar <em>trait objects</em> para almacenar
valores de diferentes tipos que implementan el mismo <em>trait</em></span></p>
<p>Cuando escribimos la biblioteca, no sabíamos que alguien podría agregar la
<code>SelectBox</code>, pero nuestra implementación <code>Screen</code> fue capaz de operar en
nuevo tipo y dibujarlo porque <code>SelectBox</code> implementa el tipo <code>Draw</code>, que
significa que implementa el método de <code>draw</code>.</p>
<p>Este concepto-de preocuparse solo por los mensajes a los que responde un valor
en lugar del tipo concreto del valor, es similar al concepto <em>duck typing</em>
(<em>tipaje de pato</em>) en lenguajes tipados dinámicamente: si camina como un pato
y grazna como un pato, ¡entonces debe ser un pato! En la implementación de
<code>run</code> en <code>Screen</code> en Listado 17-5, <code>run</code> no necesita saber cuál es el tipo
concreto de cada componente. No verifica si un componente es una instancia de
un <code>Button</code> o una <code>SelectBox</code>, simplemente llama al método <code>draw</code> en el 
componente. Al especificar
<code>Box&lt;Draw&gt;</code> como el tipo de los valores en el vector <code>components</code>, hemos
definido <code>Screen</code> necesita valores a los que podamos llamar el método <code>draw</code>.</p>
<p>La ventaja de usar <em>trait objects</em> y el sistema de tipos de Rust para
escribir código similar al código que usa el tipado de pato es que nunca
tenemos que verificar si valor implementa un método particular en tiempo de
ejecución o se preocupa por obtener errores si un valor no implementa un
método pero lo llamamos de todos modos. Rust no compilará nuestro código si
los valores no implementan los <em>trait</em> que los <em>trait objects</em> necesitan.</p>
<p>Por ejemplo, el Listado 17-10 muestra lo que sucede si tratamos de crear una
<code>Screen</code> con un <code>String</code> como componente:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listado 17-10: Intentar usar un tipo que no implementa
el <em>trait</em> del <em>trait objects</em></span></p>
<p>Obtendremos este error porque <code>String</code> no implementa el <em>trait</em> <code>Draw</code>:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<p>Este error nos permite saber que estamos pasando algo a <code>Screen</code> que no
queríamos pasar y que deberíamos pasar un tipo diferente o debemos
implementar <code>Draw</code> en <code>String</code> para que <code>Screen</code> pueda invocar <code>draw</code> en él.</p>
<h3 id="trait-objects-perform-dynamic-dispatch"><a class="header" href="#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></h3>
<p>Recordemos en la sección “Rendimiento del código usando genéricos” en el
Capítulo 10 nuestra discusión sobre el proceso de monomorfización realizado
por el compilador cuando utilizamos trait bounds en genéricos: el compilador
genera implementaciones no genéricas de funciones y métodos para cada tipo
concreto que usamos en el lugar de un parámetro de tipo genérico. El código que resulta de la monomorfización está haciendo <em>dispatch estático</em>, que es
cuando el compilador sabe a qué método está llamando en tiempo de
compilación. Esto se opone a <em>dispatch dinámico</em>, que es cuando el compilador
no puede decir en tiempo de compilación a qué método está llamando. En los
casos de envío dinámico, el compilador emite un código que en el tiempo de
ejecución determinará qué método llamar.</p>
<p>Cuando utilizamos <em>trait objects</em>, Rust debe usar el despacho dinámico. El
compilador no conoce todos los tipos que podrían usarse con el código que usa
<em>trait objects</em>, por lo que no sabe qué método se implementó en qué tipo
llamar. En cambio, en tiempo de ejecución, Rust utiliza los punteros dentro
del <em>trait objects</em> para saber qué método llamar. Hay un costo en tiempo de
ejecución cuando ocurre esta búsqueda que no ocurre con el envío estático. El
envío dinámico también evita que el compilador elija alinear el código de un
método, lo que a su vez impide algunas optimizaciones. Sin embargo, obtuvimos
flexibilidad adicional en el código que escribimos en el listado 17-5 y
pudimos apoyarlo en el listado 17-9, por lo que es una contrapartida a
considerar.</p>
<h3 id="se-requiere-seguridad-de-objetos-para-trait-objects"><a class="header" href="#se-requiere-seguridad-de-objetos-para-trait-objects">Se requiere seguridad de objetos para <em>Trait Objects</em></a></h3>
<p>Solo puede hacer <em>trait</em> <em>object-safe</em> en <em>trait objects</em>. Algunas reglas
complejas gobiernan todas las propiedades que hacen que un <em>trait objects</em>
sea seguro, pero en la práctica, solo dos reglas son relevantes. Un <em>trait</em>
es seguro para los objetos si todos los métodos definidos en el <em>trait</em>
tienen las siguientes propiedades:</p>
<ul>
<li>El tipo de devolución no es <code>Self</code>.</li>
<li>No hay parámetros genéricos de tipo.</li>
</ul>
<p>La palabra clave <code>Self</code> es un alias para el tipo en el que estamos
implementando los <em>trait</em> o métodos. Los <em>trait objects</em> deben ser seguros
para los objetos porque una vez que haya usado un <em>trait objects</em>, Rust ya no
sabe qué tipo concreto está implementando ese <em>trait</em>. Si un método de
<em>trait</em> devuelve el tipo concreto propio, pero un <em>trait objects</em> olvida
el tipo exacto que es el, no hay forma de que el método pueda
usar el tipo concreto original. Lo mismo es cierto para los parámetros de
tipo genérico que se rellenan con parámetros de tipo concreto cuando se usa
el <em>trait</em>: los tipos concreto se vuelven parte del tipo que implementa el
<em>trait</em>. Cuando el tipo se olvida mediante el uso de un <em>trait objects</em>, no
hay forma de saber qué tipos rellenar en el parámetros de tipo genérico con.</p>
<p>Un ejemplo de un <em>trait</em> cuyos métodos no son seguros para objetos es el
<em>trait</em> <code>Clone</code> de la biblioteca estándar. La firma del método <code>clone</code> en el
<em>trait</em> <code>Clone</code> se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>El tipo <code>String</code> implementa el <em>trait</em> <code>Clone</code>, y cuando llamamos al método
<code>clone</code> en una instancia de <code>String</code> recuperamos una instancia de <code>String</code>.
De manera similar, si llamamos <code>clone</code> a una instancia de <code>Vec&lt;T&gt;</code>, obtenemos
una instancia de <code>Vec&lt;T&gt;</code>. La firma de <code>clone</code> necesita saber qué tipo
representará para <code>Self</code>, porque ese es el tipo de devolución.</p>
<p>El compilador indicará cuando intenta hacer algo que viola las reglas de
seguridad de objetos con respecto a los <em>trait objects</em>. Por ejemplo,
supongamos que intentamos implementar la estructura <code>Screen</code> en el Listado
17-4 para mantener los tipos que implementan el <em>trait</em> <code>Clonar</code> en lugar del
<em>trait</em> <code>Draw</code>, como este:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>Obtendríamos este error:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>Este error significa que no puede usar este <em>trait</em> como un <em>trait object</em> de
esta manera. Si está interesado en más detalles sobre la seguridad de los
objetos, consulte <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementación-de-un-patrón-de-diseño-orientado-a-objetos"><a class="header" href="#implementación-de-un-patrón-de-diseño-orientado-a-objetos">Implementación de un patrón de diseño orientado a objetos</a></h2>
<p>El <em>state pattern</em> es un patrón de diseño orientado a objetos. La clave del
patrón es que un valor tiene un estado interno, que se representa mediante un
conjunto de <em>state objects</em>, y el comportamiento del valor cambia en función
del interno estado. Los objetos de estado comparten funcionalidad: en Rust,
por supuesto, usamos estructuras y <em>traits</em> en lugar de objetos y herencia.
Cada objeto de estado es responsable de su propio comportamiento y de
gobernar cuando debería cambiar a otro Estado. El valor que contiene un
<em>state object</em> (<em>objeto de estado</em>) no sabe nada sobre comportamiento
diferente de los estados o cuándo hacer la transición entre estados.</p>
<p>Usar el patrón de estado significa que cuando cambien los requisitos
comerciales del programa, no necesitaremos cambiar el código del valor que
contiene el estado o el código que usa el valor. Solo necesitaremos
actualizar el código dentro de uno de los objetos de estado para cambiar sus
reglas o quizás agregar más objetos de estado. Veamos un ejemplo del patrón
de diseño del estado y cómo usarlo en Rust.</p>
<p>Implementaremos un flujo de trabajo de publicación de blog de forma
incremental. El final del blog la funcionalidad se verá así:</p>
<ol>
<li>Una publicación de blog comienza como un borrador en blanco.</li>
<li>Cuando se finaliza el borrador, se solicita una revisión de la publicación.</li>
<li>Cuando se aprueba la publicación, se publica.</li>
<li>Solo las publicaciones de blog publicadas devuelven contenido para
imprimir, por lo que las publicaciones no aprobadas no pueden
accidentalmente ser publicadas.</li>
</ol>
<p>Cualquier otro cambio que se intente en una publicación no debería tener
ningún efecto. Por ejemplo, si tratamos de aprobar un borrador de entrada de
blog antes de solicitar una revisión, la publicación debe seguir siendo un
borrador no publicado.</p>
<p>El listado 17-11 muestra este flujo de trabajo en forma de código: este es un
ejemplo de uso de la API que implementaremos en una caja de la biblioteca
denominada <code>blog</code>. Esto aún no se compilará porque aún no hemos implementado
el <em>crate</em> <code>blog</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listado 17-11: Código que demuestra el comportamiento
deseado que queremos que tenga nuestro <em>crate</em> <code>blog</code></span></p>
<p>Queremos permitirle al usuario crear una nueva publicación borrador de blog
con <code>Post::new</code>. Entonces, queremos permitir que el texto se agregue a la
publicación del blog mientras está en el borrador estado. Si tratamos de
obtener el contenido de la publicación inmediatamente, antes de su aprobación,
no debería pasar nada porque la publicación sigue siendo un borrador. Hemos
agregado <code>assert_eq!</code> en el código con fines de demostración. Una excelente
prueba unitaria para esto sería afirmar que un borrador de una publicación de
blog devuelve un <em>string</em> vacía del método <code>content</code>, pero no vamos a
escribir pruebas para este ejemplo.</p>
<p>A continuación, queremos habilitar una solicitud de revisión de la
publicación, y queremos <code>content</code> para devolver un <em>string</em> vacía mientras
espera la revisión. Cuando la publicación recibe la aprobación, debe
publicarse, lo que significa que el texto de la publicación se devolverá
cuando se llame a <code>content</code>.</p>
<p>Tenga en cuenta que el único tipo con el que estamos interactuando desde el
<em>crate</em> es el <code>Post</code> tipo. Este tipo usará el patrón de estado y mantendrá un
valor que será uno de los tres objetos de estado que representan los diversos
estados en los que se puede publicar una publicación en borrador, en espera
de revisión o publicado. Cambiar de un estado a otro se gestionará
internamente dentro del tipo <code>Post</code>. Los estados cambian en respuesta a los
métodos llamados por los usuarios de nuestra biblioteca en la instancia
<code>Post</code>, pero no tienen que administrar los cambios de estado directamente.
Además, los usuarios no pueden cometer un error con los estados, como
publicar una publicación antes de que se revise.</p>
<h3 id="definición-de-post-y-creación-de-una-nueva-instancia-en-el-borrador-de-estado-draft-state"><a class="header" href="#definición-de-post-y-creación-de-una-nueva-instancia-en-el-borrador-de-estado-draft-state">Definición de <code>Post</code> y Creación de una nueva instancia en el <em>borrador de estado</em> (<em>Draft State</em>)</a></h3>
<p>¡Comencemos con la implementación de la biblioteca! Sabemos que necesitamos
una estructura pública de <code>Post</code> que contenga algo de contenido, así que
comenzaremos con la definición de la estructura y una función pública
asociada <code>new</code> para crear una instancia de <code>Post</code>, como se muestra en el
Listado 17-12 . También haremos un <em>trait</em> privado de <code>State</code>. Entonces
<code>Post</code> mantendrá un <em>trait object</em> de <code>Box&lt;State&gt;</code> dentro de un <code>Option</code> en
un campo privado llamado <code>state</code>. Verás por qué el <code>Option</code> es necesario en
un momento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-12: Definición de una estructura <code>Post</code> y
una función <code>new</code> que crea una nueva instancia <code>Post</code>, un <em>trait</em>
<code>State</code> y una estructura <code>Draft</code></span></p>
<p>El <em>trait</em> <code>State</code> define el comportamiento compartido por diferentes estados
de publicación, y los estados <code>Draft</code>, <code>PendingReview</code>, y <code>Published</code>
implementarán el atributo <code>State</code>. Por ahora, el <em>trait</em> no tiene ningún
método, y comenzaremos definiendo solo el estado <code>Draft</code> porque ese es el
estado en el que queremos que comience una publicación.</p>
<p>Cuando creamos un nuevo <code>Post</code>, establecemos su campo <code>state</code> en un valor
<code>Some</code> que contiene un <code>Box</code>. Este <code>Box</code> apunta a una nueva instancia de la
estructura <code>Draft</code>. Esto garantiza que cada vez que creamos una nueva
instancia de <code>Post</code>, comenzará como un borrador. Debido a que el campo
<code>state</code> de <code>Post</code> es privado, ¡no hay forma de crear un <code>Post</code> en ningún otro
estado! En la función <code>Post::new</code>, establecemos el campo <code>content</code> en un
nuevo <code>String</code> vacío.</p>
<h3 id="almacenar-el-texto-del-contenido-del-post"><a class="header" href="#almacenar-el-texto-del-contenido-del-post">Almacenar el texto del contenido del <em>Post</em></a></h3>
<p>El listado 17-11 mostró que queremos poder llamar a un método llamado
<code>add_text</code> y pasarle un <code>&amp;str</code> que luego se agrega al contenido de texto de
la publicación del blog. Implementamos esto como un método en lugar de
exponer el campo <code>content</code> como <code>pub</code>. Esto significa que podemos implementar
un método más adelante que controlará cómo se leen los datos del campo
<code>content</code>. El método <code>add_text</code> es bastante sencillo, así que agreguemos la
implementación en el Listado 17-13 al bloque <code>impl Post</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-13: Implementando el método <code>add_text</code> para
agregar texto al <code>content</code> de una publicación</span></p>
<p>El método <code>add_text</code> toma una referencia mutable a <code>self</code>, porque estamos
cambiando la instancia <code>Post</code> a la que estamos llamando <code>add_text</code>. Luego
llamamos a <code>push_str</code> en <code>String</code> en <code>content</code> y pasamos el argumento <code>text</code>
para agregarlo al <code>content</code> guardado. Este comportamiento no depende del
estado en que se encuentra la publicación, por lo que no forma parte del
patrón de estado. El método <code>add_text</code> no interactúa con el campo <code>state</code>,
pero es parte del comportamiento que queremos admitir.</p>
<h3 id="asegurar-que-el-contenido-de-un-draft-post-borrador-de-publicación-esté-vacío"><a class="header" href="#asegurar-que-el-contenido-de-un-draft-post-borrador-de-publicación-esté-vacío">Asegurar que el contenido de un <em>Draft Post</em> (<em>borrador de publicación</em>) esté vacío</a></h3>
<p>Incluso después de haber llamado <code>add_text</code> y agregado algo de contenido a
nuestra publicación, aún queremos que el método <code>content</code> devuelva un
<em>string slice</em> vacío porque la publicación aún está en el estado borrador,
como se muestra en la línea 8 del Listado 17- 11. Por ahora, implementemos el
método <code>content</code> con la cosa más simple que cumplirá este requisito: devolver
siempre un <em>string slice</em> vacío. Cambiaremos esto más tarde una vez que
implementemos la capacidad de cambiar el estado de una publicación para que
se pueda publicar. Hasta ahora, las publicaciones solo pueden estar en el
estado borrador, por lo que el contenido de la publicación siempre debe estar
vacío. El listado 17-14 muestra esta implementación de marcador de posición:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-14: Agregar una implementación de marcador
de posición para el método <code>content</code> en <code>Post</code> que siempre devuelve un
<em>string slice</em> vacío</span></p>
<p>Con este método agregado de <code>content</code>, todo en el Listado 17-11 hasta la
línea 8 funciona según lo previsto.</p>
<h3 id="solicitar-una-revisión-del-estado-post-changes"><a class="header" href="#solicitar-una-revisión-del-estado-post-changes">Solicitar una revisión del estado <em>Post Changes</em></a></h3>
<p>A continuación, debemos agregar funcionalidad para solicitar una revisión de
una publicación, que debería cambiar su estado de <code>Draft</code> a <code>PendingReview</code>.
El listado 17-15 muestra este código:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-15: Implementando los métodos
<code>request_review</code> en <code>Post</code> y el <em>trait</em> <code>State</code></span></p>
<p>Le damos a <code>Post</code> un método público llamado <code>request_review</code> que tomará una
referencia mutable a <code>self</code>. Luego llamamos a un método interno
<code>request_review</code> en el estado actual de <code>Post</code>, y este segundo método
<code>request_review</code> consume el estado actual y devuelve un nuevo estado.</p>
<p>Agregamos el método <code>request_review</code> al <em>trait</em> <code>State</code>; todos los tipos que
implementan el <em>trait</em> ahora necesitarán implementar el método
<code>request_review</code>. Tenga en cuenta que en lugar de tener <code>self</code>,<code>&amp;self</code>, o
<code>&amp;mut self</code> como el primer parámetro del método, tenemos <code>self:Box&lt;Self&gt;</code>.
Esta sintaxis significa que el método solo es válido cuando se le llama a un
<code>Box</code> que contiene el tipo. Esta sintaxis toma posesión de <code>Box&lt;Self&gt;</code>,
invalidando el estado anterior para que el valor de estado del <code>Post</code> pueda
transformarse en un nuevo estado.</p>
<p>Para consumir el estado anterior, el método <code>request_review</code> necesita tomar
posesión del valor del estado. Aquí es donde entra el <code>Option</code> en el campo
<code>state</code> de <code>Post</code>: llamamos al método <code>take</code> para sacar el valor <code>Some</code> del
campo <code>state</code> y dejar <code>None</code> en su lugar , porque Rust no nos permite tener
campos despoblados en las estructuras. Esto nos permite mover el valor de
<code>state</code> fuera de <code>Post</code> en lugar de tomarlo prestado. Luego estableceremos el
valor de <code>state</code> de la publicación en el resultado de esta operación.</p>
<p>Necesitamos establecer <code>state</code> en <code>None</code> temporalmente en lugar de
establecerlo directamente con un código como
<code>self.state = self.state.request_review();</code> para obtener la propiedad del
valor <code>state</code>. Esto garantiza que <code>Post</code> no pueda usar el antiguo valor
<code>state</code> una vez que lo hayamos transformado en un nuevo estado.</p>
<p>El método <code>request_review</code> en <code>Draft</code> necesita devolver una nueva instancia
encuadrada de una nueva estructura <code>PendingReview</code>, que representa el estado
cuando una publicación está esperando una revisión. La estructura
<code>PendingReview</code> también implementa el método <code>request_review</code>, pero no
realiza transformaciones. Más bien, se devuelve a sí mismo, porque cuando
solicitamos una revisión en una publicación que ya se encuentra en el estado
<code>PendingReview</code>, debe permanecer en el estado <code>PendingReview</code>.</p>
<p>Ahora podemos comenzar a ver las ventajas del patrón de estado: el método
<code>request_review</code> en <code>Post</code> es el mismo sin importar su valor <code>state</code>. Cada
estado es responsable de sus propias reglas.</p>
<p>Dejaremos el método <code>content</code> en <code>Post</code> tal como está, devolviendo un
<em>string slice</em> vacío. Ahora podemos tener un <code>Post</code> en el estado
<code>PendingReview</code>, así como en el estado <code>Draft</code>, pero queremos el mismo
comportamiento en el estado <code>PendingReview</code>. ¡El listado 17-11 ahora funciona
hasta la línea 11!.</p>
<h3 id="agregar-el-método-approve-que-cambia-el-comportamiento-del-content"><a class="header" href="#agregar-el-método-approve-que-cambia-el-comportamiento-del-content">Agregar el método <code>approve</code> que cambia el comportamiento del <code>content</code></a></h3>
<p>El método <code>approve</code> será similar al método <code>request_review</code>: establecerá
<code>state</code> en el valor que el estado actual dice que debería tener cuando se
aprueba ese estado, como se muestra en el Listado 17-16:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-16: Implementando el método <code>approve</code> en
<code>Post</code> y el <em>trait</em> <code>State</code></span></p>
<p>Agregamos el método <code>approve</code> al <em>trait</em> <code>State</code> y agregamos una nueva
estructura que implementa <code>State</code>, el estado <code>Published</code>.</p>
<p>Similar a <code>request_review</code>, si llamamos al método <code>approve</code> en un <code>Draft</code>, no
tendrá ningún efecto porque devolverá <code>self</code>. Cuando llamamos a <code>approve</code> on
<code>PendingReview</code>, devuelve una nueva instancia encuadrada de la estructura
<code>Published</code>. La estructura <code>Publicada</code> implementa el <em>trait</em> <code>State</code>, y tanto
para el método <code>request_review</code> como para el método <code>approve</code>, se devuelve a
sí mismo, porque la publicación debe permanecer en el estado <code>Published</code> en
esos casos.</p>
<p>Ahora necesitamos actualizar el método <code>content</code> en <code>Post</code>: si el estado es
<code>Published</code>, queremos devolver el valor en el campo <code>content</code> de la
publicación; de lo contrario, queremos devolver un <em>string slice</em> vacío, como
se muestra en el Listado 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait State {
</span><span class="boring">    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
</span><span class="boring">}
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-17: Actualización del método <code>content</code> en
<code>Post</code> para delegar en un método <code>content</code> en <code>State</code></span></p>
<p>Porque el objetivo es mantener todas estas reglas dentro de las estructuras
que implementan <code>State</code>, llamamos a un método <code>content</code> sobre el valor en
<code>state</code> y pasamos la publicación instancia (es decir, <code>self</code>) como argumento.
Luego devolvemos el valor que es regresó de usar el método <code>content</code> en el
valor <code>state</code>.</p>
<p>Llamamos al método <code>as_ref</code> en la <code>Option</code> porque queremos una referencia al
valor dentro de la <code>Option</code> en lugar de la propiedad del valor. Porque
<code>state</code> es un <code>Option&lt;Box&lt;State&gt;&gt;</code>, cuando llamamos <code>as_ref</code>, un
<code>Option&lt;&amp;Box&lt;State&gt;&gt;</code> es devuelto. Si no llamamos a <code>as_ref</code>, obtendríamos un
error porque no podemos mueve <code>state</code> fuera del <code>&amp;self</code> prestado del
parámetro function.</p>
<p>Luego llamamos al método <code>unwrap</code>, que sabemos que nunca entrará en pánico,
porque conocer los métodos en 'Post' asegurar que <code>state</code> siempre contenga un
<code>Some</code> valor cuando esos métodos están hechos. Este es uno de los casos de
los que hablamos en la sección “Casos cuando tiene más información que el
compilador” del Capítulo 9 cuando sabemos que un valor <code>None</code> nunca es
posible, aunque el compilador no es capaz de entender eso.</p>
<p>En este punto, cuando llamemos a <code>content</code> en <code>&amp;Box&lt;State&gt;</code>, la coerción
<em>deref</em> tendrá efecto en el <code>&amp;</code> y en el <code>Box</code> por lo que el método <code>content</code>
será en última instancia llamado en el tipo que implementa el <em>trait</em>
<code>State</code>. Eso significa que tenemos que agregar <code>content</code> a la definición de
<em>trait</em> <code>State</code>, y ahí es donde pondremos la lógica de qué contenido devolver
dependiendo de qué estado tenemos, como se muestra en el Listado 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String
</span><span class="boring">}
</span>trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-18: Agregar el método <code>content</code> al <em>trait</em>
<code>State</code></span></p>
<p>Agregamos una implementación predeterminada para el método <code>content</code> que
devuelve un <em>string slice</em> vacío. Eso significa que no necesitamos
implementar <code>content</code> en las estructuras <code>Draft</code> y <code>PendingReview</code>. La
estructura <code>Published</code> anulará el método <code>content</code> y devolverá el valor en
<code>post.content</code>.</p>
<p>Tenga en cuenta que necesitamos anotaciones de <em>lifetime</em> en este método,
como discutimos en el Capítulo 10. Estamos tomando como referencia un
<code>post</code> como argumento y devolviendo una referencia a parte de ese
<code>post</code>, por lo que la vida de la referencia devuelta está relacionado con el
<em>lifetime</em> del argumento <code>post</code>.</p>
<p>Y hemos terminado, ¡todo el Listado 17-11 ahora funciona!. Implementamos el
patrón de estado con las reglas del flujo de trabajo de publicación de blog.
La lógica relacionada con las reglas vive en los <em>objetos de estado</em>
(<em>state objects</em>) en lugar de dispersarse en <code>Post</code>.</p>
<h3 id="trade-offs-del-patrón-de-estado"><a class="header" href="#trade-offs-del-patrón-de-estado"><em>Trade-offs</em> del patrón de estado</a></h3>
<p>Hemos demostrado que Rust es capaz de implementar el patrón de estado
orientado a objetos para encapsular los diferentes tipos de comportamiento
que una publicación debe tener en cada estado. Los métodos en <code>Post</code> no saben
nada sobre los diversos comportamientos. La forma en que organizamos el
código, tenemos que buscar en un solo lugar para conocer las diferentes
formas en que se puede comportar una publicación publicada: la implementación
del <em>trait</em> <code>State</code> en la estructura <code>Published</code>.</p>
<p>Si tuviéramos que crear una implementación alternativa que no usara el patrón
de estado, podríamos usar expresiones <code>match</code> en los métodos en <code>Post</code> o
incluso en el código <code>main</code> que verifica el estado de la publicación y cambia
el comportamiento en esos lugares. ¡Eso significaría que tendríamos que
buscar en varios lugares para comprender todas las implicaciones de una
publicación en el estado publicado! Esto solo aumentaría a más estados que
agregamos: cada una de esas expresiones <code>match</code> necesitaría otro brazo.</p>
<p>Con el patrón de estado, los métodos <code>Post</code> y los lugares que usamos <code>Post</code>
no necesitan expresiones <code>match</code>, y para agregar un nuevo estado, solo
necesitaríamos agregar una nueva estructura e implementar los métodos del
<em>trait</em> en esa estructura.</p>
<p>La implementación que usa el patrón de estado es fácil de ampliar para
agregar más funcionalidad. Para ver la simplicidad de mantener el código que
usa el patrón de estado, pruebe algunas de estas sugerencias:</p>
<ul>
<li>Agregue un método <code>reject</code> que cambie el estado de la publicación de
<code>PendingReview</code> de nuevo a <code>Draft</code>.</li>
<li>Requiere dos llamadas para <code>approve</code> antes de que el estado pueda cambiarse
a <code>Published</code>.</li>
<li>Permitir a los usuarios agregar contenido de texto solo cuando una
publicación está en el estado <code>Draft</code>. Sugerencia: haga que el objeto de
estado sea responsable de lo que podría cambiar sobre el contenido, pero no
será responsable de modificar el <code>Post</code>.</li>
</ul>
<p>Una desventaja del patrón de estado es que, debido a que los estados
implementan las transiciones entre estados, algunos de los estados están
acoplados entre sí. Si agregamos otro estado entre <code>PendingReview</code> y
<code>Published</code>, como <code>Scheduled</code>, tendríamos que cambiar el código en
<code>PendingReview</code> para pasar a <code>Scheduled</code> en su lugar. Sería menos trabajo si
<code>PendingReview</code> no necesitara cambiarse con la adición de un nuevo estado,
pero eso significaría cambiar a otro patrón de diseño.</p>
<p>Otro inconveniente es que hemos duplicado algo de lógica. Para eliminar
parte de la duplicación, podemos intentar realizar implementaciones
predeterminadas para los métodos <code>request_review</code> y <code>approve</code> en el <em>trait</em>
<code>State</code> que devuelve <code>self</code>; sin embargo, esto violaría la seguridad de los
objetos, porque el <em>trait</em> no sabe cuál será exactamente el <code>self</code> concreto. Queremos poder utilizar <code>State</code> como un <em>trait object</em>, por lo que necesitamos que sus métodos sean seguros para los objetos.</p>
<p>Otra duplicación incluye las implementaciones similares de los métodos
<code>request_review</code> y <code>approve</code> en <code>Post</code>. Ambos métodos delegan a la
implementación del mismo método en el valor en el campo <code>state</code> de <code>Option</code>
y establecen el nuevo valor del campo <code>state</code> en el resultado. Si tuviéramos
muchos métodos en <code>Post</code> que siguieran este patrón, podríamos considerar la
definición de una macro para eliminar la repetición (ver el Apéndice D para
más información sobre macros).</p>
<p>Al implementar el patrón de estado exactamente como está definido para los
lenguajes orientados a objetos, no estamos aprovechando al máximo las
fortalezas de Rust como podríamos. Veamos algunos cambios que podemos hacer
en el <em>crate</em> <code>blog</code> que puede convertir los estados inválidos y las
transiciones en errores de tiempo de compilación.</p>
<h4 id="codificación-de-estados-encoding-states-y-comportamiento-como-tipos"><a class="header" href="#codificación-de-estados-encoding-states-y-comportamiento-como-tipos"><em>Codificación de estados</em> (<em>Encoding States</em>) y comportamiento como tipos</a></h4>
<p>Le mostraremos cómo repensar el patrón de estado para obtener un conjunto
diferente de concesiones. En lugar de encapsular completamente los estados y
las transiciones, por lo que el código externo no los conoce, codificaremos
los estados en diferentes tipos. En consecuencia, el sistema de comprobación
de tipos de Rust evitará los intentos de utilizar borradores de
publicaciones donde solo se permiten publicaciones publicadas al emitir un
error de compilación.</p>
<p>Consideremos la primera parte de <code>main</code> en el Listado 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<p>Todavía habilitamos la creación de nuevas publicaciones en el estado del
borrador utilizando <code>Post::new</code> y la posibilidad de agregar texto al
contenido de la publicación. Pero en lugar de tener un método <code>content</code> en
una publicación preliminar que devuelve un <em>string</em> vacío, lo haremos para
que las publicaciones preliminares no tengan el método <code>content</code> en
absoluto. De esta forma, si tratamos de obtener el contenido de un borrador,
obtendremos un error de compilación que nos indicará que el método no
existe. Como resultado, nos será imposible mostrar accidentalmente el
contenido del borrador de la publicación en producción, porque ese código ni
siquiera se compilará. El listado 17-19 muestra la definición de una
estructura <code>Post</code> y una estructura <code>DraftPost</code>, así como los métodos en cada
uno:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-19: Un <code>Post</code> con un método <code>content</code> y un
<code>DraftPost</code> sin un método <code>content</code></span></p>
<p>Las estructuras <code>Post</code> y <code>DraftPost</code> tienen un campo <code>content</code> privado que
almacena el texto de la entrada del blog. Las estructuras ya no tienen el
campo <code>state</code> porque estamos moviendo la codificación del estado a los tipos
de las estructuras. La estructura <code>Post</code> representará una publicación
publicada, y tiene un método <code>content</code> que devuelve el <code>content</code>.</p>
<p>Todavía tenemos una función <code>Post::new</code>, pero en lugar de devolver una
instancia de<code> Post</code>, devuelve una instancia de <code>DraftPost</code>. Como <code>content</code>
es privado y no hay funciones que devuelvan <code>Post</code>, no es posible crear una
instancia de <code>Post</code> en este momento.</p>
<p>La estructura <code>DraftPost</code> tiene un método <code>add_text</code>, por lo que podemos
agregar texto a <code>content</code> como antes, pero tenga en cuenta que <code>DraftPost</code>
no tiene definido un método <code>content</code>. Entonces, ahora el programa asegura
que todas las publicaciones comiencen como borradores de publicaciones, y
las publicaciones preliminares no tienen su contenido disponible para
mostrar. Cualquier intento de evitar estas restricciones dará como resultado
un error de compilación.</p>
<h4 id="implementando-transiciones-como-transformaciones-en-diferentes-tipos"><a class="header" href="#implementando-transiciones-como-transformaciones-en-diferentes-tipos">Implementando transiciones como transformaciones en diferentes tipos</a></h4>
<p>Entonces, ¿cómo conseguimos una publicación publicada?. Queremos hacer
cumplir la regla de que un borrador debe ser revisado y aprobado antes de
que pueda publicarse. Una publicación en el estado de revisión pendiente aún
no debe mostrar ningún contenido. Implementemos estas restricciones
agregando otra estructura, <code>PendingReviewPost</code>, definiendo el método
<code>request_review</code> en <code>DraftPost</code> para devolver <code>PendingReviewPost</code>, y
definiendo un método <code>approve</code> en <code>PendingReviewPost</code> para devolver <code>Post</code>,
como se muestra en el listado 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 17-20: Un <code>PendingReviewPost</code> que se crea al
invocar <code>request_review</code> en <code>DraftPost</code> y un método <code>approve</code> que convierte
un <code>PendingReviewPost</code> en un <code>Post</code> publicado</span></p>
<p>Los métodos <code>request_review</code> y <code>approve</code> toman la propiedad de <code>self</code>,
consumiendo así las instancias <code>DraftPost</code> y <code>PendingReviewPost</code> y
transformándolas en <code>PendingReviewPost</code> y en <code>Post</code> publicado,
respectivamente. De esta manera, no tendremos ninguna instancia <code>DraftPost</code>
persistente después de haber llamado <code>request_review</code> en ellos, y así
sucesivamente. La estructura <code>PendingReviewPost</code> no tiene un método
<code>content</code> definido, por lo que intentar leer su contenido genera un error de
compilación, como con <code>DraftPost</code>. Porque la única forma de obtener una
instancia de publicación publicada que tenga un método de <code>content</code> definido
es llamar al método <code>approve</code> en un <code>PendingReviewPost</code>, y la única forma de
obtener un <code>PendingReviewPost</code> es llamar al método <code>request_review</code> en un
<code>DraftPost</code>, ahora hemos codificado el flujo de trabajo de la publicación de
blog en el sistema de tipos.</p>
<p>Pero también tenemos que hacer algunos pequeños cambios en <code>main</code>. Los
métodos <code>request_review</code> y <code>approve</code> devuelven nuevas instancias en lugar de
modificar la estructura a la que están llamadas, por lo que necesitamos
agregar más asignaciones <em>shadowing</em> <code>let post =</code> para guardar las instancias
devueltas. Tampoco podemos tener las afirmaciones sobre el borrador y los
contenidos pendientes de revisión del mensaje como cadenas vacías, ni las
necesitamos: no podemos compilar código que intente usar el contenido de las
publicaciones en esos estados por más tiempo. El código actualizado en
<code>main</code> se muestra en el Listado 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listado 17-21: Modificaciones a <code>main</code> para usar la
nueva implementación del flujo de trabajo de blog</span></p>
<p>Los cambios que necesitamos hacer a <code>main</code> para reasignar <code>post</code> significan
que esta implementación ya no sigue el patrón de estado orientado a objetos:
las transformaciones entre los estados ya no están encapsuladas por completo
dentro de la implementación <code>Post</code>. Sin embargo, nuestra ganancia es que los
estados inválidos ahora son imposibles debido al sistema de tipos y la
verificación de tipos que ocurre en tiempo de compilación. Esto garantiza
que se descubrirán ciertos errores, como la visualización del contenido de
una publicación no publicada, antes de que lleguen a la producción.</p>
<p>Pruebe las tareas sugeridas para los requisitos adicionales que mencionamos
al comienzo de esta sección en el <em>crate</em> <code>blog</code>, ya que es posterior al
Listado 17-20 para ver qué piensa sobre el diseño de esta versión del
código. Tenga en cuenta que algunas de las tareas pueden completarse ya en
este diseño.</p>
<p>Hemos visto que, aunque Rust es capaz de implementar patrones de diseño
orientados a objetos, otros patrones, como el estado de codificación en el
sistema de tipos, también están disponibles en Rust. Estos patrones tienen
diferentes intercambios. Aunque es posible que esté muy familiarizado con
los patrones orientados a objetos, repensar el problema para aprovechar las
características de Rust puede proporcionar beneficios, como la prevención de
algunos errores en tiempo de compilación. Los patrones orientados a objetos
no siempre serán la mejor solución en Rust debido a ciertas características,
como la propiedad, que los lenguajes orientados a objetos no tienen.</p>
<h2 id="resumen-15"><a class="header" href="#resumen-15">Resumen</a></h2>
<p>No importa si cree que Rust es un lenguaje orientado a objetos después de
leer este capítulo, ahora sabe que puede usar <em>trait objects</em> para obtener
algunas características orientadas a objetos en Rust. El <em>dynamic dispatch</em>
(<em>despacho dinámico</em>) puede darle flexibilidad a su código a cambio de un
poco de rendimiento en el tiempo de ejecución. Puede utilizar esta
flexibilidad para implementar patrones orientados a objetos que pueden
ayudar al mantenimiento de su código. Rust también tiene otras
características, como la propiedad, que los lenguajes orientados a objetos
no tienen. Un patrón orientado a objetos no siempre será la mejor manera de
aprovechar las fortalezas de Rust, pero es una opción disponible.</p>
<p>A continuación, veremos patrones, que son otra de las características de
Rust que permiten mucha flexibilidad. Los hemos visto brevemente a lo largo
del libro, pero todavía no hemos visto su capacidad completa. ¡Vamonos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-and-matching"><a class="header" href="#patterns-and-matching">Patterns and Matching</a></h1>
<p>Los patrones son una sintaxis especial en Rust para hacer coincidir con la
estructura de tipos, tanto complejos como simples. El uso de patrones junto
con las expresiones <code>match</code> y otras construcciones le da más control sobre el
flujo de control de un programa. Un patrón consiste en una combinación de los
siguientes:</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>Estos componentes describen la forma de los datos con los que estamos
trabajando, y luego los comparamos con los valores para determinar si nuestro
programa tiene los datos correctos para continuar ejecutando un fragmento de
código en particular.</p>
<p>Para usar un patrón, lo comparamos con algún valor. Si el patrón coincide con
el valor, usamos las partes de valor en nuestro código. Recuerde las
expresiones <code>match</code> en el Capítulo 6 que utilizan patrones, como el ejemplo
de la máquina clasificadora de monedas. Si el valor se ajusta a la forma del
patrón, podemos usar las piezas nombradas. Si no lo hace, el código asociado
con el patrón no se ejecutará.</p>
<p>Este capítulo es una referencia sobre todo lo relacionado con patrones.
Cubriremos los lugares válidos para usar patrones, la diferencia entre
patrones refutables e irrefutables y los diferentes tipos de sintaxis de
patrones que podría ver. Al final del capítulo, sabrá cómo usar patrones para
expresar muchos conceptos de una manera clara.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="all-the-places-patterns-can-be-used"><a class="header" href="#all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</a></h2>
<p>¡Los patrones aparecen en varios lugares en Rust, y los has estado usando
mucho sin darte cuenta! Esta sección trata sobre todos los lugares donde los
patrones son válidos.</p>
<h3 id="match-brazos"><a class="header" href="#match-brazos"><code>match</code> Brazos</a></h3>
<p>Como se discutió en el Capítulo 6, usamos patrones en los brazos de las
expresiones <code>match</code>. Formalmente, las expresiones <code>match</code> se definen como la
palabra clave <code>match</code>, un valor para coincidir y uno o más brazos de
coincidencia que consisten en un patrón y una expresión para ejecutar si el
valor coincide con el patrón de ese brazo, como este:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>Un requisito para las expresiones <code>match</code> es que deben ser <em>exhaustivas</em> en
el sentido de que todas las posibilidades para el valor en la expresión
<code>match</code> deben ser contabilizadas. Una forma de asegurarse de haber cubierto
todas las posibilidades es tener un patrón de catchall para el último brazo:
por ejemplo, un nombre de variable que coincida con cualquier valor nunca
puede fallar y, por lo tanto, cubre todos los casos restantes.</p>
<p>Un patrón particular <code>_</code> coincidirá con cualquier cosa, pero nunca se une a
una variable, por lo que a menudo se usa en el último brazo de coincidencia.
El patrón <code>_</code> puede ser útil cuando quiere ignorar cualquier valor no
especificado, por ejemplo. Cubriremos el patrón <code>_</code> con más detalle en la
sección&quot; Ignorar valores en un patrón &quot;más adelante en este capítulo.</p>
<h3 id="expresiones-condicional-if-let"><a class="header" href="#expresiones-condicional-if-let">Expresiones condicional <code>if let</code></a></h3>
<p>En el Capítulo 6 discutimos cómo usar las expresiones <code>if let</code> principalmente
como una forma más corta de escribir el equivalente de un <code>match</code> que solo
coincide con un caso. Opcionalmente, <code>if let</code> puede tener un código que
contenga <code>else</code> correspondiente para ejecutar si el patrón en <code>if let</code> no
coincide.</p>
<p>El listado 18-1 muestra que también es posible mezclar y combinar las
expresiones <code>if let</code>, <code>else if</code>, y <code>else if let</code>. Hacerlo nos da más
flexibilidad que una expresión de <code>match</code> en la que podemos expresar un solo
valor para comparar con los patrones. Además, las condiciones en una serie de
brazos <code>if let</code>,<code>else if</code>, <code>else if let</code> no están obligados a relacionarse
entre sí.</p>
<p>El código en el listado 18-1 muestra una serie de comprobaciones para varias
condiciones que deciden cuál debe ser el color de fondo. Para este ejemplo,
hemos creado variables con valores codificados que un programa real podría
recibir de la entrada del usuario.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 18-1: Mezcla <code>if let</code>, <code>else if</code>, <code>else if let</code>,
y <code>else</code></span></p>
<p>Si el usuario especifica un color favorito, ese color es el color de fondo.
Si hoy es martes, el color de fondo es verde. Si el usuario especifica su
edad como un <em>string</em> y podemos analizarla como un número con éxito, el color
es púrpura o naranja dependiendo del valor del número. Si no se cumple
ninguna de estas condiciones, el color de fondo es azul.</p>
<p>Esta estructura condicional nos permite soportar requerimientos complejos.
Con los valores codificados que tenemos aquí, este ejemplo imprimirá
<code>Using purple as the background color</code>.</p>
<p>Puedes ver que <code>if let</code> también puede introducir variables sombreadas de la
misma manera que<code> match</code> arms can: la línea <code>if let Ok(age) = age</code> introduce
una nueva variable sombreada <code>age</code> que contiene el valor dentro del <code>Ok</code>
variante. Esto significa que debemos ubicar la condición <code>if age &gt; 30</code> dentro
de ese bloque: no podemos combinar estas dos condiciones en
<code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. La <code>age</code> sombreada que queremos comparar con 30 no es válida hasta que el nuevo alcance comience con llaves.</p>
<p>La desventaja de usar expresiones <code>if let</code> es que el compilador no verifica
la exhaustividad, mientras que con las expresiones <code>match</code> sí lo hace. Si
omitimos el último bloque <code>else</code> y, por lo tanto, fallamos al manejar algunos
casos, el compilador no nos alertaría sobre la posible falla lógica.</p>
<h3 id="while-let-bucles-condicionales"><a class="header" href="#while-let-bucles-condicionales"><code>while let</code> Bucles condicionales</a></h3>
<p>Similar en la construcción a <code>if let</code>, el bucle condicional <code>while let</code>
permite que un bucle <code>while</code> se ejecute mientras el patrón continúe
coincidiendo. El ejemplo en el Listado 18-2 muestra un bucle <code>while let</code> que
usa un vector como una pila e imprime los valores en el vector en el orden
opuesto en el que fueron empujados.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-2: Usando un bucle <code>while let</code> para imprimir
valores mientras <code>stack.pop()</code> devuelva <code>Some</code></span></p>
<p>Este ejemplo imprime 3, 2 y luego 1. El método <code>pop</code> toma el último elemento
del vector y devuelve <code>Some(value)</code>. Si el vector está vacío, <code>pop</code> devuelve
<code>None</code>. El bucle <code>while</code> continúa ejecutando el código en su bloque siempre
que <code>pop</code> devuelva <code>Some</code>. Cuando <code>pop</code> devuelve <code>None</code>, el ciclo se detiene.
Podemos usar <code>while let</code> para hacer estallar cada elemento de nuestra pila.</p>
<h3 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h3>
<p>En el Capítulo 3, mencionamos que el bucle <code>for</code> es la construcción de bucle
más común en el código Rust, pero aún no hemos discutido el patrón que <code>for</code>
toma. En un ciclo <code>for</code>, el patrón es el valor que sigue directamente a la
palabra clave <code>for</code>, por lo que en <code>for x in y</code> la <code>x</code> es el patrón.</p>
<p>El listado 18-3 muestra cómo usar un patrón en un ciclo <code>for</code> para
desestructurar o separar una tupla como parte del ciclo <code>for</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-3: Usar un patrón en un ciclo <code>for</code> para
desestructurar una tupla</span></p>
<p>El código en el Listado 18-3 imprimirá lo siguiente:</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>Usamos el método <code>enumerate</code> para adaptar un iterador para producir un valor
y el índice de ese valor en el iterador, colocado en una tupla. La primera
llamada a <code>enumerar</code> produce la tupla <code>(0, 'a')</code>. Cuando este valor se
corresponde con el patrón <code>(index, value)</code>, <code>index</code> será <code>0</code> y <code>value</code>
será <code>'a'</code>, imprimiendo la primera línea de la salida.</p>
<h3 id="let-statements"><a class="header" href="#let-statements"><code>let</code> Statements</a></h3>
<p>Antes de este capítulo, solo habíamos discutido explícitamente el uso de
patrones con <code>match</code> y <code>if let</code>, pero de hecho, también hemos usado patrones
en otros lugares, incluso en sentencias <code>let</code>. Por ejemplo, considere esta
asignación de variable directa con <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>A lo largo de este libro, hemos usado <code>let</code> de esta manera cientos de veces,
y aunque no te hayas dado cuenta, ¡estabas usando patrones!. Más formalmente,
una declaración <code>let</code> se ve así:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>En declaraciones como <code>let x = 5;</code> con un nombre de variable en la ranura
<code>PATTERN</code>, el nombre de la variable es simplemente una forma particularmente
simple de un patrón. Rust compara la expresión con el patrón y asigna los
nombres que encuentra. Entonces en el ejemplo <code>let x = 5;</code>, <code>x</code> es un patrón
que significa “Vincula lo que coincide aquí con la variable <code>x</code>”. Debido a
que el nombre <code>x</code> es el patrón completo, este patrón significa efectivamente
“enlazar todo a la variable <code>x</code>, cualquiera que sea el valor”.</p>
<p>Para ver el aspecto de coincidencia de patrones de <code>let</code> con mayor claridad,
considere el Listado 18-4, que utiliza un patrón con <code>let</code> para
desestructurar una tupla.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-4: Usar un patrón para desestructurar una
tupla y crear tres variables a la vez</span></p>
<p>Aquí, hacemos coincidir una tupla con un patrón. Rust compara el valor
<code>(1, 2, 3)</code> con el patrón <code>(x, y, z)</code> y ve que el valor coincide con el
patrón, por lo que Rust vincula <code>1</code> a <code>x</code>, <code>2</code> a <code>y</code>, y <code>3</code> a<code> z</code>. Puedes
pensar en este patrón de tuplas como anidando tres patrones variables
individuales dentro de él.</p>
<p>Si el número de elementos en el patrón no coincide con el número de elementos
en la tupla, el tipo general no coincidirá y obtendremos un error de
compilación. Por ejemplo, el Listado 18-5 muestra un intento de
desestructurar una tupla con tres elementos en dos variables, que no
funcionarán.</p>
<pre><code class="language-rust ignore">let (x, y) = (1, 2, 3);
</code></pre>
<p><span class="caption">Listado 18-5: Construcción incorrecta de un patrón
cuyas variables no coinciden con el número de elementos en la tupla</span></p>
<p>Intentar compilar este código da como resultado este tipo de error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<p>Si quisiéramos ignorar uno o más de los valores en la tupla, podríamos usar
<code>_</code> o <code>..</code>, como verá en la sección “Ignorar valores en un patrón”. Si el
problema es que tenemos demasiadas variables en el patrón, la solución es
hacer coincidir los tipos mediante la eliminación de variables para que el
número de variables sea igual al número de elementos en la tupla.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>Los parámetros de función también pueden ser patrones. El código en el
Listado 18-6, que declara una función llamada <code>foo</code> que toma un parámetro
llamado <code>x</code> de tipo <code>i32</code>, ahora debería parecer familiar.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: i32) {
    // code goes here
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-6: Una firma de función usa patrones en los
parámetros</span></p>
<p>¡La parte <code>x</code> es un patrón! Como hicimos con <code>let</code>, podríamos hacer coincidir
una tupla en los argumentos de una función con el patrón. El listado 18-7
divide los valores en una tupla cuando lo pasamos a una función.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listado 18-7: Una función con parámetros que
desestructuran una tupla</span></p>
<p>Este código imprime  <code>Current location: (3, 5)</code>. Los valores <code>&amp;(3, 5)</code>
coinciden con el patrón <code>&amp;(x, y)</code>, por lo que <code>x</code> es el valor <code>3</code> y <code>y</code> es el
valor <code>5</code>.</p>
<p>También podemos usar patrones en las listas de parámetros de <em>closure</em> de la
misma manera que en las listas de parámetros de función, porque los
<em>closures</em> son similares a las funciones, como se discutió en el Capítulo 13.</p>
<p>En este punto, ha visto varias formas de usar patrones, pero los patrones no
funcionan igual en todos los lugares donde podemos usarlos. En algunos
lugares, los patrones deben ser irrefutables; en otras circunstancias, pueden
ser refutables. Discutiremos estos dos conceptos a continuación.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refutability-whether-a-pattern-might-fail-to-match"><a class="header" href="#refutability-whether-a-pattern-might-fail-to-match">Refutability: Whether a Pattern Might Fail to Match</a></h2>
<p>Los patrones vienen en dos formas: refutable e irrefutable. Patrones que
coincidirán para cualquier valor posible pasado son <em>irrefutables</em>. Un
ejemplo sería <code>x</code> en la declaración <code>let x = 5;</code> porque <code>x</code> coincide con
cualquier cosa y por lo tanto no puede fallar. Los patrones que pueden no
coincidir con algún posible valor son <em>refutable</em>. Un ejemplo sería
<code>Some(x)</code> en la expresión <code>if let Some (x) = a_value</code> porque si el valor en
la variable <code>a_value</code> es <code>None</code> en lugar de <code>Some</code>, el patrón<code> Some (x)</code> no coincidirá.</p>
<p>Los parámetros de función, declaraciones <code>let</code> y <code>for</code> <em>loops</em> solo pueden
aceptar patrones irrefutables, porque el programa no puede hacer nada
significativo cuando los valores no coinciden Las expresiones <code>if let</code> y
<code>while let</code> solo aceptan patrones refutables, porque por definición están
destinados a manejar posibles falla: la funcionalidad de un condicional está
en su capacidad para realizar diferente dependiendo del éxito o el fracaso.</p>
<p>En general, no debería preocuparse por la distinción entre refutable
y patrones irrefutables; sin embargo, necesitas estar familiarizado con el
concepto de refutabilidad para que pueda responder cuando lo ve en un mensaje
de error. En esos casos, deberá cambiar el patrón o la construcción con la
que está utilizando el patrón, dependiendo del comportamiento previsto del
código.</p>
<p>Veamos un ejemplo de lo que sucede cuando tratamos de usar un patrón refutable
donde Rust requiere un patrón irrefutable y viceversa. El listado 18-8
muestra una declaración <code>let</code>, pero para el patrón hemos especificado
<code>Some(x)</code>, un patrón refutable. Como era de esperar, este código no se
compilará.</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">Listado 18-8: Intentando usar un patrón refutable con
<code>let</code></span></p>
<p>Si <code>some_option_value</code> era un valor <code>None</code>, no coincidiría con el patrón
<code>Some(x)</code>, lo que significa que el patrón es refutable. Sin embargo, la
instrucción <code>let</code> solo puede aceptar un patrón irrefutable porque no hay nada
válido que el código pueda hacer con un valor <code>None</code>. En tiempo de
compilación, Rust se quejará de que hemos intentado utilizar un patrón
refutable cuando se requiere un patrón irrefutable:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt;
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>Como no cubrimos (y no pudimos cubrir) todos los valores válidos con el
patrón <code>Some(x)</code>, Rust produce correctamente un error de compilación.</p>
<p>Para solucionar el problema donde tenemos un patrón refutable donde se
necesita un patrón irrefutable, podemos cambiar el código que usa el patrón:
en lugar de usar <code>let</code>, podemos usar <code>if let</code>. Entonces, si el patrón no
coincide, el código omitirá el código en las llaves, dándole una forma de
continuar válidamente. El Listado 18-9 muestra cómo arreglar el código en el
Listado 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_option_value: Option&lt;i32&gt; = None;
</span>if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-9: Usando <code>if let</code> y un bloque con patrones
refutables en vez de <code>let</code></span></p>
<p>¡Le hemos dado un código! Este código es perfectamente válido, aunque
significa que no podemos usar un patrón irrefutable sin recibir un error. Si
le damos a <code>if let</code> un patrón que siempre coincidirá, como <code>x</code>, como se
muestra en el Listado 18-10, no se compilará.</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">Listado 18-10: Intentando usar un patrón irrefutable
con <code>if let</code></span></p>
<p>Rust se queja de que no tiene sentido usar <code>if let</code> con un patrón irrefutable:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>Por esta razón, los brazos de <em>match</em> deben usar patrones refutables, excepto
el último brazo, que debe coincidir con cualquier valor restante con un
patrón irrefutable. Rust nos permite usar un patrón irrefutable en un
<code>match</code> con un solo brazo, pero esta sintaxis no es particularmente útil y
podría ser reemplazada por una declaración <code>let</code> más simple.</p>
<p>Ahora que sabe dónde usar patrones y la diferencia entre patrones refutables
e irrefutables, cubramos toda la sintaxis que podemos usar para crear
patrones.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sintaxis-de-patrones"><a class="header" href="#sintaxis-de-patrones">Sintaxis de patrones</a></h2>
<p>A lo largo del libro, has visto ejemplos de muchos tipos de patrones. En esta
sección, reunimos toda la sintaxis válida en los patrones y discutimos por
qué es posible que desee usar cada uno.</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<p>Como viste en el Capítulo 6, puedes unir patrones contra literales
directamente. El siguiente código brinda algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprime <code>one</code> porque el valor en <code>x</code> es 1. Esta sintaxis es útil
cuando desea que su código realice una acción si obtiene un valor concreto en
particular.</p>
<h3 id="coincidencia-de-variables-con-nombre"><a class="header" href="#coincidencia-de-variables-con-nombre">Coincidencia de variables con nombre</a></h3>
<p>Las variables con nombre son patrones irrefutables que coinciden con
cualquier valor, y los hemos utilizado muchas veces en el libro. Sin embargo,
hay una complicación cuando usa variables con nombre en expresiones <code>match</code>.
Debido a que <code>match</code> inicia un nuevo ámbito, las variables declaradas como
parte de un patrón dentro de la expresión <code>match</code> sombrearán aquellas con el
mismo nombre fuera de la construcción <code>match</code>, como es el caso de todas las
variables. En el listado 18-11, declaramos una variable llamada <code>x</code> con el
valor <code>Some(5)</code> y una variable <code>y</code> con el valor <code>10</code>. Luego creamos una
expresión <code>match</code> en el valor <code>x</code>. Mire los patrones en los brazos de partido
y <code>println!</code>. Al final, e intente descubrir qué se imprimirá el código antes
de ejecutar este código o leer más.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listado 18-11: Una expresión <code>match</code> con un brazo que
introduce un <em>shadowed variable</em> <code>y</code></span></p>
<p>Veamos qué pasa cuando se ejecuta la expresión <code>match</code>. El patrón
en el primer brazo coincidente no coincide con el valor definido de <code>x</code>, por
lo que el código continúa. El patrón en el brazo del segundo <em>match</em>
introduce una nueva variable llamada <code>y</code> que coincidirá con cualquier valor
dentro de un valor <code>Some</code>. Porque estamos en un nuevo alcance dentro
la expresión <code>match</code>, esta es una nueva variable <code>y</code>, no la <code>y</code> que
declaramos en el comienzo con el valor 10. Este nuevo enlace <code>y</code> coincidirá
con cualquier valor dentro de <code>Some</code>, que es lo que tenemos en <code>x</code>. Por lo
tanto, este nuevo <code>y</code> se une a el valor interno de <code>Some</code> en <code>x</code>. Ese valor
es <code>5</code>, por lo que la expresión de ese brazo ejecuta e imprime
<code>Matched, y = 5</code>.</p>
<p>Si <code>x</code> ha sido un valor <code>None</code> en lugar de <code>Some(5)</code>, los patrones en el
primer dos brazos no habrían coincidido, por lo que el valor habría
coincidido con el guion bajo. No introdujimos la variable <code>x</code> en el patrón del
subrayar el brazo, por lo que la <code>x</code> en la expresión sigue siendo la <code>x</code>
externa que no ha sido <em>shadowed</em>. En este caso hipotético, el <code>match</code>
imprimiría <code>Default case, x = None</code>.</p>
<p>Cuando se completa la expresión <code>match</code>, su alcance finaliza, y también lo
hace el alcance del <code>y</code> interno. El último <code>println!</code> produce
<code>at the end: x = Some(5), y = 10</code>.</p>
<p>Para crear una expresión de <code>match</code> que compare los valores de las <code>x</code> y las <code>y</code> externas, en lugar de introducir una variable <em>shadowed</em>, tendríamos que
usar un <em>match guard conditional</em> en su lugar. Hablaremos sobre los protectores de partido más adelante en la sección “Condicionales adicionales con <em>Match Guards</em>”.</p>
<h3 id="patrones-múltiples"><a class="header" href="#patrones-múltiples">Patrones múltiples</a></h3>
<p>En las expresiones <code>match</code>, puede hacer coincidir varios patrones con la
sintaxis <code>|</code>, lo que significa <em>o</em>. Por ejemplo, el siguiente código coincide
con el valor de <code>x</code> contra los brazos del <code>match</code>, el primero de los cuales
tiene una opción <em>o</em>, lo que significa que si el valor de <code>x</code> coincide con
cualquiera de los valores en ese brazo, el código de ese brazo se ejecutará:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código imprime <code>uno o dos</code>.</p>
<h3 id="coincidencia-de-rangos-de-valores-con-"><a class="header" href="#coincidencia-de-rangos-de-valores-con-">Coincidencia de rangos de valores con <code>...</code></a></h3>
<p>La sintaxis <code>...</code> nos permite coincidir con un rango de valores inclusivo. En
el siguiente código, cuando un patrón coincide con cualquiera de los valores
dentro del rango, ese brazo se ejecutará:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Si <code>x</code> es 1, 2, 3, 4 o 5, el primer brazo coincidirá. Esta sintaxis es más
conveniente que usar el operador <code>|</code> para expresar la misma idea; en lugar
de <code>1 ... 5</code>, tendríamos que especificar <code>1 | 2 | 3 | 4 | 5</code> si usamos <code>|</code>.
Especificar un rango es mucho más corto, especialmente si queremos hacer
coincidir, por ejemplo, cualquier número entre 1 y 1.000.</p>
<p>Los rangos solo se permiten con valores numéricos o valores <code>char</code>, porque
el compilador verifica que el rango no esté vacío en tiempo de compilación.
Los únicos tipos que Rust puede decir si un rango está vacío o no son <code>char</code>
y valores numéricos.</p>
<p>Aquí hay un ejemplo que usa rangos de valores <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 'c';

match x {
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust puede decir que <code>c</code> está dentro del rango del primer patrón e imprime
<code>early ASCII letter</code>.</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>También podemos usar patrones para desestructurar estructuras, enumeraciones
tuplas y referencias para usar diferentes partes de estos valores. Veamos
cada valor.</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h4>
<p>El listado 18-12 muestra una estructura <code>Point</code> con dos campos, <code>x</code> y <code>y</code>,
que podemos separar utilizando un patrón con una declaración <code>let</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listado 18-12: Desestructuración de los campos de una
estructura en variables separadas</span></p>
<p>Este código crea las variables <code>a</code> y <code>b</code> que coinciden con los valores de
los campos <code>x</code> y <code>y</code> de la variable <code>p</code>. Este ejemplo muestra que los
nombres de las variables en el patrón no tienen que coincidir con los
nombres de campo de la estructura. Pero es común querer que los nombres de
las variables coincidan con los nombres de los campos para que sea más fácil
recordar qué variables provienen de qué campos.</p>
<p>Debido a que tener nombres de variables coinciden con los campos es común y
porque al escribir <code>let Point { x: x, y: y } = p;</code> contiene mucha
duplicación, hay una forma abreviada de patrones que coinciden con los
campos de estructura: solo necesita listar el nombre del campo de estructura
y las variables creadas a partir del patrón tendrán los mismos nombres. El
listado 18-13 muestra código que se comporta de la misma manera que el
código en el listado 18-12, pero las variables creadas en el patrón <code>let</code>
son <code>x</code> y <code>y</code> en lugar de <code>a</code> y <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span></p>
<p>Este código crea las variables <code>x</code> y <code>y</code> que coinciden con los campos <code>x</code> y
<code>y</code> de la variable <code>p</code>. El resultado es que las variables <code>x</code> y <code>y</code>
contienen los valores de la estructura <code>p</code>.</p>
<p>También podemos desestructurar con valores literales como parte del patrón
<em>struct</em> en lugar de crear variables para todos los campos. Hacerlo nos
permite probar algunos de los campos para valores particulares al crear
variables para desestructurar los otros campos.</p>
<p>El listado 18-14 muestra una expresión de <code>match</code> que separa los valores de
<code>Point</code> en tres casos: puntos que se encuentran directamente en el eje <code>x</code>
(que es verdadero cuando <code>y = 0</code>), en el eje <code>y</code> (<code>x = 0</code>), o ninguno.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listado 18-14: <em>Destructuring</em> y <em>matching</em> valores
literales en un patrón</span></p>
<p>El primer brazo coincidirá con cualquier punto que se encuentre en el eje
<code>x</code> al especificar que el campo <code>y</code> coincide si su valor coincide con el
literal <code>0</code>. El patrón aún crea una variable <code>x</code> que podemos usar en el
código para este brazo.</p>
<p>De forma similar, el segundo brazo coincide con cualquier punto del eje <code>y</code>
al especificar que el campo <code>x</code> coincide si su valor es <code>0</code> y crea una
variable <code>y</code> para el valor del campo <code>y</code>. El tercer brazo no especifica
ningún literal, por lo que coincide con cualquier otro <code>Point</code> y crea
variables para los campos <code>x</code> y <code>y</code>.</p>
<p>En este ejemplo, el valor <code>p</code> coincide con el segundo brazo en virtud de
<code>x</code> que contiene un 0, por lo que este código imprimirá <code>On the y axis at 7</code>.</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h4>
<p>Hemos desestructurado las enumeraciones anteriormente en este libro, por
ejemplo, cuando desestructuramos <code>Option&lt;i32&gt;</code> en el Listado 6-5 en el
Capítulo 6. Un detalle que no hemos mencionado explícitamente es que el
patrón para desestructurar una enumeración debe corresponder a la forma en
que se definen los datos almacenados dentro de la enumeración. Como ejemplo,
en el Listado 18-15 utilizamos la enumeración <code>Message</code> del Listado 6-2 y
escribimos un <code>match</code> con patrones que desestructurarán cada valor interno.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listado 18-15: <em>Destructuring enum</em> variantes que contienen diferentes tipos de valores</span></p>
<p>Este código imprimirá <code>Change the color to red 0, green 160, and blue 255</code>.
Intente cambiar el valor de <code>msg</code> y ejecutarlo para ver el código de los
otros brazos.</p>
<p>Para las variantes <em>enum</em> sin ningún dato, como <code>Message::Quit</code>, no podemos
desestructurar el valor más. Solo podemos hacer coincidir el valor literal
<code>Message::Quit</code>, y no hay variables en ese patrón.</p>
<p>Para las variantes de enumeración tipo <em>struct</em>, como <code>Message::Move</code>,
podemos usar un patrón similar al patrón que especificamos para que coincida
con las estructuras. Después del nombre de la variante, colocamos llaves
y luego enumeramos los campos con variables para separar las piezas y
usarlas en el código para este brazo. Aquí usamos la forma abreviada como lo
hicimos en el listado 18-13.</p>
<p>Para las variantes <em>enum</em> tipo tupla, como <code>Message::Write</code> que contiene una
tupla con un elemento y <code>Message::ChangeColor</code> que contiene una tupla con
tres elementos, el patrón es similar al patrón que especificamos para hacer
coincidir tuplas. El número de variables en el patrón debe coincidir con la
cantidad de elementos en la variante que estamos combinando.</p>
<h4 id="destructuring-references"><a class="header" href="#destructuring-references">Destructuring References</a></h4>
<p>Cuando el valor que estamos combinando con nuestro patrón contiene una
referencia, necesitamos desestructurar la referencia del valor, lo cual
podemos hacer especificando un <code>&amp;</code> en el patrón. Hacerlo nos permite obtener
una variable que contenga el valor al que apunta la referencia en lugar de
obtener una variable que contenga la referencia. Esta técnica es
especialmente útil en <em>closures</em> donde tenemos iteradores que iteran sobre
referencias, pero queremos usar los valores en el <em>closure</em> en lugar de las
referencias.</p>
<p>El ejemplo en el listado 18-16 itera sobre referencias a instancias <code>Point</code>
en un vector, desestructurando la referencia y la estructura para que
podamos realizar cálculos sobre los valores <code>x</code> y <code>y</code> fácilmente.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];

let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point { x, y }| x * x + y * y)
    .sum();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-16: <em>Destructuring</em> una referencia a una
estructura en los valores del campo <em>struct</em></span></p>
<p>Este código nos da la variable <code>sum_of_squares</code> que contiene el valor 135,
que es el resultado de cuadrar el valor <code>x</code> y el valor <code>y</code>, sumarlos y luego
sumar el resultado de cada <code>Point</code> en los <code>points</code> vector para obtener un
número.</p>
<p>Si no hubiésemos incluido <code>&amp;</code> en <code>&amp;Punto { x, y }</code>, obtendríamos un error de
coincidencia de tipo, porque <code>iter</code> repetiría las referencias a los
elementos en el vector en lugar de los valores reales. El error sería así:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point { x, y }| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<p>Este error indica que Rust esperaba que nuestro <em>closure</em> coincidiera con
<code>&amp;Point</code>, pero tratamos de hacer coincidir directamente con un valor de
<code>Point</code>, no con una referencia a un <code>Point</code>.</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>Podemos mezclar, unir y jerarquizar patrones de desestructuración de formas
aún más complejas. El siguiente ejemplo muestra una desestructuración
complicada donde anidamos estructuras y tuplas dentro de una tupla y
desestructuramos todos los valores primitivos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>Este código nos permite dividir los tipos complejos en sus componentes para
que podamos usar los valores que nos interesan por separado.</p>
<p>La desestructuración con patrones es una forma conveniente de usar
fragmentos de valores, como el valor de cada campo en una estructura,
separadamente el uno del otro.</p>
<h3 id="ignorar-valores-en-un-patrón"><a class="header" href="#ignorar-valores-en-un-patrón">Ignorar valores en un patrón</a></h3>
<p>Has visto que a veces es útil ignorar los valores en un patrón, como en el
último brazo de una <code>match</code>, para obtener una captura que en realidad no
hace nada, pero que da cuenta de todos los valores posibles restantes. Hay
algunas maneras de ignorar valores enteros o partes de valores en un patrón:
usando el patrón <code>_</code> (que has visto), usando el patrón <code>_</code> dentro de otro
patrón, usando un nombre que comienza con un guión bajo, o usando <code>..</code> para
ignorar las partes restantes de un valor. Exploremos cómo y por qué usar
cada uno de estos patrones.</p>
<h4 id="ignorar-un-valor-completo-con-_"><a class="header" href="#ignorar-un-valor-completo-con-_">Ignorar un valor completo con <code>_</code></a></h4>
<p>Hemos utilizado el guión bajo (<code>_</code>) como un patrón comodín que coincidirá
con cualquier valor pero no se vinculará al valor. Aunque el patrón de
subrayado <code>_</code> es especialmente útil como el último brazo en una expresión de
<code>match</code>, podemos usarlo en cualquier patrón, incluidos los parámetros de
función, como se muestra en el listado 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Listado 18-17: Usando <code>_</code> en una firma de
función</span></p>
<p>Este código ignorará por completo el valor pasado como primer argumento, <code>3</code>
e imprimirá <code>This code only uses the y parameter: 4</code>.</p>
<p>En la mayoría de los casos, cuando ya no necesita un parámetro de función en
particular, debe cambiar la firma para que no incluya el parámetro no
utilizado. Ignorar un parámetro de función puede ser especialmente útil en
algunos casos, por ejemplo, cuando se implementa un <em>trait</em> cuando se
necesita una determinada firma de tipo, pero el cuerpo de la función en su
implementación no necesita uno de los parámetros. El compilador no advertirá
sobre los parámetros de la función no utilizados, como lo haría si usara un
nombre en su lugar.</p>
<h4 id="ignorar-partes-de-un-valor-con-un-anidado-_"><a class="header" href="#ignorar-partes-de-un-valor-con-un-anidado-_">Ignorar partes de un valor con un anidado <code>_</code></a></h4>
<p>También podemos usar <code>_</code> dentro de otro patrón para ignorar solo parte de un
valor, por ejemplo, cuando queremos probar solo una parte de un valor, pero
no tenemos uso para las otras partes en el código correspondiente que
queremos ejecutar. El listado 18-18 muestra el código responsable de
administrar el valor de una configuración. Los requisitos comerciales son
que no se debe permitir que el usuario sobrescriba una personalización
existente de una configuración, pero puede deshacer la configuración y puede
darle un valor a la configuración si está actualmente desarmada.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-18: Utilizando un guión bajo dentro de
patrones que coinciden con las variantes <code>Some</code> cuando no necesitamos usar
el valor dentro de <code>Some</code></span></p>
<p>Este código imprimirá <code>Can't overwrite an existing customized value</code> y
luego <code>setting is Some(5)</code>. En el primer brazo de coincidencia, no es
necesario que coincidamos ni utilicemos los valores dentro de la variante
<code>Some</code>, pero sí debemos probar el caso cuando <code>setting_value</code> y
<code>new_setting_value</code> son la variante <code>Some</code>. En ese caso, imprimimos por qué
no estamos cambiando <code>setting_value</code>, y no se cambia.</p>
<p>En todos los demás casos (si <code>setting_value</code> o <code>new_setting_value</code> son
<code>None</code>) expresados por el patrón <code>_</code> en el segundo brazo, queremos permitir
que <code>new_setting_value</code> se convierta en <code>setting_value</code>.</p>
<p>También podemos usar guiones bajos en varios lugares dentro de un patrón
para ignorar valores particulares. El listado 18-19 muestra un ejemplo de
ignorar los valores segundo y cuarto en una tupla de cinco elementos.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-19: Ignorar varias partes de una
tupla</span></p>
<p>Este código imprimirá <code>Some numbers: 2, 8, 32</code>, y los valores 4 y 16 serán
ignorados.</p>
<h4 id="ignorar-una-variable-no-utilizada-iniciando-su-nombre-con-_"><a class="header" href="#ignorar-una-variable-no-utilizada-iniciando-su-nombre-con-_">Ignorar una variable no utilizada iniciando su nombre con <code>_</code></a></h4>
<p>Si creas una variable pero no la usas en ningún lado, Rust generalmente
emitirá una advertencia porque podría ser un error. Pero a veces es útil
crear una variable que no usará todavía, como cuando está creando prototipos
o simplemente iniciando un proyecto. En esta situación, puede decirle a Rust
que no le advierta sobre la variable no utilizada comenzando el nombre de la
variable con un guión bajo. En el listado 18-20, creamos dos variables sin
usar, pero cuando ejecutamos este código, solo deberíamos recibir una
advertencia sobre una de ellas.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listado 18-20: Iniciar un nombre de variable con un
guión bajo para evitar recibir advertencias de variables no utilizadas</span></p>
<p>Aquí recibimos una advertencia acerca de no usar la variable <code>y</code>, pero no
recibimos una advertencia acerca de no usar la variable precedida por el
guión bajo.</p>
<p>Tenga en cuenta que hay una diferencia sutil entre usar solo <code>_</code> y usar un
nombre que comience con un guión bajo. La sintaxis <code>_x</code> todavía vincula el
valor a la variable, mientras que <code>_</code> no se une en absoluto. Para mostrar un
caso en el que importa esta distinción, el Listado 18-21 nos proporcionará
un error.</p>
<pre><code class="language-rust ignore">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">Listado 18-21: una variable no utilizada que comience
con un guión bajo aún vincula el valor, que podría tomar posesión del
valor</span></p>
<p>Recibiremos un error porque el valor <code>s</code> se moverá a <code>_s</code>, lo que nos impide
usar <code>s</code> nuevamente. Sin embargo, usar el guión bajo por sí mismo nunca se
vincula al valor. El listado 18-22 se compilará sin ningún error porque <code>s</code>
no se mueve a <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-22: El uso de un guión bajo no vincula el
valor</span></p>
<p>Este código funciona bien porque nunca vinculamos <code>s</code> a nada; no se mueve.</p>
<h4 id="ignorar-las-partes-restantes-de-un-valor-con-"><a class="header" href="#ignorar-las-partes-restantes-de-un-valor-con-">Ignorar las partes restantes de un valor con <code>..</code></a></h4>
<p>Con valores que tienen muchas partes, podemos usar la sintaxis <code>..</code> para
usar solo algunas partes e ignorar el resto, evitando la necesidad de
enumerar guiones bajos para cada valor ignorado. El patrón <code>..</code> ignora
cualquier parte de un valor que no hayamos igualado explícitamente en el
resto del patrón. En el listado 18-23, tenemos una estructura <code>Point</code> que
contiene una coordenada en el espacio tridimensional. En la expresión
<code>match</code>, queremos operar solo en la coordenada <code>x</code> e ignorar los valores en
los campos <code>y</code> y <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-23: Ignorando todos los campos de un
<code>Point</code> a excepción de <code>x</code> usando <code>..</code></span></p>
<p>Enumeramos el valor <code>x</code> y luego solo incluimos el patrón <code>..</code>. Esto es más
rápido que tener que listar <code>y: _</code> y <code>z: _</code>, particularmente cuando estamos
trabajando con estructuras que tienen muchos campos en situaciones donde
solo uno o dos campos son relevantes.</p>
<p>La sintaxis <code>..</code> se ampliará a tantos valores como sea necesario. El listado
18-24 muestra cómo usar <code>..</code> con una tupla.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">Listado 18-24: Coincidencia solo del primer y último
valor en una tupla e ignorando todos los demás valores</span></p>
<p>En este código, el primer y último valor se corresponden con <code>first</code> y
<code>last</code>. El <code>..</code> coincidirá e ignorará todo en el medio.</p>
<p>Sin embargo, usar <code>..</code> no debe ser ambiguo. Si no está claro qué valores
están destinados a la correspondencia y cuáles deben ignorarse, Rust nos
dará un error. El listado 18-25 muestra un ejemplo de uso de <code>..</code>
ambiguamente, por lo que no se compilará.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listado 18-25: Un intento de usar <code>..</code> de una manera
ambigua</span></p>
<p>Cuando compilamos este ejemplo, obtenemos este error:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>Es imposible para Rust determinar cuántos valores en la tupla ignorar antes
de hacer coincidir un valor con <code>second</code> y cuántos valores adicionales
ignorar después. Este código podría significar que queremos ignorar <code>2</code>,
enlazar <code>second</code> a <code>4</code>, y luego ignorar <code>8</code>, <code>16</code> y <code>32</code>; o que queremos
ignorar <code>2</code> y <code>4</code>, enlazar <code>second</code> a <code>8</code>, y luego ignorar <code>16</code> y <code>32</code>;
Etcétera. El nombre de la variable <code>second</code> no significa nada especial para
Rust, así que obtenemos un error de compilación porque el uso de <code>..</code> en dos
lugares como este es ambiguo.</p>
<h3 id="crear-referencias-en-patrones-con-ref-y-ref-mut"><a class="header" href="#crear-referencias-en-patrones-con-ref-y-ref-mut">Crear referencias en patrones con <code>ref</code> y <code>ref mut</code></a></h3>
<p>Veamos el uso de <code>ref</code> para hacer referencias para que la propiedad de los
valores no se mueva a las variables en el patrón. Por lo general, cuando
coincide con un patrón, las variables introducidas por el patrón están
vinculadas a un valor. Las reglas de propiedad de Rust significan que el
valor se moverá al <code>match</code> o al lugar en el que esté utilizando el patrón.
El listado 18-26 muestra un ejemplo de un <code>match</code> que tiene un patrón con
una variable y luego el uso de todo el valor en la instrucción <code>println!</code>.
Más tarde, después del <code>match</code>. Este código no podrá compilarse porque la
propiedad de parte del valor <code>robot_name</code> se transfiere a la variable <code>name</code>
en el patrón del primer brazo <code>match</code>.</p>
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<p><span class="caption">Listado 18-26: Crear una variable en un patrón de
brazo <code>match</code> toma posesión del valor</span></p>
<p>Como la propiedad de parte de <code>robot_name</code> se ha movido a <code>name</code>, ya no
podemos usar <code>robot_name</code> en <code>println!</code> después de la <code>coincidencia</code> porque
<code>robot_name</code> ya no tiene propiedad.</p>
<p>Para corregir este código, queremos hacer que el patrón <code>Some (name)</code>
<em>tome prestado</em> esa parte de <code>robot_name</code> en lugar de tomar posesión. Ya has
visto que, fuera de los patrones, la forma de tomar prestado un valor es
crear una referencia usando <code>&amp;</code>, por lo que podrías pensar que la solución
está cambiando <code>Some(name)</code> a <code>Some(&amp;name)</code>.</p>
<p>Sin embargo, como viste en la sección “Destructuring to Break Apart Values”,
la sintaxis <code>&amp;</code> en patrones no <em>crea</em> una referencia sino <em>coincide</em> con una
referencia existente en el valor. Debido a que <code>y</code> ya tiene ese significado
en los patrones, no podemos usar <code>&amp;</code> para crear una referencia en un patrón.</p>
<p>En cambio, para crear una referencia en un patrón, usamos la palabra clave
<code>ref</code> antes de la nueva variable, como se muestra en el Listado 18-27.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-27: Crear una referencia para que una
variable de patrón no tome posesión de un valor</span></p>
<p>Este ejemplo se compilará porque el valor en la variante <code>Some</code> en
<code>robot_name</code> no se mueve al <code>match</code>; el <code>match</code> solo tomó una referencia a
los datos en <code>robot_name</code> en lugar de moverlo.</p>
<p>Para crear una referencia mutable para que podamos mutar un valor
coincidente en un patrón, usamos <code>ref mut</code> en lugar de <code>&amp;mut</code>. La razón es,
una vez más, que en los patrones, el último es para hacer coincidir las
referencias mutables existentes, no crear nuevas. El listado 18-28 muestra
un ejemplo de un patrón que crea una referencia mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-28: Crear una referencia mutable a un valor
como parte de un patrón usando <code>ref mut</code></span></p>
<p>Este ejemplo compilará e imprimirá <code>robot_name is: Some(&quot;Another name&quot;)</code>.
Debido a que <code>name</code> es una referencia mutable, tenemos que eliminar la
referencia dentro del código del brazo de coincidencia usando el operador
<code>*</code> para mutar el valor.</p>
<h3 id="condicionales-adicionales-con-match-guards"><a class="header" href="#condicionales-adicionales-con-match-guards">Condicionales adicionales con <em>Match Guards</em></a></h3>
<p>Un <em>match guard</em> es una condición adicional <code>if</code> especificada después del
patrón en un brazo <code>match</code> que también debe coincidir, junto con la
coincidencia de patrón, para que se elija ese brazo. Los <em>match guard</em> son útiles para expresar ideas más complejas de lo que permite un
patrón solo.</p>
<p>La condición puede usar variables creadas en el patrón. El listado 18-29
muestra un <code>match</code> donde el primer brazo tiene el patrón <code>Some(x)</code> y también
tiene un guarda partido de <code>if x &lt; 5</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-29: Agregar un <em>match guard</em> a un
patrón</span></p>
<p>Este ejemplo imprimirá <code>less than five: 4</code>. Cuando <code>num</code> se compara con el
patrón en el primer brazo, coincide, porque <code>Some(4)</code> coincide con
<code>Some(x)</code>. Luego, el <em>match guard</em> verifica si el valor en <code>x</code> es menor que
<code>5</code>, y como lo es, se selecciona el primer brazo.</p>
<p>Si <code>num</code> hubiera sido <code>Some(10)</code>en su lugar, el <em>match guard</em> en el primer
brazo habría sido falso porque 10 no es menor que 5. Rust luego iría al
segundo brazo, que coincidiría porque el segundo brazo no tiene un
<em>match guard</em> y por lo tanto coincide con cualquier variante de <code>Some</code>.</p>
<p>No hay forma de expresar la condición <code>if x &lt; 5</code>dentro de un patrón, por lo
que el <em>match guard</em> nos da la capacidad de expresar esta lógica.</p>
<p>En el Listado 18-11, mencionamos que podríamos usar <em>match guard</em> para
resolver nuestro problema de <em>shadowing</em> de patrones. Recuerde que se creó
una nueva variable dentro del patrón en la expresión <code>match</code> en lugar de
usar la variable fuera del <code>match</code>. Esa nueva variable significaba que no
podíamos comparar con el valor de la variable externa. El listado 18-30
muestra cómo podemos usar un <em>match guard</em> para solucionar este problema.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listado 18-30: Uso de un <em>match guard</em> para
probar la igualdad con una variable externa</span></p>
<p>Este código ahora imprimirá <code>Default case, x = Some(5)</code>. El patrón en el
brazo del segundo <em>match</em> no introduce una nueva variable <code>y</code> que <em>shadow</em>
el<code> y</code> externo, lo que significa que podemos usar el <code>y</code> externo en el
<em>match guard</em>. En lugar de especificar el patrón como <code>Some(y)</code>, que habría
<em>shadowed</em> el <code>y</code> externo, especificamos <code>Some(n)</code>. Esto crea una nueva
variable <code>n</code> que no <em>shadow</em> nada porque no hay una variable <code>n</code> fuera del
<code>match</code>.</p>
<p>La función <em>match guard</em> <code>if n == y</code> no es un patrón y, por lo tanto, no
introduce nuevas variables. Este <code>y</code> <em>es</em> el <code>y</code> externo en vez de un nuevo
<code>y</code> <em>shadowed</em>, y podemos buscar un valor que tenga el mismo valor que el
<code>y</code> externo al comparar <code>n</code> con <code>y</code>.</p>
<p>También puede usar el operador <em>o</em> <code>|</code> en un <em>match guard</em> para especificar
múltiples patrones; la condición de <em>match guard</em> se aplicará a todos los
patrones. El listado 18-31 muestra la prioridad de combinar un <em>match guard</em>
con un patrón que usa <code>|</code>. La parte importante de este ejemplo es que el
<em>match guard</em> <code>if y</code> se aplica a <code>4</code>, <code>5</code>, <em>y</em> <code>6</code>, aunque podría parecer
<code>if y</code> solo se aplica a <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-31: Combinando múltiples patrones con un
<em>match guard</em></span></p>
<p>La condición de coincidencia establece que el brazo solo coincide si el
valor de <code>x</code> es igual a <code>4</code>, <code>5</code>, o <code>6</code> <em>y</em> si <code>y</code> es <code>true</code>. Cuando se
ejecuta este código, el patrón del primer brazo coincide porque <code>x</code> es <code>4</code>,
pero el <em>match guard</em> <code>if y</code> es falso, por lo que no se elige el primer
brazo. El código pasa al segundo brazo, que no coincide, y este programa
imprime <code>no</code>. La razón es que la condición <code>if</code> se aplica a todo el patrón
<code>4 | 5 | 6</code>, no solo al último valor <code>6</code>. En otras palabras, la precedencia
de un <em>match guard</em> en relación con un patrón se comporta así:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Después de ejecutar el código, el comportamiento de precedencia es evidente:
si el <em>match guard</em> se aplicara solo al valor final en la lista de valores
especificada usando el operador <code>|</code>, el brazo se habría igualado y el
programa habría impreso <code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>El operador <em>arroba</em> (<code>@</code>) nos permite crear una variable que contiene un
valor al mismo tiempo que probamos ese valor para ver si coincide con un
patrón. El listado 18-32 muestra un ejemplo donde queremos probar que un
campo <code>Message::Hello</code> <code>id</code> está dentro del rango <code>3 ... 7</code>. Pero también
queremos vincular el valor a la variable <code>id_variable</code> para que podamos
usarlo en el código asociado con el brazo. Podríamos nombrar esta variable
<code>id</code>, lo mismo que el campo, pero para este ejemplo utilizaremos un nombre
diferente.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 18-32: Usando <code>@</code> para enlazar a un valor en
un patrón mientras también lo prueba</span></p>
<p>Este ejemplo imprimirá <code>Found an id in range: 5</code>. Al especificar
<code>id_variable @</code> antes del rango <code>3 ... 7</code>, estamos capturando cualquier
valor que coincida con el rango, al mismo tiempo que probamos que el valor
coincide con el <em>patrón de rango</em> (<em>range pattern</em>).</p>
<p>En el segundo brazo, donde solo tenemos un rango especificado en el patrón,
el código asociado con el brazo no tiene una variable que contenga el valor
real del campo <code>id</code>. El valor del campo <code>id</code> podría haber sido 10, 11 o 12,
pero el código que acompaña a ese patrón no sabe cuál es. El código de
patrón no puede usar el valor del campo <code>id</code>, porque no hemos guardado el
valor <code>id</code> en una variable.</p>
<p>En el último brazo, donde hemos especificado una variable sin un rango,
tenemos el valor disponible para usar en el código del brazo en una variable
llamada <code>id</code>. La razón es que hemos utilizado la sintaxis abreviada del
campo <em>struct</em>. Pero no hemos aplicado ninguna prueba al valor en el campo
<code>id</code> en este brazo, como hicimos con los primeros dos brazos: cualquier
valor coincidiría con este patrón.</p>
<p>Usar <code>@</code> nos permite probar un valor y guardarlo en una variable dentro de
un patrón.</p>
<h2 id="resumen-16"><a class="header" href="#resumen-16">Resumen</a></h2>
<p>Los patrones de Rust son muy útiles ya que ayudan a distinguir entre
diferentes tipos de datos. Cuando se usa en expresiones <code>match</code>, Rust
asegura que sus patrones cubren todos los valores posibles, o su programa no
compilará. Los patrones en las declaraciones <code>let</code> y los parámetros de
función hacen que esos constructos sean más útiles, lo que permite la
desestructuración de los valores en partes más pequeñas al mismo tiempo que
la asignación a las variables. Podemos crear patrones simples o complejos
para satisfacer nuestras necesidades.</p>
<p>Luego, para el penúltimo capítulo del libro, veremos algunos aspectos
avanzados de una variedad de características de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="características-avanzadas"><a class="header" href="#características-avanzadas">Características avanzadas</a></h1>
<p>Hasta ahora, ha aprendido las partes más comúnmente usadas del lenguaje de
programación Rust. Antes de hacer un proyecto más en el Capítulo 20, veremos
algunos aspectos del lenguaje que puede encontrar de vez en cuando. Puede
usar este capítulo como referencia para cuando encuentre incógnitas cuando
use Rust. Las características que aprenderá a usar en este capítulo son
útiles en situaciones muy específicas. Aunque es posible que no los busque
con frecuencia, queremos asegurarnos de que comprende todas las
características que Rust tiene para ofrecer.</p>
<p>En este capítulo, cubriremos:</p>
<ul>
<li>Unsafe Rust: cómo desvincularse de algunas de las garantías de Rust y
asumir la responsabilidad de mantener manualmente esas garantías</li>
<li><em>Lifetimes</em> avanzada: sintaxis para situaciones complejas con <em>lifetime</em></li>
<li><em>Traits</em> avanzados: tipos asociados, parámetros de tipo predeterminados,
sintaxis completa, supertraits y el nuevo patrón de tipo en relación con los
<em>trait</em></li>
<li>Tipos avanzados: más sobre el nuevo tipo de patrón, los alias de tipo, el
nunca tipo y los tipos de tamaño dinámico</li>
<li>Funciones avanzadas y <em>closures</em>: <em>function pointers</em> y <em>returning closures</em></li>
</ul>
<p>¡Es una colección de características de Rust con algo para todos! ¡Vamos a sumergirnos!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-inseguro-rust"><a class="header" href="#unsafe-inseguro-rust"><em>Unsafe</em> (<em>inseguro</em>) Rust</a></h2>
<p>Todo el código que hemos discutido hasta ahora ha tenido las garantías de
seguridad de la memoria de Rust aplicadas en tiempo de compilación. Sin
embargo, Rust tiene un segundo lenguaje oculto dentro que no impone estas
garantías de seguridad de la memoria: se llama <em>Rust inseguro</em>
(<em>unsafe Rust</em>) y funciona igual que el Rust normal, pero nos da superpoderes
adicionales.</p>
<p>Rust inseguro existe porque, por naturaleza, el análisis estático es
conservador. Cuando el compilador intenta determinar si el código mantiene o
no las garantías, es mejor que rechace algunos programas válidos en lugar de
aceptar algunos programas no válidos. Aunque el código podría estar bien, por
lo que Rust puede decir, ¡no lo es!. En estos casos, puede usar un código
inseguro para decirle al compilador: “Créame, sé lo que estoy haciendo”. Lo
malo es que lo usa bajo su propio riesgo: si utiliza el código inseguro
incorrectamente, pueden ocurrir problemas debido a la inseguridad de la
memoria, como la desreferenciación de punteros nulos.</p>
<p>Otra razón por la que Rust tiene un alter ego inseguro es que el hardware
subyacente de la computadora es inherentemente inseguro. Si Rust no le
permitió hacer operaciones inseguras, no podría hacer ciertas tareas. Rust
debe permitirle realizar una programación de sistemas de bajo nivel, como
interactuar directamente con el sistema operativo o incluso escribir su
propio sistema operativo. Trabajar con sistemas de programación de bajo nivel
es uno de los objetivos del lenguaje. Exploremos qué podemos hacer con Rust
inseguro y cómo hacerlo.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>Para cambiar a Rust inseguro, use la palabra clave <code>unsafe</code> y luego comience
un nuevo bloque que contenga el código inseguro. Puedes tomar cuatro acciones
en Rust inseguro, llamadas <em>unsafe superpowers</em>, que no puedes usar en Rust seguro. Esos <em>Superpowers</em> incluyen la capacidad de:</p>
<ul>
<li>Desreferenciar un <em>raw pointer</em></li>
<li>Llamar a una función o método inseguro</li>
<li>Accede o modifica una variable estática mutable</li>
<li>Implementar un <em>trait</em> inseguro</li>
</ul>
<p>Es importante comprender que <code>unsafe</code> no apaga el comprobador de préstamos ni
desactiva ninguna otra de las verificaciones de seguridad de Rust: si utiliza
una referencia en un código inseguro, seguirá siendo revisado. La palabra
clave <code>unsafe</code> solo le da acceso a estas cuatro características que el
compilador no verifica para la seguridad de la memoria. Todavía obtendrá un
cierto grado de seguridad dentro de un bloque inseguro.</p>
<p>Además, <code>unsafe</code> no significa que el código dentro del bloque sea
necesariamente peligroso o que definitivamente tenga problemas de seguridad
en la memoria: la intención es que, como programador, se asegure de que el
código dentro de un bloque <code>unsafe</code> acceda a la memoria de una manera válida.</p>
<p>Las personas son falibles y se producirán errores, pero al requerir que estas
cuatro operaciones inseguras estén dentro de bloques anotados con <code>unsafe</code>,
sabrá que cualquier error relacionado con la seguridad de la memoria debe
estar dentro de un bloque <code>unsafe</code>. Mantenga los bloques <code>unsafe</code> pequeños;
Estarás agradecido más tarde cuando investigue errores de memoria.</p>
<p>Para aislar el código inseguro tanto como sea posible, es mejor incluir el
código no seguro dentro de una abstracción segura y proporcionar una API
segura, que veremos más adelante en el capítulo cuando examinemos funciones y
métodos inseguros. Partes de la biblioteca estándar se implementan como
abstracciones seguras sobre el código inseguro que se ha auditado. Envolver
el código no seguro en una abstracción segura evita que los usos de
<code>unsafe</code> se filtren en todos los lugares donde usted o sus usuarios puedan
querer usar la funcionalidad implementada con el código <code>unsafe</code>, porque usar
una abstracción segura es seguro.</p>
<p>Miremos cada una de las cuatro <em>superpowers unsafe</em> a su vez. También veremos
algunas abstracciones que proporcionan una interfaz segura para el código
inseguro.</p>
<h3 id="desreferenciar-un-raw-pointer"><a class="header" href="#desreferenciar-un-raw-pointer">Desreferenciar un <em>Raw Pointer</em></a></h3>
<p>En el Capítulo 4, en la sección “<em>Dangling</em> que cuelgan”, mencionamos que el
compilador asegura que las referencias siempre son válidas. <em>Unsafe</em> Rust
tiene dos nuevos tipos llamados <em>raw pointers</em> que son similares a las
referencias. Al igual que con las referencias, los punteros crudos pueden ser
inmutables o mutables y se escriben como <code>*const T</code> y <code>*mut T</code>,
respectivamente. El asterisco no es el operador de desreferencia; es parte
del nombre del tipo. En el contexto de los punteros sin formato,
<em>inmutables</em> significa que el puntero no puede asignarse directamente después
de haber sido desreferenciados.</p>
<p>A diferencia de las referencias y los punteros inteligentes, los punteros sin
formato:</p>
<ul>
<li>Se les permite ignorar las reglas de préstamo al tener punteros inmutables
y mutables o múltiples punteros mutables en la misma ubicación</li>
<li>No se garantiza que apunte a la memoria válida</li>
<li>Pueden ser nulos</li>
<li>No implemente ninguna limpieza automática</li>
</ul>
<p>Al optar por evitar que Rust haga cumplir estas garantías, puede renunciar a
la seguridad garantizada a cambio de un mayor rendimiento o la capacidad de
interactuar con otro lenguaje o hardware donde las garantías de Rust no se
apliquen.</p>
<p>El listado 19-1 muestra cómo crear un <em>raw pointer</em> inmutable y mutable a
partir de las referencias.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-1: Creación de <em>raw pointers</em> a partir de
referencias</span></p>
<p>Tenga en cuenta que no incluimos la palabra clave <code>unsafe</code> en este código.
Podemos crear <em>raw pointers</em> en código seguro; simplemente no podemos
desreferenciar <em>raw pointers</em> fuera de un bloque <code>unsafe</code>, como verán en un
momento.</p>
<p>Hemos creado <em>raw pointers</em> utilizando <code>as</code> para convertir una referencia
inmutable y mutable en sus correspondientes tipos de <em>raw pointers</em>. Debido a
que los creamos directamente a partir de referencias que se garantiza que son
válidas, sabemos que estos <em>raw pointers</em> particulares son válidos, pero no
podemos hacer esa suposición sobre cualquier <em>raw pointers</em>.</p>
<p>A continuación, crearemos un <em>raw pointers</em> cuya validez no podemos estar tan
seguros. El Listado 19-2 muestra cómo crear un <em>raw pointers</em> a una ubicación
arbitraria en la memoria. Intentar usar memoria arbitraria no está definido:
puede haber datos en esa dirección o puede que no, el compilador podría
optimizar el código para que no haya acceso a la memoria, o el programa
podría generar un error con un error de segmentación. Por lo general, no hay
una buena razón para escribir código como este, pero es posible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let address = 0x012345usize;
let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-2: Creación de un <em>raw pointer</em> a una
dirección de memoria arbitraria</span></p>
<p>Recuerde que podemos crear <em>raw pointers</em> en código seguro, pero no podemos
<em>desreferenciar</em>, <em>raw pointers</em> y leer los datos que se apuntan. En el
listado 19-3, usamos el operador de desreferencia <code>*</code> en un <em>raw pointers</em>
que requiere un bloque <code>unsafe</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-3: Cómo desreferenciar <em>raw pointers</em>
dentro de un bloque <code>unsafe</code></span></p>
<p>Crear un puntero no hace daño; solo cuando tratamos de acceder al valor que
señala, podríamos terminar lidiando con un valor no válido.</p>
<p>Tenga en cuenta también que en el listado 19-1 y 19-3, creamos <em>raw pointers</em> <code>*const i32</code> y <code>*mut i32</code> que apuntaban a la misma ubicación de memoria,
donde <code>num</code> está almacenado. Si en lugar de eso intentamos crear una
referencia inmutable y mutable a <code>num</code>, el código no se habría compilado
porque las reglas de propiedad de Rust no permiten una referencia mutable al
mismo tiempo que cualquier referencia inmutable. Con los <em>raw pointers</em>,
podemos crear un puntero mutable y un puntero inmutable en la misma ubicación
y cambiar los datos a través del puntero mutable, lo que podría crear una
carrera de datos. ¡Tenga cuidado!</p>
<p>Con todos estos peligros, ¿por qué usaría <em>raw pointers</em>?. Un caso de uso
importante es cuando se interactúa con el código C, como verá en la siguiente
sección, “Llamar a una función o método inseguro”. Otro caso es cuando se
crean abstracciones seguras que el verificador de préstamos no entiende.
Introduciremos funciones inseguras y luego veremos un ejemplo de abstracción
segura que usa código inseguro.</p>
<h3 id="llamar-a-una-función-o-método-inseguro"><a class="header" href="#llamar-a-una-función-o-método-inseguro">Llamar a una función o método inseguro</a></h3>
<p>El segundo tipo de operación que requiere un bloque inseguro es llamadas a
funciones inseguras. Las funciones y métodos inseguros se ven exactamente
como las funciones y los métodos normales, pero tienen un <code>unsafe</code> adicional
antes del resto de la definición. La palabra clave <code>unsafe</code> en este contexto
indica que la función tiene requisitos que debemos mantener cuando llamamos a
esta función, porque Rust no puede garantizar que cumplamos con estos
requisitos. Al llamar a una función insegura dentro de un bloque <code>unsafe</code>,
estamos diciendo que hemos leído la documentación de esta función y asumimos
la responsabilidad de mantener los contratos de la función.</p>
<p>Aquí hay una función insegura llamada <code>dangerous</code> que no hace nada en su
cuerpo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}

unsafe {
    dangerous();
}
<span class="boring">}
</span></code></pre></pre>
<p>Debemos llamar a la función <code>dangerous</code> dentro de un bloque <code>unsafe</code>
separado. Si tratamos de llamar <code>dangerous</code> sin el bloque <code>unsafe</code>,
obtendremos un error:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>Al insertar el bloque <code>unsafe</code> en nuestra llamada a <code>dangerous</code>, le estamos
diciendo a Rust que hemos leído la documentación de la función, que sabemos
cómo usarla correctamente y que hemos verificado que estamos cumpliendo el
contrato. de la función.</p>
<p>Los cuerpos de funciones inseguras son efectivamente bloques <code>unsafe</code>, por lo
que para realizar otras operaciones inseguras dentro de una función insegura,
no es necesario agregar otro bloque <code>unsafe</code>.</p>
<h4 id="creando-una-abstracción-segura-sobre-un-código-inseguro"><a class="header" href="#creando-una-abstracción-segura-sobre-un-código-inseguro">Creando una abstracción segura sobre un código inseguro</a></h4>
<p>El hecho de que una función contenga un código inseguro no significa que
tengamos que marcar toda la función como insegura. De hecho, envolver código
inseguro en una función segura es una abstracción común. Como ejemplo,
estudiemos una función de la biblioteca estándar, <code>split_at_mut</code>, que
requiere algún código inseguro y explore cómo podemos implementarlo. Este
método seguro se define en porciones mutables: toma una porción y la
convierte en dos dividiendo la porción en el índice dado como argumento. El
listado 19-4 muestra cómo usar <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-4: Uso de la función segura
<code>split_at_mut</code></span></p>
<p>No podemos implementar esta función usando solo Rust seguro. Un intento puede
parecerse al Listado 19-5, que no se compilará. Para simplificar,
implementaremos <code>split_at_mut</code> como una función en lugar de un método y solo
para segmentos de valores <code>i32</code> en lugar de para un tipo genérico <code>T</code>.</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">Listado 19-5: Un intento de implementación de
<code>split_at_mut</code> usando solo Rust seguro</span></p>
<p>Esta función primero obtiene la longitud total del <em>slice</em>. Luego afirma que
el índice dado como parámetro está dentro del <em>slice</em> al verificar si es
menor o igual a la longitud. La afirmación significa que si pasamos un índice
que es mayor que el índice para dividir el <em>slice</em>, la función entrará en
pánico antes de intentar usar ese índice.</p>
<p>Luego devolvemos dos <em>slice</em> mutables en una tupla: una desde el inicio del
<em>slice</em> original al índice <code>mid</code> y otra desde <code>mid</code> hasta el final del
<em>slice</em>.</p>
<p>Cuando intentemos compilar el código en el listado 19-5, obtendremos un error.</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>El comprobador de préstamos de Rust no puede entender que estamos tomando
prestadas partes diferentes del <em>slice</em>; solo sabe que tomamos prestado del misma <em>slice</em> dos veces. Pedir prestado diferentes partes de un <em>slice</em> es
fundamentalmente correcto porque los dos <em>slice</em> no se superponen, pero Rust
no es lo suficientemente inteligente como para saberlo. Cuando sabemos que el
código está bien, pero Rust no, es hora de buscar un código inseguro.</p>
<p>El Listado 19-6 muestra cómo utilizar un bloque <code>unsafe</code>, un <em>raw pointer</em> y
algunas llamadas a funciones inseguras para hacer que la implementación de
<code>split_at_mut</code> funcione.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-6: Usar código inseguro en la implementación
de la función <code>split_at_mut</code></span></p>
<p>Recuerde de la sección “Tipo de <em>Slice</em>” en el Capítulo 4 que los <em>slices</em>
son un puntero a algunos datos y la longitud del <em>slices</em>. Utilizamos el
método <code>len</code> para obtener la longitud de un <em>slices</em> y el método <code>as_mut_ptr</code>
para acceder al puntero sin formato de un <em>slices</em>. En este caso, como
tenemos un <em>slices</em> mutable a valores <code>i32</code>, <code>as_mut_ptr</code> devuelve un puntero
sin formato con el tipo <code>*mut i32</code>, que hemos almacenado en la variable <code>ptr</code>.</p>
<p>Mantenemos la afirmación de que el índice <code>mid</code> está dentro del <em>slices</em>.
Luego llegamos al código inseguro: la función <code>slice::from_raw_parts_mut</code>
toma un puntero sin formato y una longitud, y crea un <em>slices</em>. Usamos esta
función para crear un <em>slices</em> que comienza desde <code>ptr</code> y es <code>mid</code> largo.
Luego llamamos al método <code>offset</code> en <code>ptr</code> con <code>mid</code> como argumento para
obtener un puntero sin formato que comience en <code>mid</code>, y creamos un <em>slices</em>
usando ese puntero y el número restante de elementos después de <code>mid</code> como la
longitud.</p>
<p>La función <code>slice::from_raw_parts_mut</code> no es segura porque toma un puntero
sin formato y debe confiar en que este puntero es válido. El método <code>offset</code>
en punteros sin formato también es inseguro, porque debe confiar en que la
ubicación del desplazamiento también es un puntero válido. Por lo tanto,
tuvimos que poner un bloque <code>unsafe</code> alrededor de nuestras llamadas a
<code>slice::from_raw_parts_mut</code> y <code>offset</code> para que pudiéramos llamarlas. Al
observar el código y al agregar la afirmación de que <code>mid</code> debe ser menor o
igual que <code>len</code>, podemos decir que todos los <em>raw pointers</em> utilizados dentro
del bloque <code>unsafe</code> serán punteros válidos para los datos dentro del
<em>slice</em>. Este es un uso aceptable y apropiado de <code>unsafe</code>.</p>
<p>Tenga en cuenta que no necesitamos marcar la función <code>split_at_mut</code>
resultante como <code>unsafe</code>, y podemos llamar a esta función desde Rust seguro.
Hemos creado una abstracción segura del código inseguro con una
implementación de la función que usa el código <code>unsafe</code> de forma segura, ya
que solo crea punteros válidos a partir de los datos a los que tiene acceso
esta función.</p>
<p>Por el contrario, el uso de <code>slice::from_raw_parts_mut</code> en el Listado 19-7
probablemente se bloquee cuando se use el <em>slice</em>. Este código toma una
ubicación de memoria arbitraria y crea un <em>slice</em> de 10.000 elementos de
longitud.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-7: Crear un <em>slice</em> desde una ubicación de
memoria arbitraria</span></p>
<p>No poseemos la memoria en esta ubicación arbitraria, y no hay garantía de que
el <em>slice</em> que crea este código contenga valores <code>i32</code> válidos. Intentar
utilizar el <code>slice</code> como si fuera un <em>slice</em> válido da como resultado un
comportamiento indefinido.</p>
<h4 id="uso-de-funciones-extern-para-llamar-al-código-externo"><a class="header" href="#uso-de-funciones-extern-para-llamar-al-código-externo">Uso de funciones <code>extern</code> para llamar al código externo</a></h4>
<p>A veces, su código Rust podría necesitar interactuar con código escrito en
otro lenguaje. Para esto, Rust tiene una palabra clave, <code>extern</code>, que
facilita la creación y el uso de una <em>Foreign Function Interface (FFI)</em>. Un
FFI es una forma para que un lenguaje de programación defina funciones y
habilite un lenguaje de programación diferente (extranjero) para llamar a
esas funciones.</p>
<p>El listado 19-8 muestra cómo configurar una integración con la función <code>abs</code>
de la biblioteca estándar C. Las funciones declaradas dentro de bloques
<code>extern</code> siempre son inseguras para llamar desde el código Rust. La razón es
que otros lenguajes no hacen cumplir las reglas y garantías de Rust, y Rust
no puede verificarlos, por lo que la responsabilidad recae en el programador
para garantizar la seguridad.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Listado 19-8: Declarar y llamar a una función <code>extern</code>
definida en otro lenguaje</span></p>
<p>Dentro del bloque <code>extern&quot; C &quot;</code>, enumeramos los nombres y firmas de funciones
externas de otro lenguaje que queremos llamar. La parte <code>&quot;C&quot;</code> define qué
<em>application binary interface (ABI)</em> (<em>interfaz binaria de aplicación (ABI)</em>)
utiliza la función externa: el ABI define cómo llamar a la función en el
nivel de ensamblaje. El <code>&quot;C&quot;</code> ABI es el más común y sigue el ABI del lenguaje
de programación C.</p>
<blockquote>
<h4 id="llamar-a-funciones-de-rust-desde-otros-lenguajes"><a class="header" href="#llamar-a-funciones-de-rust-desde-otros-lenguajes">Llamar a funciones de Rust desde otros lenguajes</a></h4>
<p>También podemos usar <code>extern</code> para crear una interfaz que permita a otros
lenguajes llamar a las funciones de Rust. En lugar de un bloque <code>extern</code>,
agregamos la palabra clave <code>extern</code> y especificamos el ABI para usar justo
antes de la palabra clave <code>fn</code>. También necesitamos agregar una anotación
<code>#[no_mangle]</code> para decirle al compilador de Rust que no modifique el nombre
de esta función. <em>Mangling</em> es cuando un compilador cambia el nombre al que
hemos asignado una función por un nombre diferente que contiene más
información para que otras partes del proceso de compilación lo consuman,
pero es menos legible para el ser humano. Cada compilador de lenguaje de
programación manipula los nombres de forma ligeramente diferente, por lo
que para que una función Rust sea reconocible por otros lenguajes, debemos
deshabilitar el nombre del compilador Rust.</p>
<p>En el siguiente ejemplo, hacemos que la función <code>call_from_c</code> sea accesible
desde el código C, después de compilarla en una biblioteca compartida y
vincularla desde C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Este uso de <code>extern</code> no requiere <code>unsafe</code>.</p>
</blockquote>
<h3 id="acceder-o-modificar-una-variable-estática-mutable"><a class="header" href="#acceder-o-modificar-una-variable-estática-mutable">Acceder o modificar una variable estática mutable</a></h3>
<p>Hasta ahora, no hemos hablado sobre <em>variables globales</em>, que Rust sí admite,
pero puede ser problemático con las reglas de propiedad de Rust. Si dos hilos
están accediendo a la misma variable global mutable, puede causar una carrera
de datos.</p>
<p>En Rust, las variables globales se llaman <em>variables estáticas</em>. El listado
19-9 muestra una declaración de ejemplo y el uso de una variable estática con
un <em>string slice</em> como un valor.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listado 19-9: Definición y uso de una variable estática
inmutable</span></p>
<p>Las variables estáticas son similares a las constantes, que discutimos en la
sección “Diferencias entre variables y constantes” en el Capítulo 3. Los
nombres de las variables estáticas están en <code>SCREAMING_SNAKE_CASE</code> por
convención, y debemos <em>anotar</em> el tipo de la variable, que es <code>&amp;'static str</code>
en este ejemplo. Las variables estáticas solo pueden almacenar referencias
con el <em>lifetime</em> <code>'static</code>, lo que significa que el compilador de Rust puede
calcular la duración; no necesitamos anotarlo explícitamente. El acceso a una
variable estática inmutable es seguro.</p>
<p>Las constantes y las variables estáticas inmutables pueden parecer similares,
pero una diferencia sutil es que los valores en una variable estática tienen
una dirección fija en la memoria. El uso del valor siempre tendrá acceso a
los mismos datos. Las constantes, por otro lado, pueden duplicar sus datos
siempre que se utilicen.</p>
<p>Otra diferencia entre las constantes y las variables estáticas es que las
variables estáticas pueden ser mutables. El acceso y la modificación de
variables estáticas mutables es <em>inseguro</em>. El listado 19-10 muestra cómo
declarar, acceder y modificar una variable estática mutable llamada <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 19-10: leer o escribir en una variable estática
mutable es inseguro</span></p>
<p>Al igual que con las variables regulares, especificamos la mutabilidad usando
la palabra clave <code>mut</code>. Cualquier código que lea o escriba de <code>COUNTER</code> debe
estar dentro de un bloque <code>unsafe</code>. Este código compila e imprime
<code>COUNTER: 3</code> como se esperaría porque tiene un solo hilo. Tener múltiples
hilos de acceso <code>COUNTER</code> probablemente resultaría en carreras de datos.</p>
<p>Con los datos mutables que son accesibles a nivel mundial, es difícil
garantizar que no haya carreras de datos, razón por la cual Rust considera
que las variables estáticas mutables no son seguras. Siempre que sea posible,
es preferible utilizar las técnicas de concurrencia y <em>thread-safe smart
pointers</em> que discutimos en el Capítulo 16, de modo que el compilador
compruebe que los datos a los que se accede desde diferentes subprocesos se
realizan de forma segura.</p>
<h3 id="implementando-un-trait-inseguro"><a class="header" href="#implementando-un-trait-inseguro">Implementando un <em>Trait</em> Inseguro</a></h3>
<p>La acción final que solo funciona con <code>unsafe</code> está implementando un <em>trait</em>
inseguro. Un <em>trait</em> no es seguro cuando al menos uno de sus métodos tiene
alguna invariante que el compilador no puede verificar. Podemos declarar que
un <em>trait</em> es <code>unsafe</code> añadiendo la palabra clave <code>unsafe</code> antes de <code>trait</code> y
marcando la implementación del <code>trait</code> como <code>unsafe</code> también, como se muestra
en el Listado 19-11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-11: Definición e implementación de un <em>trait</em>
inseguro</span></p>
<p>Al utilizar <code>unsafe impl</code>, prometemos que mantendremos las invariantes que el
compilador no puede verificar.</p>
<p>Como ejemplo, recuerde los <em>trait</em> del marcador <code>Sync</code> y <code>Send</code> que
discutimos en la sección “Concurrencia extensible con los <em>Traits</em><code>Sync</code> y
<code>Send</code>” en el Capítulo 16: el compilador implementa estos <em>trait</em>
automáticamente si nuestros tipos están compuestos completamente de los tipos
<code>Send</code> y <code>Sync</code>. Si implementamos un tipo que contiene un tipo que no es
<code>Send</code> o <code>Sync</code>, como <em>raw pointers</em>, y queremos marcar ese tipo como <code>Send</code>
o <code>Sync</code>, debemos usar <code>unsafe</code>. Rust no puede verificar que nuestro tipo
mantenga las garantías de que puede enviarse de manera segura a través de
hilos o acceder desde múltiples hilos; por lo tanto, necesitamos hacer esos
controles manualmente e indicar como tal con <code>unsafe</code>.</p>
<h3 id="cuándo-usar-el-código-no-seguro"><a class="header" href="#cuándo-usar-el-código-no-seguro">Cuándo usar el código no seguro</a></h3>
<p>Usar <code>unsafe</code> para tomar una de las cuatro acciones (<em>superpoderes</em>)
(<em>superpowers</em>) que acabamos de discutir no es incorrecto o incluso
desaprobado. Pero es más complicado obtener el código <code>unsafe</code> correcto
porque el compilador no puede ayudar a mantener la seguridad de la memoria.
Cuando tiene una razón para usar el código <code>unsafe</code>, puede hacerlo, y tener
la anotación <code>unsafe</code> explícita hace que sea más fácil rastrear el origen de
los problemas si ocurren.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-traits"><a class="header" href="#advanced-traits">Advanced Traits</a></h2>
<p>Primero cubrimos los <em>traits</em> en la sección “Traits: Definición del
comportamiento compartido” del Capítulo 10, pero al igual que en los
<em>lifetimes</em>, no discutimos los detalles más avanzados. Ahora que sabes más
sobre Rust, podemos entrar en detalles.</p>
<h3 id="especificación-de-tipos-de-marcadores-de-posición-en-definiciones-de-trait-con-tipos-asociados"><a class="header" href="#especificación-de-tipos-de-marcadores-de-posición-en-definiciones-de-trait-con-tipos-asociados">Especificación de tipos de marcadores de posición en definiciones de <em>trait</em> con tipos asociados</a></h3>
<p><em>Associated types</em> (<em>Tipos asociados</em>) conectan un <em>placeholder</em> (<em>marcador
de posición</em>) de tipo con un <em>trait</em> tal que las definiciones del método del
<em>trait</em> pueden usar estos tipos de marcadores en sus firmas. El implementador
de un <em>trait</em> especificará el tipo concreto que se utilizará en el lugar de
este tipo para la implementación particular. De esta forma, podemos definir un <em>trait</em> que usa algunos tipos sin necesidad de saber exactamente qué tipos
son hasta que se implemente el <em>trait</em>.</p>
<p>Hemos descrito la mayoría de las características avanzadas de este capítulo
como raramente necesarias. Los tipos asociados están en algún punto
intermedio: se usan con más raramente que las funciones explicadas en el
resto del libro, pero más comúnmente que muchas de las otras características
que se analizan en este capítulo.</p>
<p>Un ejemplo de un <em>trait</em> con un tipo asociado es el <em>trait</em> <code>Iterator</code> que
proporciona la biblioteca estándar. El tipo asociado se denomina <code>Item</code> y
representa el tipo de valores sobre los que se está iterando el tipo que
implementa el atributo <code>Iterator</code>. En la sección &quot;El <em>trait</em> de <code>Iterator</code> y
método <code>next</code>” del Capítulo 13, mencionamos que la definición del <em>trait</em> de
<code>Iterator</code> es como se muestra en el Listado 19-20.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-20: La definición del *trait <code>Iterator</code> que
tiene un tipo asociado <code>Item</code></span></p>
<p>El tipo <code>Item</code> es un tipo de marcador de posición, y la definición del método
<code>next</code> muestra que devolverá valores de tipo <code>Option&lt;Self::Item&gt;</code>. Los
implementadores del <em>trait</em> <code>Iterator</code> especificarán el tipo concreto
para <code>Item</code>, y el método <code>next</code> devolverá un <code>Option</code> que contiene un valor
de ese tipo concreto.</p>
<p>Los tipos asociados pueden parecer un concepto similar a los genéricos, ya
que estos últimos nos permiten definir una función sin especificar qué tipos
puede manejar. Entonces, ¿por qué usar tipos asociados?.</p>
<p>Examinemos la diferencia entre los dos conceptos con un ejemplo del Capítulo 13 que implementa el <em>trait</em> <code>Iterator</code> en la estructura <code>Counter</code>. En el
listado 13-21, especificamos que el tipo <code>Item</code> era <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<p>Esta sintaxis parece comparable a la de los genéricos. Entonces, ¿por qué no
simplemente definir el <em>trait</em> <code>Iterator</code> con genéricos, como se muestra en
el Listado 19-21?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-21: Definición hipotética del <em>trait</em>
<code>Iterator</code> usando genéricos</span></p>
<p>La diferencia es que al usar genéricos, como en el listado 19-21, debemos
anotar los tipos en cada implementación; porque también podemos implementar
<code>Iterator&lt;String&gt; for Counter</code> o cualquier otro tipo, podríamos tener
múltiples implementaciones de <code>Iterator</code> para <code>Counter</code>. En otras palabras,
cuando un <em>trait</em> tiene un parámetro genérico, puede implementarse para un
tipo varias veces, cambiando los tipos concretos de los parámetros de tipo
genérico cada vez. Cuando utilizamos el método <code>next</code> en <code>Counter</code>,
deberíamos proporcionar anotaciones tipo para indicar qué implementación de
<code>Iterator</code> queremos usar.</p>
<p>Con los tipos asociados, no necesitamos anotar tipos porque no podemos
implementar un <em>trait</em> en un tipo varias veces. En el listado 19-20 con la
definición que usa tipos asociados, solo podemos elegir cuál será el tipo de
<code>Item</code> una vez, porque solo puede haber un <code>impl Iterator for Counter</code>. No es
necesario que especifiquemos que queremos un iterador de valores <code>u32</code> en
todas partes que llamemos <code>next</code> en <code>Counter</code>.</p>
<h3 id="parámetros-genéricos-predeterminados-y-sobrecarga-del-operador"><a class="header" href="#parámetros-genéricos-predeterminados-y-sobrecarga-del-operador">Parámetros genéricos predeterminados y sobrecarga del operador</a></h3>
<p>Cuando usamos parámetros genéricos, podemos especificar un tipo concreto
predeterminado para el tipo genérico. Esto elimina la necesidad de que los
implementadores del <em>trait</em> especifiquen un tipo concreto si el tipo
predeterminado funciona. La sintaxis para especificar un tipo predeterminado
para un tipo genérico es <code>&lt;PlaceholderType=ConcreteType&gt;</code> cuando se declara
el tipo genérico.</p>
<p>Un gran ejemplo de una situación donde esta técnica es útil es con la
sobrecarga del operador. <em>Sobrecarga del operador</em> (<em>Operator overloading</em>)
es la personalización del comportamiento de un operador (como <code>+</code>) en
situaciones particulares.</p>
<p>Rust no le permite crear sus propios operadores ni sobrecargar operadores
arbitrarios. Pero puede sobrecargar las operaciones y los <em>trait</em>
correspondientes listados en <code>std::ops</code> implementando los <em>trait</em>  asociados
con el operador. Por ejemplo, en el listado 19-22 sobrecargamos el operador
<code>+</code> para agregar dos instancias <code>Point</code> juntas. Hacemos esto implementando el
<em>trait</em>  <code>Add</code> en una estructura <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">Listado 19-22: Implementando el <em>trait</em> <code>Add</code> para
sobrecargar el operador <code>+</code> para instancias <code>Point</code></span></p>
<p>El método <code>add</code> agrega los valores <code>x</code> de dos instancias <code>Point</code> y los
valores <code>y</code> de dos instancias <code>Point</code> para crear un <code>Point</code> nuevo. El <em>trait</em>
<code>Add</code> tiene un tipo asociado llamado <code>Output</code> que determina el tipo devuelto
por el método <code>add</code>.</p>
<p>El tipo genérico predeterminado en este código está dentro del <em>trait</em>
<code>Add</code>. Aquí está su definición:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código debería parecer generalmente familiar: un <em>trait</em> con un método y
un tipo asociado. La parte nueva es <code>RHS=Self</code>: esta sintaxis se llama
<em>parámetros de tipo por defecto</em>. El parámetro de tipo genérico <code>RHS</code>
(abreviatura de “right hand side”) define el tipo del parámetro <code>rhs</code> en el
método <code>add</code>. Si no especificamos un tipo concreto para <code>RHS</code> cuando
implementamos el <em>trait</em> <code>Add</code>, el tipo de <code>RHS</code> cambiará automáticamente a
<code>Self</code>, que será del tipo en el que estamos implementando <code>Add</code>.</p>
<p>Cuando implementamos <code>Add</code> para <code>Point</code>, usamos el valor predeterminado para
<code>RHS</code> porque queríamos agregar dos instancias <code>Point</code>. Veamos un ejemplo de
implementación del <em>trait</em> <code>Add</code> donde queremos personalizar el tipo <code>RHS</code> en
lugar de usar el predeterminado.</p>
<p>Tenemos dos estructuras, <code>Millimeters</code> y <code>Meters</code>, que contienen valores en
diferentes unidades. Queremos agregar valores en milímetros a valores en
metros y hacer que la implementación de <code>Add</code> haga la conversión
correctamente. Podemos implementar <code>Add</code> para <code>Millimeters</code> con <code>Meters</code> como
<code>RHS</code>, como se muestra en el Listado 19-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-23: Implementando el <em>trait</em> <code>Add</code> en
<code>Millimeters</code> para agregar <code>Millimeters</code> a <code>Meters</code></span></p>
<p>Para agregar <code>Millimeters</code> y <code>Meters</code>, especificamos <code>impl Add&lt;Meters&gt;</code> para
establecer el valor del parámetro de tipo <code>RHS</code> en lugar de usar el valor
predeterminado de <code>Self</code>.</p>
<p>Utilizará parámetros de tipo predeterminados de dos formas principales:</p>
<ul>
<li>Para extender un tipo sin romper el código existente</li>
<li>Para permitir la personalización en casos específicos, la mayoría de los
usuarios no necesitarán</li>
</ul>
<p>El <em>trait</em> <code>Add</code> de la biblioteca estándar es un ejemplo del segundo
propósito: generalmente, agregará dos tipos similares, pero el <em>trait</em> <code>Add</code>
proporciona la capacidad de personalizar más allá de eso. El uso de un
parámetro de tipo predeterminado en la definición del  <em>trait</em> <code>Add</code>
significa que no tiene que especificar el parámetro extra la mayor parte del
tiempo. En otras palabras, no se necesita un poco de texto repetitivo de
implementación, lo que facilita el uso del <em>trait</em>.</p>
<p>El primer propósito es similar al segundo pero a la inversa: si desea agregar
un parámetro de tipo a un <em>trait</em> existente, puede otorgarle un valor
predeterminado para permitir la extensión de la funcionalidad del <em>trait</em> sin
romper el código de implementación existente.</p>
<h3 id="sintaxis-totalmente-calificada-para-desambiguación-métodos-de-llamada-con-el-mismo-nombre"><a class="header" href="#sintaxis-totalmente-calificada-para-desambiguación-métodos-de-llamada-con-el-mismo-nombre">Sintaxis totalmente calificada para desambiguación: métodos de llamada con el mismo nombre</a></h3>
<p>Nada en Rust impide que un <em>trait</em> tenga un método con el mismo nombre que el
de otro <em>trait</em>, ni Rust le impide implementar ambos <em>traits</em> en un solo
tipo. También es posible implementar un método directamente en el tipo con el
mismo nombre que los métodos de los <em>traits</em>.</p>
<p>Cuando llame a métodos con el mismo nombre, tendrá que decirle a Rust cuál
quiere usar. Considere el código en el listado 19-24 donde hemos definido dos
<em>traits</em>, <code>Pilot</code> y <code>Wizard</code>, que tienen un método llamado <code>fly</code>. Luego
implementamos ambos <em>traits</em> en un tipo <code>Human</code> que ya tiene implementado un método llamado <code>fly</code>. Cada método <code>fly</code> hace algo diferente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-24: Dos <em>traits</em> se definen para tener un
método <code>fly</code> y se implementan en el tipo <code>Human</code>, y un método <code>fly</code> que se
implementa en <code>Human</code> directamente</span></p>
<p>Cuando llamamos <code>fly</code> en una instancia de <code>Human</code>, el compilador establece de
manera predeterminada el método que se implementa directamente en el tipo,
como se muestra en el Listado 19-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listado 19-25: Llamar a <code>fly</code> en una instancia de
<code>Human</code></span></p>
<p>Al ejecutar este código se imprimirá <code>*waving arms furiously*</code>, mostrando que
Rust llamó directamente al método <code>fly</code> implementado en <code>Human</code>.</p>
<p>Para llamar a los métodos <code>fly</code> desde el <em>trait</em> <code>Pilot</code> o el <em>trait</em>
<code>Wizard</code>, necesitamos usar una sintaxis más explícita para especificar a qué
método <code>fly</code> nos referimos. El listado 19-26 demuestra esta sintaxis.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listado 19-26: Especificando el método <code>fly</code> de ese
<em>trait</em> que queremos llamar</span></p>
<p>Especificando el nombre del <em>trait</em> antes de que el nombre del método aclare
a Rust qué implementación de <code>fly</code> queremos llamar. También podríamos
escribir <code>Human::fly(&amp;person)</code>, que es equivalente a <code>person.fly()</code> que
usamos en el listado 19-26, pero esto es un poco más largo de escribir si no
necesitamos desambiguar.</p>
<p>Al ejecutar este código, se imprime lo siguiente:</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Debido a que el método <code>fly</code> toma un parámetro <code>self</code>, si tuviéramos dos
<em>tipos</em> que implementaran un <em>trait</em>, Rust podría averiguar qué
implementación de un <em>trait</em> utilizar en función del tipo de <code>self</code>.</p>
<p>Sin embargo, las funciones asociadas que son parte de <em>trait</em> no tienen un
parámetro <code>self</code>. Cuando dos tipos en el mismo ámbito implementan ese <em>trait</em>
Rust no puede determinar a qué tipo se refiere a menos que use la
<em>sintaxis completa</em>. Por ejemplo, el <em>trait</em> <code>Animal</code> en el Listado 19-27
tiene la función asociada <code>baby_name</code>, la implementación de <code>Animal</code> para la
estructura <code>Dog</code>, y la función asociada <code>baby_name</code> definida en <code>Dog</code>
directamente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listado 19-27: Un <em>trait</em> con una función asociada y un
tipo con una función asociada del mismo nombre que también implementa el
<em>trait</em></span></p>
<p>Este código es para un refugio de animales que quiere nombrar a todos los
cachorros <em>Spot</em>, que se implementa en la función asociada <code>baby_name</code> que se
define en <code>Dog</code>. El tipo <code>Dog</code> también implementa el <em>trait</em> <code>Animal</code>, que
describe las características que tienen todos los animales. Los perros bebé
se llaman cachorros, y eso se expresa en la implementación del <em>trait</em>
<code>Animal</code> en <code>Dog</code> en la función <code>baby_name</code> asociada con el <em>trait</em> <code>Animal</code>.</p>
<p>En <code>main</code>, llamamos a la función <code>Dog::baby_name</code>, que llama directamente a
la función asociada definida en <code>Dog</code>. Este código imprime lo siguiente:</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<p>Este resultado no es lo que queríamos. Queremos llamar a la función
<code>baby_name</code> que forma parte del <em>trait</em> <code>Animal</code> que implementamos en <code>Dog</code>,
por lo que el código se imprime <code>A baby dog is called a puppy</code>. La técnica de
especificar el nombre del <em>trait</em> que utilizamos en el listado 19-26 no ayuda
aquí; si cambiamos <code>main</code> al código en el Listado 19-28, obtendremos un error
de compilación.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">Listado 19-28: Intentando llamar a la función
<code>baby_name</code> del <em>trait</em> <code>Animal</code>, pero Rust no sabe qué implementación
usar</span></p>
<p>Como <code>Animal::baby_name</code> es una función asociada más que un método, y por lo
tanto no tiene un parámetro <code>self</code>, Rust no puede determinar qué
implementación de <code>Animal::baby_name</code> queremos. Obtendremos este error de
compilación:</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
</code></pre>
<p>Para desambiguar y decirle a Rust que queremos usar la implementación de
<code>Animal</code> para <code>Dog</code>, necesitamos usar una sintaxis totalmente calificada. El
listado 19-29 demuestra cómo utilizar la sintaxis totalmente calificada.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listado 19-29: Usar la sintaxis totalmente calificada
para especificar que queremos llamar a la función <code>baby_name</code> del <em>trait</em>
<code>Animal</code> tal como se implementó en <code>Dog</code></span></p>
<p>Le proporcionamos a Rust una anotación de tipo dentro de los corchetes
angulares, lo que indica que queremos llamar al método <code>baby_name</code> del
<em>trait</em> <code>Animal</code> implementado en <code>Dog</code> diciendo que queremos tratar el tipo
<code>Dog</code> como un <code>Animal</code> para esta llamada de función. Este código ahora
imprimirá lo que queremos:</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<p>En general, la sintaxis totalmente calificada se define de la siguiente
manera:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>Para las funciones asociadas, no habría un <code>receiver</code>: solo habría una lista
de otros argumentos. Puede usar sintaxis totalmente calificada en todas
partes a las que llame funciones o métodos. Sin embargo, puede omitir
cualquier parte de esta sintaxis que Rust pueda deducir de otra información
en el programa. Solo necesita usar esta sintaxis más detallada en los casos
en que hay varias implementaciones que usan el mismo nombre y Rust necesita
ayuda para identificar a qué implementación desea llamar.</p>
<h3 id="usar-supertraits-para-exigir-la-funcionalidad-de-un-trait-dentro-de-otro-trait"><a class="header" href="#usar-supertraits-para-exigir-la-funcionalidad-de-un-trait-dentro-de-otro-trait">Usar <em>Supertraits</em> para exigir la funcionalidad de un <em>Trait</em> dentro de otro <em>Trait</em></a></h3>
<p>Algunas veces, puede necesitar un <em>trait</em> para usar la funcionalidad de otro
<em>trait</em>. En este caso, debe confiar en que los <em>traits</em> dependientes también
se están implementando. El <em>trait</em> en el que confía es un <em>supertrait</em> del
<em>trait</em> que está implementando.</p>
<p>Por ejemplo, supongamos que queremos crear un <em>trait</em> <code>OutlinePrint</code> con un
método <code>outline_print</code> que imprimirá un valor enmarcado en asteriscos. Es
decir, dada una estructura <code>Point</code> que implementa <code>Display</code> para dar como
resultado <code>(x, y)</code>, cuando llamamos a <code>outline_print</code> en una instancia
<code>Point</code> que tiene <code>1</code> para <code>x</code> y <code>3</code> para <code>y</code>, debe imprimir lo siguiente:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>En la implementación de <code>outline_print</code>, queremos usar la funcionalidad del
<em>trait</em> <code>Display</code>. Por lo tanto, debemos especificar que el <em>trait</em>
<code>OutlinePrint</code> solo funcionará para los tipos que también implementen
<code>Display</code> y proporcionen la funcionalidad que <code>OutlinePrint</code> necesita.
Podemos hacer eso en la definición de <em>trait</em> especificando
<code>OutlinePrint: Display</code>. Esta técnica es similar a agregar un <em>trait</em> ligado
al <em>trait</em>. El listado 19-30 muestra una implementación del <em>trait</em>
<code>OutlinePrint</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-30: Implementando el <em>trait</em> <code>OutlinePrint</code>
que requiere la funcionalidad de <code>Display</code></span></p>
<p>Debido a que hemos especificado que <code>OutlinePrint</code> requiere el <em>trait</em>
<code>Display</code>, podemos usar la función <code>to_string</code> que se implementa
automáticamente para cualquier tipo que implemente <code>Display</code>. Si intentamos
usar <code>to_string</code> sin agregar dos puntos y especificando el <em>trait</em> <code>Display</code>
después del nombre del <em>trait</em>, obtendríamos un error al decir que no se
encontró ningún método llamado <code>to_string</code> para el tipo <code>&amp;Self</code> en el alcance
actual .</p>
<p>Veamos qué sucede cuando tratamos de implementar <code>OutlinePrint</code> en un tipo
que no implementa <code>Display</code>, como la estructura <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait OutlinePrint {}
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">}
</span></code></pre></pre>
<p>Recibimos un error al decir que <code>Display</code> es obligatorio pero no implementado:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<p>Para solucionar esto, implementamos <code>Display</code> en <code>Point</code> y satisfacemos la
restricción que <code>OutlinePrint</code> requiere, así:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Luego, la implementación del <em>trait</em> <code>OutlinePrint</code> en <code>Point</code> se compilará
correctamente, y podemos llamar <code>outline_print</code> en una instancia <code>Point</code> para
mostrarlo dentro de un contorno de asteriscos.</p>
<h3 id="uso-del-patrón-newtype-para-implementar-rasgos-externos-en-tipos-externos"><a class="header" href="#uso-del-patrón-newtype-para-implementar-rasgos-externos-en-tipos-externos">Uso del patrón <em>Newtype</em> para implementar rasgos externos en tipos externos</a></h3>
<p>En el Capítulo 10 en la sección “Implementación de un <em>trait</em> en un tipo”,
mencionamos la regla huérfana que establece que podemos implementar un
<em>trait</em> en un tipo, siempre que el <em>trait</em> o el tipo sean locales para
nuestro <em>crate</em>. Es posible sortear esta restricción usando el
<em>newtype pattern</em>, que implica la creación de un nuevo tipo en una estructura
tuple. (Cubrimos las estructuras de tuplas en la sección “Usar estructuras
<em>Tuple</em> sin <em>Named Fields</em> para crear diferentes tipos” del Capítulo 5). La
estructura de tuplas tendrá un campo y será un envoltorio del tipo para el
que queremos implementar un <em>trait</em>. Entonces el tipo de envoltura es local
para nuestro <em>crate</em>, y podemos implementar el <em>trait</em> en el envoltorio.
<em>Newtype</em> es un término que se origina del lenguaje de programación Haskell.
No hay penalización de rendimiento en el tiempo de ejecución para usar este
patrón, y el tipo de envoltura se elimina en el momento de la compilación.</p>
<p>Como ejemplo, digamos que queremos implementar <code>Display</code> en <code>Vec&lt;T&gt;</code>, que la
regla huérfana nos impide hacer directamente porque el <em>trait</em> <code>Display</code> y el
tipo <code>Vec&lt;T&gt;</code> se definen fuera de nuestro <em>crate</em> . Podemos hacer una
estructura <code>Wrapper</code> que contenga una instancia de <code>Vec&lt;T&gt;</code>; luego podemos
implementar <code>Display</code> en <code>Wrapper</code> y usar el valor <code>Vec&lt;T&gt;</code>, como se muestra
en el Listado 19-31.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Listado 19-31: Crear un tipo <code>Wrapper</code> alrededor d
<code>Vec&lt;String&gt;</code> para implementar <code>Display</code></span></p>
<p>La implementación de <code>Display</code> usa <code>self.0</code> para acceder al <code>Vec&lt;T&gt;</code> interno,
porque <code>Wrapper</code> es una estructura <em>tuple</em> y <code>Vec&lt;T&gt;</code>es el ítem en el índice
0 en la tupla. Entonces podemos usar la funcionalidad del tipo <code>Display</code> en
<code>Wrapper</code>.</p>
<p>La desventaja de usar esta técnica es que <code>Wrapper</code> es un tipo nuevo, por lo
que no tiene los métodos del valor que tiene. Tendríamos que implementar
todos los métodos de <code>Vec&lt;T&gt;</code> directamente en <code>Wrapper</code> de manera que los
métodos deleguen en <code>self.0</code>, lo que nos permitiría tratar <code>Wrapper</code>
exactamente como <code>Vec&lt;T&gt;</code>. Si quisiéramos que el nuevo tipo tuviera todos los
métodos del tipo interno, implementando el <em>trait</em> <code>Deref</code> (discutido en el
Capítulo 15 en la sección “Tratar punteros inteligentes como referencias
regulares con el <em>Trait</em> <code>Deref</code>”) en el <code>Wrapper</code> para devolver el tipo
interno sería una solución. Si no queremos que el tipo <code>Wrapper</code> tenga todos
los métodos del tipo interno, por ejemplo, para restringir el comportamiento
del tipo <code>Wrapper</code>, tendríamos que implementar solo los métodos que queremos
manualmente.</p>
<p>Ahora ya sabes cómo se usa el patrón de tipo nuevo en relación con los
<em>traits</em>; también es un patrón útil incluso cuando los <em>traits</em> no están
involucrados. Cambiemos el enfoque y veamos algunas formas avanzadas de
interactuar con el sistema de tipos de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h2>
<p>El sistema de tipo Rust tiene algunas características que hemos mencionado en
este libro pero que aún no hemos discutido. Comenzaremos analizando los tipos
nuevos en general al examinar por qué los tipos nuevos son útiles como tipos.
Luego pasaremos a escribir <em>alias</em>, una característica similar a <em>newtypes</em>
pero con semántica ligeramente diferente. También discutiremos el tipo <code>!</code> Y
los tipos de tamaño dinámico.</p>
<blockquote>
<p>Nota: La siguiente sección supone que ha leído la sección anterior  “<em>The Newtype</em>
Patrón para implementar <em>traits</em> externos en tipos externos.”</p>
</blockquote>
<h3 id="uso-del-patrón-newtype-para-la-seguridad-y-la-abstracción-de-tipos"><a class="header" href="#uso-del-patrón-newtype-para-la-seguridad-y-la-abstracción-de-tipos">Uso del patrón <em>Newtype</em> para la seguridad y la abstracción de tipos</a></h3>
<p>El patrón de tipo nuevo es útil para tareas más allá de las que hemos
discutido hasta ahora, incluida la aplicación estática de que los valores
nunca se confundan y que indiquen las unidades de un valor. Viste un ejemplo
del uso de <em>newtypes</em> para indicar unidades en el listado 19-23: recuerde que
las estructuras <code>Millimeters</code> y <code>Meters</code> envolvieron los valores <code>u32</code> en un
nuevo tipo. Si escribimos una función con un parámetro de tipo <code>Millimeters</code>,
no podríamos compilar un programa que accidentalmente intentó llamar a esa
función con un valor de tipo <code>Meters</code> o simplemente <code>u32</code>.</p>
<p>Otro uso del patrón <em>newtype</em> es abstraer algunos detalles de implementación
de un tipo: el nuevo tipo puede exponer una API pública que es diferente de
la API del tipo interno privado si usamos el nuevo tipo directamente para
restringir la funcionalidad disponible, para ejemplo.</p>
<p><em>Newtypes</em> también puede ocultar la implementación interna. Por ejemplo,
podríamos proporcionar un tipo <code>People</code> para ajustar un
<code>HashMap&lt;i32, String&gt;</code> que almacena la identificación de una persona asociada
con su nombre. El código que utiliza <code>People</code> solo interactuaría con la API
pública que proporcionamos, como un método para agregar un <em>string</em> de nombre
a la colección <code>People</code>; ese código no necesitaría saber que asignamos una
identificación <code>i32</code> a los nombres internamente. El nuevo patrón de tipo es
una forma ligera de lograr la encapsulación para ocultar los detalles de
implementación, que discutimos en la sección “Encapsulación que oculta
detalles de implementación” del Capítulo 17.</p>
<h3 id="creación-de-sinónimos-de-tipo-con-alias-de-tipo"><a class="header" href="#creación-de-sinónimos-de-tipo-con-alias-de-tipo">Creación de sinónimos de tipo con alias de tipo</a></h3>
<p>Junto con el patrón de <em>newtype</em>, Rust proporciona la capacidad de declarar
un <em>type alias</em> para dar a un tipo existente otro nombre. Para esto, usamos
la palabra clave <code>type</code>. Por ejemplo, podemos crear el alias <code>Kilometers</code> a
<code>i32</code> de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Ahora, el alias <code>Kilometers</code> es un <em>sinónimo</em> para <code>i32</code>; a diferencia de los
tipos <code>Millimeters</code> y <code>Meters</code> que creamos en el listado 19-23, <code>Kilometers</code>
no es un tipo nuevo e independiente. Los valores que tienen el tipo
<code>Kilometers</code> se tratarán de la misma manera que los valores de tipo <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>Debido a que <code>Kilometers</code> y <code>i32</code> son del mismo tipo, podemos agregar valores
de ambos tipos y podemos pasar valores <code>Kilometers</code> a las funciones que toman
los parámetros <code>i32</code>. Sin embargo, al usar este método, no obtenemos los
beneficios de verificación de tipo que obtenemos del nuevo patrón de tipo
discutido anteriormente.</p>
<p>El principal caso de uso para los sinónimos de tipo es reducir la repetición.
Por ejemplo, podríamos tener un tipo largo como este:</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<p>Escribir este tipo largo en las firmas de función y como anotaciones de tipo
en todo el código puede ser molesto y propenso a errores. Imagine tener un
proyecto lleno de código como ese en el listado 19-32.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-32: Usar un <em>tipo largo</em> (<em>long type</em>) en
muchos lugares</span></p>
<p>Un tipo <em>alias</em> hace que este código sea más manejable al reducir la
repetición. En el listado 19-33, hemos introducido un <em>alias</em> llamado <code>Thunk</code>
para el tipo detallado y podemos reemplazar todos los usos del tipo con el
<em>alias</em> más corto <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-33: Presentamos un tipo de <em>alias</em> <code>Thunk</code>
para reducir la repetición</span></p>
<p>¡Este código es mucho más fácil de leer y escribir! Elegir un nombre
significativo para un tipo <em>alias</em> también puede ayudarlo a comunicar su
intención (<em>thunk</em> es una palabra para evaluar el código más adelante, por lo
que es un nombre apropiado para un <em>closure</em> que se almacena).</p>
<p>Los <em>alias</em> de tipo también se usan comúnmente con el tipo <code>Result &lt;T, E&gt;</code>
para reducir la repetición. Considere el módulo <code>std::io</code> en la biblioteca
estándar. Las operaciones de E/S a menudo devuelven un <code>Result&lt;T, E&gt;</code> para
manejar situaciones cuando las operaciones no funcionan. Esta biblioteca
tiene una estructura <code>std::io::Error</code> que representa todos los posibles
errores de E/S. Muchas de las funciones en <code>std::io</code> devolverán
<code>Result &lt;T, E&gt;</code> donde <code>'E</code> es <code>std::io::Error</code>, como estas funciones en el
<em>trait</em> <code>Write</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>El <code>Result&lt;..., Error&gt;</code> se repite mucho. Como tal, <code>std::io</code> tiene este tipo
de declaración de <em>alias</em>:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Como esta declaración está en el módulo <code>std::io</code>, podemos usar el <em>alias</em>
totalmente calificado <code>std::io::Result &lt;T&gt;</code>-es decir, un <code>Result &lt;T, E&gt;</code> con
el <code>E</code> rellenado como <code>std::io::Error</code>. Las firmas de funciones de <em>traits</em>
<code>Write</code> terminan pareciéndose a esto:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>El <em>alias</em> tipo ayuda de dos maneras: hace que el código sea más fácil de
escribir <em>y</em> nos da una interfaz consistente en todo el <code>std::io</code>. Como es un
<em>alias</em>, es simplemente otro <code>Result &lt;T, E&gt;</code>, lo que significa que podemos
usar cualquier método que funcione en <code>Result &lt;T, E&gt;</code> con él, así como una
sintaxis especial como el operador <code>?</code>.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust tiene un tipo especial llamado <code>!</code> que se conoce en la jerga de teoría
de tipos como <em>tipo vacío</em> (<em>empty type</em>) porque no tiene valores. Preferimos
llamarlo <em>never type</em> porque se encuentra en el lugar del tipo de devolución
cuando una función nunca volverá. Aquí hay un ejemplo:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<p>Este código se lee como “la función <code>bar</code> nunca retorna”. Las funciones que
retornan nunca se llaman <em>funciones divergentes</em>. No podemos crear valores
del tipo <code>!</code> para que <code>bar</code> nunca pueda regresar.</p>
<p>Pero, ¿para qué sirve un tipo para el que nunca se pueden crear valores?.
Recordar el código del listado 2-5; hemos reproducido una parte aquí en el
listado 19-34.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let guess = &quot;3&quot;;
</span><span class="boring">loop {
</span>let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
<span class="boring">break;
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-34: Un <code>match</code> con un brazo que termina en
<code>continue</code></span></p>
<p>En ese momento, omitimos algunos detalles en este código. En el Capítulo 6 de
la sección “El operador de flujo de control <code>match</code>”, discutimos que los
brazos del <code>match</code> deben devolver el mismo tipo. Entonces, por ejemplo, el
siguiente código no funciona:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>El tipo de <code>guess</code> en este código debería ser un entero <em>y</em> un <em>string</em>, y
Rust requiere que <code>guess</code> tenga solo un tipo. Entonces, ¿qué devuelve
<code>continue</code>?.Cómo se nos permitió devolver un <code>u32</code> de un brazo y tener otro
brazo que termina con <code>continue</code> en el Listado 19-34?</p>
<p>Como habrás adivinado, <code>continue</code> tiene un valor <code>!</code>. Es decir, cuando Rust
calcula el tipo de <code>guess</code>, mira ambos brazos del <em>match</em>, el primero con un
valor de <code>u32</code> y el último con un valor <code>!</code>. Debido a que <code>!</code> nunca puede
tener un valor, Rust decide que el tipo de <code>guess</code> es <code>u32</code>.</p>
<p>La forma formal de describir este comportamiento es que las expresiones de
tipo <code>!</code> pueden forzarse en cualquier otro tipo. Podemos terminar este brazo
<code>match</code> con <code>continue</code> porque <code>continue</code> no devuelve un valor; en su lugar,
mueve el control de nuevo a la parte superior del ciclo, por lo que en el
caso de <code>Err</code>, nunca asignamos un valor a <code>guess</code>.</p>
<p>El tipo nunca es útil con la macro <code>panic!</code> También. ¿Recuerda la función
<code>unwrap</code> que llamamos a los valores <code>Option&lt;T&gt;</code> para producir un valor o
pánico?. Aquí está su definición:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>En este código, sucede lo mismo que en el <code>match</code> en el Listado 19-34: Rust
ve que <code>val</code> tiene el tipo <code>T</code> y <code>panic!</code> tiene el tipo <code>!</code>, por lo que el
resultado de la expresión general de <code>match</code> es <code>T</code>. Este código funciona
porque <code>panic!</code> No produce un valor; termina el programa. En el caso <code>None</code>,
no devolveremos un valor de <code>unwrap</code>, por lo que este código es válido.</p>
<p>Una expresión final que tiene el tipo <code>!</code> es un <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Aquí, el ciclo nunca termina, entonces <code>!</code> es el valor de la expresión. Sin
embargo, esto no sería cierto si incluyéramos un <code>break</code>, porque el ciclo
terminaría cuando llegara al <code>break</code>.</p>
<h3 id="tipos-dinámicamente-dimensionados-y-el-trait-sized"><a class="header" href="#tipos-dinámicamente-dimensionados-y-el-trait-sized">Tipos dinámicamente dimensionados y el <em>Trait</em> <code>Sized</code></a></h3>
<p>Debido a la necesidad de Rust de conocer ciertos detalles, como la cantidad
de espacio para asignar un valor de un tipo particular, hay una esquina de su
sistema de tipo que puede ser confusa: el concepto de <em>tipos de tamaño
dinámico</em>. A veces denominados <em>DSTs</em> o <em>unsized types</em>, estos tipos nos
permiten escribir código utilizando valores cuyo tamaño solo podemos conocer
en tiempo de ejecución.</p>
<p>Vamos a profundizar en los detalles de un tipo de tamaño dinámico llamado
<code>str</code>, que hemos estado utilizando a lo largo del libro. Así es, no <code>&amp;str</code>,
sino <code>str</code> en sí mismo, es un DST. No podemos saber cuánto tiempo dura la
<em>string</em> hasta el tiempo de ejecución, lo que significa que no podemos crear
una variable de tipo <code>str</code>, ni podemos tomar un argumento de tipo <code>str</code>.
Considere el siguiente código, que no funciona:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>Rust necesita saber cuánta memoria asignar para cualquier valor de un tipo
particular, y todos los valores de un tipo deben usar la misma cantidad de
memoria. Si Rust nos permitiera escribir este código, estos dos valores <code>str</code>
necesitarían ocupar la misma cantidad de espacio. Pero tienen diferentes
longitudes: <code>s1</code> necesita 12 bytes de almacenamiento y <code>s2</code> necesita 15. Es
por eso que no es posible crear una variable que tenga un tipo de tamaño
dinámico.</p>
<p>¿Asi que que hacemos?. En este caso, ya conoce la respuesta: hacemos los
tipos de <code>s1</code> y <code>s2</code> a <code>&amp;str</code> en lugar de <code>str</code>. Recuerde que en la sección
String Slices” del Capítulo 4, dijimos que la estructura de datos de sectores
almacena la posición inicial y la longitud del sector.</p>
<p>Entonces, aunque un <code>&amp;T</code> es un valor único que almacena la dirección de
memoria de donde el <code>T</code> se encuentra, un <code>&amp;str</code> es <em>dos</em> valores: la
dirección del <code>str</code> y su longitud. Como tal, podemos conocer el tamaño de un
valor <code>&amp;str</code> en tiempo de compilación: es el doble de la longitud de un
<code>usize</code>. Es decir, siempre sabemos el tamaño de un <code>&amp;str</code>, no importa cuánto
tiempo se refiere al <em>string</em> a la que se refiere. En general, este es el
camino en qué tipos de tamaño dinámico se usan en Rust: tienen un poco más de
metadatos que almacena el tamaño de la información dinámica. La regla de oro
de tipos de tamaño dinámico es que siempre debemos poner valores de tamaño
dinámico tipos detrás de un puntero de algún tipo.</p>
<p>Podemos combinar <code>str</code> con todo tipo de punteros: por ejemplo,<code>Box&lt;str&gt;</code> o
<code>Rc&lt;str&gt;</code>. De hecho, ya has visto esto antes, pero con una dinámica diferente
tipo de tamaño: <em>traits</em>. Cada característica es un tipo de tamaño dinámico
al que podemos hacer referencia usando el nombre del <em>trait</em>. En el Capítulo
17 en la sección “Uso de <em>Trait Objects</em> que permiten valores de diferentes
tipos” mencionamos que para usar los <em>traits</em> como <em>trait objects</em>, debemos
ponerlos detrás de un puntero, como <code>&amp;Trait</code> o <code>Box&lt;Trait&gt;</code>
(<code>Rc&lt;Trait&gt;</code> también funcionaría).</p>
<p>Para trabajar con los DST, Rust tiene un <em>trait</em> particular llamado el
<em>trait</em> <code>Sized</code> para determinar si se conoce o no el tamaño de un tipo en el
momento de la compilación. Este <em>trait</em> es implementado automáticamente para
todo cuyo tamaño se conoce en tiempo de compilación. Además, Rust agrega
implícitamente un límite en <code>Sized</code> a cada función genérica.
Es decir, una definición de función genérica como esta:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>en realidad se trata como si hubiéramos escrito esto:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>Por defecto, las funciones genéricas solo funcionarán en los tipos que tienen
un tamaño conocido en el momento de la compilación. Sin embargo, puede usar
la siguiente sintaxis especial para relajar esta restricción:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>Un <em>trait</em> ligado en <code>?Sized</code> es el opuesto de un <em>trait</em> ligado en <code>Sized</code>:
leemos esto como “<code>T</code> puede o no ser <code>Sized</code>”.Esta sintaxis solo está
disponible para <code>Sized</code>, no cualquier otro <em>trait</em>.</p>
<p>También tenga en cuenta que cambiamos el tipo del parámetro <code>t</code> de <code>T</code> a
<code>&amp;T</code>. Debido a que el tipo puede no ser <code>Sized</code>, tenemos que usarlo detrás de
algún tipo de puntero. En este caso, hemos elegido una referencia.</p>
<p>¡A continuación, hablaremos sobre funciones y closures!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funciones-avanzadas-y-closures"><a class="header" href="#funciones-avanzadas-y-closures">Funciones avanzadas y <em>Closures</em></a></h2>
<p>Finalmente, exploraremos algunas funciones avanzadas relacionadas con
funciones y <em>closures</em>, que incluyen punteros de funciones y <em>closures</em> de retorno.</p>
<h3 id="punteros-de-función"><a class="header" href="#punteros-de-función">Punteros de función</a></h3>
<p>Hemos hablado sobre cómo pasar <em>closures</em> a las funciones; ¡también puede
pasar funciones regulares a funciones! Esta técnica es útil cuando desea
pasar una función que ya ha definido en lugar de definir un nuevo <em>closure</em>.
Hacer esto con punteros de función le permitirá usar funciones como
argumentos para otras funciones. Las funciones fuerzan al tipo <code>fn</code> (con una
f minúscula), que no debe confundirse con el <em>trait</em> de <em>closure</em> <code>Fn</code>. El
tipo <code>fn</code> se llama <em>puntero de función</em>
(<em>function pointer</em>). La sintaxis para especificar que un parámetro es un
puntero a la función es similar a la de los <em>closures</em>, como se muestra en el
Listado 19-35.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Listado 19-35: Usar el tipo <code>fn</code> para aceptar un
puntero a la función como argumento</span></p>
<p>Este código imprime <code>The answer is: 12</code>. Especificamos que el parámetro <code>f</code>
en <code>do_twice</code> es un <code>fn</code> que toma un parámetro de tipo <code>i32</code> y devuelve un
<code>i32</code>. Entonces podemos llamar a <code>f</code> en el cuerpo de <code>do_twice</code>. En <code>main</code>,
podemos pasar el nombre de función <code>add_one</code> como primer argumento a
<code>do_twice</code>.</p>
<p>A diferencia de los <em>closures</em>, <code>fn</code> es un tipo en lugar de un <em>trait</em>, por
lo que especificamos <code>fn</code> como el tipo de parámetro directamente en lugar de
declarar un parámetro de tipo genérico con uno de los <em>traits</em> <code>Fn</code> como un
<em>trait bound</em>.</p>
<p>Los punteros de función implementan los tres <em>traits</em> de <em>closure</em>
(<code>Fn</code>, <code>FnMut</code> y <code>FnOnce</code>), por lo que siempre puede pasar un puntero a la
función como argumento para una función que espera un <em>closure</em>. Lo mejor es
escribir funciones usando un tipo genérico y uno de los <em>traits</em> de <em>closure</em>
para que sus funciones puedan aceptar funciones o <em>closures</em>.</p>
<p>Un ejemplo de dónde solo desearía aceptar <code>fn</code> y no <em>closures</em> es cuando
interactúa con un código externo que no tiene <em>closures</em>: las funciones C
pueden aceptar funciones como argumentos, pero C no tiene <em>closures</em>.</p>
<p>Como ejemplo de dónde podría usar un <em>closure</em> definido en línea o una
función nombrada, veamos el uso de <code>map</code>. Para usar la función <code>map</code> para
convertir un vector de números en un vector de <em>string</em>, podríamos usar un
<em>closure</em>, como este:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
<span class="boring">}
</span></code></pre></pre>
<p>O podríamos nombrar una función como el argumento para <code>map</code> en lugar del
<em>closure</em>, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
<span class="boring">}
</span></code></pre></pre>
<p>Tenga en cuenta que debemos usar la sintaxis totalmente calificada de la que
hablamos anteriormente en la sección “<em>Traits</em> avanzados” porque hay varias
funciones disponibles llamadas <code>to_string</code>. Aquí, estamos usando la función
<code>to_string</code> definida en el <em>trait</em> <code>ToString</code>, que la biblioteca estándar ha
implementado para cualquier tipo que implemente <code>Display</code>.</p>
<p>Algunas personas prefieren este estilo, y algunas personas prefieren usar
<em>closures</em>. Terminan compilando el mismo código, por lo que debe usar el
estilo que le resulte más claro.</p>
<h3 id="returning-closures"><a class="header" href="#returning-closures">Returning Closures</a></h3>
<p>Los <em>closures</em> están representados por <em>traits</em>, lo que significa que no
puede devolver los <em>closures</em> directamente. En la mayoría de los casos en los
que es posible que desee devolver un <em>trait</em>, en su lugar puede usar el tipo
concreto que implementa el <em>trait</em> como el valor de retorno de la función.
Pero no se puede hacer eso con <em>closures</em> porque no tienen un tipo concreto
que sea retornable; no está permitido usar el puntero de función <code>fn</code> como un
tipo de retorno, por ejemplo.</p>
<p>El siguiente código intenta devolver un <em>closure</em> directamente, pero no se
compilará:</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>El error del compilador es el siguiente:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<p>¡El error hace referencia al <em>trait</em> <code>Sized</code> de nuevo! Rust no sabe cuánto
espacio necesitará para almacenar el <em>closure</em>. Vimos una solución a este
problema antes. Podemos usar un <em>trait object</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código compilará muy bien. Para obtener más información sobre los
<em>trait objects</em>, consulte la sección “Uso de <em>trait objects</em> que permiten
valores de diferentes tipos” en el Capítulo 17.</p>
<h2 id="resumen-17"><a class="header" href="#resumen-17">Resumen</a></h2>
<p>¡Uf! Ahora tiene algunas características de Rust en su caja de herramientas
que no usará con frecuencia, pero sabrá que están disponibles en
circunstancias muy particulares. Hemos introducido varios temas complejos
para que cuando los encuentres en sugerencias de mensajes de error o en el
código de otras personas, puedas reconocer estos conceptos y la sintaxis. Use
este capítulo como referencia para guiarlo a las soluciones.</p>
<p>A continuación, pondremos en práctica todo lo que hemos discutido a lo largo
del libro y haremos un proyecto más.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-d-macros"><a class="header" href="#apéndice-d-macros">Apéndice D: Macros</a></h2>
<p>Hemos utilizado macros como <code>println!</code> a lo largo de este libro, pero no
hemos explorado completamente qué es una macro y cómo funciona. Este apéndice
explica las macros de la siguiente manera:</p>
<ul>
<li>Qué son las macros y cómo se diferencian de las funciones</li>
<li>Cómo definir una macro declarativa para hacer metaprogramación</li>
<li>Cómo definir una macro de procedimiento para crear <em>traits</em> <code>derive</code>
personalizados</li>
</ul>
<p>Estamos cubriendo los detalles de las macros en un apéndice porque todavía
están evolucionando en Rust. Las macros han cambiado y, en un futuro próximo,
cambiarán a un ritmo más rápido que el resto del lenguaje y la biblioteca
estándar desde Rust 1.0, por lo que es más probable que esta sección quede
desactualizada que el resto del libro. Debido a las garantías de estabilidad
de Rust, el código que se muestra aquí seguirá funcionando con versiones
futuras, pero puede haber capacidades adicionales o formas más sencillas de
escribir macros que no estaban disponibles en el momento de esta publicación.
Tenga esto en cuenta cuando intente implementar algo de este apéndice.</p>
<h3 id="la-diferencia-entre-macros-y-funciones"><a class="header" href="#la-diferencia-entre-macros-y-funciones">La diferencia entre macros y funciones</a></h3>
<p>Fundamentalmente, las macros son una forma de escribir código que escribe
otro código, que se conoce como <em>metaprogramación</em>. En el Apéndice C,
discutimos el atributo <code>derive</code>, que genera una implementación de varios
rasgos para usted. También utilizamos las macros <code>println!</code> Y <code>vec!</code>. En todo
el libro. Todas estas macros <em>se expanden</em> para producir más código que el
código que ha escrito manualmente.</p>
<p>La metaprogramación es útil para reducir la cantidad de código que tiene que
escribir y mantener, que también es uno de los roles de las funciones. Sin
embargo, las macros tienen algunos poderes adicionales que las funciones no
tienen.</p>
<p>Una firma de función debe declarar el número y tipo de parámetros que tiene
la función. Las macros, por otro lado, pueden tomar un número variable de
parámetros: podemos llamar <code>println!(&quot;Hello&quot;)</code> con un argumento o
<code>println!(&quot;hello {}&quot;, name)</code> con dos argumentos. Además, las macros se
expanden antes de que el compilador interprete el significado del código, por
lo que una macro puede, por ejemplo, implementar un <em>trait</em> en un tipo dado.
Una función no puede, porque se llama en el tiempo de ejecución y un <em>trait</em>
debe implementarse en tiempo de compilación.</p>
<p>La desventaja de implementar una macro en lugar de una función es que las
definiciones de macro son más complejas que las definiciones de función
porque estás escribiendo el código de Rust que escribe el código de Rust.
Debido a esta indirección, las definiciones de macro generalmente son más
difíciles de leer, comprender y mantener que las definiciones de funciones.</p>
<p>Otra diferencia entre las macros y las funciones es que las definiciones de
macro no son espacios de nombres dentro de los módulos, como son las
definiciones de funciones. Para evitar conflictos de nombres inesperados al
usar <em>crate</em> externas, tiene que incluir explícitamente las macros en el
alcance de su proyecto al mismo tiempo que lleva el <em>crate</em> externo dentro
del alcance, usando la anotación <code>#[macro_use]</code>. El siguiente ejemplo traerá
todas las macros definidas en el <em>crate</em> <code>serde</code> dentro del alcance del
<em>crate</em> actual:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate serde;
</code></pre>
<p>Si <code>extern crate</code> fuera capaz de traer macros al alcance de forma
predeterminada sin esta anotación explícita, no se le permitiría usar dos
<em>crates</em> que le permitieron definir macros con el mismo nombre. En la
práctica, este conflicto no ocurre a menudo, pero cuantas más <em>crates</em> uses,
más posibilidades habrá.</p>
<p>Existe una última diferencia importante entre las macros y las funciones:
debe definir o incluir macros en el alcance <em>antes</em> de que las llame en un
archivo, mientras que puede definir funciones en cualquier lugar y llamarlas
a cualquier lugar.</p>
<h3 id="macros-declarativas-con-macro_rules-para-la-metaprogramación-general"><a class="header" href="#macros-declarativas-con-macro_rules-para-la-metaprogramación-general">Macros declarativas con <code>macro_rules!</code> para la metaprogramación general</a></h3>
<p>La forma más utilizada de macros en Rust son <em>macros declarativas</em>. A veces
también se les conoce como <em>macros por ejemplo</em>, <em><code>macro_rules!</code> macros</em>, o
simplemente simples <em>macros</em>. En esencia, las macros declarativas le permiten
escribir algo similar a una expresión de <code>match</code> de Rust. Como se discutió en
el Capítulo 6, las expresiones <code>match</code> son estructuras de control que toman
una expresión, comparan el valor resultante de la expresión con patrones y
luego ejecutan el código asociado con el patrón coincidente. Las macros
también comparan un valor con patrones que tienen código asociado a ellos; en
esta situación, el valor es el código fuente literal de Rust que se pasa a la
macro, los patrones se comparan con la estructura de ese código fuente, y el
código asociado con cada patrón es el código que reemplaza el código pasado a
la macro. Todo esto sucede durante la compilación.</p>
<p>Para definir una macro, utiliza la construcción <code>macro_rules!</code>. ¡Exploremos
cómo usar <code>macro_rules!</code>. Mirando cómo se define la macro <code>vec!</code>. El Capítulo
8 cubrió cómo podemos usar la macro <code>vec!</code>. Para crear un nuevo vector con
valores particulares. Por ejemplo, la siguiente macro crea un nuevo vector
con tres enteros dentro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>También podríamos usar la macro <code>vec!</code> para hacer un vector de dos enteros o
un vector de cinco <em>string slices</em>. No podríamos usar una función para hacer
lo mismo porque no sabríamos la cantidad o el tipo de valores por adelantado.</p>
<p>Veamos una definición ligeramente simplificada de la macro <code>vec!</code> en el
Listado D-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado D-1: Una versión simplificada de la definición
de macro <code>vec!</code></span></p>
<blockquote>
<p>Nota: La definición real de la macro <code>vec!</code> en la biblioteca estándar
incluye un código para preasignar la cantidad correcta de memoria por
adelantado. Ese código es una optimización que no incluimos aquí para
simplificar el ejemplo.</p>
</blockquote>
<p>La anotación <code>#[macro_export]</code> indica que esta macro debe estar disponible
siempre que se importe el <em>crate</em> en la que estamos definiendo la macro. Sin
esta anotación, incluso si alguien que dependa de este <em>crate</em> usa la
anotación <code>#[macro_use]</code>, la macro no se incluiría en el alcance.</p>
<p>Luego comenzamos la definición de macro con <code>macro_rules!</code> y el nombre de la
macro que estamos definiendo <em>sin</em> el signo de exclamación. El nombre, en
este caso <code>vec</code>, es seguido por llaves que denotan el cuerpo de la definición
de macro.</p>
<p>La estructura en el cuerpo <code>vec!</code> es similar a la estructura de una expresión
<code>match</code>. Aquí tenemos un brazo con el patrón <code>( $( $x:expr ),* )</code>, seguido de
<code>=&gt;</code> y el bloque de código asociado con este patrón. Si el patrón coincide,
se emitirá el bloque de código asociado. Dado que este es el único patrón en
esta macro, solo hay una forma válida de concordar; cualquier otro será un
error. Las macros más complejas tendrán más de un brazo.</p>
<p>La sintaxis de patrón válida en las definiciones de macro es diferente de la
sintaxis de patrón cubierta en el Capítulo 18 porque los patrones de macro se
hacen coincidir con la estructura de código de Rust en lugar de los valores.
Veamos qué significan las piezas del patrón del Listado D-1; para ver la
sintaxis completa del patrón de macro, vea <a href="../../reference/macros.html">la referencia</a>.</p>
<p>Primero, un conjunto de paréntesis abarca todo el patrón. Luego viene un
signo de dólar (<code>$</code>) seguido de un conjunto de paréntesis, que captura
valores que coinciden con el patrón entre paréntesis para usar en el código
de reemplazo. Dentro de <code>$()</code> es <code>$x:expr</code>, que coincide con cualquier
expresión de Rust y le da a la expresión el nombre <code>$ x</code>.</p>
<p>La coma que sigue a <code>$()</code> indica que un carácter literal de separador de coma
podría aparecer opcionalmente después del código que coincide con el código
capturado en <code>$()</code>. El <code>*</code> que sigue a la coma especifica que el patrón
coincide con cero o más de lo que precede al <code>*</code>.</p>
<p>Cuando llamamos a esta macro con <code>vec![1, 2, 3];</code>, el patrón <code>$ x</code> coincide
tres veces con las tres expresiones <code>1</code>, <code>2</code> y <code>3</code>.</p>
<p>Ahora veamos el patrón en el cuerpo del código asociado a este brazo: el
código <code>temp_vec.push()</code> dentro de la parte <code>$()*</code> se genera para cada parte
que coincide con <code>$()</code> en el patrón , cero o más veces, según cuántas veces
coincida el patrón. El <code>$ x</code> se reemplaza con cada expresión coincidente.
Cuando llamamos a esta macro con <code>vec! [1, 2, 3];</code>, el código generado que
reemplaza esta llamada de macro será el siguiente:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>Hemos definido una macro que puede tomar cualquier cantidad de argumentos de
cualquier tipo y puede generar código para crear un vector que contenga los
elementos especificados.</p>
<p>Dado que la mayoría de los programadores de Rust <em>utilizarán</em> macros más que
<em>write</em> macros, no discutiremos <code>macro_rules!</code>. Para obtener más información
sobre cómo escribir macros, consulte la documentación en línea u otros
recursos, como <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a>.</p>
<h3 id="macros-de-procedimiento-para-personalizar-derive"><a class="header" href="#macros-de-procedimiento-para-personalizar-derive">Macros de procedimiento para personalizar <code>derive</code></a></h3>
<p>La segunda forma de macros se llama <em>procedural macros</em> (<em>macros de
procedimiento</em>) porque se asemejan más a funciones (que son un tipo de
procedimiento). Las macros de procedimiento aceptan algún código de Rust como
entrada, operan en ese código y producen algún código de Rust como salida en
lugar de coincidir con patrones y reemplazar el código con otro código como
lo hacen las macros declarativas. En el momento de escribir estas líneas,
solo puede definir macros de procedimiento para permitir que sus <em>traits</em> se
implementen en un tipo especificando el nombre de <em>trait</em> en una anotación
<code>derivar</code>.</p>
<p>Crearemos un <em>crate</em> llamada <code>hello_macro</code> que define un <em>trait</em> llamado
<code>HelloMacro</code> con una función asociada llamada <code>hello_macro</code>. En lugar de
hacer que nuestros usuarios del <em>crate</em> implementen el <em>trait</em> <code>HelloMacro</code>
para cada uno de sus tipos, proporcionaremos una macro de procedimientos para
que los usuarios puedan anotar su tipo con <code>#[derive(HelloMacro)]</code> para
obtener una implementación predeterminada de <code>hello_macro</code> función. La
implementación predeterminada imprimirá <code>Hello, Macro! My name is TypeName!</code>
donde <code>TypeName</code> es el nombre del tipo en el que se ha definido este <em>trait</em>.
En otras palabras, escribiremos un <em>crate</em> que permita a otro programador
escribir código como el Listado D-2 usando nuestro <em>crate</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_macro;
#[macro_use]
extern crate hello_macro_derive;

use hello_macro::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Listado D-2: El código que un usuario de nuestro <em>crate</em>
podrá escribir cuando utilice nuestra macro de procedimientos</span></p>
<p>Este código imprimirá <code>Hello, Macro! My name is Pancakes!</code> cuando hayamos
terminado. El primer paso es crear un nueva <em>library crate</em>, como esta:</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<p>A continuación, definiremos el <em>trait</em> <code>HelloMacro</code> y su función asociada:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<p>Tenemos un <em>trait</em> y su función. En este punto, nuestro usuario del <em>trait</em>
podría implementar el <em>trait</em> para lograr la funcionalidad deseada, así:</p>
<pre><code class="language-rust ignore">extern crate hello_macro;

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>Sin embargo, tendrían que escribir el bloque de implementación para cada tipo
que quisieran usar con <code>hello_macro</code>; queremos evitar que tengan que hacer
este trabajo.</p>
<p>Además, todavía no podemos proporcionar una implementación predeterminada
para la función <code>hello_macro</code> que imprimirá el nombre del tipo en el que se
implementa el <em>trait</em>: Rust no tiene capacidades de reflexión, por lo que no
puede buscar el nombre del tipo en tiempo de ejecución necesitamos una macro
para generar código en tiempo de compilación.</p>
<p>El siguiente paso es definir la macro de procedimiento. En el momento de
escribir estas líneas, las macros de procedimiento deben estar en su propio
<em>crate</em>. Eventualmente, esta restricción podría ser levantada. La convención
para estructurar <em>crates</em> y macrofolios es la siguiente: para un <em>crate</em>
llamada <code>foo</code>, un <em>crate</em> macro de procedimientos derivada personalizada se
llama <code>foo_derive</code>. Comencemos un nuevo <em>crate</em> llamada <code>hello_macro_derive</code>
dentro de nuestro proyecto <code>hello_macro</code>:</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Nuestros dos <em>crates</em> están estrechamente relacionadas, por lo que creamos la
macro de procedimiento dentro del directorio de nuestro <em>crate</em>
<code>hello_macro</code>. Si cambiamos la definición de <em>trait</em> en <code>hello_macro</code>,
también tendremos que cambiar la implementación de la macro de procedimiento
en <code>hello_macro_derive</code>. Los dos <em>crates</em> tendrán que publicarse por separado
y los programadores que utilicen estos <em>crates</em> tendrán que agregar ambas
como dependencias y ponerlas a ambas en el alcance. Podríamos, en cambio, hacer que el <em>crates</em> <code>hello_macro</code> use <code>hello_macro_derive</code> como una
dependencia y reexportar el código macro de procedimiento. Pero la forma en
que hemos estructurado el proyecto hace posible que los programadores usen <code>hello_macro</code> incluso si no quieren la funcionalidad <code>derivar</code>.</p>
<p>Necesitamos declarar el <em>crate</em> <code>hello_macro_derive</code> como una macro <em>crate</em>
de procedimientos. También necesitaremos la funcionalidad de los <em>crates</em>
<code>syn</code> y <code>quote</code>, como verá en un momento, por lo que debemos agregarlas como
dependencias. Agregue lo siguiente al archivo <em>Cargo.toml</em> para
<code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<p>Para comenzar a definir la macro de procedimiento, coloque el código en el
Listado D-3 en su archivo <em>src/lib.rs</em> para el <em>crate</em> <code>hello_macro_derive</code>.
Tenga en cuenta que este código no se compilará hasta que agreguemos una
definición para la función <code>impl_hello_macro</code>.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_macro(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<p><span class="caption">Listado D-3: Código que la mayoría de los
<em>macro crates</em> de procedimiento deberán tener para procesar el código de
Rust</span></p>
<p>Observe la forma en que hemos dividido las funciones en D-3; esto será el
mismo para casi todos los <em>macro crate</em> de procedimiento que ve o crea,
porque hace que escribir un macro de procedimiento sea más conveniente. Lo
que elija hacer en el lugar donde se llama a la función <code>impl_hello_macro</code>
será diferente dependiendo del propósito de su macro de procedimiento.</p>
<p>Hemos introducido tres <em>crates</em> nuevos: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, y <a href="https://crates.io/crates/quote"><code>quote</code></a>.
El <em>crate</em> <code>proc_macro</code> viene con Rust, por lo que no fue necesario agregarlo a las dependencias en <em>Cargo.toml</em>. El <em>crate</em> <code>proc_macro</code> nos permite
convertir el código Rust en un <em>string</em> que contiene ese código Rust. El
<code>syn</code> crate analiza el código de Rust de un <em>string</em> en una estructura de
datos en la que podemos realizar operaciones. El <em>crate</em> <code>quote</code> toma las
estructuras de datos <code>syn</code> y las convierte nuevamente en código Rust. Estos
<em>crates</em> hacen que sea mucho más simple analizar cualquier tipo de código
Rust que podamos querer manejar: escribir un analizador completo para el
código Rust no es tarea fácil.</p>
<p>Se llamará a la función <code>hello_macro_derive</code> cuando un usuario de nuestra
biblioteca especifique <code>#[derive(HelloMacro)]</code> en un tipo. La razón es que
hemos anotado la función <code>hello_macro_derive</code> aquí con <code>proc_macro_derive</code> y
hemos especificado el nombre, <code>HelloMacro</code>, que coincide con nuestro nombre
de <em>trait</em>; esa es la convención que siguen la mayoría de las macros de
procedimiento.</p>
<p>Esta función primero convierte la <code>input</code> de un <code>TokenStream</code> en un <code>String</code>
llamando a <code>to_string</code>. Este <code>String</code> es una representación de <em>string</em> del
código Rust para el cual derivamos <code>HelloMacro</code>. En el ejemplo del Listado
D-2, <code>s</code> tendrá el valor <code>String</code> <code>struct Pancakes;</code> porque ese es el código
Rust al que agregamos la anotación <code>#[derive(HelloMacro)]</code>.</p>
<blockquote>
<p>Nota: En el momento de escribir esto, solo puedes convertir un
<code>TokenStream</code> en un <em>string</em>. Una API más rica existirá en el futuro.</p>
</blockquote>
<p>Ahora tenemos que analizar el código de Rust <code>String</code> en una estructura de
datos que luego podemos interpretar y realizar operaciones. Aquí es donde
<code>syn</code> entra en juego. La función <code>parse_derive_input</code> en <code>syn</code> toma <code>String</code>
y devuelve una estructura <code>DeriveInput</code> que representa el código Rust
analizado. El siguiente código muestra las partes relevantes de la estructura
<code>DeriveInput</code> que obtenemos al analizar el <em>string</em> <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<p>Los campos de esta estructura muestran que el código de Rust que hemos
analizado es una estructura de unidad con el <code>ident</code> (identificador, que
significa el nombre) de <code>Pancakes</code>. Hay más campos en esta estructura para
describir todo tipo de código Rust; revise la
<a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>syn</code> documentation for <code>DeriveInput</code></a> para más información.</p>
<p>En este punto, no hemos definido la función <code>impl_hello_macro</code>, que es donde
construiremos el nuevo código Rust que queremos incluir. Pero antes de
hacerlo, tenga en cuenta que la última parte de esta función
<code>hello_macro_derive</code> usa la función <code>parse</code> del <em>crate</em> <code>quote</code> para convertir
la salida de la función <code>impl_hello_macro</code> de nuevo en <code>TokenStream</code>. El
<code>TokenStream</code> devuelto se agrega al código que escriben nuestros usuarios de
<em>crates</em>, por lo que cuando compilan su <em>crate</em>, obtendrán la funcionalidad
adicional que proporcionamos.</p>
<p>Es posible que haya notado que estamos llamando <code>unwrap</code> al pánico si las
llamadas a las funciones <code>parse_derive_input</code> o <code>analizar</code> fracasan aquí.
Pánico en los errores es necesario en el código de macro de procedimiento
porque las funciones <code>proc_macro_derive</code> deben devolver <code>TokenStream</code> en
lugar de <code>Result</code> para ajustarse a la API de macro de procedimiento. Elegimos
simplificar este ejemplo usando <code>unwrap</code>; en el código de producción, debe
proporcionar mensajes de error más específicos sobre lo que salió mal usando
<code>panic!</code> o <code>expect</code>.</p>
<p>Ahora que tenemos el código para convertir el código anotado de Rust de un
<code>TokenStream</code> en una instancia <code>String</code> y <code>DeriveInput</code>, generemos el código
que implementa el <em>trait</em> <code>HelloMacro</code> en el tipo anotado:</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<p>Obtenemos una instancia de estructura <code>Ident</code> que contiene el nombre
(identificador) del tipo anotado usando <code>ast.ident</code>. El código en el Listado
D-2 especifica que el <code>name</code> será <code>Ident(&quot;Pancakes&quot;)</code>.</p>
<p>La macro <code>quote!</code> nos permite escribir el código Rust que queremos devolver y
convertirlo en <code>quote::Tokens</code>. Esta macro también proporciona algunas
mecánicas de plantillas muy interesantes; podemos escribir <code>#name</code>, y
<code>quote!</code> lo reemplazará con el valor en la variable llamada <code>name</code>. Incluso
puede hacer una repetición similar a la forma en que funcionan las macros
normales. Consulte <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> para una
introducción completa.</p>
<p>Queremos que nuestra macro de procedimientos genere una implementación de
nuestro <em>trait</em> <code>HelloMacro</code> para el tipo anotado por el usuario, que podemos
obtener usando <code>#name</code>.La implementación del <em>trait</em> tiene una función,
<code>hello_macro</code>, cuyo cuerpo contiene el funcionalidad que queremos
proporcionar: impresión <code>Hello, Macro! My name is</code> y luego el nombre del tipo
anotado.</p>
<p>La macro <code>stringify!</code> Utilizada aquí está integrada en Rust. Toma una
expresión Rust, como <code>1 + 2</code>, y en tiempo de compilación convierte la
expresión en un literal de <em>string</em>, como <code>&quot;1 + 2&quot;</code>. Esto es diferente de
<code>format!</code> o <code>println!</code>, que evalúa la expresión y luego convierte el
resultado en <code>String</code>. Existe la posibilidad de que la entrada <code>#name</code> sea
una expresión para imprimir literalmente, entonces usamos <code>stringify!</code>.
Usando <code>stringify!</code> también guarda una asignación convirtiendo <code>#name</code> a un
<em>string</em> literal en tiempo de compilación.</p>
<p>En este punto, <code>cargo build</code> debería completarse con éxito en ambos
<code>hello_macro</code> y <code>hello_macro_derive</code>. Vamos a conectar estos <em>crates</em> al
código en el Listado D-2 para ver la macro de procedimiento en acción! cree
un nuevo proyecto binario en su directorio <em>proyectos</em> utilizando
<code>cargo new --bin pancakes</code>. Necesitamos agregar <code>hello_macro</code> y
<code>hello_macro_derive</code> como dependencias en los <code>pancakes</code>
<em>crates</em> <em>Cargo.toml</em>. Si publica sus versiones de <code>hello_macro</code> y
<code>hello_macro_derive</code> a <em>https://crates.io/</em>, serían dependencias regulares;
si no, puede especificarlos como dependencias <code>path</code> de la siguiente manera:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Coloque el código del Listado D-2 en <em>src/main.rs</em>, y ejecute <code>cargo run</code>:
debería imprimir <code>Hello, Macro! My name is Pancakes!</code> la implementación del
<em>trait</em> <code>HelloMacro</code> de la macro procedural se incluyó sin que el <em>crate</em>
<code>pancakes</code> necesitara implementarla; el <code>#[derive HelloMacro)]</code> agregó la
implementación del <em>traits</em>.</p>
<h3 id="el-futuro-de-las-macros"><a class="header" href="#el-futuro-de-las-macros">El futuro de las macros</a></h3>
<p>En el futuro, Rust ampliará las macros declarativas y de procedimiento. Rust
utilizará un mejor sistema de macros declarativas con la palabra clave
<code>macro</code> y agregará más tipos de macros de procedimientos para tareas más
potentes que simplemente <code>derive</code>. Estos sistemas aún están en desarrollo en
el momento de esta publicación; Consulte la documentación en línea de Rust
para obtener la información más reciente.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proyecto-final-creación-de-un-servidor-web-multiproceso"><a class="header" href="#proyecto-final-creación-de-un-servidor-web-multiproceso">Proyecto final: creación de un servidor web multiproceso</a></h1>
<p>Ha sido un largo viaje, pero hemos llegado al final del libro. En este capítulo, construiremos un proyecto más juntos para demostrar algunos de los conceptos que cubrimos en los capítulos finales, así como recapitular algunas lecciones anteriores.</p>
<p>Para nuestro proyecto final, haremos un servidor web que diga &quot;hola&quot; y se parezca a la figura 20-1 en un navegador web.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 20-1: Nuestro último proyecto compartido</span></p>
<p>Aquí está el plan para construir el servidor web:</p>
<ol>
<li>Aprende un poco sobre TCP y HTTP.</li>
<li>Escuche las conexiones TCP en un socket.</li>
<li>Analice una pequeña cantidad de solicitudes HTTP.</li>
<li>Crea una respuesta HTTP adecuada.</li>
<li>Mejore el rendimiento de nuestro servidor con un grupo de subprocesos
(<em>thread pool</em>).</li>
</ol>
<p>Pero antes de comenzar, debemos mencionar un detalle: el método que usaremos
no será la mejor manera de construir un servidor web con Rust. En <em>https:
//crates.io/</em> se encuentran disponibles varias <em>crates</em> listas para
producción que proporcionan implementaciones más completas de servidor web y
conjunto de subprocesos que las que crearemos.</p>
<p>Sin embargo, nuestra intención en este capítulo es ayudarlo a aprender, no a
tomar la ruta fácil. Debido a que Rust es un lenguaje de programación de
sistemas, podemos elegir el nivel de abstracción con el que queremos trabajar
y podemos ir a un nivel más bajo de lo que es posible o práctico en otros
lenguajes. Escribiremos el servidor HTTP básico y el grupo de subprocesos
manualmente para que pueda aprender las ideas generales y técnicas detrás de
los <em>crates</em> que puede usar en el futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-a-single-threaded-web-server"><a class="header" href="#building-a-single-threaded-web-server">Building a Single-Threaded Web Server</a></h2>
<p>Comenzaremos trabajando en un servidor web con un <em>single-threaded</em>. Antes de
comenzar, veamos una descripción general rápida de los protocolos
involucrados en la creación de servidores web. Los detalles de estos
protocolos están más allá del alcance de este libro, pero una breve
descripción general le brindará la información que necesita.</p>
<p>Los dos protocolos principales que intervienen en los servidores web son el
<em>Protocolo de transferencia de hipertexto</em>, (<em>Hypertext Transfer
Protocol</em>) <em>(HTTP)</em> y el
<em>Protocolo de control de transmisión</em>, (<em>Transmission Control Protocol</em>)
<em>(TCP)</em>. Ambos protocolos son <em>protocolos de solicitud-respuesta</em>, (<em>request-response</em>), lo que significa que un <em>cliente</em> inicia las
solicitudes y un <em>servidor</em> escucha las solicitudes y proporciona una
respuesta al cliente. El contenido de esas solicitudes y respuestas está
definido por los protocolos.</p>
<p>TCP es el protocolo de nivel inferior que describe los detalles de cómo se
obtiene la información de un servidor a otro, pero no especifica qué es esa
información. HTTP se construye sobre TCP definiendo el contenido de las
solicitudes y respuestas. Es técnicamente posible utilizar HTTP con otros
protocolos, pero en la gran mayoría de los casos, HTTP envía sus datos a
través de TCP. Trabajaremos con los bytes sin procesar de las solicitudes y
respuestas TCP y HTTP.</p>
<h3 id="escuchando-la-conexión-tcp"><a class="header" href="#escuchando-la-conexión-tcp">Escuchando la conexión TCP</a></h3>
<p>Nuestro servidor web necesita escuchar una conexión TCP, por lo que es la
primera parte en la que trabajaremos. La biblioteca estándar ofrece un módulo
<code>std::net</code> que nos permite hacer esto. Hagamos un nuevo proyecto de la manera
habitual:</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Ahora ingrese el código en el Listado 20-1 en <em>src/main.rs</em> para comenzar.
Este código escuchará en la dirección <code>127.0.0.1: 7878</code> para las
transmisiones entrantes de TCP. Cuando recibe una transmisión entrante,
imprimirá <code>Connection established!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listado 20-1: Escuchando las transmisiones entrantes e
imprimiendo un mensaje cuando recibimos una transmisión</span></p>
<p>Usando <code>TcpListener</code>, podemos escuchar las conexiones TCP en la dirección
<code>127.0.0.1:7878</code>. En la dirección, la sección antes de los dos puntos es una
dirección IP que representa su computadora (esto es igual en cada computadora
y no representa específicamente la computadora de los autores), y <code>7878</code> es
el puerto. Hemos elegido este puerto por dos razones: HTTP normalmente se
acepta en este puerto, y 7878 es <em>rust</em> escrito en un teléfono.</p>
<p>La función <code>bind</code> en este escenario funciona como la función <code>new</code> en que
devolverá una nueva instancia <code>TcpListener</code>. La razón por la cual la función
se llama <code>bind</code> es que, en una red, conectarse a un puerto para escuchar se
conoce como “binding to a port”.</p>
<p>La función <code>bind</code> devuelve un <code>Result &lt;T, E&gt;</code>, que indica que el enlace puede
fallar. Por ejemplo, conectarse al puerto 80 requiere privilegios de
administrador (los no administradores pueden escuchar solo en puertos de más
de 1024), por lo que si intentamos conectarnos al puerto 80 sin ser un
administrador, el enlace no funcionaría. Como otro ejemplo, el enlace no
funcionaría si ejecutamos dos instancias de nuestro programa y, por lo tanto,
teníamos dos programas escuchando el mismo puerto. Debido a que estamos
escribiendo un servidor básico solo para fines de aprendizaje, no nos
preocuparemos por manejar este tipo de errores; en su lugar, usamos <code>unwrap</code>
para detener el programa si ocurren errores.</p>
<p>El método <code>incoming</code> en <code>TcpListener</code> devuelve un iterador que nos da un
secuencia de flujos (más específicamente, flujos de tipo <code>TcpStream</code>). Un
solo <em>stream</em> representa una conexión abierta entre el cliente y el servidor.
Una <em>connection</em> es el nombre del proceso completo de solicitud y respuesta
en el que el cliente se conecta al servidor, el servidor genera una respuesta
y el servidor cierra la conexión. Como tal, <code>TcpStream</code> leerá de sí mismo
para ver qué el cliente envió y luego nos permitió escribir nuestra respuesta
a la transmisión. En general, este bucle <code>for</code> procesará cada conexión por
turno y producirá una serie de secuencias para que podamos manejar.</p>
<p>Por ahora, nuestro manejo de la transmisión consiste en llamar a <code>unwrap</code>
para terminar nuestro programa si la transmisión tiene algún error; si no hay
ningún error, el programa imprime un mensaje. Añadiremos más funcionalidades
para el caso de éxito en el siguiente listado. La razón por la que podríamos
recibir errores del método <code>incoming</code> cuando un cliente se conecta al
servidor es que en realidad no estamos iterando conexiones. En cambio,
estamos iterando sobre <em>intentos de conexión</em>. los conexión puede no ser
exitosa por una serie de razones, muchas de ellas sistema operativo
específico. Por ejemplo, muchos sistemas operativos tienen un límite para la
cantidad de conexiones abiertas simultáneas que pueden admitir; nueva conexión
los intentos más allá de ese número producirán un error hasta que algunos de
los abiertos las conexiones estan cerradas</p>
<p>¡Tratemos de ejecutar este código! invocar <code>cargo run</code>  en la terminal y
luego cargar <em>127.0.0.1: 7878</em> en un navegador web. El navegador debe mostrar
un mensaje de error como “Connection reset”, porque el servidor no está
enviando ningún datos. Pero cuando mira su terminal, debería ver varios
mensajes que se imprimieron cuando el navegador se conectó al servidor!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>A veces, verá múltiples mensajes impresos para una solicitud del navegador;
la razón podría ser que el navegador está haciendo una solicitud de la página
así como una solicitud de otros recursos, como el icono <em>favicon.ico</em> que
aparece en la pestaña del navegador.</p>
<p>También podría ser que el navegador esté intentando conectarse al servidor
varias veces porque el servidor no responde con ningún dato. Cuando <code>stream</code>
sale del alcance y se elimina al final del ciclo, la conexión se cierra como
parte de la implementación <code>drop</code>. Los navegadores a veces tratan las
conexiones cerradas reintentando, porque el problema puede ser temporal. ¡El
factor importante es que hemos logrado obtener un control para una conexión
TCP!</p>
<p>Recuerde detener el programa presionando
<span class="keystroke">ctrl-c</span> cuando termine de ejecutar una versión
particular del código. Luego, reinicie <code>cargo run</code> después de realizar cada
conjunto de cambios de código para asegurarse de que está ejecutando el
código más nuevo.</p>
<h3 id="leyendo-la-solicitud"><a class="header" href="#leyendo-la-solicitud">Leyendo la Solicitud</a></h3>
<p>¡Implementemos la funcionalidad para leer la solicitud desde el navegador!.
Para separar las preocupaciones de primero obtener una conexión y luego tomar
alguna medida con la conexión, comenzaremos una nueva función para procesar
las conexiones. En esta nueva función <code>handle_connection</code>, leeremos datos de
la transmisión TCP e imprimiremos para que podamos ver los datos que se
envían desde el navegador. Cambie el código para que se vea como el Listado
20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">Listado 20-2: Lectura del <code>TcpStream</code> e impresión de
los datos</span></p>
<p>Traemos <code>std::io::prelude</code> en alcance para obtener acceso a ciertos
<em>traits</em> que nos permiten leer y escribir en la transmisión. En el bucle
<code>for</code> de la función <code>main</code>, en lugar de imprimir un mensaje que dice que
hicimos una conexión, ahora llamamos a la nueva función <code>handle_connection</code> y
le pasamos el <code>stream</code>.</p>
<p>En la función <code>handle_connection</code>, hemos hecho que el parámetro <code>stream</code> sea
mutable. La razón es que la instancia <code>TcpStream</code> hace un seguimiento de qué
datos nos devuelve internamente. Puede leer más datos de los que pedimos y
guardarlos para la próxima vez que solicitemos datos. Por lo tanto, debe ser
<code>mut</code> porque su estado interno puede cambiar; por lo general, pensamos que
“reading” no necesita mutación, pero en este caso necesitamos la palabra
clave <code>mut</code>.</p>
<p>Luego, necesitamos leer de la transmisión. Hacemos esto en dos pasos: primero
declaramos un <code>buffer</code> en la pila para contener los datos que se leen. Hemos
creado un tamaño de buffer de 512 bytes, que es lo suficientemente grande
como para contener los datos de una solicitud básica y suficiente para
nuestros propósitos en este capítulo. Si quisiéramos manejar solicitudes de
un tamaño arbitrario, la gestión del buffer debería ser más complicada; lo
mantendremos simple por ahora. Pasamos el búfer a <code>stream.read</code>, que leerá
bytes de <code>TcpStream</code> y los colocará en el búfer.</p>
<p>Segundo, convertimos los bytes en el buffer a una cadena e imprimimos esa
cadena. La función <code>String::from_utf8_lossy</code> toma <code>&amp;[u8]</code> y produce <code>String</code>
a partir de ella. La parte “lossy” del nombre indica el comportamiento de
esta función cuando ve una secuencia UTF-8 no válida: reemplazará la
secuencia no válida con <code>�</code>, el <code>CARÁCTER DE REEMPLAZO U + FFFD</code>. Es posible
que vea caracteres de reemplazo para los caracteres en el búfer que no se
llenan con los datos de solicitud.</p>
<p>¡Probemos este código! Inicie el programa y vuelva a realizar una solicitud
en un navegador web. Tenga en cuenta que todavía obtendremos una página de
error en el navegador, pero la salida de nuestro programa en el terminal
ahora se verá similar a esto:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>Dependiendo de su navegador, puede obtener resultados ligeramente diferentes.
Ahora que estamos imprimiendo los datos de solicitud, podemos ver por qué
recibimos múltiples conexiones de una solicitud de navegador mirando la ruta
después de <code>Request: GET</code>. Si todas las conexiones repetidas solicitan
<em>/</em>, sabemos que el navegador está intentando recuperar <em>/</em> repetidamente
porque no recibe una respuesta de nuestro programa.</p>
<p>Vamos a desglosar los datos de esta solicitud para comprender qué le pide el
navegador a nuestro programa.</p>
<h3 id="una-mirada-más-cercana-a-una-solicitud-http"><a class="header" href="#una-mirada-más-cercana-a-una-solicitud-http">Una mirada más cercana a una solicitud HTTP</a></h3>
<p>HTTP es un protocolo basado en texto, y una solicitud toma este formato:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>La primera línea es la <em>línea de solicitud</em> que contiene información sobre lo
que el cliente está solicitando. La primera parte de la línea de solicitud
indica el <em>método</em> se usa, como <code>GET</code> o <code>POST</code>, que describe cómo el cliente
está haciendo esta petición. Nuestro cliente usó una solicitud <code>GET</code>.</p>
<p>La siguiente parte de la línea de solicitud es <em>/</em>, que indica el
<em>Recurso uniforme Identificador</em>, (<em>Uniform Resource Identifier</em>) <em>(URI)</em> que
el cliente está solicitando: un URI es casi, pero no del todo,
lo mismo que un <em>Localizador Uniforme de Recursos</em>, (<em>Uniform Resource
Locator</em>) <em>(URL)</em>. La diferencia entre los URI
y las URL no son importantes para nuestros propósitos en este capítulo, pero
la especificación HTTP utiliza el término URI, por lo que podemos sustituir
mentalmente URL por URI aquí.</p>
<p>La última parte es la versión HTTP que usa el cliente y luego la línea de
solicitud termina en una <em>secuencia CRLF</em>. (CRLF significa <em>carriage return</em>
y <em>line feed</em>, ¡que son términos de los días de la máquina de escribir!). La
secuencia CRLF también puede ser escrito como <code>\r\n</code>, donde <code>\r</code> es un
retorno de carro y <code>\n</code> es un salto de línea. La secuencia CRLF separa la
línea de solicitud del resto de los datos de solicitud.
Tenga en cuenta que cuando se imprime el CRLF, vemos un nuevo inicio de línea
en lugar de <code>\r\n</code>.</p>
<p>Mirando los datos de línea de solicitud que recibimos al ejecutar nuestro
programa hasta ahora, vemos que <code>GET</code> es el método, <em>/</em> es el URI de
solicitud, y <code>HTTP/1.1</code> es la versión.</p>
<p>Después de la línea de solicitud, las líneas restantes que comienzan desde
<code>Host:</code> en adelante son encabezados, las peticiones <code>GET</code> no tienen cuerpo.</p>
<p>Intente hacer una solicitud desde un navegador diferente o solicite una
dirección, como <em>127.0.0.1: 7878/test</em>, para ver cómo cambian los datos de
solicitud.</p>
<p>Ahora que sabemos lo que el navegador está pidiendo, ¡enviemos algunos datos!</p>
<h3 id="escribir-una-respuesta"><a class="header" href="#escribir-una-respuesta">Escribir una respuesta</a></h3>
<p>Ahora implementaremos el envío de datos en respuesta a una solicitud del
cliente. Las respuestas tienen el siguiente formato:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>La primera línea es <em>una línea de estado</em> (<em>status line</em>) que contiene la
versión HTTP utilizada en la respuesta, un código de estado numérico que
resume el resultado de la solicitud y una frase de motivo que proporciona una
descripción de texto del código de estado. Después de la secuencia CRLF hay
encabezados, otra secuencia CRLF y el cuerpo de la respuesta.</p>
<p>Aquí hay una respuesta de ejemplo que usa HTTP versión 1.1, tiene un código
de estado de 200, una frase de razón OK, sin encabezados y sin cuerpo:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>El código de estado 200 es la respuesta de éxito estándar. El texto es una
pequeña respuesta HTTP exitosa. ¡Escribamos esto en la transmisión como
respuesta a una solicitud exitosa!. Desde la función <code>handle_connection</code>,
elimine <code>println!</code> Que estaba imprimiendo los datos de solicitud y
reemplácelo con el código en el Listado 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-3: Escribir una pequeña respuesta HTTP
exitosa a la transmisión</span></p>
<p>La primera nueva línea define la variable <code>response</code> que contiene los datos
del mensaje de éxito. Luego llamamos <code>as_bytes</code> a nuestra <code>response</code> para
convertir los datos de cadena en bytes. El método <code>write</code> en <code>stream</code> toma
<code>&amp;[u8]</code> y envía esos bytes directamente a través de la conexión.</p>
<p>Debido a que la operación <code>write</code> puede fallar, usamos <code>unwrap</code> en cualquier
resultado de error como antes. De nuevo, en una aplicación real agregaría el
manejo de errores aquí. Finalmente, <code>flush</code> esperará e impedirá que el
programa continúe hasta que todos los bytes se escriban en la conexión;
<code>TcpStream</code> contiene un búfer interno para minimizar las llamadas al sistema
operativo subyacente.</p>
<p>Con estos cambios, ejecutemos nuestro código y hagamos una solicitud. Ya no
imprimimos datos en la terminal, por lo que no veremos otra salida que no sea
la salida de Cargo. Cuando carga <em>127.0.0.1:7878</em> en un navegador web, debe
obtener una página en blanco en lugar de un error. ¡Has codificado
manualmente una solicitud y respuesta HTTP!</p>
<h3 id="devolución-de-html-real"><a class="header" href="#devolución-de-html-real">Devolución de HTML real</a></h3>
<p>Implementemos la funcionalidad para devolver más que una página en blanco.
Cree un nuevo archivo, <em>hello.html</em>, en la raíz del directorio de su proyecto
no en el directorio <em>src</em>. Puede ingresar cualquier HTML que desee; El
listado 20-4 muestra una posibilidad.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listado 20-4: Un archivo HTML de muestra para devolver
en una respuesta</span></p>
<p>Este es un documento HTML5 mínimo con un encabezado y texto. Para devolver
esto desde el servidor cuando se recibe una solicitud, modificaremos
<code>handle_connection</code> como se muestra en el Listado 20-5 para leer el archivo
HTML, agregarlo a la respuesta como un cuerpo y enviarlo.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span>use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-5: Envío de los contenidos de <em>hello.html</em>
como el cuerpo de la respuesta</span></p>
<p>Hemos agregado una línea en la parte superior para poner el <code>File</code> de la
biblioteca estándar en el alcance. El código para abrir un archivo y leer los
contenidos debería ser familiar; lo usamos en el Capítulo 12 cuando leemos el
contenido de un archivo para nuestro proyecto de E/S en el Listado 12-4.</p>
<p>A continuación, usamos <code>format!</code> Para agregar el contenido del archivo como
el cuerpo de la respuesta de éxito.</p>
<p>Ejecute este código con <code>cargo run</code> y cargue <em>127.0.0.1:7878</em>
en su navegador; ¡deberías ver tu HTML renderizado!</p>
<p>Actualmente, ignoramos los datos de solicitud en <code>buffer</code> y simplemente
enviamos el contenido del archivo HTML incondicionalmente. Eso significa que
si intentas solicitar <em>127.0.0.1:7878/something-else</em> en tu navegador, igual
obtendrás la misma respuesta HTML. Nuestro servidor es muy limitado y no es
lo que hacen la mayoría de los servidores web. Queremos personalizar nuestras
respuestas según la solicitud y solo enviar el archivo HTML para una
solicitud bien formada a <em>/</em>.</p>
<h3 id="validar-la-solicitud-y-responder-selectivamente"><a class="header" href="#validar-la-solicitud-y-responder-selectivamente">Validar la solicitud y responder selectivamente</a></h3>
<p>En este momento, nuestro servidor web devolverá el código HTML en el archivo
sin importar lo que el cliente solicite. Agreguemos funcionalidad para
verificar que el navegador esté solicitando <em>/</em> antes de devolver el archivo
HTML y devuelva un error si el navegador solicita algo más. Para esto,
necesitamos modificar <code>handle_connection</code>, como se muestra en el Listado
20-6. Este nuevo código verifica el contenido de la solicitud recibida contra
lo que sabemos que parece una solicitud para <em>/</em> y agrega bloques <code>if</code> y
<code>else</code> para tratar las solicitudes de manera diferente.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-6: Igualar las solicitudes y gestionar las
solicitudes a <em>/</em> que otras solicitudes</span></p>
<p>Primero, codificamos los datos correspondientes a la solicitud <em>/</em> en la
variable <code>get</code>. Debido a que estamos leyendo bytes sin formato en el búfer,
transformamos <code>get</code> en una cadena de bytes agregando la sintaxis  <code>b&quot;&quot;</code> <em>byte
string</em> al comienzo de los datos de contenido. Luego comprobamos si <code>buffer</code>
comienza con los bytes en <code>get</code>. Si lo hace, significa que hemos recibido una
solicitud bien formada para <em>/</em>, que es el caso de éxito que manejaremos en
el bloque <code>if</code> que devuelve los contenidos de nuestro archivo HTML.</p>
<p>Si <code>buffer</code> <em>no</em> comienza*con los <em>bytes</em> en <code>get</code>, significa que hemos
recibido alguna otra solicitud. Añadiremos código al bloque <code>else</code> en un
momento para responder a todas las demás solicitudes.</p>
<p>Ejecute este código ahora y solicite <em>127.0.0.1:7878</em>; deberías obtener el
HTML en <em>hello.html</em>. Si realiza cualquier otra solicitud, como
<em>127.0.0.1:7878/something-else</em>, obtendrá un error de conexión como los que
vio al ejecutar el código en el Listado 20-1 y el Listado 20-2.</p>
<p>Ahora agreguemos el código del listado 20-7 al bloque <code>else</code> para devolver
una respuesta con el código de estado 404, que indica que no se encontró el
contenido de la solicitud. También le devolveremos algo de HTML para que una
página se represente en el navegador e indique la respuesta al usuario final.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">if true {
</span>// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-7: Respondiendo con el código de estado 404
y una página de error si se solicitó algo más que <em>/</em></span></p>
<p>Aquí, nuestra respuesta tiene una línea de estado con el código de estado 404
y la frase de razón <code>NOT FOUND</code>. Todavía no estamos devolviendo encabezados,
y el cuerpo de la respuesta será el HTML en el archivo <em>404.html</em>. Deberá
crear un archivo <em>404.html</em> junto a <em>hello.html</em> para la página de error; de
nuevo, siéntase libre de usar cualquier HTML que desee o use el HTML de
ejemplo en el Listado 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listado 20-8: muestra el contenido de la página para
enviar de vuelta con cualquier respuesta 404</span></p>
<p>Con estos cambios, ejecute su servidor de nuevo. La solicitud de
<em>127.0.0.1:7878</em> debe devolver el contenido de <em>hello.html</em>, y cualquier otra
solicitud, como <em>127.0.0.1:7878/foo</em>, debe devolver el HTML de error de
<em>404.html</em>.</p>
<h3 id="un-toque-de-refactorización"><a class="header" href="#un-toque-de-refactorización">Un toque de refactorización</a></h3>
<p>Por el momento, los bloques <code>if</code> y <code>else</code> tienen mucha repetición: ambos leen
archivos y escriben el contenido de los archivos en la transmisión. Las
únicas diferencias son la línea de estado y el nombre del archivo. Hagamos
que el código sea más conciso sacando esas diferencias en líneas separadas
<code>if</code> y <code>else</code> que asignarán los valores de la línea de estado y el nombre de
archivo a las variables; entonces podemos usar esas variables
incondicionalmente en el código para leer el archivo y escribir la respuesta.
El listado 20-9 muestra el código resultante después de reemplazar los
bloques grandes <code>if</code> y <code>else</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
<span class="boring">    let mut buffer = [0; 512];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span>    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-9: Refactorizando los bloques <code>if</code> y <code>else</code>
para contener solo el código que difiere entre los dos casos</span></p>
<p>Ahora los bloques <code>if</code> y <code>else</code> solo devuelven los valores apropiados para la
línea de estado y el nombre de archivo en una tupla; luego usamos la
desestructuración para asignar estos dos valores a <code>status_line</code> y <code>filename</code>
usando un patrón en la declaración <code>let</code>, como se discutió en el Capítulo 18.</p>
<p>El código previamente duplicado está ahora fuera de los bloques <code>if</code> y <code>else</code>
y usa las variables <code>status_line</code> y <code>filename</code>. Esto hace que sea más fácil
ver la diferencia entre los dos casos, y significa que tenemos un solo lugar
para actualizar el código si queremos cambiar el funcionamiento de la lectura
de archivos y la escritura de respuestas. El comportamiento del código en el
listado 20-9 será el mismo que en el listado 20-8.</p>
<p>¡Increíble! Ahora tenemos un servidor web simple en aproximadamente 40
líneas de código Rust que responde a una solicitud con una página de
contenido y responde a todas las demás solicitudes con una respuesta 404.</p>
<p>Actualmente, nuestro servidor se ejecuta en un único hilo, lo que significa
que solo puede servir una solicitud a la vez. Examinemos cómo puede ser un
problema simulando algunas solicitudes lentas. Luego lo arreglaremos para que
nuestro servidor pueda manejar múltiples solicitudes a la vez.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="convirtiendo-nuestro-servidor-de-un-single-threaded-en-un-servidor-multithreaded"><a class="header" href="#convirtiendo-nuestro-servidor-de-un-single-threaded-en-un-servidor-multithreaded">Convirtiendo nuestro servidor de un <em>Single-Threaded</em> en un servidor Multithreaded</a></h2>
<p>En este momento, el servidor procesará cada solicitud por turno, lo que
significa que no procesará una segunda conexión hasta que la primera termine
de procesarse. Si el servidor recibió más y más solicitudes, esta ejecución
en serie sería cada vez menos óptima. Si el servidor recibe una solicitud
que tarda mucho tiempo en procesarse, las solicitudes posteriores deberán
esperar hasta que finalice la solicitud larga, incluso si las nuevas
solicitudes se pueden procesar rápidamente. Tendremos que arreglar esto,
pero primero, veremos el problema en acción.</p>
<h3 id="simular-una-solicitud-lenta-en-la-implementación-del-servidor-actual"><a class="header" href="#simular-una-solicitud-lenta-en-la-implementación-del-servidor-actual">Simular una solicitud lenta en la implementación del servidor actual</a></h3>
<p>Veremos cómo una solicitud de procesamiento lento puede afectar otras
solicitudes realizadas a nuestra implementación actual del servidor. El
listado 20-10 implementa el manejo de una solicitud <em>/sleep</em> con una
respuesta lenta simulada que hará que el servidor duerma durante 5 segundos
antes de responder.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;
<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
<span class="boring">    let mut buffer = [0; 512];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span>    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-10: simulando una solicitud lenta
reconociendo <em>/sleep</em> y durmiendo durante 5 segundos</span></p>
<p>Este código es un poco complicado, pero es lo suficientemente bueno para
fines de simulación. Creamos una segunda solicitud <code>sleep</code>, cuyos datos
reconoce nuestro servidor. Añadimos un <code>else if</code> después del bloque <code>if</code>
para verificar la solicitud a <em>/sleep</em>. Cuando se recibe esa solicitud, el
servidor duerme durante 5 segundos antes de mostrar la página HTML correcta.</p>
<p>Puedes ver cuán primitivo es nuestro servidor: ¡las bibliotecas reales
manejarían el reconocimiento de múltiples solicitudes de una manera mucho
menos detallada!</p>
<p>Inicie el servidor usando <code>cargo run</code>. A continuación, abra dos ventanas del
navegador: una para <em>http://127.0.0.1:7878/</em> y la otra para
<em>http://127.0.0.1:7878/sleep</em>. Si ingresa el <em>/</em> URI varias veces, como
antes, verá que responde rápidamente. Pero si ingresa <em>/sleep</em> y luego carga
<em>/</em>, verá que <em>/</em> espera hasta que <code>sleep</code> haya dormido durante 5 segundos
antes de cargar.</p>
<p>Hay varias formas en que podemos cambiar la forma en que funciona nuestro
servidor web para evitar tener más solicitudes de respaldo detrás de una
solicitud lenta; el que implementaremos es un <em>thread pool</em>.</p>
<h3 id="mejorar-el-rendimiento-con-un-thread-pool"><a class="header" href="#mejorar-el-rendimiento-con-un-thread-pool">mejorar el rendimiento con un <em>Thread Pool</em></a></h3>
<p>Un <em>thread pool</em> es un <em>pool</em> de hilos generados que están esperando y listos
para manejar una tarea. Cuando el programa recibe una nueva tarea, asigna
uno de los hilos en el <em>pool</em> a la tarea, y ese hilo procesará la tarea. los
los hilos restantes en el <em>pool</em> están disponibles para manejar cualquier
otra tarea que se presente mientras el primer hilo está procesando. Cuando
se termina el primer hilo procesando su tarea, se devuelve al <em>thread pool</em>
inactivos, listo para manejar una nueva tarea. Un <em>thread pool</em> le permite
procesar conexiones al mismo tiempo, aumentando el rendimiento de su
servidor.</p>
<p>Limitaremos el número de <em>threads</em> en el <em>pool</em> a un número pequeño para
protegernos de ataques de denegación de servicio (DoS); si tuviéramos
nuestro programa, cree un nuevo hilo para cada solicitud que entró, alguien
haciendo 10 millones de solicitudes a nuestro servidor podría crear estragos
al detener todos los recursos de nuestro servidor y detener el procesamiento
de las solicitudes.</p>
<p>En lugar de engendrar hilos ilimitados, tendremos un número fijo de hilos
esperando en el <em>pool</em>. A medida que llegan las solicitudes, se enviarán al
<em>pool</em> para procedimiento. El grupo mantendrá una cola de solicitudes
entrantes. Cada una de las los <em>threads</em> del <em>pool</em> extraerán una solicitud
de esta cola, manejarán la solicitud, y luego pedirle a la cola otra
solicitud. Con este diseño, podemos procesar solicitudes <code>N</code>
concurrentemente, donde <code>N</code> es la cantidad de hilos. Si cada <em>thread</em>
responde a una solicitud de larga ejecución, las solicitudes posteriores aún
pueden realizar una copia de seguridad en la cola, pero hemos aumentado la
cantidad de solicitudes de larga ejecución que podemos manejar antes de
llegar a ese punto.</p>
<p>Esta técnica es solo una de las muchas formas de mejorar el rendimiento de
un servidor web. Otras opciones que puede explorar son el modelo de
<em>fork/join</em> y el modelo de E/S asíncronas de un solo hilo. Si le interes
este tema, puede leer más sobre otras soluciones e intentar implementarlas
en Rust; con un lenguaje de bajo nivel como Rust, todas estas opciones son
posibles.</p>
<p>Antes de comenzar a implementar un <em>thread pool</em>, hablemos sobre cómo
debería ser el uso del <em>pool</em>. Cuando intenta diseñar código, escribir
primero la interfaz del cliente puede ayudar a guiar su diseño. Escriba la
API del código para que esté estructurado de la manera que desea llamarlo;
luego implemente la funcionalidad dentro de esa estructura en lugar de
implementar la funcionalidad y luego diseñar la API pública.</p>
<p>De manera similar a como utilizamos el desarrollo basado en pruebas en el
proyecto en el Capítulo 12, usaremos el <em>compiler-driven development</em> aquí.
Escribiremos el código que llama a las funciones que queremos, y luego
veremos los errores del compilador para determinar qué debemos cambiar luego
para que el código funcione.</p>
<h4 id="estructura-del-código-si-pudiéramos-spawn-un-hilo-para-cada-solicitud"><a class="header" href="#estructura-del-código-si-pudiéramos-spawn-un-hilo-para-cada-solicitud">Estructura del código si pudiéramos <em>Spawn</em> un hilo para cada solicitud</a></h4>
<p>Primero, exploremos cómo podría verse nuestro código si creara un nuevo hilo
para cada conexión. Como se mencionó anteriormente, este no es nuestro plan
final debido a los problemas con el potencial de generar un número ilimitado
de hilos, pero es un punto de partida. El listado 20-11 muestra los cambios
que se realizarán en <code>main</code> para <em>spawning</em> un nuevo hilo para manejar cada
flujo dentro del bucle <code>for</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::thread;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">fn handle_connection(mut stream: TcpStream) {}
</span></code></pre></pre>
<p><span class="caption">Listado 20-11: Generando un nuevo hilo para cada
flujo</span></p>
<p>Como aprendió en el Capítulo 16, <code>thread::spawn</code> creará un nuevo hilo y
luego ejecutará el código en el <em>closure</em> del nuevo hilo. Si ejecuta este
código y carga <em>/sleep</em> en su navegador, entonces <em>/</em> en dos pestañas más
del navegador, verá que las solicitudes a <em>/</em> no tienen que esperar
<em>/sleep</em> para finalizar. Pero como mencionamos, esto eventualmente abrumará
al sistema porque estarías creando nuevos hilos sin límite.</p>
<h4 id="crear-una-interfaz-similar-para-un-número-finito-de-hilos"><a class="header" href="#crear-una-interfaz-similar-para-un-número-finito-de-hilos">Crear una interfaz similar para un número finito de hilos</a></h4>
<p>Queremos que nuestro <em>thread pool</em> funcione de forma similar y familiar, por
lo que cambiar de <em>thread</em> a un <em>thread pool</em> no requiere grandes cambios en
el código que usa nuestra API. El listado 20-12 muestra la interfaz
hipotética para una estructura <code>ThreadPool</code> que queremos usar en lugar de
<code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::thread;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">struct ThreadPool;
</span><span class="boring">impl ThreadPool {
</span><span class="boring">   fn new(size: u32) -&gt; ThreadPool { ThreadPool }
</span><span class="boring">   fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">       where F: FnOnce() + Send + 'static {}
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">fn handle_connection(mut stream: TcpStream) {}
</span></code></pre></pre>
<p><span class="caption">Listado 20-12: nuestra interfaz ideal
<code>ThreadPool</code></span></p>
<p>Usamos <code>ThreadPool::new</code> para crear un nuevo <em>thread pool</em> con un número
configurable de <em>threads</em>, en este cuatro caso. Luego, en el bucle <code>for</code>,
<code>pool.execute</code> tiene una interfaz similar a <code>thread::spawn</code>, ya que requiere
un <em>closure</em> para que el pool se ejecute para cada stream. Necesitamos
implementar <code>pool.execute</code> para que se lleve a cabo el <em>closure</em> y se lo
entregue a un hilo en el <em>pool</em> para que se ejecute. Este código aún no se
compilará, pero lo intentaremos para que el compilador pueda guiarnos en
cómo solucionarlo.</p>
<h4 id="construyendo-la-estructura-threadpool-usando-compiler-driven-development"><a class="header" href="#construyendo-la-estructura-threadpool-usando-compiler-driven-development">Construyendo la estructura <code>ThreadPool</code> usando <em>Compiler Driven Development</em></a></h4>
<p>Realice los cambios en el listado 20-12 a <em>src/main.rs</em>, y luego usemos los
errores del compilador de <code>cargo check</code> para impulsar nuestro desarrollo.
Este es el primer error que obtenemos:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>¡Estupendo! Este error nos dice que necesitamos un tipo o módulo
<code>ThreadPool</code>, así que crearemos uno ahora. Nuestra implementación
<code>ThreadPool</code> será independiente del tipo de trabajo que nuestro servidor web
está haciendo. Entonces, cambiemos el <em>crate</em> <code>hello</code> de un <em>binary crate</em> a
un <em>library crate</em> para mantener nuestra implementación <code>ThreadPool</code>.
Después de cambiar a un <em>library crate</em>, también podríamos usar la
biblioteca del <em>thread pool</em> por separado para cualquier trabajo que
deseemos con un <em>thread pool</em>, no solo para servir solicitudes web.</p>
<p>Cree un <em>src/lib.rs</em> que contenga lo siguiente, que es la definición más
simple de una estructura <code>ThreadPool</code> que podemos tener por ahora:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;
<span class="boring">}
</span></code></pre></pre>
<p>A continuación, cree un nuevo directorio, <em>src/bin</em>, y mueva el <em>binary
crate</em> enraizada en <em>src/main.rs</em> en <em>src/bin/main.rs</em>. Hacerlo hará que el
<em>library crate</em> cargue el <em>crate</em> primario en el directorio <em>hello</em>; aún
podemos ejecutar el binario en <em>src/bin/main.rs</em> usando <code>cargo run</code>. Después
de mover el archivo <em>main.rs</em>, edítelo para que aparezca el <em>library crate</em>
y coloque <code>ThreadPool</code> en el alcance agregando el siguiente código a la
parte superior de <em>src/bin/main.rs</em>:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<p>Este código aún no funcionará, pero revisemoslo nuevamente para obtener el
próximo error que necesitamos abordar:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<p>Este error indica que a continuación debemos crear una función asociada
denominada <code>new</code> para <code>ThreadPool</code>. También sabemos que <code>new</code> necesita tener
un parámetro que pueda aceptar <code>4</code> como argumento y debe devolver una
instancia <code>ThreadPool</code>. Implementemos la función <code>new</code> más simple que tendrá
esas características:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Elegimos <code>usize</code> como el tipo del parámetro <code>size</code>, porque sabemos que un
número negativo de hilos no tiene ningún sentido. También sabemos que
usaremos este 4 como el número de elementos en una colección de hilos, que
es para lo que el tipo <code>usize</code> es, como se discutió en la sección “Tipos de
enteros” del Capítulo 3.</p>
<p>Revisemos el código nuevamente:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<p>Ahora recibimos una advertencia y un error. Ignorando la advertencia por un
momento, el error ocurre porque no tenemos un método <code>execute</code> en
<code>ThreadPool</code>. Recuerde en la sección “Crear una interfaz similar para un
número finito de <em>Threads</em>” que decidimos que nuestro <em>thread pool</em> debería
tener una interfaz similar a <code>thread::spawn</code>. Además, implementaremos la
función <code>execute</code> para que tome el <em>closure</em> que se le da y lo entregue a un
hilo inactivo en el <em>pool</em> para ejecutar.</p>
<p>Definiremos el método <code>execute</code> en <code>ThreadPool</code> para tomar un <em>closure</em> como
parámetro. Recuerde en la sección “Almacenamiento de <em>closures</em> con
parámetros genéricos y <em>traits</em> de Fn” en el Capítulo 13 que podemos tomar
<em>closures</em> como parámetros con tres características diferentes: <code>Fn</code>,
<code>FnMut</code> y <code>FnOnce</code>. Tenemos que decidir qué tipo de <em>closure</em> usar aquí.
Sabemos que terminaremos haciendo algo similar a la implementación de la
biblioteca estándar <code>thread::spawn</code>, para que podamos ver qué límites tiene
la firma de <code>thread::spawn</code> en su parámetro. La documentación nos muestra lo
siguiente:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>El parámetro de tipo <code>F</code> es el que nos interesa aquí; el parámetro de tipo
<code>T</code> está relacionado con el valor de retorno, y no estamos preocupados por
eso. Podemos ver que <code>spawn</code> usa <code>FnOnce</code> como el <em>trait bound</em> a <code>F</code>. Esto
es probablemente lo que queremos también, porque eventualmente pasaremos el
argumento que obtenemos en <code>execute</code> a <code>spawn</code>. Podemos estar más seguros de
que <code>FnOnce</code> es el <em>trait</em> que queremos usar, ya que el hilo para ejecutar
una solicitud solo ejecutará el <em>closure</em> de esa solicitud una vez, que
coincide con <code>Once</code> en <code>FnOnce</code>.</p>
<p>El parámetro de tipo <code>F</code> también tiene el <em>trait bound</em> <code>Send</code> y el
<em>lifetime bound</em> <code>'static</code>, que son útiles en nuestra situación:
necesitamos <code>Send</code> para transferir el <em>closure</em> de un hilo a otro y
<code>'static</code> porque no sabemos cuánto tardará el hilo en ejecutarse. Vamos a
crear un método <code>execute</code> en <code>ThreadPool</code> que tomará un parámetro genérico
de tipo <code>F</code> con estos límites:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span>impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Todavía usamos el <code>()</code> después de <code>FnOnce</code> porque este <code>FnOnce</code> representa
un <em>closure</em> que no toma parámetros y no devuelve un valor. Al igual que las
definiciones de función, el tipo de devolución puede omitirse de la firma,
pero incluso si no tenemos parámetros, aún necesitamos los paréntesis.</p>
<p>De nuevo, esta es la implementación más simple del método <code>execute</code>: no hace
nada, pero solo intentamos compilar nuestro código. Veámoslo de nuevo:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<p>Estamos recibiendo solo advertencias ahora, ¡lo que significa que compila!
Pero tenga en cuenta que si prueba <code>cargo run</code> y realiza una solicitud en el
navegador, verá los errores en el navegador que vimos al principio del
capítulo. ¡Nuestra biblioteca no está llamando al <em>closure</em> pasado a <code>ejecutar</code> todavía!</p>
<blockquote>
<p>Nota: Un dicho que usted puede escuchar sobre los leenguajes con
compiladores estrictos, como Haskell y Rust, es “si el código se compila,
funciona”. Pero este dicho no es universalmente cierto. Nuestro proyecto se
compila, ¡pero no hace absolutamente nada! Si estuviéramos construyendo un
proyecto real y completo, este sería un buen momento para comenzar a
escribir pruebas unitarias para verificar que el código compila <em>y</em> tenga
el comportamiento que queremos.</p>
</blockquote>
<h4 id="validar-el-número-de-threads-en-new"><a class="header" href="#validar-el-número-de-threads-en-new">Validar el número de <em>Threads</em> en <code>new</code></a></h4>
<p>Seguiremos recibiendo advertencias porque no estamos haciendo nada con los
parámetros para <code>new</code> y <code>execute</code>. Implementemos los cuerpos de estas
funciones con el comportamiento que queremos. Para empezar, pensemos en
<code>new</code>. Anteriormente elegimos un tipo sin signo para el parámetro <code>size</code>,
porque un <em>pool</em> con un número negativo de <em>threads</em> no tiene sentido. Sin
embargo, un <em>pool</em> con cero <em>threads</em> tampoco tiene sentido, pero cero es un
<code>usize</code> perfectamente válido. Agregaremos código para verificar que <code>size</code>
sea mayor que cero antes de devolver una instancia <code>ThreadPool</code> y pánico al
programa si recibe un cero usando la macro <code>assert!</code>, Como se muestra en el
Listado 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-13: Implementando <code>ThreadPool::new</code> para
entrar en pánico si <code>size</code> es cero</span></p>
<p>Hemos agregado documentación para nuestro <code>ThreadPool</code> con comentarios de
doc. Tenga en cuenta que seguimos buenas prácticas de documentación al
agregar una sección que indica las situaciones en las que nuestra función
puede entrar en pánico, como se discutió en el Capítulo 14. Pruebe ejecutar
<code>cargo doc --open</code> y haga clic en la estructura <code>ThreadPool</code> para ver lo que
generó documentos para <code>new</code>!</p>
<p>En lugar de agregar la macro <code>assert!</code> como hemos hecho aquí, podríamos
hacer que <code>new</code> devolviera un <code>Result</code> como lo hicimos con <code>Config::new</code> en
el proyecto de E/S del Listado 12-9. Pero hemos decidido en este caso que
intentar crear un <em>thread pool</em> sin ningún <em>threads</em> debería ser un error
irrecuperable. Si te sientes ambicioso, intenta escribir una versión de
<code>new</code> con la siguiente firma para comparar ambas versiones:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4 id="crear-espacio-para-almacenar-los-threads"><a class="header" href="#crear-espacio-para-almacenar-los-threads">Crear espacio para almacenar los <em>Threads</em></a></h4>
<p>Ahora que tenemos una manera de saber que tenemos un número válido de hilos
para almacenar en el <em>pool</em>, podemos crear esos hilos y almacenarlos en la
estructura <code>ThreadPool</code> antes de devolverlos. Pero, ¿cómo “almacenamos” un
hilo? Echemos otro vistazo a la firma <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>La función <code>spawn</code> devuelve <code>JoinHandle&lt;T&gt;</code>, donde <code>T</code> es el tipo que
devuelve el <em>closure</em>. Tratemos de usar <code>JoinHandle</code> también y veamos qué
pasa. En nuestro caso, los <em>closures</em> que estamos pasando al <em>thread pool</em>
qur manejarán la conexión y no devolverán nada, por lo que <code>T</code> será el tipo
de unidad <code>()</code>.</p>
<p>El código en el listado 20-14 se compilará pero aún no crea <em>threads</em>. Hemos
cambiado la definición de <code>ThreadPool</code> para contener un vector de
instancias <code>thread::JoinHandle&lt;()&gt;</code>, inicializamos el vector con una
capacidad de <code>size</code>, configuramos un bucle <code>for</code> que ejecutará algún código
para crear los hilos, y devolvió una instancia <code>ThreadPool</code> que los contiene.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<p><span class="caption">Listado 20-14: Creando un vector para <code>ThreadPool</code>
para contener los hilos</span></p>
<p>Hemos introducido <code>std::thread</code> en el alcance del <em>library crate</em>, porque
estamos usando <code>thread::JoinHandle</code> como el tipo de elementos en el vector
en <code>ThreadPool</code>.</p>
<p>Una vez que se recibe un tamaño válido, nuestro <code>ThreadPool</code> crea un nuevo
vector que puede contener elementos <code>size</code>. Todavía no hemos utilizado la
función <code>with_capacity</code> en este libro, que realiza la misma tarea que
<code>Vec::new</code> pero con una diferencia importante: asigna espacio previamente en
el vector. Debido a que sabemos que necesitamos almacenar elementos <code>size</code>
en el vector, hacer esta asignación por adelantado es ligeramente más
eficiente que usar <code>Vec::new</code>, que se redimensiona a medida que se insertan
los elementos.</p>
<p>Cuando ejecute <code>cargo check</code> nuevamente, obtendrá algunas advertencias más,
pero debería tener éxito.</p>
<h4 id="una-worker-responsable-de-enviar-el-código-desde-threadpool-a-un-thread"><a class="header" href="#una-worker-responsable-de-enviar-el-código-desde-threadpool-a-un-thread">Una <code>Worker</code> responsable de Enviar el Código desde 'ThreadPool' a un <em>Thread</em></a></h4>
<p>Dejamos un comentario en el bucle <code>for</code> en el Listado 20-14 con respecto a
la creación de <em>threads</em>. Aquí, veremos cómo realmente creamos hilos. La
biblioteca estándar proporciona <code>thread::spawn</code> como una forma de crear
<em>thread</em>, y <code>thread::spawn</code> espera obtener algún código para que el
<em>thread</em> se ejecute tan pronto como se cree el <em>thread</em>. Sin embargo, en
nuestro caso, queremos crear los hilos y hacer que <em>esperen</em> el código que
enviaremos más tarde. La implementación de hilos de la biblioteca estándar
no incluye ninguna forma de hacerlo; tenemos que implementarlo manualmente.</p>
<p>Implementaremos este comportamiento introduciendo una nueva estructura de
datos entre <code>ThreadPool</code> y los hilos que administrarán este nuevo
comportamiento. Llamaremos esta estructura de datos <code>Worker</code>, que es un
término común en las implementaciones de <em>pooling</em>. Piensa en las personas
que trabajan en la cocina de un restaurante: los trabajadores esperan hasta
que los pedidos lleguen de los clientes, y luego son responsables por tomar
esos pedidos y llenarlos.</p>
<p>En lugar de almacenar un vector de instancias <code>JoinHandle&lt;()&gt;</code> en el <em>thread
pool</em>, almacenaremos instancias de la estructura <code>Worker</code>. Cada
<code>Worker</code> almacenará una sola instancia <code>JoinHandle&lt;()&gt;</code>. Luego
implementaremos un método en <code>Worker</code> que tomar un <em>closure</em> de código para
ejecutar y enviarlo al hilo que ya se ejecuta para ejecución. También le
daremos a cada trabajador un <code>id</code> para que podamos distinguir entre
los diferentes trabajadores en el <em>pool</em> al iniciar sesión o depurar.</p>
<p>Hagamos los siguientes cambios a lo que sucede cuando creamos un
<code>ThreadPool</code>. Implementaremos el código que envía el <em>closure</em> al hilo
después de que tengamos <code>Worker</code> configurado de esta manera:</p>
<ol>
<li>Defina una estructura <code>Worker</code> que contenga un <code>id</code> y un <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Cambie <code>ThreadPool</code> para contener un vector de instancias <code>Worker</code>.</li>
<li>Defina una función <code>Worker::new</code> que toma un número <code>id</code> y devuelve una
instancia <code>Worker</code> que contiene el <code>id</code> y un hilo <em>spawned</em> con un
<em>closure</em> vacío.</li>
<li>En <code>ThreadPool::new</code>, use el contador de bucles <code>for</code> para generar un
<code>id</code>, cree un nuevo <code>Worker</code> con ese <code>id</code>, y almacene el <code>Worker</code> en el
vector.</li>
</ol>
<p>Si está preparado para un desafío, intente implementar estos cambios por su
cuenta antes de mirar el código en el Listado 20-15.</p>
<p>¿Listo?. Aquí está el Listado 20-15 con una forma de hacer las modificaciones
precedentes.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-15: Modificación de <code>ThreadPool</code> para
contener instancias <code>Worker</code> en lugar de contener hilos directamente</span></p>
<p>Hemos cambiado el nombre del campo en <code>ThreadPool</code> de<code> threads</code> a <code>workers</code>
porque ahora contiene instancias <code>Worker</code> en lugar de instancias
<code>JoinHandle&lt;()&gt;</code>. Usamos el contador en el bucle <code>for</code> como argumento para
<code>Worker::new</code>, y almacenamos cada <code>Worker</code> nuevo en el vector llamado
<code>workers</code>.</p>
<p>El código externo (como nuestro servidor en <em>src/bin/main.rs</em>) no necesita
conocer los detalles de implementación con respecto al uso de una estructura
<code>Worker</code> dentro de <code>ThreadPool</code>, por lo que hacemos la estructura <code>Worker</code> y
su función privada <code>new</code>. La función <code>Worker::new</code> usa el <code>id</code> que le damos
y almacena una instancia <code>JoinHandle&lt;()&gt;</code> que se crea al generar un nuevo
hilo usando un <em>closure</em> vacío.</p>
<p>Este código compilará y almacenará el número de instancias <code>Worker</code> que
especificamos como argumento para <code>ThreadPool::new</code>. Pero <em>todavía</em> no
estamos procesando el <em>closure</em> que obtenemos en <code>execute</code>. Veamos cómo
hacer eso a continuación.</p>
<h4 id="envío-de-solicitudes-a-hilos-por-canales"><a class="header" href="#envío-de-solicitudes-a-hilos-por-canales">Envío de solicitudes a hilos por canales</a></h4>
<p>Ahora abordaremos el problema de que los <em>closures</em> dados a
<code>thread::spawn</code> no hacen absolutamente nada. Actualmente, obtenemos el
<em>closure</em> que queremos ejecutar en el método <code>execute</code>. Pero tenemos que
darle a <code>thread::spawn</code> un <em>closure</em> para que se ejecute cuando creamos
cada <code>Worker</code> durante la creación de <code>ThreadPool</code>.</p>
<p>Queremos que las estructuras <code>Worker</code> que acabamos de crear busquen código
para ejecutar desde una <em>cola</em> (<em>queue</em>) contenida en <code>ThreadPool</code> y envíen
ese código a su hilo para que se ejecute.</p>
<p>En el Capítulo 16, aprendió sobre <em>canales</em>, una forma sencilla de
comunicarse entre dos hilos, que sería perfecto para este caso de uso.
Usaremos un canal para funcionar como la cola de trabajos, y <code>execute</code>
enviará un trabajo del <code>ThreadPool</code> a las instancias <code>Worker</code>, que enviará
el trabajo a su hilo. Este es el plan:</p>
<ol>
<li>El <code>ThreadPool</code> creará un canal y se mantendrá en el lado de envío del
canal.</li>
<li>Cada <code>Worker</code> se mantendrá en el lado receptor del canal.</li>
<li>Crearemos una nueva estructura <code>Job</code> que contendrá los <em>closures</em> que
queremos enviar al canal.</li>
<li>El método <code>execute</code> enviará el trabajo que quiere ejecutar por el lado de
envío del canal.</li>
<li>En su hilo, el <code>Worker</code> recorrerá su lado de recepción del canal y
ejecutará los <em>closures</em> de cualquier trabajo que reciba.</li>
</ol>
<p>Comencemos creando un canal en <code>ThreadPool::new</code> y manteniendo el lado
emisor en la instancia <code>ThreadPool</code>, como se muestra en el Listado 20-16. La
estructura <code>Job</code> no contiene nada por ahora, pero será el tipo de elemento
que estamos enviando por el canal.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-16: Modificando <code>ThreadPool</code> para almacenar
el final de envío de un canal que envía instancias <code>Job</code></span></p>
<p>En <code>ThreadPool::new</code>, creamos nuestro nuevo canal y hacemos que el <em>pool</em>
contenga el extremo que envía. Esto compilará con éxito, aún con
advertencias.</p>
<p>Intentemos pasar un extremo de recepción del canal a cada <em>worker</em> a medida
que el <em>thread pool</em> crea el canal. Sabemos que queremos utilizar el extremo
receptor en el hilo que crea los <em>workers</em>, por lo que haremos referencia al
parámetro <code>receptor</code> en el <em>closure</em>. El código en el listado 20-17 aún no
se compilará del todo.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-17: Pasar el extremo receptor del canal a
los <em>workers</em></span></p>
<p>Hemos realizado algunos cambios pequeños y directos: pasamos el extremo
receptor del canal a <code>Worker::new</code>, y luego lo usamos dentro del <em>closure</em>.</p>
<p>Cuando tratamos de verificar este código, obtenemos este error:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>El código está tratando de pasar <code>receiver</code> a múltiples instancias
<code>Worker</code>. Esto no funcionará, como recordará en el Capítulo 16: la
implementación del canal que proporciona Rust es múltiple <em>productor</em>, único
<em>consumidor</em>. Esto significa que no podemos simplemente clonar el extremo
consumidor del canal para arreglar este código. Incluso si pudiéramos, esa
no es la técnica que quisiéramos usar; en su lugar, queremos distribuir los
<em>jobs</em> a través de los hilos al compartir el único <code>receiver</code> entre todos
los <em>workers</em>.</p>
<p>Además, quitar un <em>job</em> (<em>trabajo</em>) de la cola del canal implica mutar el
<code>receiver</code>,
por lo que los hilos necesitan una forma segura de compartir y modificar
<code>receiver</code>; de lo contrario, podríamos obtener condiciones de carrera (como
se describe en el Capítulo 16).</p>
<p>Recuerde los <em>thread-safe smart pointers</em> analizados en el Capítulo 16: para
compartir la propiedad entre varios <em>threads</em> y permitir que los <em>threads</em>
muten el valor, necesitamos usar <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. El tipo <code>Arc</code> permitirá
que varios <em>workers</em> posean el receptor, y <code>Mutex</code> garantizará que solo un
<em>worker</em> obtenga un <em>trabajo</em> (<em>job</em>) del receptor a la vez. El listado
20-18 muestra los cambios que debemos hacer.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span>use std::sync::Arc;
use std::sync::Mutex;
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">           receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread,
</span><span class="boring">        }
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-18: Compartir el extremo receptor del canal
entre los <em>workers</em> que usan <code>Arc</code> y <code>Mutex</code></span></p>
<p>En <code>ThreadPool::new</code>, ponemos el extremo receptor del canal en un <code>Arc</code> y un
<code>Mutex</code>. Para cada nuevo <em>worker</em>, clonamos el <code>Arc</code> para aumentar el
recuento de referencias para que los <em>workers</em> puedan compartir la propiedad
del extremo receptor.</p>
<p>Con estos cambios, ¡el código compila! ¡Estamos llegando!</p>
<h4 id="implementando-el-método-execute"><a class="header" href="#implementando-el-método-execute">Implementando el método <code>execute</code></a></h4>
<p>Implementemos finalmente el método <code>execute</code> en <code>ThreadPool</code>. También
cambiaremos <code>Job</code> de una estructura a un alias de tipo para un <em>trait
object</em> que contiene el tipo de <em>closure</em> que recibe <code>execute</code>. Como se
explica en la sección “Creación de sinónimos de tipo con alias de tipo” en
el Capítulo 19, los alias de tipo nos permiten acortar los largos. Mire el
Listado 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --snip--
<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">struct Worker {}
</span>
type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 20-19: Creación de un alias de tipo <code>Job</code>
para una <code>Box</code> que contiene cada <em>closure</em> y luego envía el <em>trabajo</em> (<em>job</em>
al canal</span></p>
<p>Después de crear una nueva instancia <code>Job</code> utilizando el <em>closure</em> que
obtenemos en <code>execute</code>, enviamos ese trabajo al final del canal emisor.
Estamos llamando <code>unwrap</code> on <code>send</code> para el caso de que el envío falle. Esto
podría suceder si, por ejemplo, dejamos de ejecutar todos nuestros
<em>threads</em>, lo que significa que el receptor ha dejado de recibir mensajes
nuevos. Por el momento, no podemos detener la ejecución de nuestros
<em>threads</em>: nuestros <em>threads</em> continúan ejecutándose mientras exista el
<em>pool</em>. La razón por la que usamos <code>unwrap</code> es que sabemos que el caso de
falla no ocurrirá, pero el compilador no lo sabe.</p>
<p>¡Pero aún no hemos terminado! En el <em>worker</em>, nuestro <em>closure</em> pasó a
<code>thread::spawn</code> todavía sólo <em>referencias</em> al extremo receptor del canal. En
su lugar, necesitamos que el <em>closure</em> se repita para siempre, pidiendo al
receptor del canal que realice un trabajo y ejecute el trabajo cuando lo
obtenga. Hagamos el cambio que se muestra en el Listado 20-20 a
<code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-20: Recepción y ejecución de trabajos en el
<em>worker’s thread</em></span></p>
<p>Aquí, primero llamamos a <code>lock</code> en el <code>receiver</code> para adquirir el <em>mutex</em>, y
luego llamamos <code>unwrap</code> al <em>panic</em> sobre cualquier error. La adquisición de
un bloqueo puede fallar si el <em>mutex</em> está en un estado <em>envenenado</em>, lo que
puede ocurrir si otro <em>thread</em> entra en <em>panic</em> mientras se mantiene el
bloqueo en lugar de liberar el bloqueo. En esta situación, llamar a <code>unwrap</code>
para que este <em>thread</em> entre en <em>panic</em> es la acción correcta a tomar.
Siéntase libre de cambiar este <code>unwrap</code> a un <code>expect</code> con un mensaje de
error que sea significativo para usted.</p>
<p>Si obtenemos el bloqueo en el <em>mutex</em>, llamamos a <code>recv</code> para recibir un
<code>Job</code> del canal. Un <code>unwrap</code> final también pasa aquí por los errores, lo que
puede ocurrir si el hilo que contiene el lado emisor del canal se ha apagado
similar a como el método <code>send</code> devuelve <code>Err</code> si el lado receptor se apaga.</p>
<p>La llamada a los bloques <code>recv</code>, por lo que si aún no hay <em>trabajo</em> (<em>job</em>),
el hilo actual esperará hasta que un <em>job</em> esté disponible. El <code>Mutex&lt;T&gt;</code>
asegura que solo un hilo <code>Worker</code> a la vez está tratando de solicitar un
<em>job</em>.</p>
<p>Teóricamente, este código debería compilarse. Desafortunadamente, el
compilador de Rust no es perfecto todavía, y obtenemos este error:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>Este error es bastante críptico porque el problema es bastante críptico.
Para llamar a un <em>closure</em> <code>FnOnce</code> que está almacenado en <code>Box&lt;T&gt;</code>(que es
lo que es nuestro alias de tipo <code>Job</code>), el <em>closure</em> tiene que moverse
<em>fuera</em> del <code>Box&lt;T&gt;</code> porque el <em>closure</em> asume la propiedad del
<code>self</code> cuando lo llamamos. En general, Rust no nos permite mover un valor de
un <code>Box&lt;T&gt;</code> porque Rust no sabe cuán grande será el valor dentro de
<code>Box&lt;T&gt;</code>: recordar en el Capítulo 15 que utilizamos <code>Box&lt;T&gt;</code> precisamente
porque teníamos un tamaño desconocido que queríamos almacenar en un
<code>Box&lt;T&gt;</code> para obtener un valor de un tamaño conocido.</p>
<p>Como vimos en el listado 17-15, podemos escribir métodos que usan la
sintaxis <code>self:Box&lt;Self&gt;</code>, que permite que el método tome posesión de un
valor <code>Self</code> almacenado en <code>Box&lt;T&gt;</code>. Eso es exactamente lo que queremos
hacer aquí, pero desafortunadamente Rust no nos lo permite: la parte de Rust
que implementa el comportamiento cuando se llama a un <em>closure</em> no se
implementa con <code>self:Box&lt;Self&gt;</code>. Así que Rust aún no comprende que podría
usar <code>self:Box&lt;Self&gt;</code> en esta situación para apropiarse del <em>closure</em> y
sacar el <em>closure</em> del <code>Box&lt;T&gt;</code>.</p>
<p>Rust sigue siendo un trabajo en progreso con lugares donde el compilador
podría mejorarse, pero en el futuro, el código en el listado 20-20 debería
funcionar bien. ¡Personas como tú están trabajando para solucionar este y
otros problemas!. Después de que hayas terminado este libro, nos encantaría
que te unas.</p>
<p>Pero, por ahora, vamos a solucionar este problema utilizando un truco útil.
Podemos decirle a Rust explícitamente que en este caso podemos apropiarnos
del valor dentro de <code>Box&lt;T&gt;</code> usando <code>self:Box&lt;Self&gt;</code>; luego, una vez que
tenemos la propiedad del <em>closure</em>, podemos llamarlo. Esto implica definir
un nuevo <em>trait</em> <code>FnBox</code> con el método <code>call_box</code> que usará
<code>self:Box&lt;Self&gt;</code> en su firma, definiendo <code>FnBox</code> para cualquier tipo que
implemente <code>FnOnce()</code>, cambiando nuestro alias de tipo a use el nuevo
<em>trait</em> y cambie <code>Worker</code> para usar el método <code>call_box</code>. Estos cambios se
muestran en el listado 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-21: Agregar un nuevo <em>trait</em> <code>FnBox</code> para
evitar las limitaciones actuales de <code>Box&lt;FnOnce()&gt;</code></span></p>
<p>Primero, creamos un nuevo <em>trait</em> llamado <code>FnBox</code>. Este <em>trait</em> tiene el
método <code>call_box</code>, que es similar a los métodos <code>call</code> en los otros <em>traits</em>
<code>Fn*</code> excepto que toma <code>self:Box&lt;Self&gt;</code> para tomar posesión de <code>self</code> y
mover el valor fuera de <code>Box&lt;T&gt;</code>.</p>
<p>A continuación, implementamos el <em>trait</em> <code>FnBox</code> para cualquier tipo <code>F</code> que
implemente el <em>trait</em> <code>FnOnce()</code>. Efectivamente, esto significa que
cualquier <em>closure</em> <code>FnOnce ()</code> puede usar nuestro método <code>call_box</code>. La
implementación de <code>call_box</code> usa <code>(*self)()</code> para mover el <em>closure</em> fuera
de <code>Box &lt;T&gt;</code> y llamar al <em>closure</em>.</p>
<p>Ahora necesitamos que nuestro alias tipo <code>Job</code> sea un <code>Box</code> de cualquier
cosa que implemente nuestro nuevo <em>trait</em> <code>FnBox</code>. Esto nos permitirá usar
<code>call_box</code> en <code>Worker</code> cuando obtengamos un valor <code>Job</code> en lugar de invocar
el <em>closure</em> directamente. Implementar el <em>trait</em> <code>FnBox</code> para cualquier
<em>closure</em> <code>FnOnce()</code> significa que no tenemos que cambiar nada sobre los
valores reales que estamos enviando al canal. Ahora Rust es capaz de
reconocer que lo que queremos hacer está bien.</p>
<p>Este truco es muy astuto y complicado. No te preocupes si no tiene perfecto
sentido; algún día, será completamente innecesario.</p>
<p>¡Con la implementación de este truco, nuestro <em>thread pool</em> está en buen
estado! Dale un <code>cargo run</code> y haz algunas solicitudes:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>¡Éxito! Ahora tenemos un <em>thread pool</em> que ejecuta las conexiones de forma
asincrónica. Nunca se crean más de cuatro <em>threads</em>, por lo que nuestro
sistema no se sobrecargará si el servidor recibe muchas solicitudes. Si
hacemos una solicitud a <em>/sleep</em>, el servidor podrá atender otras
solicitudes haciendo que otro hilo las ejecute.</p>
<p>Después de aprender sobre el bucle <code>while let</code> en el Capítulo 18, tal vez se
pregunte por qué no escribimos el código del hilo del <em>worker</em> como se
muestra en el Listado 20-22.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-22: una implementación alternativa de
<code>Worker::new</code> using <code>while let</code></span></p>
<p>Este código se compila y ejecuta, pero no da como resultado el
comportamiento de <em>threading</em> deseado: una solicitud lenta aún causará que
otras solicitudes esperen a ser procesadas. La razón es algo sutil: la
estructura <code>Mutex</code> no tiene un método público de <code>unlock</code> porque la
propiedad del <em>lock</em> se basa en el <em>lifetime</em> de <code>MutexGuard&lt;T&gt;</code> dentro de
<code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>  que devuelve el método <code>lock</code>. En el momento de
la compilación, el comprobador de préstamos puede entonces hacer cumplir la
regla de que no se puede acceder a un recurso protegido por un <code>Mutex</code> a
menos que tengamos el <em>lock</em>. Pero esta implementación también puede
provocar que el <em>lock</em> se mantenga más tiempo de lo previsto si no pensamos
detenidamente sobre la duración del <code>MutexGuard&lt;T&gt;</code>. Debido a que los
valores en la expresión <code>while</code> permanecen en el alcance durante la duración
del bloque, el <em>lock</em> permanece retenido durante la duración de la llamada
a <code>job.call_box()</code>, lo que significa que otros <em>workers</em> no pueden recibir
<em>jobs</em>.</p>
<p>Al utilizar <code>loop</code> en su lugar y adquirir el <em>lock</em> y un <em>job</em> dentro del
bloque en lugar de fuera de él, el <code>MutexGuard</code> devuelto por el método
<code>lock</code> se elimina tan pronto como finaliza la instrucción <code>let job</code>. Esto
garantiza que el bloqueo se mantenga durante la llamada a <code>recv</code>, pero se
libera antes de la llamada a <code>job.call_box ()</code>, lo que permite atender
varias solicitudes al mismo tiempo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="elegante-shutdown-y-cleanup"><a class="header" href="#elegante-shutdown-y-cleanup">Elegante <em>Shutdown</em> y <em>Cleanup</em></a></h2>
<p>El código en el listado 20-21 responde a las solicitudes de forma asincrónica
mediante el uso de un <em>thread pool</em>, como pretendíamos. Recibimos algunas
advertencias sobre los campos <code>workers</code>, <code>id</code>, y <code>thread</code> que no estamos
usando de manera directa que nos recuerda que no estamos limpiando nada.
Cuando utilizamos el método menos elegante
<span class="keystroke">ctrl-c</span> para detener el hilo principal, todos
los demás hilos también se detienen inmediatamente, incluso si están en medio
de atender una solicitud.</p>
<p>Ahora implementaremos el <em>trait</em> <code>Drop</code> para llamar <code>join</code> en cada uno de los
<em>threads</em> en el <em>pool</em> para que puedan finalizar las solicitudes en las que
están trabajando antes de cerrar. Luego implementaremos una forma de decirle
a los hilos que deben dejar de aceptar nuevas solicitudes y cerrar. Para ver
este código en acción, modificaremos nuestro servidor para que acepte solo
dos solicitudes antes de cerrar correctamente su <em>thread pool</em>.</p>
<h3 id="implementando-el-trait-drop-en-threadpool"><a class="header" href="#implementando-el-trait-drop-en-threadpool">Implementando el <em>Trait</em> <code>Drop</code> en <code>ThreadPool</code></a></h3>
<p>Comencemos implementando <code>Drop</code> en nuestro <em>thread pool</em>. Cuando se abandona
el <em>pool</em>, nuestros hilos deben unirse para asegurarse de que terminen su
trabajo. El listado 20-23 muestra un primer intento de implementación de un
<code>Drop</code>; este código aún no funcionará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-23: Unirse a cada subproceso cuando el
<em>thread pool</em> se sale del alcance</span></p>
<p>Primero, recorremos cada uno de los <em>thread pool</em> de <code>workers</code>. Usamos
<code>&amp;mut</code> para esto porque <code>self</code> es una referencia mutable, y también
necesitamos poder mutar <code>worker</code>. Para cada <em>worker</em>, imprimimos un mensaje
que dice que este <em>worker</em> en particular se está cerrando, y luego llamamos
<code>join</code> en el hilo de ese <em>worker</em>. Si la llamada a <code>join</code> falla, usamos
<code>unwrap</code> para hacer que Rust se inunde y entrar en un apagado desvergonzado.</p>
<p>Aquí está el error que obtenemos cuando compilamos este código:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>El error nos dice que no podemos llamar <code>join</code> porque solo tenemos un
préstamo mutable de cada <code>worker</code> y <code>join</code> toma posesión de su argumento.
Para resolver este problema, debemos mover el hilo de la instancia <code>Worker</code>
que posee <code>thread</code> para que <code>join</code> pueda consumir el hilo. Hicimos esto en el
Listado 17-15: si <code>Worker</code> tiene una <code>Option&lt;thread::JoinHandle&lt;()&gt;</code> en su
lugar, podemos llamar al método <code>take</code> en <code>Option</code> para mover el valor de la
variante <code>Some</code> y dejar un una variante <code>None</code> en su lugar. En otras palabras
un <code>Worker</code> que se ejecuta tendrá una variante <code>Some</code> en <code>thread</code>, y cuando
queremos limpiar un <code>Worker</code>, reemplazaremos <code>Some</code> por <code>None</code> de modo que el
<code>Worker</code> no tenga un hilo para ejecutar.</p>
<p>Entonces sabemos que queremos actualizar la definición de <code>Worker</code> de esta
manera:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora apoyémonos en el compilador para encontrar los otros lugares que
necesitan cambiar. Al revisar este código, obtenemos dos errores:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>Vamos a abordar el segundo error, que apunta al código al final de
<code>Worker::new</code>; necesitamos envolver el valor <code>thread</code> en <code>Some</code> cuando
creamos un nuevo <code>Worker</code>. Realice los siguientes cambios para corregir este
error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>El primer error está en nuestra implementación <code>Drop</code>. Anteriormente
mencionamos que teníamos la intención de llamar a <code>take</code> en el valor
<code>Option</code> para mover <code>thread</code> de <code>worker</code>. Los siguientes cambios lo harán:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>Como se discutió en el Capítulo 17, el método <code>take</code> en <code>Option</code> saca la
variante <code>Some</code> y deja <code>None</code> en su lugar. Estamos usando <code>if let</code> para
desestructurar el <code>Some</code> y obtener el hilo; entonces llamamos <code>join</code> en el
hilo. Si el hilo de un <em>worker</em> ya es <code>None</code>, sabemos que el <em>worker</em> ya ha
limpiado el hilo, por lo que no ocurre nada en ese caso.</p>
<h3 id="señalización-a-los-threads--para-dejar-de-escuchar-jobs"><a class="header" href="#señalización-a-los-threads--para-dejar-de-escuchar-jobs">Señalización a los <em>Threads</em>  para dejar de escuchar <em>Jobs</em></a></h3>
<p>Con todos los cambios que hemos realizado, nuestro código se compila sin
advertencias. Pero la mala noticia es que este código aún no funciona como
queremos. La clave es la lógica en los <em>closures</em> ejecutados por los hilos de
las instancias <code>Worker</code>: en este momento, llamamos <code>join</code>, pero eso no
cerrará los hilos porque <code>loop</code> siempre buscan <em>jobs</em>. Si intentamos soltar
nuestro <code>ThreadPool</code> con nuestra implementación actual de <code>drop</code>, el hilo
principal se bloqueará para siempre esperando a que termine el primer hilo.</p>
<p>Para solucionar este problema, modificaremos los hilos para que escuchen la
ejecución de <code>Job</code> o una señal de que deben dejar de escuchar y salir del
ciclo infinito. En lugar de instancias <code>Job</code>, nuestro canal enviará una de
estas dos variantes <em>enum</em>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Job;
</span>enum Message {
    NewJob(Job),
    Terminate,
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta enumeración <code>Message</code> será una variante <code>NewJob</code> que contiene el <code>Job</code>
que debe ejecutar el hilo, o será una variante <code>Terminate</code> que hará que el
hilo salga de su ciclo y se detenga.</p>
<p>Necesitamos ajustar el canal para usar valores de tipo <code>Mensaje</code> en lugar de
escribir <code>Job</code>, como se muestra en el Listado 20-24.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-24: Enviar y recibir valores <code>Message</code> y
salir del bucle si un <code>Worker</code> recibe <code>Message::Terminate</code></span></p>
<p>Para incorporar el <em>enum</em> <code>Message</code>, necesitamos cambiar <code>Job</code> a <code>Message</code> en
dos lugares: la definición de <code>ThreadPool</code> y la firma de <code>Worker::new</code>. El
método <code>execute</code> de <code>ThreadPool</code> necesita enviar <em>jobs wrapped</em> envueltos en
la variante <code>Message::NewJob</code>. Luego, en <code>Worker::new</code> donde se recibe un
<code>Message</code> desde el canal, el trabajo será procesado si se recibe la variante
<code>NewJob</code>, y el hilo se saldrá del ciclo si la variante <code>Terminate</code> es
recibida.</p>
<p>Con estos cambios, el código se compilará y continuará funcionando de la
misma forma que lo hizo después del Listado 20-21. Pero recibiremos una
advertencia porque no estamos creando ningún mensaje de la variedad
<code>Terminate</code>. Arreglemos esta advertencia cambiando nuestra implementación
<code>Drop</code> para que se vea como el Listado 20-25.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listado 20-25: Enviar <code>Message::Terminate</code> a los
<em>workers</em> antes de llamar <code>join</code> en cada hilo de <em>worker</em></span></p>
<p>Ahora estamos iterando sobre los <em>workers</em> dos veces: una para enviar un
mansaje <code>Terminate</code> para cada <em>worker</em> y una vez para llamar <code>join</code> en el
hilo de cada <em>worker</em>. Si nosotros intentado enviar un mensaje y
<code>join</code> inmediatamente en el mismo ciclo, no pudimos
garantizar que el <em>worker</em> en la iteración actual sea el que obtenga el
mensaje del canal</p>
<p>Para comprender mejor por qué necesitamos dos bucles separados, imagine un
escenario con dos <em>workers</em>, si usamos un solo ciclo para iterar a través de
cada <em>worker</em>, en la primera iteración, un mensaje de finalización se enviará
por el canal y el <code>join</code> llamado en el hilo del primer <em>worker</em>. Si ese
primer <em>worker</em> estaba ocupado procesando una solicitud en ese momento, el
segundo <em>worker</em> tomaría el mensaje de terminación del canal y se apagaría.
Nos quedaríamos esperando que el primer <em>worker</em> cerrara, pero nunca lo haría
porque el segundo hilo recogió el mensaje de terminación. ¡Punto muerto!</p>
<p>Para evitar este escenario, primero colocamos todos nuestros mensajes
<code>Terminate</code> en el canal en un bucle; luego unimos todos los hilos en otro
ciclo. Cada <em>worker</em> dejará de recibir solicitudes en el canal una vez que
reciba un mensaje de terminación. Por lo tanto, podemos estar seguros de que
si enviamos la misma cantidad de mensajes de terminación porque hay <em>workers</em>
cada <em>worker</em> recibirá un mensaje de terminación antes de que se llame a
<code>join</code> en su hilo.</p>
<p>Para ver este código en acción, modifiquemos <code>main</code> para aceptar solo dos
solicitudes antes de cerrar con gracia el servidor, como se muestra en el
Listado 20-26.</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<p><span class="caption">Listado 20-26: Apague el servidor después de atender
dos solicitudes saliendo del ciclo</span></p>
<p>No querrías que un servidor web del mundo real se apagara después de servir
solo dos solicitudes. Este código solo demuestra que el cierre y la limpieza
elegantes funcionan correctamente.</p>
<p>El método <code>take</code> se define en el <em>trait</em> <code>Iterator</code> y limita la iteración a
los dos primeros elementos como máximo. El <code>ThreadPool</code> saldrá del alcance a
final de <code>main</code>, y se ejecutará la implementación <code>drop</code>.</p>
<p>Inicie el servidor con <code>cargo run</code>, y realice tres solicitudes. La tercera
solicitud debería generar un error, y en su terminal debería ver un resultado
similar al siguiente:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Es posible que vea un pedido diferente de <em>workers</em> y mensajes impresos.
Podemos ver cómo funciona este código a partir de los mensajes: los
<em>workers</em> 0 y 3 obtuvieron las dos primeras solicitudes y luego, en la
tercera solicitud, el servidor dejó de aceptar las conexiones. Cuando e
<code>ThreadPool</code> sale del ámbito de aplicación al final de <code>main</code>, su
implementación <code>Drop</code> entra en acción y el <em>pool</em> ordena a todos los
<em>workers</em> que finalicen. Cada uno de los <em>workers</em> imprime un mensaje cuando
ven el mensaje de terminación, y luego el <em>thread pool</em> llama a <code>join</code> para
cerrar cada <em>worker thread</em>.</p>
<p>Observe un aspecto interesante de esta ejecución en particular: el
<code>ThreadPool</code> envió los mensajes de terminación al canal, y antes de que
cualquier <em>worker</em> recibiera los mensajes, intentamos unirnos al <em>worker</em> 0.
El <em>worker</em> 0 aún no había recibido el mensaje de terminación, por lo que el
hilo principal bloqueado esperando que el <em>worker</em> 0 termine. Mientras tanto,
cada uno de los workers recibió los mensajes de terminación. Cuando el
<em>worker</em> 0 finalizó, el hilo principal esperó a que el resto de los workers
terminara. En ese momento, todos habían recibido el mensaje de terminación y
pudieron cerrar.</p>
<p>¡Felicidades! Ya hemos completado nuestro proyecto; tenemos un servidor web
básico que usa un <em>thread pool</em> para responder de forma asincrónica. Podemos
realizar un cierre elegante del servidor, que limpia todos los hilos del
<em>pool</em>.</p>
<p>Aquí está el código completo para referencia:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>¡Podríamos hacer más aquí! Si desea continuar mejorando este proyecto, aquí
hay algunas ideas:</p>
<ul>
<li>Agregue más documentación a <code>ThreadPool</code> y sus métodos públicos.</li>
<li>Agregar pruebas de la funcionalidad de la biblioteca.</li>
<li>Cambie las llamadas a <code>unwrap</code> para un manejo de errores más robusto.</li>
<li>Use <code>ThreadPool</code> para realizar alguna tarea que no sea servir solicitudes
web.</li>
<li>Encuentra un <em>crate</em> de <em>thread pool</em> en <em>https://crates.io/</em> e implemente
un servidor web similar utilizando el <em>crate</em> en su lugar. Luego, compare su
API y su robustez con el <em>thread pool</em> que implementamos.</li>
</ul>
<h2 id="resumen-18"><a class="header" href="#resumen-18">Resumen</a></h2>
<p>¡Bien hecho! ¡Has llegado al final del libro! Queremos agradecerle por
unirse a nosotros en esta gira de Rust. Ahora está listo para implementar sus
propios proyectos de Rust y ayudar con los proyectos de otras personas. Tenga
en cuenta que hay una comunidad acogedora de otros <em>Rustaceans</em>
que les encantaría ayudarlo con cualquier desafío que encuentre en su viaje en
Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apéndice"><a class="header" href="#apéndice">Apéndice</a></h1>
<p>Las siguientes secciones contienen material de referencia
que puede serle útil en su viaje a Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-a-palabras-clave"><a class="header" href="#apéndice-a-palabras-clave">Apéndice A: Palabras clave</a></h2>
<p>La siguiente lista contiene palabras clave que están reservadas para uso
actual o futuro por el idioma Rust. Como tales, no se pueden usar como
identificadores, como nombres de funciones, variables, parámetros, campos de estructura, módulos, <em>crates</em>, constantes, macros, valores estáticos
atributos, tipos, <em>traits</em> o <em>lifetimes</em>.</p>
<h3 id="palabras-clave-actualmente-en-uso"><a class="header" href="#palabras-clave-actualmente-en-uso">Palabras clave actualmente en uso</a></h3>
<p>Las siguientes palabras clave actualmente tienen la funcionalidad descrita.</p>
<ul>
<li><code>as</code> - realiza una conversión primitiva, elimina la ambigüedad del <em>trait</em>
específico que contiene
un elemento, o cambiar el nombre de los elementos en las declaraciones <code>use</code> y <code>extern crate</code></li>
<li><code>break</code> - salir de un bucle inmediatamente</li>
<li><code>const</code> - define elementos constantes o <em>raw pointers</em> constantes</li>
<li><code>continue</code> - continúa a la siguiente iteración de bucle</li>
<li><code>cajón</code> - enlaza un <em>crate</em> externa o una variable macro que representa el
<em>crate</em> en
que la macro está definida</li>
<li><code>else</code> - repliegue para construcciones de flujo de control <code>if</code> y <code>if let</code></li>
<li><code>enum</code> - define una enumeración</li>
<li><code>extern</code>: vincula un <em>crate</em>, función o variable externa</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - define una función o el tipo de puntero a función</li>
<li><code>for</code> - itera sobre elementos de un iterador, implementa un <em>trait</em> o
especifica un
<em>higher-ranked lifetime</em></li>
<li><code>if</code> - bifurcación basada en el resultado de una expresión condicional</li>
<li><code>impl</code> - implementar funcionalidad inherente o de <em>trait</em></li>
<li><code>in</code> - parte de la sintaxis de bucle <code>for</code></li>
<li><code>let</code> - enlazar una variable</li>
<li><code>loop</code> - loop incondicionalmente</li>
<li><code>match</code> - relaciona un valor con los patrones</li>
<li><code>mod</code> - define un módulo</li>
<li><code>move</code> - hacer un <em>closure</em> tomar posesión de todas sus capturas</li>
<li><code>mut</code> - denota mutabilidad en referencias, <em>raw pointers</em> o enlaces de
patrones</li>
<li><code>pub</code> - denotan visibilidad pública en campos struct, bloques <code>impl</code> o
módulos</li>
<li><code>ref</code> - enlazar por referencia</li>
<li><code>return</code> - regreso de la función</li>
<li><code>Self</code> - un alias tipo para el tipo que implementa un <em>trait</em></li>
<li><code>self</code> - tema del método o módulo actual</li>
<li><code>static</code> - variable global o <em>lifetime</em> que dura toda la ejecución del
programa</li>
<li><code>struct</code> - define una estructura</li>
<li><code>super</code> - módulo principal del módulo actual</li>
<li><code>trait</code> - define un <em>trait</em></li>
<li><code>true</code> - Boolean verdadero literal</li>
<li><code>type</code> - define un tipo de alias o tipo asociado</li>
<li><code>unsafe</code> - denota código inseguro, funciones, <em>traits</em> o implementaciones</li>
<li><code>use</code> - importar símbolos en el alcance</li>
<li><code>where</code> - denote cláusulas que restringen un tipo</li>
<li><code>while</code> - loop condicionalmente basado en el resultado de una expresión</li>
</ul>
<h3 id="palabras-clave-reservadas-para-uso-futuro"><a class="header" href="#palabras-clave-reservadas-para-uso-futuro">Palabras clave reservadas para uso futuro</a></h3>
<p>Las siguientes palabras clave no tienen ninguna funcionalidad, pero están
reservadas por Rust para un posible uso futuro.</p>
<ul>
<li><code>abstract</code></li>
<li><code>alignof</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>offsetof</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>proc</code></li>
<li><code>pure</code></li>
<li><code>sizeof</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-b-operadores-y-símbolos"><a class="header" href="#apéndice-b-operadores-y-símbolos">Apéndice B: Operadores y Símbolos</a></h2>
<p>Este apéndice contiene un glosario de la sintaxis de Rust, que incluye
operadores y otros símbolos que aparecen solos o en el contexto de rutas,
genéricos, <em>trait bounds</em>, macros, atributos, comentarios, tuplas y
<em>brackets</em>.</p>
<h3 id="operadores"><a class="header" href="#operadores">Operadores</a></h3>
<p>La Tabla B-1 contiene los operadores en Rust, un ejemplo de cómo el operador
aparecería en contexto, una breve explicación y si ese operador es
sobrecargable. Si un operador es sobrecargable, el <em>trait</em> relevante para
usar para sobrecargar ese operador está en la lista.</p>
<p><span class="caption">Tabla B-1: Operadores</span></p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Example</th><th>Explanation</th><th>Overloadable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro expansion</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitwise or logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Nonequality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Borrow</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Borrowed pointer type</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitwise AND and assignment</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Logical AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Dereference</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Raw pointer</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Compound type constraint</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument and element separator</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Function and closure return type</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Member access</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Right-exclusive range literal</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Struct literal update syntax</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>“And the rest” pattern binding</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>In a pattern: inclusive range pattern</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Constraints</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Struct field initializer</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Loop label</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Statement and item terminator</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Part of fixed-size array syntax</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Left-shift</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Left-shift and assignment</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignment/equivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Part of match arm syntax</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Right-shift</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Right-shift and assignment</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitwise exclusive OR and assignment</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Pattern alternatives</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitwise OR and assignment</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Logical OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Error propagation</td><td></td></tr>
</tbody></table>
</div>
<h3 id="símbolos-sin-operador"><a class="header" href="#símbolos-sin-operador">Símbolos sin operador</a></h3>
<p>La siguiente lista contiene todas las letras que no funcionan como operadores
es decir, no se comportan como una llamada a función o método.</p>
<p>La Tabla B-2 muestra símbolos que aparecen por sí mismos y son válidos en una
variedad de ubicaciones.</p>
<p><span class="caption">Table B-2: Stand-Alone Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Named lifetime or loop label</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Numeric literal of specific type</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>String literal</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Raw string literal, escape characters not processed</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Byte string literal; constructs a <code>[u8]</code> instead of a string</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Raw byte string literal, combination of raw and byte string literal</td></tr>
<tr><td><code>'...'</code></td><td>Character literal</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII byte literal</td></tr>
<tr><td><code>|...| expr</code></td><td>Closure</td></tr>
<tr><td><code>!</code></td><td>Always empty bottom type for diverging functions</td></tr>
<tr><td><code>_</code></td><td>“Ignored” pattern binding; also used to make integer literals readable</td></tr>
</tbody></table>
</div>
<p>La Tabla B-3 muestra símbolos que aparecen en el contexto de una ruta a
través de la jerarquía del módulo a un elemento.</p>
<p><span class="caption">Table B-3: Path-Related Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the crate root (i.e., an explicitly absolute path)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path).</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it’s defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
</div>
<p>La Tabla B-4 muestra símbolos que aparecen en el contexto del uso de
parámetros de tipo genérico.</p>
<p><span class="caption">Table B-4: Generics</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Specifies parameters to generic type in a type (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define generic function</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define generic structure</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define generic enumeration</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define generic implementation</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Higher-ranked lifetime bounds</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>A generic type where one or more associated types have specific assignments (e.g., <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>La Tabla B-5 muestra símbolos que aparecen en el contexto de restringir los
parámetros de tipo genérico con <em>trait bounds</em>.</p>
<p><span class="caption">Table B-5: Trait Bound Constraints</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Generic parameter <code>T</code> constrained to types that implement <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Generic type <code>T</code> must outlive lifetime <code>'a</code> (meaning the type cannot transitively contain any references with lifetimes shorter than <code>'a</code>)</td></tr>
<tr><td><code>T : 'static</code></td><td>Generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones</td></tr>
<tr><td><code>'b: 'a</code></td><td>Generic lifetime <code>'b</code> must outlive lifetime <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Allow generic type parameter to be a dynamically sized type</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Compound type constraint</td></tr>
</tbody></table>
</div>
<p>La Tabla B-6 muestra símbolos que aparecen en el contexto de llamar o definir
macros y especificar atributos en un elemento.</p>
<p><span class="caption">Table B-6: Macros and Attributes</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Outer attribute</td></tr>
<tr><td><code>#![meta]</code></td><td>Inner attribute</td></tr>
<tr><td><code>$ident</code></td><td>Macro substitution</td></tr>
<tr><td><code>$ident:kind</code></td><td>Macro capture</td></tr>
<tr><td><code>$(…)…</code></td><td>Macro repetition</td></tr>
</tbody></table>
</div>
<p>La Tabla B-7 muestra símbolos que crean comentarios.</p>
<p><span class="caption">Table B-7: Comments</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment</td></tr>
<tr><td><code>//!</code></td><td>Inner line doc comment</td></tr>
<tr><td><code>///</code></td><td>Outer line doc comment</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment</td></tr>
<tr><td><code>/*!...*/</code></td><td>Inner block doc comment</td></tr>
<tr><td><code>/**...*/</code></td><td>Outer block doc comment</td></tr>
</tbody></table>
</div>
<p>La Tabla B-8 muestra símbolos que aparecen en el contexto del uso de tuplas.</p>
<p><span class="caption">Table B-8: Tuples</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Empty tuple (aka unit), both literal and type</td></tr>
<tr><td><code>(expr)</code></td><td>Parenthesized expression</td></tr>
<tr><td><code>(expr,)</code></td><td>Single-element tuple expression</td></tr>
<tr><td><code>(type,)</code></td><td>Single-element tuple type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tuple expression</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tuple type</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro invocation</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Tuple indexing</td></tr>
</tbody></table>
</div>
<p>La Tabla B-9 muestra los contextos en los que se usan llaves.</p>
<p><span class="caption">Table B-9: Curly Brackets</span></p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Block expression</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
</div>
<p>La Tabla B-10 muestra los contextos en los que se usan corchetes.</p>
<p><span class="caption">Table B-10: Square Brackets</span></p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Array literal</td></tr>
<tr><td><code>[expr; len]</code></td><td>Array literal containing <code>len</code> copies of <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Array type containing <code>len</code> instances of <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> as the “index”</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-c-trait-derivables"><a class="header" href="#apéndice-c-trait-derivables">Apéndice C: <em>Trait</em> derivables</a></h2>
<p>En varios lugares del libro, hemos discutido el atributo <code>derive</code>, que
puedes aplicar a una definición <em>struct</em> o <em>enum</em>. El atributo <code>derive</code> genera
código que implementará un <em>trait</em> con su propia implementación en el tipo
que ha anotado con la sintaxis <code>derive</code>.</p>
<p>En este apéndice, proporcionamos una referencia de todos los <em>traits</em> en la
biblioteca estándar que puede usar con <code>derivar</code>. Cada sección cubre:</p>
<ul>
<li>Qué operadores y métodos que derivan este <em>trait</em> permitirán</li>
<li>Lo que hace la implementación del <em>trait</em> proporcionado por <code>derive</code></li>
<li>Qué significa implementar el <em>trait</em> sobre el tipo</li>
<li>Las condiciones en las que se le permite o no se le permite implementar el
<em>trait</em></li>
<li>Ejemplos de operaciones que requieren el <em>trait</em></li>
</ul>
<p>Si desea un comportamiento diferente al proporcionado por el atributo
<code>derive</code>, consulte la documentación de la biblioteca estándar para cada
<em>trait</em> para obtener detalles sobre cómo implementarlos manualmente.</p>
<p>El resto de los <em>traits</em> definidos en la biblioteca estándar no se pueden
implementar en tus tipos usando <code>derivar</code>. Estos <em>traits</em> no tienen un
comportamiento predeterminado sensible, por lo tanto, depende de usted
implementarlos de la manera que tenga sentido para lo que está tratando de
lograr.</p>
<p>Un ejemplo de un <em>trait</em> que no se puede derivar es <code>Display</code>, que maneja
formateo para usuarios finales. Siempre debe considerar la forma adecuada de
mostrar un tipo a un usuario final. ¿Qué partes del tipo debería permitir que
un usuario final vea? ¿Qué partes encontrarían relevantes?. ¿Qué formato de
los datos sería más relevante para ellos? El compilador Rust no tiene esta
información, por lo que no puede proporcionar el comportamiento
predeterminado adecuado para usted.</p>
<p>La lista de <em>traits</em> derivables proporcionada en este apéndice no es
exhaustiva:
las bibliotecas pueden implementar <code>derivar</code> para sus propios <em>traits</em>,
haciendo que la lista de <em>traits</em> que puede utilizar <code>derivar</code> con
verdaderamente abiertos. Implementando <code>derivar</code> implica el uso de una macro
de procedimiento, que se trata en el Apéndice D.</p>
<h3 id="debug-para-la-salida-del-programador"><a class="header" href="#debug-para-la-salida-del-programador"><code>Debug</code> para la salida del programador</a></h3>
<p>El <em>trait</em> <code>Debug</code> habilita el formateo de depuración en los <em>strings</em> de
formato, que usted indica al agregar <code>:?</code> dentro de los placeholders con
<code>{}</code>.</p>
<p>El <em>trait</em> <code>Debug</code> le permite imprimir instancias de un tipo con fines de
depuración, para que usted y otros programadores que usen su tipo puedan
inspeccionar una instancia en un punto particular de la ejecución de un
programa.</p>
<p>El <em>trait</em> <code>Debug</code> es requerido, por ejemplo, en el uso de la macro
<code>assert_eq!</code>. Esta macro imprime los valores de las instancias dadas como
argumentos si falla la aserción de igualdad para que los programadores puedan
ver por qué las dos instancias no fueron iguales.</p>
<h3 id="partialeq-y-eq-para-comparaciones-de-igualdad"><a class="header" href="#partialeq-y-eq-para-comparaciones-de-igualdad"><code>PartialEq</code> y <code>Eq</code> para comparaciones de igualdad</a></h3>
<p>El <em>trait</em> <code>PartialEq</code> le permite comparar instancias de un tipo para
verificar la igualdad y permite el uso de los operadores <code>==</code> y <code>! = </code>.</p>
<p>Derivar <code>PartialEq</code> implementa el método <code>eq</code>. Cuando <code>PartialEq</code> se deriva
en structs, dos instancias son iguales solo si los campos <em>all</em> son iguales,
y las instancias no son iguales si los campos no son iguales. Cuando se
deriva en <em>enums</em>, cada variante es igual a sí misma y no igual a las otras
variantes.</p>
<p>El <em>trait</em> <code>PartialEq</code> es requerido, por ejemplo, con el uso de la macro
<code>assert_eq!</code>, que necesita poder comparar dos instancias de un tipo para la
igualdad.</p>
<p>El <em>trait</em> <code>Eq</code> no tiene métodos. Su propósito es señalar que para cada valor
del tipo anotado, el valor es igual a sí mismo. El <em>trait</em> <code>Eq</code> solo se puede
aplicar a los tipos que también implementan <code>PartialEq</code>, aunque no todos los
tipos que implementan <code>PartialEq</code> pueden implementar <code>Eq</code>. Un ejemplo de esto
son los tipos de números de coma flotante: la implementación de números de
coma flotante establece que dos instancias del valor <em>not-a-number</em> (<code>NaN</code>) no
son iguales entre sí.</p>
<p>Un ejemplo de cuando se requiere <code>Eq</code> es para las teclas en <code>HashMap&lt;K, V&gt;</code>,
por lo que <code>HashMap&lt;K, V&gt;</code> puede indicar si dos teclas son iguales.</p>
<h3 id="partialord-y-ord-para-hacer-comparaciones-de-pedidos"><a class="header" href="#partialord-y-ord-para-hacer-comparaciones-de-pedidos"><code>PartialOrd</code> y <code>Ord</code> para hacer comparaciones de pedidos</a></h3>
<p>El <em>trait</em> <code>PartialOrd</code> le permite comparar instancias de un tipo para
clasificar propósitos. Un tipo que implementa <code>PartialOrd</code> se puede usar con
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, y <code>&gt;=</code> operadores. Solo puede aplicar el <em>trait</em> <code>PartialOrd</code>
a los tipos que también implementan <code>PartialEq</code>.</p>
<p>Derivar <code>PartialOrd</code> implementa el método <code>partial_cmp</code>, que devuelve un
<code>Option&lt;Ordering&gt;</code> que será <code>None</code> cuando los valores dados no producen un
orden. Un ejemplo de un valor que no produce un orden, aunque la mayoría de
los valores de ese tipo se pueden comparar, es el valor de punto flotante
<em>not-a-number</em> (<code>NaN</code>). Llamar <code>partial_cmp</code> con cualquier número de punto
flotante y el valor de punto flotante <code>NaN</code> devolverá <code>None</code>.</p>
<p>Cuando se deriva en estructuras, <code>PartialOrd</code> compara dos instancias al
comparar el valor en cada campo en el orden en que los campos aparecen en la
estructura definición. Cuando se deriva en <em>enums</em>, variantes de la
enumeración declarada anteriormente en la definición de <em>enum</em> se considera
menor que las variantes enumeradas más adelante.</p>
<p>El <em>trait</em> <code>PartialOrd</code> es obligatorio, por ejemplo, para el método
<code>gen_range</code> desde el <em>crate</em> <code>rand</code> que genera un valor aleatorio en el rango
especificado por un valor bajo y un valor alto .</p>
<p>El <em>trait</em> <code>Ord</code> le permite saber que para cualquier dos valores del tipo
anotado, existirá un pedido válido. El <em>trait</em> <code>Ord</code> implementa el método
<code>cmp</code>, que devuelve <code>Ordering</code> en lugar de <code>Option&lt;Ordering&gt;</code> porque siempre
será posible realizar un pedido válido. Solo puede aplicar el <em>trait</em> <code>Ord</code> a
los tipos que también implementan <code>PartialOrd</code> y <code>Eq</code> (y <code>Eq</code> requiere
<code>PartialEq</code>). Cuando se deriva en estructuras y <em>enums</em>, <code>cmp</code> se comporta de
la misma manera que la implementación derivada para <code>partial_cmp</code> con
<code>PartialOrd</code>.</p>
<p>Un ejemplo de cuando se requiere <code>Ord</code> es cuando se almacenan valores en un
<code>BTreeSet&lt;T&gt;</code>, una estructura de datos que almacena datos según el orden de
clasificación de los valores.</p>
<h3 id="clone-y-copy-para-duplicar-valores"><a class="header" href="#clone-y-copy-para-duplicar-valores"><code>Clone</code> y <code>Copy</code> para duplicar valores</a></h3>
<p>El <em>trait</em> <code>Clonar</code> le permite crear explícitamente una copia profunda de un
valor, y el proceso de duplicación puede implicar ejecutar código arbitrario
y copiar montículo de datos. Consulte la sección “Ways Variables and Data
Interact: Clone” en el Capítulo 4 para más información sobre <code>Clone</code>.</p>
<p>Derivar <code>Clone</code> implementa el método <code>clon</code>, que cuando se implementa para el
tipo completo, llama <code>clon</code> a cada una de las partes del tipo. Esto significa
que todos los campos o valores en el tipo también deben implementar <code>Clone</code>
para derivar <code>Clone</code>.</p>
<p>Un ejemplo de cuando se requiere <code>Clone</code> es cuando se llama al método
<code>to_vec</code> en un <em>slice</em>. El sector no posee las instancias de tipo que
contiene, pero el vector devuelto desde <code>to_vec</code> necesitará poseer sus
instancias, por lo que las llamadas <code>to_vec</code> <code>clon</code> en cada elemento. Por lo
tanto, el tipo almacenado en la división debe implementar <code>Clone</code>.</p>
<p>El <em>trait</em> <code>Copy</code> le permite duplicar un valor copiando solo los bits
almacenados en la pila; no es necesario ningún código arbitrario. Consulte la
sección “Stack-Only Data: Copy” en el Capítulo 4 para obtener más
información sobre <code>Copy</code>.</p>
<p>El <em>trait</em> <code>Copy</code> no define ningún método para evitar que los programadores
sobrecarguen esos métodos y violando la suposición de que no se está
ejecutando ningún código arbitrario. De esta forma, todos los programadores
pueden asumir que copiar un valor será muy rápido.</p>
<p>Puede derivar <code>Copy</code> en cualquier tipo cuyas partes implementen <code>Copy</code>. Solo
puede aplicar el <em>trait</em> <code>Copy</code> a los tipos que también implementan <code>Clon</code>,
porque un tipo que implementa <code>Copy</code> tiene una implementación trivial de
<code>Clon</code> que realiza la misma tarea que <code>Copy</code>.</p>
<p>El <em>trait</em> <code>Copy</code> rara vez se requiere; los tipos que implementan <code>Copy</code>
tienen optimizaciones disponibles, lo que significa que no tiene que llamar
<code>clone</code>, lo que hace que el código sea más conciso.</p>
<p>Todo lo que se puede hacer con <code>Copy</code> también se puede lograr con <code>Clone</code>,
pero el código puede ser más lento o tener que usar <code>clone</code> en algunos
lugares.</p>
<h3 id="hash-para-asignar-un-valor-a-un-valor-de-tamaño-fijo"><a class="header" href="#hash-para-asignar-un-valor-a-un-valor-de-tamaño-fijo"><code>Hash</code> para asignar un valor a un valor de tamaño fijo</a></h3>
<p>El <em>trait</em> <code>Hash</code> le permite tomar una instancia de un tipo de tamaño
arbitrario y asignar esa instancia a un valor de tamaño fijo usando una
función hash. Derivar <code>Hash</code> implementa el método <code>hash</code>. La implementación
derivada del método <code>hash</code> combina el resultado de invocar <code>hash</code> en cada una
de las partes del tipo, lo que significa que todos los campos o valores
también deben implementar <code>Hash</code> para derivar <code>Hash</code>.</p>
<p>Un ejemplo de cuándo se requiere <code>Hash</code> es almacenar las claves en
<code>HashMap&lt;K, V&gt;</code>para almacenar datos de manera eficiente.</p>
<h3 id="default-para-valores-predeterminados"><a class="header" href="#default-para-valores-predeterminados"><code>Default</code> para valores predeterminados</a></h3>
<p>El <em>trait</em> <code>Default</code> le permite crear un valor predeterminado para un tipo.
Derivar <code>Default</code> implementa la función <code>default</code>. La implementación derivada
de la función <code>default</code> llama a la función <code>default</code> en cada parte del tipo,
lo que significa que todos los campos o valores del tipo también deben
implementar <code>Default</code> para derivar <code>Default</code>.</p>
<p>La función <code>Default::default</code> se usa comúnmente en combinación con la
sintaxis de actualización struct discutida en la sección “Crear instancias de
otras instancias con <em>Struct Update Syntax</em>” en el Capítulo 5. Puede
personalizar algunos campos de una estructura y luego configurar y use un
valor predeterminado para el resto de los campos usando
<code>..Default::default()</code>.</p>
<p>El <em>trait</em> <code>Default</code> es obligatorio cuando utiliza el método
<code>unwrap_or_default</code> en instancias <code>Option&lt;T&gt;</code>, por ejemplo. Si la
<code>Opción &lt;T&gt;</code> es <code>None</code>, el método <code>unwrap_or_default</code> devolverá el resultado
de <code>Default::default</code> para el tipo <code>T</code> almacenado en <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-d---herramientas-Útiles-de-desarrollo"><a class="header" href="#apéndice-d---herramientas-Útiles-de-desarrollo">Apéndice D - Herramientas Útiles de Desarrollo</a></h2>
<p>En este apéndice, hablamos de algunas herramientas de desarrollo útiles que el proyecto Rust proporciona. Veremos el formato automático, formas rápidas de aplicar correcciones de  advertencia, un linter e integración con IDEs. </p>
<h3 id="formateo-automático-con-rustfmt"><a class="header" href="#formateo-automático-con-rustfmt">Formateo Automático con <em>rustfmt</em></a></h3>
<p>La herramienta <code>rustfmt</code> reformatea su código de acuerdo con el estilo de código de la comunidad. Muchos proyectos colaborativos usan <code>rustfmt</code> para evitar discusiones sobre qué estilo usar al escribir Rust: todos formatean su código usando la herramienta.</p>
<p>Para instalar <code>rustfmt</code> ingrese lo siguiente:</p>
<pre><code class="language-text">$ rustup component add rustfmt
</code></pre>
<p>Este comando le proporciona <code>rustfmt</code> y <code>cargo-fmt</code>, similar a como Rust te da tanto <code>rustc</code> como <code>cargo</code>. Para dar formato a cualquier proyecto Cargo, ingrese lo siguiente:</p>
<pre><code class="language-text">$ cargo fmt
</code></pre>
<p>Ejecutar este comando reformatea todo el código de Rust en el <em>crate</em> actual. Esto solo debería cambiar el estilo del código, no la semántica del código. Para obtener más información sobre <code>rustfmt</code>, consulte <a href="https://github.com/rust-lang/rustfmt">su documentación</a>.</p>
<h3 id="corrija-tu-código-con-rustfix"><a class="header" href="#corrija-tu-código-con-rustfix">Corrija tu código con rustfix</a></h3>
<p>La herramienta <em>rustfix</em> se incluye con las instalaciones de Rust y puede corregir automáticamente las advertencias del compilador que tienen una forma clara de corregir el problema que probablemente sea lo que desea. Es probable que haya visto advertencias del compilador antes. Por ejemplo, considere este código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Aquí llamamos a la función <code>do_something</code> 100 veces, pero nunca usamos la variable <code>i</code> en el cuerpo del bucle <code>for</code>. Rust nos advierte sobre eso:</p>
<pre><code class="language-text">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>La advertencia sugiere que usemos <code>_i</code> en su lugar: el guión bajo indica que tenemos la intención de que esta variable no se use. Podemos aplicar automáticamente esa sugerencia usando la herramienta <code>rustfix</code> ejecutando el comando <code>cargo fix</code>:</p>
<pre><code class="language-text">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Cuando volvamos a mirar <em>src/main.rs</em>, veremos que <code>cargo fix</code> ha cambiado el código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>La variable de bucle <code>for</code> ahora se llama <code>_i</code> y ya no aparece la advertencia.</p>
<p>También puede usar el comando <code>cargo fix</code> para hacer la transición de su código entre diferentes ediciones de Rust. Las ediciones están cubiertas en el Apéndice E.</p>
<h3 id="más-lints-con-clippy"><a class="header" href="#más-lints-con-clippy">Más Lints con Clippy</a></h3>
<p>La herramienta Clippy es una colección de lints para analizar su código, poder detectar errores comunes y mejorar su código Rust.</p>
<p>Para instalar Clippy, ingrese lo siguiente:</p>
<pre><code class="language-text">$ rustup component add clippy
</code></pre>
<p>Para ejecutar los lints de Clippy en cualquier proyecto de Cargo, ingrese lo siguiente:</p>
<pre><code class="language-text">$ cargo clippy
</code></pre>
<p>Por ejemplo, supongamos que escribe un programa que usa una aproximación de una constante matemática, como <em>pi</em>, como lo hace este programa:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Ejecutar <code>cargo clippy</code> en este proyecto da como resultado este error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Este error le permite saber que Rust ya tiene definida una constante <code>PI</code> más precisa, y que su programa sería más correcto si usara la constante en su lugar. Usted cambiaría entonces su código para usar la constante <code>PI</code>. El siguiente código no genera ningún error o advertencia de Clippy:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Para más información sobre Clippy, vea <a href="https://github.com/rust-lang/rust-clippy">esta documentación</a>.</p>
<h3 id="integración-ide-usando-rust-analyzer"><a class="header" href="#integración-ide-usando-rust-analyzer">Integración IDE usando <em>rust-analyzer</em></a></h3>
<p>Para ayudar a la integración de IDE, la comunidad de Rust recomienda usar <a href="https://rust-analyzer.github.io/"><code>rust-analyzer</code></a>. Esta herramienta es un conjunto de utilidades centradas en compiladores que habla el <a href="https://langserver.org/">Protocolo del Servidor de Idiomas</a>, que es una especificación para que los IDEs y los lenguajes de programación se comuniquen entre sí. Diferentes clientes pueden usar <code>rust-analyzer</code>, como el <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">complemento Rust Analyzer para Visual Studio Code</a>.</p>
<p>Visite la <a href="https://rust-analyzer.github.io/">página de inicio</a> del proyecto <code>rust-analyzer</code> para obtener instrucciones de instalación, luego instale el soporte del servidor de idiomas en su IDE particular. Su IDE obtendrá capacidades como autocompletado, salto a definición y errores en línea de código.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="apéndice-d---herramientas-Útiles-de-desarrollo-1"><a class="header" href="#apéndice-d---herramientas-Útiles-de-desarrollo-1">Apéndice D - Herramientas Útiles de Desarrollo</a></h2>
<p>En este apéndice, hablamos de algunas herramientas de desarrollo útiles que el proyecto Rust proporciona. Veremos el formato automático, formas rápidas de aplicar correcciones de  advertencia, un linter e integración con IDEs. </p>
<h3 id="formateo-automático-con-rustfmt-1"><a class="header" href="#formateo-automático-con-rustfmt-1">Formateo Automático con <em>rustfmt</em></a></h3>
<p>La herramienta <code>rustfmt</code> reformatea su código de acuerdo con el estilo de código de la comunidad. Muchos proyectos colaborativos usan <code>rustfmt</code> para evitar discusiones sobre qué estilo usar al escribir Rust: todos formatean su código usando la herramienta.</p>
<p>Para instalar <code>rustfmt</code> ingrese lo siguiente:</p>
<pre><code class="language-text">$ rustup component add rustfmt
</code></pre>
<p>Este comando le proporciona <code>rustfmt</code> y <code>cargo-fmt</code>, similar a como Rust te da tanto <code>rustc</code> como <code>cargo</code>. Para dar formato a cualquier proyecto Cargo, ingrese lo siguiente:</p>
<pre><code class="language-text">$ cargo fmt
</code></pre>
<p>Ejecutar este comando reformatea todo el código de Rust en el <em>crate</em> actual. Esto solo debería cambiar el estilo del código, no la semántica del código. Para obtener más información sobre <code>rustfmt</code>, consulte <a href="https://github.com/rust-lang/rustfmt">su documentación</a>.</p>
<h3 id="corrija-tu-código-con-rustfix-1"><a class="header" href="#corrija-tu-código-con-rustfix-1">Corrija tu código con rustfix</a></h3>
<p>La herramienta <em>rustfix</em> se incluye con las instalaciones de Rust y puede corregir automáticamente las advertencias del compilador que tienen una forma clara de corregir el problema que probablemente sea lo que desea. Es probable que haya visto advertencias del compilador antes. Por ejemplo, considere este código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Aquí llamamos a la función <code>do_something</code> 100 veces, pero nunca usamos la variable <code>i</code> en el cuerpo del bucle <code>for</code>. Rust nos advierte sobre eso:</p>
<pre><code class="language-text">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>La advertencia sugiere que usemos <code>_i</code> en su lugar: el guión bajo indica que tenemos la intención de que esta variable no se use. Podemos aplicar automáticamente esa sugerencia usando la herramienta <code>rustfix</code> ejecutando el comando <code>cargo fix</code>:</p>
<pre><code class="language-text">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Cuando volvamos a mirar <em>src/main.rs</em>, veremos que <code>cargo fix</code> ha cambiado el código:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>La variable de bucle <code>for</code> ahora se llama <code>_i</code> y ya no aparece la advertencia.</p>
<p>También puede usar el comando <code>cargo fix</code> para hacer la transición de su código entre diferentes ediciones de Rust. Las ediciones están cubiertas en el Apéndice E.</p>
<h3 id="macros-declarativas-con-macro_rules-para-la-metaprogramación-general-1"><a class="header" href="#macros-declarativas-con-macro_rules-para-la-metaprogramación-general-1">Macros declarativas con <code>macro_rules!</code> para la metaprogramación general</a></h3>
<p>La forma más utilizada de macros en Rust son <em>macros declarativas</em>. A veces
también se les conoce como <em>macros por ejemplo</em>, <em><code>macro_rules!</code> macros</em>, o
simplemente simples <em>macros</em>. En esencia, las macros declarativas le permiten
escribir algo similar a una expresión de <code>match</code> de Rust. Como se discutió en
el Capítulo 6, las expresiones <code>match</code> son estructuras de control que toman
una expresión, comparan el valor resultante de la expresión con patrones y
luego ejecutan el código asociado con el patrón coincidente. Las macros
también comparan un valor con patrones que tienen código asociado a ellos; en
esta situación, el valor es el código fuente literal de Rust que se pasa a la
macro, los patrones se comparan con la estructura de ese código fuente, y el
código asociado con cada patrón es el código que reemplaza el código pasado a
la macro. Todo esto sucede durante la compilación.</p>
<p>Para definir una macro, utiliza la construcción <code>macro_rules!</code>. ¡Exploremos
cómo usar <code>macro_rules!</code>. Mirando cómo se define la macro <code>vec!</code>. El Capítulo
8 cubrió cómo podemos usar la macro <code>vec!</code>. Para crear un nuevo vector con
valores particulares. Por ejemplo, la siguiente macro crea un nuevo vector
con tres enteros dentro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>También podríamos usar la macro <code>vec!</code> para hacer un vector de dos enteros o
un vector de cinco <em>string slices</em>. No podríamos usar una función para hacer
lo mismo porque no sabríamos la cantidad o el tipo de valores por adelantado.</p>
<p>Veamos una definición ligeramente simplificada de la macro <code>vec!</code> en el
Listado D-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado D-1: Una versión simplificada de la definición
de macro <code>vec!</code></span></p>
<blockquote>
<p>Nota: La definición real de la macro <code>vec!</code> en la biblioteca estándar
incluye un código para preasignar la cantidad correcta de memoria por
adelantado. Ese código es una optimización que no incluimos aquí para
simplificar el ejemplo.</p>
</blockquote>
<p>La anotación <code>#[macro_export]</code> indica que esta macro debe estar disponible
siempre que se importe el <em>crate</em> en la que estamos definiendo la macro. Sin
esta anotación, incluso si alguien que dependa de este <em>crate</em> usa la
anotación <code>#[macro_use]</code>, la macro no se incluiría en el alcance.</p>
<p>Luego comenzamos la definición de macro con <code>macro_rules!</code> y el nombre de la
macro que estamos definiendo <em>sin</em> el signo de exclamación. El nombre, en
este caso <code>vec</code>, es seguido por llaves que denotan el cuerpo de la definición
de macro.</p>
<p>La estructura en el cuerpo <code>vec!</code> es similar a la estructura de una expresión
<code>match</code>. Aquí tenemos un brazo con el patrón <code>( $( $x:expr ),* )</code>, seguido de
<code>=&gt;</code> y el bloque de código asociado con este patrón. Si el patrón coincide,
se emitirá el bloque de código asociado. Dado que este es el único patrón en
esta macro, solo hay una forma válida de concordar; cualquier otro será un
error. Las macros más complejas tendrán más de un brazo.</p>
<p>La sintaxis de patrón válida en las definiciones de macro es diferente de la
sintaxis de patrón cubierta en el Capítulo 18 porque los patrones de macro se
hacen coincidir con la estructura de código de Rust en lugar de los valores.
Veamos qué significan las piezas del patrón del Listado D-1; para ver la
sintaxis completa del patrón de macro, vea <a href="../../reference/macros.html">la referencia</a>.</p>
<p>Primero, un conjunto de paréntesis abarca todo el patrón. Luego viene un
signo de dólar (<code>$</code>) seguido de un conjunto de paréntesis, que captura
valores que coinciden con el patrón entre paréntesis para usar en el código
de reemplazo. Dentro de <code>$()</code> es <code>$x:expr</code>, que coincide con cualquier
expresión de Rust y le da a la expresión el nombre <code>$ x</code>.</p>
<p>La coma que sigue a <code>$()</code> indica que un carácter literal de separador de coma
podría aparecer opcionalmente después del código que coincide con el código
capturado en <code>$()</code>. El <code>*</code> que sigue a la coma especifica que el patrón
coincide con cero o más de lo que precede al <code>*</code>.</p>
<p>Cuando llamamos a esta macro con <code>vec![1, 2, 3];</code>, el patrón <code>$ x</code> coincide
tres veces con las tres expresiones <code>1</code>, <code>2</code> y <code>3</code>.</p>
<p>Ahora veamos el patrón en el cuerpo del código asociado a este brazo: el
código <code>temp_vec.push()</code> dentro de la parte <code>$()*</code> se genera para cada parte
que coincide con <code>$()</code> en el patrón , cero o más veces, según cuántas veces
coincida el patrón. El <code>$ x</code> se reemplaza con cada expresión coincidente.
Cuando llamamos a esta macro con <code>vec! [1, 2, 3];</code>, el código generado que
reemplaza esta llamada de macro será el siguiente:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>Hemos definido una macro que puede tomar cualquier cantidad de argumentos de
cualquier tipo y puede generar código para crear un vector que contenga los
elementos especificados.</p>
<p>Dado que la mayoría de los programadores de Rust <em>utilizarán</em> macros más que
<em>write</em> macros, no discutiremos <code>macro_rules!</code>. Para obtener más información
sobre cómo escribir macros, consulte la documentación en línea u otros
recursos, como <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a>.</p>
<h3 id="macros-de-procedimiento-para-personalizar-derive-1"><a class="header" href="#macros-de-procedimiento-para-personalizar-derive-1">Macros de procedimiento para personalizar <code>derive</code></a></h3>
<p>La segunda forma de macros se llama <em>procedural macros</em> (<em>macros de
procedimiento</em>) porque se asemejan más a funciones (que son un tipo de
procedimiento). Las macros de procedimiento aceptan algún código de Rust como
entrada, operan en ese código y producen algún código de Rust como salida en
lugar de coincidir con patrones y reemplazar el código con otro código como
lo hacen las macros declarativas. En el momento de escribir estas líneas,
solo puede definir macros de procedimiento para permitir que sus <em>traits</em> se
implementen en un tipo especificando el nombre de <em>trait</em> en una anotación
<code>derivar</code>.</p>
<p>Crearemos un <em>crate</em> llamada <code>hello_macro</code> que define un <em>trait</em> llamado
<code>HelloMacro</code> con una función asociada llamada <code>hello_macro</code>. En lugar de
hacer que nuestros usuarios del <em>crate</em> implementen el <em>trait</em> <code>HelloMacro</code>
para cada uno de sus tipos, proporcionaremos una macro de procedimientos para
que los usuarios puedan anotar su tipo con <code>#[derive(HelloMacro)]</code> para
obtener una implementación predeterminada de <code>hello_macro</code> función. La
implementación predeterminada imprimirá <code>Hello, Macro! My name is TypeName!</code>
donde <code>TypeName</code> es el nombre del tipo en el que se ha definido este <em>trait</em>.
En otras palabras, escribiremos un <em>crate</em> que permita a otro programador
escribir código como el Listado D-2 usando nuestro <em>crate</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_macro;
#[macro_use]
extern crate hello_macro_derive;

use hello_macro::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Listado D-2: El código que un usuario de nuestro <em>crate</em>
podrá escribir cuando utilice nuestra macro de procedimientos</span></p>
<p>Este código imprimirá <code>Hello, Macro! My name is Pancakes!</code> cuando hayamos
terminado. El primer paso es crear un nueva <em>library crate</em>, como esta:</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<p>A continuación, definiremos el <em>trait</em> <code>HelloMacro</code> y su función asociada:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<p>Tenemos un <em>trait</em> y su función. En este punto, nuestro usuario del <em>trait</em>
podría implementar el <em>trait</em> para lograr la funcionalidad deseada, así:</p>
<pre><code class="language-rust ignore">extern crate hello_macro;

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>Sin embargo, tendrían que escribir el bloque de implementación para cada tipo
que quisieran usar con <code>hello_macro</code>; queremos evitar que tengan que hacer
este trabajo.</p>
<p>Además, todavía no podemos proporcionar una implementación predeterminada
para la función <code>hello_macro</code> que imprimirá el nombre del tipo en el que se
implementa el <em>trait</em>: Rust no tiene capacidades de reflexión, por lo que no
puede buscar el nombre del tipo en tiempo de ejecución necesitamos una macro
para generar código en tiempo de compilación.</p>
<p>El siguiente paso es definir la macro de procedimiento. En el momento de
escribir estas líneas, las macros de procedimiento deben estar en su propio
<em>crate</em>. Eventualmente, esta restricción podría ser levantada. La convención
para estructurar <em>crates</em> y macrofolios es la siguiente: para un <em>crate</em>
llamada <code>foo</code>, un <em>crate</em> macro de procedimientos derivada personalizada se
llama <code>foo_derive</code>. Comencemos un nuevo <em>crate</em> llamada <code>hello_macro_derive</code>
dentro de nuestro proyecto <code>hello_macro</code>:</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Nuestros dos <em>crates</em> están estrechamente relacionadas, por lo que creamos la
macro de procedimiento dentro del directorio de nuestro <em>crate</em>
<code>hello_macro</code>. Si cambiamos la definición de <em>trait</em> en <code>hello_macro</code>,
también tendremos que cambiar la implementación de la macro de procedimiento
en <code>hello_macro_derive</code>. Los dos <em>crates</em> tendrán que publicarse por separado
y los programadores que utilicen estos <em>crates</em> tendrán que agregar ambas
como dependencias y ponerlas a ambas en el alcance. Podríamos, en cambio, hacer que el <em>crates</em> <code>hello_macro</code> use <code>hello_macro_derive</code> como una
dependencia y reexportar el código macro de procedimiento. Pero la forma en
que hemos estructurado el proyecto hace posible que los programadores usen <code>hello_macro</code> incluso si no quieren la funcionalidad <code>derivar</code>.</p>
<p>Necesitamos declarar el <em>crate</em> <code>hello_macro_derive</code> como una macro <em>crate</em>
de procedimientos. También necesitaremos la funcionalidad de los <em>crates</em>
<code>syn</code> y <code>quote</code>, como verá en un momento, por lo que debemos agregarlas como
dependencias. Agregue lo siguiente al archivo <em>Cargo.toml</em> para
<code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<p>Para comenzar a definir la macro de procedimiento, coloque el código en el
Listado D-3 en su archivo <em>src/lib.rs</em> para el <em>crate</em> <code>hello_macro_derive</code>.
Tenga en cuenta que este código no se compilará hasta que agreguemos una
definición para la función <code>impl_hello_macro</code>.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_macro(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<p><span class="caption">Listado D-3: Código que la mayoría de los
<em>macro crates</em> de procedimiento deberán tener para procesar el código de
Rust</span></p>
<p>Observe la forma en que hemos dividido las funciones en D-3; esto será el
mismo para casi todos los <em>macro crate</em> de procedimiento que ve o crea,
porque hace que escribir un macro de procedimiento sea más conveniente. Lo
que elija hacer en el lugar donde se llama a la función <code>impl_hello_macro</code>
será diferente dependiendo del propósito de su macro de procedimiento.</p>
<p>Hemos introducido tres <em>crates</em> nuevos: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, y <a href="https://crates.io/crates/quote"><code>quote</code></a>.
El <em>crate</em> <code>proc_macro</code> viene con Rust, por lo que no fue necesario agregarlo a las dependencias en <em>Cargo.toml</em>. El <em>crate</em> <code>proc_macro</code> nos permite
convertir el código Rust en un <em>string</em> que contiene ese código Rust. El
<code>syn</code> crate analiza el código de Rust de un <em>string</em> en una estructura de
datos en la que podemos realizar operaciones. El <em>crate</em> <code>quote</code> toma las
estructuras de datos <code>syn</code> y las convierte nuevamente en código Rust. Estos
<em>crates</em> hacen que sea mucho más simple analizar cualquier tipo de código
Rust que podamos querer manejar: escribir un analizador completo para el
código Rust no es tarea fácil.</p>
<p>Se llamará a la función <code>hello_macro_derive</code> cuando un usuario de nuestra
biblioteca especifique <code>#[derive(HelloMacro)]</code> en un tipo. La razón es que
hemos anotado la función <code>hello_macro_derive</code> aquí con <code>proc_macro_derive</code> y
hemos especificado el nombre, <code>HelloMacro</code>, que coincide con nuestro nombre
de <em>trait</em>; esa es la convención que siguen la mayoría de las macros de
procedimiento.</p>
<p>Esta función primero convierte la <code>input</code> de un <code>TokenStream</code> en un <code>String</code>
llamando a <code>to_string</code>. Este <code>String</code> es una representación de <em>string</em> del
código Rust para el cual derivamos <code>HelloMacro</code>. En el ejemplo del Listado
D-2, <code>s</code> tendrá el valor <code>String</code> <code>struct Pancakes;</code> porque ese es el código
Rust al que agregamos la anotación <code>#[derive(HelloMacro)]</code>.</p>
<blockquote>
<p>Nota: En el momento de escribir esto, solo puedes convertir un
<code>TokenStream</code> en un <em>string</em>. Una API más rica existirá en el futuro.</p>
</blockquote>
<p>Ahora tenemos que analizar el código de Rust <code>String</code> en una estructura de
datos que luego podemos interpretar y realizar operaciones. Aquí es donde
<code>syn</code> entra en juego. La función <code>parse_derive_input</code> en <code>syn</code> toma <code>String</code>
y devuelve una estructura <code>DeriveInput</code> que representa el código Rust
analizado. El siguiente código muestra las partes relevantes de la estructura
<code>DeriveInput</code> que obtenemos al analizar el <em>string</em> <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<p>Los campos de esta estructura muestran que el código de Rust que hemos
analizado es una estructura de unidad con el <code>ident</code> (identificador, que
significa el nombre) de <code>Pancakes</code>. Hay más campos en esta estructura para
describir todo tipo de código Rust; revise la
<a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>syn</code> documentation for <code>DeriveInput</code></a> para más información.</p>
<p>En este punto, no hemos definido la función <code>impl_hello_macro</code>, que es donde
construiremos el nuevo código Rust que queremos incluir. Pero antes de
hacerlo, tenga en cuenta que la última parte de esta función
<code>hello_macro_derive</code> usa la función <code>parse</code> del <em>crate</em> <code>quote</code> para convertir
la salida de la función <code>impl_hello_macro</code> de nuevo en <code>TokenStream</code>. El
<code>TokenStream</code> devuelto se agrega al código que escriben nuestros usuarios de
<em>crates</em>, por lo que cuando compilan su <em>crate</em>, obtendrán la funcionalidad
adicional que proporcionamos.</p>
<p>Es posible que haya notado que estamos llamando <code>unwrap</code> al pánico si las
llamadas a las funciones <code>parse_derive_input</code> o <code>analizar</code> fracasan aquí.
Pánico en los errores es necesario en el código de macro de procedimiento
porque las funciones <code>proc_macro_derive</code> deben devolver <code>TokenStream</code> en
lugar de <code>Result</code> para ajustarse a la API de macro de procedimiento. Elegimos
simplificar este ejemplo usando <code>unwrap</code>; en el código de producción, debe
proporcionar mensajes de error más específicos sobre lo que salió mal usando
<code>panic!</code> o <code>expect</code>.</p>
<p>Ahora que tenemos el código para convertir el código anotado de Rust de un
<code>TokenStream</code> en una instancia <code>String</code> y <code>DeriveInput</code>, generemos el código
que implementa el <em>trait</em> <code>HelloMacro</code> en el tipo anotado:</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<p>Obtenemos una instancia de estructura <code>Ident</code> que contiene el nombre
(identificador) del tipo anotado usando <code>ast.ident</code>. El código en el Listado
D-2 especifica que el <code>name</code> será <code>Ident(&quot;Pancakes&quot;)</code>.</p>
<p>La macro <code>quote!</code> nos permite escribir el código Rust que queremos devolver y
convertirlo en <code>quote::Tokens</code>. Esta macro también proporciona algunas
mecánicas de plantillas muy interesantes; podemos escribir <code>#name</code>, y
<code>quote!</code> lo reemplazará con el valor en la variable llamada <code>name</code>. Incluso
puede hacer una repetición similar a la forma en que funcionan las macros
normales. Consulte <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> para una
introducción completa.</p>
<p>Queremos que nuestra macro de procedimientos genere una implementación de
nuestro <em>trait</em> <code>HelloMacro</code> para el tipo anotado por el usuario, que podemos
obtener usando <code>#name</code>.La implementación del <em>trait</em> tiene una función,
<code>hello_macro</code>, cuyo cuerpo contiene el funcionalidad que queremos
proporcionar: impresión <code>Hello, Macro! My name is</code> y luego el nombre del tipo
anotado.</p>
<p>La macro <code>stringify!</code> Utilizada aquí está integrada en Rust. Toma una
expresión Rust, como <code>1 + 2</code>, y en tiempo de compilación convierte la
expresión en un literal de <em>string</em>, como <code>&quot;1 + 2&quot;</code>. Esto es diferente de
<code>format!</code> o <code>println!</code>, que evalúa la expresión y luego convierte el
resultado en <code>String</code>. Existe la posibilidad de que la entrada <code>#name</code> sea
una expresión para imprimir literalmente, entonces usamos <code>stringify!</code>.
Usando <code>stringify!</code> también guarda una asignación convirtiendo <code>#name</code> a un
<em>string</em> literal en tiempo de compilación.</p>
<p>En este punto, <code>cargo build</code> debería completarse con éxito en ambos
<code>hello_macro</code> y <code>hello_macro_derive</code>. Vamos a conectar estos <em>crates</em> al
código en el Listado D-2 para ver la macro de procedimiento en acción! cree
un nuevo proyecto binario en su directorio <em>proyectos</em> utilizando
<code>cargo new --bin pancakes</code>. Necesitamos agregar <code>hello_macro</code> y
<code>hello_macro_derive</code> como dependencias en los <code>pancakes</code>
<em>crates</em> <em>Cargo.toml</em>. Si publica sus versiones de <code>hello_macro</code> y
<code>hello_macro_derive</code> a <em>https://crates.io/</em>, serían dependencias regulares;
si no, puede especificarlos como dependencias <code>path</code> de la siguiente manera:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Coloque el código del Listado D-2 en <em>src/main.rs</em>, y ejecute <code>cargo run</code>:
debería imprimir <code>Hello, Macro! My name is Pancakes!</code> la implementación del
<em>trait</em> <code>HelloMacro</code> de la macro procedural se incluyó sin que el <em>crate</em>
<code>pancakes</code> necesitara implementarla; el <code>#[derive HelloMacro)]</code> agregó la
implementación del <em>traits</em>.</p>
<h3 id="el-futuro-de-las-macros-1"><a class="header" href="#el-futuro-de-las-macros-1">El futuro de las macros</a></h3>
<p>En el futuro, Rust ampliará las macros declarativas y de procedimiento. Rust
utilizará un mejor sistema de macros declarativas con la palabra clave
<code>macro</code> y agregará más tipos de macros de procedimientos para tareas más
potentes que simplemente <code>derive</code>. Estos sistemas aún están en desarrollo en
el momento de esta publicación; Consulte la documentación en línea de Rust
para obtener la información más reciente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-e-translations-of-the-book"><a class="header" href="#appendix-e-translations-of-the-book">Appendix E: Translations of the Book</a></h2>
<p>For resources in languages other than English. Most are still in progress; see
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/hngnaig/rust-lang-book/tree/vi-VN">Tiếng việt</a></li>
<li><a href="http://www.broadview.com.cn/article/144">简体中文</a>, <a href="https://github.com/KaiserY/trpl-zh-cn">alternate</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/iDeBugger/rust-book-ru">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/hazama-yuinyan/book">日本語</a></li>
<li><a href="https://github.com/quadrifoglio/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apéndice-g-cómo-se-fabrica-el-rust-y-nightly-rust"><a class="header" href="#apéndice-g-cómo-se-fabrica-el-rust-y-nightly-rust">Apéndice G: cómo se fabrica el Rust y “Nightly Rust”</a></h1>
<p>Este apéndice es sobre cómo se hace Rust y cómo eso te afecta como
desarrollador de Rust. Mencionamos que el resultado en este libro fue
generado por Rust estable 1.21.0, pero cualquier ejemplo que compile debería
continuar compilando en cualquier versión estable de Rust mayor que eso. Esta
sección es para explicar cómo aseguramos que esto sea verdad.</p>
<h3 id="estabilidad-sin-estancamiento"><a class="header" href="#estabilidad-sin-estancamiento">Estabilidad sin estancamiento</a></h3>
<p>Como lenguaje, a Rust le importa <em>mucho</em> la estabilidad de su código.
Queremos que Rust sea una base sólida sobre la que pueda construir, y si las
cosas cambiaran constantemente, sería imposible. Al mismo tiempo, si no
podemos experimentar con nuevas funciones, es posible que no descubramos
fallas importantes hasta después de su lanzamiento, cuando ya no podamos
cambiar las cosas.</p>
<p>Nuestra solución a este problema es lo que llamamos “estabilidad sin
estancamiento”, y nuestro principio rector es este: nunca debería temer
actualizarse a una nueva versión de Rust estable. Cada actualización debería
ser indolora, pero también debería traerle nuevas funciones, menos errores y
tiempos de compilación más rápidos.</p>
<h3 id="choo-choo-release-channels-and-riding-the-trains"><a class="header" href="#choo-choo-release-channels-and-riding-the-trains">Choo, Choo! Release Channels and Riding the Trains</a></h3>
<p>El desarrollo de Rust opera en un <em>train schedule</em>. Es decir, todo el
desarrollo se realiza en la rama <code>master</code> del repositorio Rust. Las versiones
siguen un modelo de tren de lanzamiento de software, que ha sido utilizado
por Cisco IOS y otros proyectos de software. Hay tres <em>release channels</em> para 
Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>La mayoría de los desarrolladores de Rust utilizan principalmente el canal
estable, pero aquellos que quieran probar nuevas características
experimentales pueden usarlas todas las nightly o beta.</p>
<p>Aquí hay un ejemplo de cómo funciona el proceso de desarrollo y liberación:
supongamos que el equipo de Rust está trabajando en el lanzamiento de Rust
1.5. Ese lanzamiento se realizó en diciembre de 2015, pero nos proporcionará
números de versión realistas. Se agrega una nueva función a Rust: un nuevo
commit aterriza en la rama <code>master</code>. Cada noche, se produce una nueva versión
nocturna de Rust. Todos los días es un día de lanzamiento, y nuestra versión
de lanzamiento crea estos lanzamientos automáticamente. A medida que pasa el
tiempo, nuestros lanzamientos se ven así, una vez por noche:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>¡Cada seis semanas, es hora de preparar una nueva versión! La rama <code>beta</code> del
repositorio Rust se bifurca desde la rama <code>master</code> utilizada por cada noche.
Ahora, hay dos lanzamientos:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>La mayoría de los usuarios de Rust no usan activamente las versiones beta,
sino que las prueban en versión beta en su sistema de CI para ayudar a Rust a
descubrir posibles regresiones. Mientras tanto, todavía hay un lanzamiento
nocturno todas las noches:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Digamos que se encuentra una regresión. ¡Qué bueno que hayamos tenido un poco
de tiempo para probar la versión beta antes de que la regresión escapara a
una versión estable!. La corrección se aplica a <code>master</code>, por lo que cada
noche se repara, y luego la solución se transfiere a la rama <code>beta</code>, y se
produce una nueva versión de beta:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>¡Seis semanas después de que se creó la primera versión beta, es hora de una
versión estable!. La rama <code>estable</code> se produce a partir de la rama <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>¡Hurra! Rust 1.5 está listo! Sin embargo, hemos olvidado una cosa: porque
han pasado las seis semanas, también necesitamos una nueva versión beta de la
<em>próxima</em> versión de Rust, 1.6. Así que después de las ramas <code>stable</code> de
<code>beta</code>, la siguiente versión de <code>beta</code> se separa de <code>nightly</code> nuevamente:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Esto se llama el “modelo de tren” porque cada seis semanas, un lanzamiento
“abandona la estación”, pero aún tiene que realizar un viaje a través del
canal beta antes de que llegue como un lanzamiento estable.</p>
<p>Rust lanza cada seis semanas, como un reloj. Si conoce la fecha de una
publicación de Rust, puede saber la fecha de la siguiente: son seis semanas
después. Un buen aspecto de tener lanzamientos programados cada seis semanas
es que el próximo tren llegará pronto. Si una característica se pierde un
lanzamiento en particular, no hay necesidad de preocuparse: ¡otra está
sucediendo en poco tiempo! Esto ayuda a reducir la presión para introducir
funciones posiblemente sin pulir cerca de la fecha límite de lanzamiento.</p>
<p>Gracias a este proceso, siempre puedes consultar la próxima compilación de
Rust y verificar por ti mismo que es fácil actualizar a: si una versión beta
no funciona como se esperaba, puedes informarla al equipo y arreglarla antes
de que se publique. el próximo lanzamiento estable sucede! La rotura en una
versión beta es relativamente rara, pero <code>rustc</code> sigue siendo una pieza de
software, y existen errores.</p>
<h3 id="características-inestables"><a class="header" href="#características-inestables">Características inestables</a></h3>
<p>Hay una captura más con este modelo de lanzamiento: características
inestables. Rust utiliza una técnica llamada “indicadores de características”
para determinar qué características están habilitadas en una versión
determinada. Si una nueva característica está en desarrollo activo, aterriza
en <code>master</code>, y por lo tanto, en nightly, pero detrás de <em>feature flag</em>. Si
usted, como usuario, desea probar la función de trabajo en progreso, puede
hacerlo, pero debe usar un lanzamiento nocturno de Rust y anotar su código
fuente con la bandera apropiada para habilitarla.</p>
<p>Si está utilizando una versión beta o estable de Rust, no puede usar ninguna
<em>feature flags</em>. Esta es la clave que nos permite obtener un uso práctico con
nuevas características antes de declararlas estables para siempre. Aquellos
que deseen optar por la vanguardia pueden hacerlo, y aquellos que quieran una
experiencia sólida como una roca pueden quedarse con la estabilidad y saber
que su código no se romperá. Estabilidad sin estancamiento.</p>
<p>Este libro solo contiene información sobre características estables, ya que
las características en progreso todavía están cambiando, y seguramente serán
diferentes entre cuándo se escribió este libro y cuándo se habilitan en
versiones estables. Puede encontrar documentación solo para <em>nightly features</em>
en línea.</p>
<h3 id="rustup-y-el-papel-de-rust-nightly"><a class="header" href="#rustup-y-el-papel-de-rust-nightly">Rustup y el papel de Rust Nightly</a></h3>
<p>Rustup facilita el cambio entre diferentes canales de lanzamiento de Rust, a
nivel global o por proyecto. De forma predeterminada, tendrá instalado Rust
estable. Para instalar todas las noches, por ejemplo:</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<p>Puede ver todas las <em>toolchains</em> (versiones de Rust y componentes asociados)
que ha instalado con <code>rustup</code> también. Aquí hay un ejemplo en una de las
computadoras con Windows de sus autores:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Como puede ver, la cadena de herramientas estable es la predeterminada. La
mayoría de los usuarios de Rust usan estable la mayor parte del tiempo. Es
posible que desee utilizar estable la mayor parte del tiempo, pero use todas
las noches en un proyecto específico, porque le importa una característica de
vanguardia. Para hacerlo, puede usar <code>rustup override</code> en el directorio de
ese proyecto para establecer la cadena de herramientas nocturna como la que
debe usar <code>rustup</code> cuando se encuentre en ese directorio:</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override add nightly
</code></pre>
<p>Ahora, cada vez que llamas <code>rustc</code> o <code>cargo</code> dentro de
<em>~/projects/needs-nightly</em>, <code>rustup</code> se asegurará de que está utilizando Rust
nightly, en lugar de su defecto de Rust estable. ¡Esto es útil cuando tienes muchos proyectos de Rust!</p>
<h3 id="el-proceso-y-los-equipos-de-rfc"><a class="header" href="#el-proceso-y-los-equipos-de-rfc">El proceso y los equipos de RFC</a></h3>
<p>Entonces, ¿cómo aprendes acerca de estas nuevas características?. El modelo
de desarrollo de Rust sigue un proceso de <em>Request For Comments (RFC)
process</em>. Si desea una mejora en Rust, puede escribir una propuesta, llamada
RFC.</p>
<p>Cualquiera puede escribir RFC para mejorar Rust, y las propuestas son
revisadas y discutidas por el equipo de Rust, que se compone de muchos
subtemas de temas. Hay una lista completa de los equipos
<a href="https://www.rust-lang.org/en-US/team.html">on Rust’s website</a>, que incluye
equipos para cada área del proyecto: diseño del lenguaje, implementación del
compilador, infraestructura, documentación y más. El equipo apropiado lee la
propuesta y los comentarios, escribe algunos comentarios propios y,
finalmente, hay consenso para aceptar o rechazar la función.</p>
<p>Si la característica es aceptada, se abre un problema en el repositorio de
Rust y alguien puede implementarlo. ¡La persona que lo implementa muy bien
puede no ser la persona que propuso la función en primer lugar!. Cuando la
implementación está lista, aterriza en la rama <code>master</code> detrás de una puerta
de característica, como discutimos en la sección de “Características
inestables”.</p>
<p>Después de un tiempo, una vez que los desarrolladores de Rust que usan
lanzamientos nocturnos hayan podido probar la nueva función, los miembros del
equipo discutirán la función, cómo se resuelve todas las <em>nightly</em> y deciden
si debe convertirse en Rust estable o no. Si la decisión es avanzar, la puerta
característica se elimina y la característica ahora se considera estable.
Monta los trenes en una nueva versión estable de Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lifetimes-avanzado"><a class="header" href="#lifetimes-avanzado"><em>Lifetimes</em> avanzado</a></h2>
<p>En el Capítulo 10 de la sección “Validación de referencias con Lifetimes*”,
aprendió a anotar referencias con parámetros de <em>lifetime</em> para decirle a
Rust cómo se relacionan los <em>lifetimes</em> de diferentes referencias. Viste cómo
cada referencia tiene un <em>lifetime</em>, pero la mayoría de las veces, Rust te
dejará elidir <em>lifetimes</em>. Ahora veremos tres características avanzadas de <em>lifetimes</em> que aún no hemos cubierto:</p>
<ul>
<li>Subtipo de <em>lifetime</em>: asegura que una vida dura más que otra vida</li>
<li>Límites de <em>lifetime</em>: especifica una duración para una referencia a un
tipo genérico</li>
<li>Inferencia de <em>lifetimes</em> de los <em>trait object</em>: permite al compilador
inferir el <em>lifetime</em> de los *trait object y cuando necesitan ser
especificados</li>
</ul>
<h3 id="garantizar-un-lifetime-sobrevivir-a-otra-con-lifetime-subtyping"><a class="header" href="#garantizar-un-lifetime-sobrevivir-a-otra-con-lifetime-subtyping">Garantizar un <em>Lifetime</em> sobrevivir a otra con <em>Lifetime Subtyping</em></a></h3>
<p><em>Lifetime subtyping</em> especifica que un <em>lifetime</em> debería sobrevivir a otra
<em>lifetime</em>. Para explorar el subtipado de <em>lifetime</em>, imagina que queremos
escribir un analizador sintáctico. Usaremos una estructura llamada <code>Context</code>
que contiene una referencia al <em>string</em> que estamos analizando. Escribiremos
un analizador que analizará este <em>string</em> y devolverá el éxito o el fracaso.
El analizador necesitará tomar prestado el <code>Contexto</code> para hacer el análisis
sintáctico. El listado 19-12 implementa este código de analizador, excepto
que el código no tiene las anotaciones de <em>lifetime</em> requeridas, por lo que
no se compilará.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">Listado 19-12: Definición de un analizador sin
anotaciones de <em>lifetime</em></span></p>
<p>La compilación del código da como resultado errores porque Rust espera
parámetros de <em>lifetime</em>
en el <em>string slice</em> en <code>Context</code> y la referencia a un <code>Context</code> en
<code>Parser</code>.</p>
<p>Para simplificar, la función <code>parse</code> devuelve <code>Result&lt;(), &amp;str&gt;</code>. Es decir,
la función no tendrá éxito y, en caso de error, devolverá la parte del
<em>string slice</em> que no se analizó correctamente. Una implementación real
proporcionaría más información de error y devolvería un tipo de datos
estructurados cuando el análisis tenga éxito. No discutiremos esos detalles
porque no son relevantes para la parte de <em>lifetimes</em> de este ejemplo.</p>
<p>Para mantener este código simple, no escribiremos ninguna lógica de análisis.
Sin embargo, es muy es probable que en algún lugar de la lógica de análisis
manejemos la entrada no válida por devolver un error que hace referencia a la
parte de la entrada que no es válida; esta referencia es lo que hace que el
ejemplo del código sea interesante en lo que respecta a los <em>lifetimes</em>.
Supongamos que la lógica de nuestro analizador es que la entrada no es válida
después del primer byte. Tenga en cuenta que este código puede entrar en
pánico si el primer byte no está en un límite de caracteres válido;
nuevamente, estamos simplificando el ejemplo para enfocarnos en los
<em>lifetime</em> involucradas.</p>
<p>Para obtener este código para compilar, debemos completar los parámetros de
<em>lifetime</em> para el <em>string slic</em>e en <code>Context</code> y la referencia al <code>Context</code>
en <code>Parser</code>. La forma más sencilla de hacerlo es usar el mismo nombre de
<em>lifetime</em> en todas partes, como se muestra en el listado 19-13. Recuerde la
sección “Anotaciones de <em>lifetime</em> en definiciones de la Estructura” en el
Capítulo 10 que cada uno de <code>struct Context&lt;'a&gt;</code>, <code>struct Parser&lt;'a&gt;</code>, y
<code>impl&lt;'a&gt;</code>  está declarando un nuevo parámetro de <em>lifetime</em>.
Mientras que sus nombres pasan a ser todos iguales, los tres parámetros de
<em>lifetime</em> declarados en este ejemplo no están relacionados.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-13: anotando todas las referencias en
<code>Context</code> y <code>Parser</code> con parámetros de <em>lifetime</em></span></p>
<p>Este código compila muy bien. Le dice a Rust que un <code>Parser</code> contiene una
referencia a <code>Context</code> con un  <code>'a</code> de <em>lifetime</em> y que <code>Context</code> contiene un
<em>string slice</em> que también dura tanto como la referencia al <code>Context</code> en
<code>Parser</code>. El mensaje de error del compilador de Rust establecía que se
requerían parámetros de <em>lifetime</em> para estas referencias, y ahora hemos
agregado parámetros de <em>lifetime</em>.</p>
<p>A continuación, en el listado 19-14, agregaremos una función que toma una
instancia de <code>Context</code>, usa un <code>Parser</code> para analizar ese contexto y devuelve
lo que <code>parse</code> devuelve. Este código no funciona del todo.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listado 19-14: Un intento de agregar una función
<code>parse_context</code> que toma <code> ontext</code> y usa <code>Parser</code></span></p>
<p>Obtenemos dos errores detallados cuando tratamos de compilar el código con la
adición de la función <code>parse_context</code>:</p>
<pre><code class="language-text">error[E0597]: borrowed value does not live long enough
  --&gt; src/lib.rs:14:5
   |
14 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
15 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^

error[E0597]: `context` does not live long enough
  --&gt; src/lib.rs:14:24
   |
14 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
15 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^
</code></pre>
<p>Estos errores indican que la instancia <code>Parser</code> que se crea y el parámetro
<code>context</code> solo se muestran vivos hasta el final de la función
<code>parse_context</code>. Pero ambos necesitan vivir durante toda la vida de la
función.</p>
<p>En otras palabras, <code>Parser</code> y <code>context</code> necesitan <em>sobrevivir</em> a la función
completa y ser válidos antes de que comience la función, así como después de
que termine, para que todas las referencias en este código sean siempre
válidas. El <code>Parser</code> que estamos creando y el parámetro <code>context</code> salen del
ámbito al final de la función, porque <code>parse_context</code> toma posesión de
<code>context</code>.</p>
<p>Para descubrir por qué ocurren estos errores, veamos nuevamente las
definiciones en el Listado 19-13, específicamente las referencias en la firma
del método <code>parse</code>:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<p>¿Recuerdas las reglas de elisión?. Si anotamos los <em>lifetimes</em> de las
referencias en lugar de elidir, la firma sería la siguiente:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>Es decir, la parte de error del valor de retorno de <code>parse</code> tiene un
<em>lifetime</em> que está vinculado al <em>lifetime</em> de la instancia <code>Parser</code>
(aquella de <code>&amp;self</code> en la firma del método <code>parse</code>). Eso tiene sentido: el
<em>string slice</em> devuelto hace referencia al <em>string slice</em> en la instancia de
<code>Contexto</code> sostenido por el <code>Parser</code>, y la definición de la estructura
<code>Parser</code> especifica que el <em>lifetime</em> de la referencia a <code>Contexto</code> y el
<em>lifetime</em> del <em>string slice</em> que <code>Context</code> tiene que ser el mismo.</p>
<p>El problema es que la función <code>parse_context</code> devuelve el valor devuelto por
<code>parse</code>, por lo que el <em>lifetime</em> del valor de retorno de <code>parse_context</code>
está relacionado con el <em>lifetime</em> del <code>Parser</code> también. Pero la instancia
<code>Parser</code> creada en la función <code>parse_context</code> no sobrevivirá al final de la
función (es temporal), y <code>context</code> saldrá del ámbito al final de la función
(<code>parse_context</code> se apropia de eso).</p>
<p>Rust piensa que estamos intentando devolver una referencia a un valor que
sale del alcance al final de la función, porque anotamos todos los <em>lifetime</em>
con el mismo parámetro de <em>lifetime</em>. Las anotaciones le dijeron a Rust que
la duración del <em>string slice</em> que <code>Context</code> contiene es la misma que la
duración de la referencia al <code>Context</code> que <code>Parser</code> contiene.</p>
<p>La función <code>parse_context</code> no puede ver que dentro de la función <code>parse</code>, el
<em>string slice</em> devuelto sobrevivirá <code>Context</code> y <code>Parser</code> y que la referencia
<code>parse_context</code> devuelta se refiere al <em>string slice</em>, no a <code>Context</code> o
<code>Parser</code>.</p>
<p>Al saber lo que hace la implementación de <code>parse</code>, sabemos que la única razón
por la que el valor de retorno de <code>parse</code> está vinculado a la instancia
<code>Parser</code> es que hace referencia al <code>Context</code> de la instancia <code>Parser</code>, que
hace referencia al <em>string slice</em>. Por lo tanto, es realmente el <em>lifetime</em>
del <em>string slice</em> el que <code>parse_context</code> necesita preocuparse. Necesitamos
una manera de decirle a Rust que el <em>string slice</em> en <code>Context</code> y la
referencia al <code>Context</code> en <code>Parser</code> tienen diferentes <em>lifetime</em> y que el
valor de retorno de <code>parse_context</code> está vinculado a la duración del <em>string
slice</em> en <code>Context</code>.</p>
<p>Primero, trataremos de darle a <code>Parser</code> y <code>Context</code> diferentes parámetros de
<em>lifetime</em>, como se muestra en el Listado 19-15. Utilizaremos <code>'s</code> y <code>'c</code>
como nombres de parámetros de <em>lifetime</em> para aclarar qué duración va con el
<em>string slice</em> en <code>Context</code> y que va con la referencia a <code>Context</code> en
<code>Parser</code>. Tenga en cuenta que esta solución no solucionará completamente el
problema, pero es un comienzo. Veremos por qué esta solución no es suficiente
cuando intentamos compilar.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listado 19-15: Especificación de diferentes parámetros
de <em>lifetime</em> para las referencias al string slice y al <code>Context</code></span></p>
<p>Hemos anotado los <em>lifetimes</em> de las referencias en todos los mismos lugares
donde las anotamos en el listado 19-13. Pero esta vez usamos diferentes
parámetros dependiendo de si la referencia va con el <em>string slice</em> o con
<code>Context</code>. También hemos agregado una anotación a la parte del <em>string slice</em>
del valor de retorno de <code>parse</code> para indicar que va con el <em>lifetimes</em> del
<em>string slice</em> en <code>Context</code>.</p>
<p>Cuando intentamos compilar ahora, obtenemos el siguiente error:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/lib.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>Rust no sabe de ninguna relación entre <code>'c</code> y <code>'s</code>. Para que sea válida, los
datos a los que se hace referencia en <code>Context</code> con <code>'s</code> de <em>lifetime</em> deben
restringirse para garantizar que vivan más tiempo que la referencia con <code>'c</code>
de <em>lifetime</em>. Si <code>'s</code> no es más largo que <code>'c</code>, la referencia a <code>Context</code>
podría no ser válida.</p>
<p>Ahora llegamos al punto de esta sección: la función Rust <em>lifetime subtyping</em>
especifica que un parámetro de <em>lifetime</em> dura al menos tanto como otro. En
los paréntesis angulares donde declaramos los parámetros de <em>lifetime</em>,
podemos declarar un <code>'a</code>  de <em>lifetime</em> como de costumbre y declarar un <code>'b</code>
vitalicio que viva al menos tan largo como <code>'a</code> declarando <code>'b</code> usando la
sintaxis <code>'b:'a</code>.</p>
<p>En nuestra definición de <code>Parser</code>, para decir que <code>'s</code> (el <em>lifetime</em> útil
del <em>string slice</em>) se garantiza que durará al menos tanto como <code>'c</code> (el
<em>lifetime</em> de la referencia al <code>Contexto</code>), cambiamos las declaraciones de
<em>lifetime</em> para que se vean así:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Context&lt;'a&gt;(&amp;'a str);
</span><span class="boring">
</span>struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora la referencia a <code>Context</code> en <code>Parser</code> y la referencia al <em>string
slice</em> en <code>Context</code> tienen diferentes <em>lifetimes</em>; nos hemos asegurado de que
la duración del <em>string slice</em> sea más larga que la referencia al <code>Context</code>.</p>
<p>Ese fue un ejemplo muy largo, pero como mencionamos al comienzo de este
capítulo, las características avanzadas de Rust son muy específicas. A menudo
no necesitará la sintaxis que describimos en este ejemplo, pero en tales
situaciones, sabrá cómo referirse a algo y darle la vida necesaria.</p>
<h3 id="lifetime-bounds-en-las-referencias-a-los-tipos-genéricos"><a class="header" href="#lifetime-bounds-en-las-referencias-a-los-tipos-genéricos"><em>Lifetime Bounds</em> en las referencias a los tipos genéricos</a></h3>
<p>En la sección “Trait Bounds” del Capítulo 10, discutimos el uso de <em>trait
bounds</em> en los tipos genéricos. También podemos agregar parámetros de
<em>lifetime</em> como restricciones en tipos genéricos; estos se llaman <em>lifetime
bounds</em>. Los <em>lifetime bounds</em> ayudan a Rust a verificar que las referencias
en tipos genéricos no sobrevivan datos a los que hacen referencia.</p>
<p>Como ejemplo, considere un tipo que sea un contenedor de referencias.
Recuerde el tipo “<code>RefCell&lt;T&gt;</code> de la sección <code>RefCell&lt;T&gt;</code> y el Patrón de
Mutabilidad Interior” en el Capítulo 15: sus métodos <code>borrow</code> y <code>borrow_mut</code>
devuelven los tipos <code>Ref</code> y <code>RefMut</code>, respectivamente . Estos tipos son
envoltorios sobre referencias que hacen un seguimiento de las reglas de
endeudamiento en tiempo de ejecución. La definición de la estructura <code>Ref</code> se
muestra en el listado 19-16, sin <em>lifetime bounds</em> por el momento.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Ref&lt;'a, T&gt;(&amp;'a T);
</code></pre>
<p><span class="caption">Listado 19-16: Definición de una estructura para
envolver una referencia a un tipo genérico, sin <em>lifetime bounds</em></span></p>
<p>Sin restringir explícitamente el ciclo de <em>lifetime</em> <code>'a</code> en relación con el
parámetro genérico <code>T</code>, Rust tendrá un error porque no sabe por cuánto tiempo
vivirá el tipo genérico <code>T</code>:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>Debido a que <code>T</code> puede ser de cualquier tipo,<code>T</code> podría ser una referencia o
un tipo que contenga una o más referencias, cada una de las cuales podría
tener su propio <em>lifetimes</em>. Rust no puede estar seguro de que <code>T</code> viva tanto
tiempo como <code>'a</code>.</p>
<p>Afortunadamente, el error proporciona consejos útiles sobre cómo especificar
el <em>lifetime bound</em> en este caso:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at
</code></pre>
<p>El listado 19-17 muestra cómo aplicar este consejo especificando el <em>lifetime bound</em> cuando declaramos el tipo genérico <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-17: Agregar <em>lifetime bounds</em> en <code>T</code> para
especificar que las referencias en <code>T</code> vivan al menos tanto como <code>'a</code></span></p>
<p>Este código ahora compila porque la sintaxis <code>T: 'a</code> especifica que <code>T</code> puede
ser de cualquier tipo, pero si contiene alguna referencia, las referencias
deben vivir al menos tan largo como <code>'a</code>.</p>
<p>Podríamos resolver este problema de una manera diferente, como se muestra en
la definición de una estructura <code>StaticRef</code> en el listado 19-18, al agregar
el <em>lifetime bound</em> <code>'static</code> vinculado a <code>T</code>. Esto significa que si <code>T</code>
contiene referencias, deben tener la duración <code>'estática</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listado 19-18: Agregar un <code>'static</code> <em>lifetime bound</em>
enlazado a <code>T</code> para restringir <code>T</code> a los tipos que tienen solo <code>'static</code> o no
referencias</span></p>
<p>Porque <code>'static</code> significa que la referencia debe vivir todo el
programa completo, un tipo que no contiene referencias, cumpla con los
criterios de todas las referencias que viven tanto como todo el programa
(porque no hay referencias). Para el comprobador de préstamos preocupado por
referencias que viven lo suficiente, no existe una distinción real entre un
tipo que no tiene referencias y un tipo que tiene referencias que viven para
siempre: las dos son las mismas para determinar si una referencia tiene una
vida más corta a la que se refiere.</p>
<h3 id="inferencia-de-los-tiempos-de-vida-del-trait-object"><a class="header" href="#inferencia-de-los-tiempos-de-vida-del-trait-object">Inferencia de los tiempos de vida del <em>Trait Object</em></a></h3>
<p>En el capítulo 17 en la sección “Uso de <em>Trait Objects</em> que permiten valores
de diferentes tipos”, discutimos los <em>trait objects</em>, que consisten en un
<em>trait</em> detrás de una referencia, que nos permiten usar el
<em>despacho dinámico</em>. Todavía no hemos discutido qué sucede si el tipo que
implementa el <em>trait objects</em> de <em>trait</em> tiene un <em>lifetime</em>. Considere el
Listado 19-19 donde tenemos un <em>trait</em> <code>Red</code> y una estructura <code>Ball</code>. La
estructura <code>Ball</code> contiene una referencia (y por lo tanto tiene un parámetro
de <em>lifetime</em>) y también implementa el <em>trait</em> <code>Red</code>. Queremos usar una
instancia de <code>Ball</code> como el trait object <code>Box&lt;Red&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Red { }

struct Ball&lt;'a&gt; {
    diameter: &amp;'a i32,
}

impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }

fn main() {
    let num = 5;

    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;Red&gt;;
}
</code></pre></pre>
<p><span class="caption">Listado 19-19: Usar un tipo que tiene un parámetro de
<em>lifetime</em> con un <em>trait object</em></span></p>
<p>Este código compila sin ningún error, aunque no hemos anotado explícitamente
los <em>lifetimes</em> involucradas en <code>obj</code>. Este código funciona porque hay reglas
para trabajar con <em>lifetimes</em> y <em>trait objects</em>:</p>
<ul>
<li>La <em>lifetime</em> por defecto de un <em>trait object</em> es <code>'static</code>.</li>
<li>Con <code>&amp;'a Trait</code> o <code>&amp;'a mut Trait</code>, la duración predeterminada del
<em>trait object</em> es <code>'a</code>.</li>
<li>Con una sola cláusula <code>T: 'a</code>, la duración predeterminada del
<em>trait object</em> es <code>'a</code>.</li>
<li>Con múltiples cláusulas como <code>T: 'a</code>, no hay un <em>lifetime</em> por defecto;
debemos ser explícitos</li>
</ul>
<p>Cuando debemos ser explícitos, podemos agregar un <em>lifetime bound</em> en un
<em>trait object</em> como <code>Box&lt;Red&gt;</code> usando la sintaxis <code>Box&lt;Red + 'static&gt;</code> o
<code>Box&lt;Red + 'a&gt;</code>, dependiendo de si la referencia vive todo el programa o no.
Al igual que con los otros límites, la sintaxis que agrega un <em>lifetime bound</em>
significa que cualquier implementador del <em>trait</em> <code>Red</code> que tiene referencias
dentro del tipo debe tener la misma <em>lifetime</em> especificada en los <em>trait
object bounds</em> que esas referencias.</p>
<p>A continuación, veamos algunas otras características avanzadas que
administran <em>trait</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apéndice-f---características-más-nuevas"><a class="header" href="#apéndice-f---características-más-nuevas">Apéndice F - Características más nuevas</a></h1>
<p>Este apéndice documenta características que se han agregado a Rust estable
desde que se completó la parte principal del libro.</p>
<h2 id="field-init-shorthand"><a class="header" href="#field-init-shorthand">Field init shorthand</a></h2>
<p>Podemos inicializar una estructura de datos (struct, enum, union) con campos
con nombre, escribiendo <code>fieldname</code> como una abreviatura de <code>fieldname: fieldname</code>. Esto permite una sintaxis compacta para la inicialización, con menos duplicación:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let name = String::from(&quot;Peter&quot;);
    let age = 27;

    // Using full syntax:
    let peter = Person { name: name, age: age };

    let name = String::from(&quot;Portia&quot;);
    let age = 27;

    // Using field init shorthand:
    let portia = Person { name, age };

    println!(&quot;{:?}&quot;, portia);
}
</code></pre></pre>
<h2 id="regresando-de-los-bucles"><a class="header" href="#regresando-de-los-bucles">Regresando de los bucles</a></h2>
<p>Uno de los usos de un <code>loop</code> es volver a intentar una operación que sabe que
puede fallar, como comprobar si un subproceso completó su trabajo. Sin
embargo, es posible que deba pasar el resultado de esa operación al resto de
su código. Si lo agrega a la expresión <code>break</code> que usa para detener el bucle,
lo devolverá el bucle roto:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h2 id="grupos-anidados-en-declaraciones-use"><a class="header" href="#grupos-anidados-en-declaraciones-use">Grupos anidados en declaraciones 'use'</a></h2>
<p>Si tiene un árbol de módulos complejo con muchos submódulos diferentes y
necesita importar algunos elementos de cada uno, podría ser útil agrupar
todas las importaciones en la misma declaración para mantener su código
limpio y evitar repetir el nombre de los módulos base.</p>
<p>La declaración <code>use</code> admite la anidación para ayudarlo en esos casos, tanto
con importaciones simples como globales. Por ejemplo, estos fragmentos
importan <code>bar</code>, <code>Foo</code>, todos los elementos en <code>baz</code> y <code>Bar</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_imports, dead_code)]
</span><span class="boring">
</span><span class="boring">mod foo {
</span><span class="boring">    pub mod bar {
</span><span class="boring">        pub type Foo = ();
</span><span class="boring">    }
</span><span class="boring">    pub mod baz {
</span><span class="boring">        pub mod quux {
</span><span class="boring">            pub type Bar = ();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use foo::{
    bar::{self, Foo},
    baz::{*, quux::Bar},
};
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="rangos-inclusivos"><a class="header" href="#rangos-inclusivos">Rangos inclusivos</a></h2>
<p>Anteriormente, cuando se usaba un rango (<code>..</code> o <code>...</code>) como expresión, tenía
que ser <code>..</code>, que es exclusivo del límite superior, mientras que los patrones
tenían que usar <code>...</code> , que incluye el límite superior. Ahora, <code>.. =</code> se
acepta como sintaxis para los rangos inclusivos tanto en el contexto de
expresión como de rango:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0 ..= 10 {
        match i {
            0 ..= 5 =&gt; println!(&quot;{}: low&quot;, i),
            6 ..= 10 =&gt; println!(&quot;{}: high&quot;, i),
            _ =&gt; println!(&quot;{}: out of range&quot;, i),
        }
    }
}
</code></pre></pre>
<p>La sintaxis <code>...</code> todavía se acepta en las coincidencias, pero no se acepta
en las expresiones. <code>.. =</code> debería ser preferido.</p>
<h2 id="enteros-de-128-bits"><a class="header" href="#enteros-de-128-bits">Enteros de 128 bits</a></h2>
<p>Rust 1.26.0 agregó primitivos enteros de 128 bits:</p>
<ul>
<li><code>u128</code>: Un entero sin signo de 128 bits con rango [0, 2^128 - 1]</li>
<li><code>i128</code>: Un entero con signo de 128 bits con rango [-(2^127), 2^127 - 1]</li>
</ul>
<p>Estas primitivas se implementan de manera eficiente a través del soporte
LLVM. Están disponibles incluso en plataformas que no admiten nativamente
enteros de 128 bits y se pueden usar como los otros tipos de enteros.</p>
<p>Estas primitivas pueden ser muy útiles para algoritmos que necesitan usar
enteros muy grandes de manera eficiente, como ciertos algoritmos
criptográficos.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
