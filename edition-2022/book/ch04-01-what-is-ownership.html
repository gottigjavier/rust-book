<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Qué es la Propiedad? - El Lenguaje de Programación Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Estructura de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-packages-crates-modules.html"><strong aria-hidden="true">7.</strong> Gestión de Proyectos en Crecimiento con Packages, Crates y Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo Módulos para Controlar el Scope y la Privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Llevando Rutas al Scope con la Palabra Clave use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separación de Módulos en Diferentes Archivos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones y Coincidencias</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">El Lenguaje de Programación Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="qué-es-la-propiedad-ownership"><a class="header" href="#qué-es-la-propiedad-ownership">¿Qué es la Propiedad (Ownership)?</a></h2>
<p>La <em>propiedad</em> es un conjunto de reglas que rigen cómo un programa Rust administra la memoria. Todos los programas tienen que administrar la forma en que usan la memoria de una
computadora mientras se ejecutan. Algunos lenguajes tienen un <em>recolector de basura</em>, que constantemente busca memoria que ya no se usa mientras el programa se ejecuta. En otros lenguajes, el programador debe explícitamente asignar y liberar la memoria. Rust utiliza un tercer enfoque: la memoria se gestiona a través de un sistema de propiedad con un conjunto de reglas que el compilador verifica en tiempo de compilación. Ninguna de las características de propiedad ralentizará su programa mientras se está ejecutando.</p>
<p>Como la propiedad es un concepto nuevo para muchos programadores, lleva tiempo
acostumbrarse a ella. La buena noticia es que cuanto más experimentado se vuelva con Rust
y las reglas del sistema de propiedad (<em>ownership</em>), más podrá, naturalmente,
desarrollar código que sea seguro y eficiente. ¡Sígalo!</p>
<p>Cuando comprenda la <em>propiedad</em>, tendrá una base sólida para la comprensión
las características que hacen que Rust sea único. En este capítulo, aprenderá sobre <em>propiedad</em> a través de algunos ejemplos que se centran en una estructura de datos muy común: <em>strings</em>.</p>
<blockquote>
<h3 id="la-pila-stack-y-el-montículo-heap"><a class="header" href="#la-pila-stack-y-el-montículo-heap">La Pila (<em>Stack</em>) y el Montículo (<em>Heap</em>).</a></h3>
<p>En muchos lenguajes de programación, no tiene que pensar muy a menudo en <em>Stack</em> y <em>Heap</em>, pero en un lenguaje de programación de sistemas como Rust, que un valor esté en el <em>Stack</em> o el <em>Heap</em> tiene más de un efecto sobre cómo el lenguaje se comporta y por qué tiene que tomar ciertas decisiones. Partes de la <em>propiedad</em> se describirán en relación con <em>Stack</em> y <em>Heap</em> más adelante en este capítulo, por lo que aquí hay una breve explicación a modo de preparación.</p>
<p>Tanto el <em>Stack</em> como el <em>Heap</em> son partes de la memoria que está disponible para usar en su código en tiempo de ejecución, pero están estructurados de diferentes maneras. El <em>stack</em> almacena los valores en el orden en que los obtiene y elimina los valores en el orden opuesto. Esto se conoce como <em>last in, first out</em>, <em>LIFO</em>, (último en entrar, primero en salir). Piense en una pila de platos: cuando agrega más platos, los pone encima de la pila, y cuando necesita un plato, toma uno de la parte superior. Agregar o quitar platos del medio o abajo ¡no funcionaría tan bien! Agregar datos se llama <em>pushing onto the stack</em> (~poniendo sobre la pila), y eliminar datos se llama <em>popping off the stack</em> (~sacando de arriba de la pila). Todos los datos almacenados en el <em>Stack</em> deben tener un tamaño conocido y fijo. Los datos con un tamaño desconocido en el momento de la compilación o cuyo tamaño podría cambiar deben ser almacenados en el <em>Heap</em>.</p>
<p>El <em>Heap</em> está menos organizado: cuando pone datos en el <em>Heap</em>, pide una cierta cantidad de espacio, el asignador de memoria encuentra un lugar vacío en algún lugar del <em>Heap</em> que sea lo suficientemente grande, lo marca como que esta en uso, y devuelve un <em>puntero</em>, que es la dirección de esa ubicación. Este proceso se llama <em>allocating on the Heap</em> (<em>asignando en el montículo</em>), a veces abreviado solo como “allocating” (insertar valores en el <em>Stack</em> no se considera asignación). Debido a que el puntero es de un tamaño conocido y fijo, se puede almacenar el puntero en el <em>Stack</em>, pero cuando quiere los datos reales, debe seguir el puntero. Piense en sentarse en un restaurante. Cuando ingresa, indica la cantidad de personas de su grupo, y el personal encuentra una mesa vacía que se adapta a todos y le lleva allí. Si alguien en su grupo llega tarde, pueden preguntar dónde ha estado sentado para encontrarle.</p>
<p>Colocar datos en el <em>Stack</em> es rápido debido a que el asignador de memoria nunca tiene que buscar un lugar para poner los nuevos datos: el lugar siempre es la parte superior de la pila. Comparativamente, asignar espacio en el <em>Heap</em> requiere más trabajo, porque el asignador primero debe encontrar un espacio lo suficientemente grande para mantener los datos, y luego realizar la contabilidad para prepararse para la siguiente asignación. </p>
<p>Acceder a los datos en el <em>Heap</em> es más lento que acceder a los datos en el <em>Stack</em> porque tiene que seguir un puntero para llegar allí. Los procesadores contemporáneos son más rápidos si saltan menos en la memoria. Continuando con la analogía, considere un mesero en un restaurante que recibe pedidos de muchas mesas. Es más eficiente obtener todos los pedidos en una mesa antes de pasar a la siguiente. Tomar una orden de la mesa A, luego una orden de la mesa B, luego  otra vez una de la mesa A, y entonces una más de la mesa B, sería un proceso mucho más lento. Por la misma razón, un procesador puede hacer su trabajo mejor si funciona con datos que están cerca de otros datos (como en el <em>Stack</em>) en lugar de estar más lejos (como puede ser en el <em>Heap</em>).</p>
<p>Cuando su código llama a una función, los valores pasados a la función (incluidos, potencialmente, punteros a datos en el <em>Heap</em>) y las variables locales de la función se colocan en el <em>Stack</em>. Cuando la función termina, esos valores se eliminan del <em>Stack</em>.</p>
<p>Hacer un seguimiento de qué partes del código están usando qué datos en el <em>Heap</em>, minimizar la cantidad de datos duplicados en el <em>Heap</em>, limpiar datos sin usar en el <em>Heap</em> para que no se quede sin espacio, son todos problemas que aborda la <em>propiedad</em> (<em>ownership</em>). Una vez que comprenda la <em>propiedad</em>, no tendrá que pensar en el <em>Stack</em> y el <em>Heap</em> con frecuencia, pero saber que el objetivo principal de la <em>propiedad</em> es administrar los datos del <em>Heap</em> puede ayudar a explicar por qué funciona de la manera en que lo hace.</p>
</blockquote>
<h3 id="reglas-de-propiedad-ownership"><a class="header" href="#reglas-de-propiedad-ownership">Reglas de Propiedad (<em>Ownership</em>)</a></h3>
<p>Primero, echemos un vistazo a las reglas de propiedad. Tenga en cuenta estas reglas cuando trabaje a través de los ejemplos que los ilustran:</p>
<ul>
<li>Cada valor en Rust tiene un propietario.</li>
<li>Solo puede haber un propietario a la vez.</li>
<li>Cuando el propietario queda fuera del ámbito, el valor se eliminará.</li>
</ul>
<h3 id="Ámbito-de-una-variable-scope"><a class="header" href="#Ámbito-de-una-variable-scope">Ámbito de una Variable (<em>Scope</em>)</a></h3>
<p>Ahora que hemos pasado la sintaxis básica, no incluiremos todo el código <code>fn main () {</code> en ejemplos, así que tendrá que poner los siguientes ejemplos dentro de una función <code>main</code> de forma manual. Como resultado, nuestros ejemplos serán un poco más concisos, dejándonos enfocarnos en los detalles reales en lugar de código repetitivo.</p>
<p>Como primer ejemplo de <em>propiedad</em>, veremos el ámbito o alcance (<em>scope</em>) de algunas variables. Un <em>scope</em> es el rango dentro de un programa para el cual un elemento es válido. Digamos que tenemos una variable que se ve así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>La variable <code>s</code> se refiere a un <em>string</em> literal, donde el valor del <em>string</em> es
codificado en el texto de nuestro programa. La variable es válida desde el punto en el
que se declara hasta el final del <em>scope</em> actual. El listado 4-1 tiene comentarios
anotando donde la variable <code>s</code> es válida.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s no es válida aquí, aún no está declarada
    let s = &quot;hello&quot;;   // s es válida a partir de este punto

    // hacer cosas con s, sigue siendo válida
}                      // este ámbito ha terminado, y s ya no es válida
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-1: Una variable y el ámbito en el que es válida</span></p>
<p>En otras palabras, hay dos puntos importantes en el tiempo aquí:</p>
<ul>
<li>Cuando <code>s</code> entra en el <em>scope</em>, es válida.</li>
<li>Sigue siendo válida hasta que se sale del <em>scope</em>.</li>
</ul>
<p>En este punto, la relación entre los ámbitos y cuándo las variables son válidas es similar a la de otros lenguajes de programación. Ahora construiremos sobre esta comprensión introduciendo el tipo <code>String</code>.</p>
<h3 id="el-tipo-string"><a class="header" href="#el-tipo-string">El Tipo <code>String</code></a></h3>
<p>Para ilustrar las reglas de propiedad (<em>ownership</em>), necesitamos un tipo de datos que sea más complejo que los que cubrimos en la sección <a href="ch03-02-data-types.html#tipos-de-datos">&quot;Tipos de datos&quot;</a> del Capítulo 3. Los tipos cubiertos anteriormente son todos de un tamaño conocido, pueden ser almacenados en la pila (<em>stack</em>) y sacarse de la pila cuando su alcance ha terminado, pueden ser rápida y trivialmente copiados para hacer una nueva instancia independiente si otra parte del código necesita usar el mismo valor en un ámbito diferente. Pero queremos observar los datos que se almacenan en el montículo (<em>heap</em>) y explorar cómo Rust sabe cuándo limpiar esos datos, y el tipo <code>String</code> es un gran ejemplo.</p>
<p>Nos concentraremos en las partes de <code>String</code> que se relacionan con la <em>propiedad</em>. Estos aspectos también se aplican a otros tipos de datos complejos provistos por la biblioteca estándar (<em>std</em>) o creados por usted. Estudiaremos el tipo <code>String</code> con más profundidad en el <a href="ch08-02-strings.html">Capítulo 8</a>.</p>
<p>Ya vimos <em>string</em> literales, donde un valor de <em>string</em> está codificado en nuestro programa. Los literales <em>string</em> son convenientes, pero no son adecuados para toda situación en la cual podríamos querer usar texto. Una razón es que son inmutables. Otra es que no todos los valores de <em>string</em> se pueden conocer cuando escribimos nuestro código: por ejemplo, ¿qué sucede si queremos tomar la entrada del usuario y almacenarla? por estas situaciones, Rust tiene un segundo tipo de <em>string</em>, <code>String</code>. Este tipo maneja datos asignados en el montículo (<em>heap</em>) y como tal, es capaz de almacenar una cantidad de texto que es desconocida para nosotros en tiempo de compilación. Puede crear un <code>String</code> a partir de un literal <em>string</em> usando la <em>función asociada</em> <code>from</code>, así:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>El operador dos puntos (<code>::</code>) nos permite asignar un espacio de nombres a esta función <code>from</code> particular bajo el tipo <code>String</code> en lugar de usar algún tipo de nombre como <code>string_from</code>. Discutiremos más esta sintaxis en la sección <a href="ch05-03-method-syntax.html">&quot;Sintaxis del método&quot;</a> del Capítulo 5 y cuando hablemos sobre el espacio de nombres con módulos en <a href="ch07-03-importing-names-with-use.html">&quot;Rutas para hacer Referencia a un Elemento en el Árbol de Módulos&quot;</a> en el Capítulo 7.</p>
<p>Este tipo de <em>string</em> puede mutar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() agrega un literal a un String

println!(&quot;{}&quot;, s);      // Esto imprimirá `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>Entonces, ¿cuál es la diferencia aquí? ¿Por qué <code>String</code> puede mutarse pero los literales no?
La diferencia es cómo estos dos tipos lidian con la memoria</p>
<h3 id="memoria-y-asignación"><a class="header" href="#memoria-y-asignación">Memoria y Asignación</a></h3>
<p>En el caso de un <em>string</em> literal, conocemos el contenido en tiempo de compilación, por lo que el texto está codificado directamente en el ejecutable final. Esta es la razón por la que los <em>string</em> literales son rápidos y eficientes. Pero estas propiedades solo provienen de la inmutabilidad del literal del <em>string</em>. Desafortunadamente, no podemos poner una burbuja de memoria en el binario por cada fragmento de texto cuyo tamaño se desconoce en el momento de la compilación y cuyo tamaño podría cambiar mientras se ejecuta el programa.</p>
<p>Con el tipo <code>String</code>, para admitir un fragmento de texto mutable y ampliable, necesitamos asignar una cantidad de memoria en el Heap, desconocida en tiempo de compilación, para almacenar el contenidos. Esto significa:</p>
<ul>
<li>La memoria debe solicitarse al asignador de memoria en tiempo de ejecución.</li>
<li>Necesitamos una forma de devolver esta memoria al asignador cuando hayamos terminado con nuestro <code>String</code>.</li>
</ul>
<p>Esa primera parte la hacemos nosotros: cuando llamamos a <code>String::from</code>, su implementación solicita la memoria que necesita. Esto es bastante universal en los lenguajes de programación.</p>
<p>Sin embargo, la segunda parte es diferente. En lenguajes con un <em>recolector de basura (garbage collector - GC)</em>, el GC realiza un seguimiento y limpia la memoria que ya no se usa, y no necesitamos pensar en ello. En la mayoría de los lenguajes sin un GC, es nuestra responsabilidad identificar cuándo ya no se usa la memoria y llamar al código para liberarla explícitamente, tal como lo hicimos para solicitarla. Hacer esto correctamente ha sido históricamente un problema de programación difícil. Si lo olvidamos, desperdiciamos memoria. Si lo hacemos demasiado pronto, tendremos una variable inválida. Si lo hacemos dos veces, también es un error. Necesitamos emparejar exactamente un <code>allocate</code> con exactamente un <code>free</code>.</p>
<p>Rust toma una ruta diferente: la memoria se devuelve automáticamente una vez que la variable que lo posee queda fuera del ámbito. Aquí hay una versión de nuestro ejemplo de ámbito del Listado 4-1 usando un <code>String</code> en lugar de un literal de <em>string</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s es válida a partir de este punto

    // hacer cosas con s
}                                  // este ámbito ha terminado, y s ya no es válida
<span class="boring">}
</span></code></pre></pre>
<p>Aquí hay un punto natural en el que podemos devolver la memoria que nuestro <code>String</code> necesita al asignador cuando <code>s</code> sale del ámbito. Cuando una variable sale del ámbito, Rust llama a una función especial para nosotros. Esta función se llama <code>drop</code>, y es donde el autor de <code>String</code> podría poner el código para devolver la memoria. Rust llama a <code>drop</code> automáticamente al cierre de la llave.</p>
<blockquote>
<p>Nota: En C ++, este patrón de desasignación de recursos al final de la vida útil de un elemento se denomina a veces <em>Resource Acquisition Is Initialization (RAII)</em> (<em>Inicialización de adquisición de recursos (RAII)</em>).
La función <code>drop</code> en Rust le resultará familiar si ha utilizado patrones RAII.</p>
</blockquote>
<p>Este patrón tiene un profundo impacto en la forma en que se escribe el código de Rust. Puede parecer simple en este momento, pero el comportamiento del código puede ser inesperado en situaciones más complicadas cuando queremos que múltiples variables usen los datos que hemos asignado en el <em>Heap</em>. Exploremos algunas de esas situaciones ahora.</p>
<h4 id="formas-en-que-interactúan-las-variables-y-los-datos-mover"><a class="header" href="#formas-en-que-interactúan-las-variables-y-los-datos-mover">Formas en que Interactúan las Variables y los Datos: Mover</a></h4>
<p>Múltiples variables pueden interactuar con los mismos datos de diferentes maneras en Rust.
Veamos un ejemplo usando un número entero en el Listado 4-2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-2: Asignando el valor entero de la variable <code>x</code> a <code>y</code></span></p>
<p>Probablemente podamos adivinar qué está haciendo esto: “vincula el valor <code>5</code> a <code>x</code>; luego hace una copia del valor en <code>x</code> y la agrega a <code>y</code>.” Ahora tenemos dos variables,<code>x</code> e <code>y</code>, y ambas son <code>5</code>. De hecho, esto es lo que está sucediendo, porque los enteros son valores simples con un tamaño conocido y fijo, y estos dos valores <code>5</code> se colocan en el <em>Stack</em>.</p>
<p>Ahora veamos la versión <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Esto se ve muy similar al código anterior, por lo que podemos suponer que la forma en que funciona sería la misma: es decir, la segunda línea haría una copia del valor en <code>s1</code> y lo vincularía a <code>s2</code>. Pero esto no es exactamente lo que sucede.</p>
<p>Eche un vistazo a la Figura 4-1 para ver lo que está sucediendo con <code>String</code> debajo de la superficie. Un <code>String</code> se compone de tres partes, que se muestran a la izquierda: un puntero a la memoria que guarda el contenido del <em>string</em>, una longitud y una capacidad. Este grupo de datos se almacena en el <em>Stack</em>. A la derecha está la memoria en el <em>Heap</em> que guarda los contenidos.</p>
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-1: Representación en memoria de un <code>String</code> conteniendo el valor <code>&quot;hello&quot;</code> vinculado a <code>s1</code></span></p>
<p>La longitud es la cantidad de memoria, en bytes, que está usando actualmente el contenido de <code>String</code>. La capacidad es la cantidad total de memoria, en bytes, que el <code>String</code> recibió del asignador. La diferencia entre la logitud y la capacidad importa, pero no en este contexto,
por lo que, por ahora, está bien ignorar la capacidad.</p>
<p>Cuando asignamos <code>s1</code> a <code>s2</code>, los datos de <code>String</code> se copian, lo que significa que copiamos el puntero, la longitud y la capacidad, que están en el <em>Stack</em>. No copiamos los datos del <em>Heap</em> al que hace referencia el puntero. En otras palabras, la representación de datos en la memoria se parece a la Figura 4-2.</p>
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-2: Representación en memoria de la variable <code>s2</code> que tiene una copia del puntero, longitud y capacidad de <code>s1</code></span></p>
<p>La representación <em>NO</em> se parece a la Figura 4-3, que es como se vería la memoria si Rust copiara también los datos del Heap. Si Rust hiciera esto, la operación <code>s2 = s1</code> podría ser muy costosa en términos de rendimiento en tiempo de ejecución si los datos en el Heap fueran grandes.</p>
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-3: Otra posibilidad para qué <code>s2 = s1</code> podría hacer si Rust copiara los datos del <em>Heap</em> también</span></p>
<p>Anteriormente, dijimos que cuando una variable queda fuera del alcance, Rust llama automáticamente a la función <code>drop</code> y limpia la memoria del Heap para esa variable. Pero la Figura 4-2 muestra ambos punteros de datos apuntando a la misma ubicación. Esto es un problema: cuando <code>s2</code> y <code>s1</code> salen del ámbito, ambos intentarán liberar la misma memoria. Esto se conoce como error de <em>doble liberación</em> (double free) y es uno de los errores de seguridad de la memoria que mencionamos anteriormente. Liberar memoria dos veces puede provocar daños en la memoria, lo que puede generar vulnerabilidades de seguridad.</p>
<p>Para garantizar la seguridad de la memoria, después de la línea <code>let s2 = s1</code>, Rust ya considera <code>s1</code> como no válido. Por lo tanto, Rust no necesita liberar nada cuando <code>s1</code> queda fuera del ámbito. Mire lo que sucede cuando intenta usar <code>s1</code> después que <code>s2</code> es creado; no funcionará: </p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>Recibirá un error como este porque Rust le impide usar la referencia invalidada:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Si ha escuchado los términos <em>shallow copy</em> (<em>copia superficial</em>) y <em>deep copy</em> (<em>copia profunda</em>) mientras trabaja con otros lenguajes, el concepto de copiar el puntero, la longitud y la capacidad sin copiar los datos probablemente suene como una copia superficial. Pero debido a que Rust también invalida la primera variable, en lugar de llamarse copia superficial, se la
conoce como <em>mover</em>. En este ejemplo, diríamos que <code>s1</code> se <em>movió</em> a <code>s2</code>. Entonces, lo que realmente sucede se muestra en la Figura 4-4.</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-4: La representación en memoria después de <code>s1</code> ha sido invalidada</span></p>
<p>¡Eso resuelve nuestro problema! Con solo <code>s2</code> válida, cuando salga del ámbito, ella sola
liberará la memoria y terminaremos.</p>
<p>Además, hay una opción de diseño implícita: Rust nunca creará automáticamente copias “profundas”
de sus datos. Por lo tanto, se puede suponer que cualquier copiado <em>automático</em> es económico en
términos de rendimiento en tiempo de ejecución.</p>
<h4 id="formas-en-que-interactúan-las-variables-y-los-datos-clonar"><a class="header" href="#formas-en-que-interactúan-las-variables-y-los-datos-clonar">Formas en que Interactúan las Variables y los Datos: Clonar</a></h4>
<p>Si queremos hacer una <em>copia profunda</em> de los datos en el <em>Heap</em> de <code>String</code> y no sólo los datos del <em>Stack</em>, podemos usar un método común llamado <code>clone</code>. Estudiaremos la sintaxis del método en el Capítulo 5, pero dado que los métodos son una característica común en muchos lenguajes de programación, probablemente ya los haya visto antes.</p>
<p>Aquí hay un ejemplo del método <code>clone</code> en acción:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Esto funciona correctamente y produce explícitamente el comportamiento que se muestra en la Figura 4-3, donde los datos del Heap se copian.</p>
<p>Cuando ve una llamada a <code>clone</code>, sabe que se está ejecutando algún código arbitrario y que ese código puede ser costoso. Es un indicador visual de que algo diferente está sucediendo.</p>
<h4 id="datos-de-sólo-pila-copiar"><a class="header" href="#datos-de-sólo-pila-copiar">Datos de Sólo-Pila: Copiar</a></h4>
<p>Hay otro aspecto del que aún no hemos hablado. Este código que usa números enteros, parte del cual se mostró en el Listado 4-2, funciona y es válido:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Pero este código parece contradecir lo que acabamos de aprender: no tenemos una llamada a
<code>clone</code>, pero<code> x</code> sigue siendo válida y no se movió a <code>y</code>.</p>
<p>La razón es que los tipos como los enteros, que tienen un tamaño conocido en el momento
de la compilación, se almacenan completamente en el Stack, por lo que las copias de los
valores actuales son rápidos de realizar. Eso significa que no hay ninguna razón por la que
quisiéramos evitar que <code>x</code> sea válida después de que creamos la variable<code> y</code>. En otras
palabras, aquí no hay diferencia entre la copia profunda y la poco profunda, por lo que
llamar a <code>clone</code> no haría nada diferente de la copia superficial normal y podemos omitirlo.</p>
<p>Rust tiene una anotación especial llamada el <em>trait</em> <code>Copy</code> que podemos colocar en tipos como enteros que están almacenados en el Stack (hablaremos más sobre los <em>traits</em> en el <a href="ch10-02-traits.html">Capítulo 10</a>). Si un tipo implementa el <em>trait</em> <code>Copy</code>, las variables que lo usan no son movidas, sino que se copian trivialmente, haciéndolas aún válidas después de la asignación a otra variable.</p>
<p>Rust no nos permitirá anotar un tipo con <code>Copy</code> si el tipo, o cualquiera de sus partes, ha implementado el <em>trait</em> <code>Drop</code>. Si el tipo necesita que ocurra algo especial cuando el valor se sale del ámbito y agregamos la anotación <code>Copy</code> a ese tipo, obtendremos un error en tiempo de compilación. Para obtener información sobre cómo agregar la anotación <code>Copy</code> a su tipo para implementar el <em>trait</em>, consulte <a href="appendix-03-derivable-traits.html">&quot;Traits Derivables”</a> en el Apéndice C.</p>
<p>Entonces, ¿qué tipos implementan el <em>trait</em> <code>Copy</code>? Puede verificar la documentación del tipo dado para asegurarse, pero como regla general, cualquier grupo de valores escalares simples puede ser <code>Copy</code>, y nada que requiera asignación o es alguna forma de recurso es <code>Copy</code>. Estos son algunos de los tipos que implementan <code>Copy</code>:</p>
<ul>
<li>Todos los tipos de enteros, como <code>u32</code>.</li>
<li>El tipo booleano, <code>bool</code>, con los valores <code>true</code> y <code>false</code>.</li>
<li>Todos los tipos de punto flotante, como <code>f64</code>.</li>
<li>El tipo de carácter, <code>char</code>.</li>
<li>Tuplas, pero solo si contienen tipos que también implementan <code>Copy</code>. Por ejemplo,
<code>(i32, i32)</code> implementa <code>Copy</code>, pero <code>(i32, String)</code> no lo hace.</li>
</ul>
<h3 id="propiedad-y-funciones"><a class="header" href="#propiedad-y-funciones">Propiedad y Funciones</a></h3>
<p>La mecánica para pasar un valor a una función es similar a la de asignar un valor a una variable. Pasar una variable a una función la moverá o la copiará, tal como lo hace la asignación. El listado 4-3 tiene un ejemplo con algunos comentarios que muestran dónde las variables entran y salen del ámbito (<em>scope</em>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s entra en el scope

    takes_ownership(s);             // s's el valor se mueve a la función ...
                                    // ... y entonces ya no es válido aquí

    let x = 5;                      // x entra en el scope

    makes_copy(x);                  // x se movería a la función,
                                    // pero i32 es Copy, así que está bien
                                    // todavía puede usarse x después

} // Aquí, x sale del scope, luego s. Pero como el valor de s se movió, nada
  // sucede de manera especial.

fn takes_ownership(some_string: String) { // some_string entra en el scope
    println!(&quot;{}&quot;, some_string);
} // Aquí, some_string sale del scope y se llama `drop`. La memoria de
  // respaldo se libera.

fn makes_copy(some_integer: i32) { // some_integer entra en el scope
    println!(&quot;{}&quot;, some_integer);
} // Aquí, some_integer sale del scope. Nada especial sucede.
</code></pre></pre>
<p><span class="caption">Listing 4-3: Funciones con propiedad y scope comentado</span></p>
<p>Si intentamos usar <code>s</code> después de la llamada a<code> takes_ownership</code>, Rust arrojaría un error en tiempo de compilación. Estas comprobaciones estáticas nos protegen de los errores. Intente agregar código a <code>main</code> que use<code> s</code> y <code>x</code> para ver dónde puede usarlos y dónde las reglas de propiedad le impiden hacerlo.</p>
<h3 id="valores-de-retorno-y-Ámbito"><a class="header" href="#valores-de-retorno-y-Ámbito">Valores de Retorno y Ámbito</a></h3>
<p>Los valores devueltos también puede transferir la propiedad (<em>ownership</em>).
El listado 4-4 es un ejemplo con comentarios similares a las del Listado 4-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership mueve su valor de 
                                        // retorno a s1

    let s2 = String::from(&quot;hello&quot;);     // s2 entra en el scope

    let s3 = takes_and_gives_back(s2);  // s2 se mueve a takes_and_gives_back, 
                                        // que también mueve su valor 
                                        // de retorno a s3
} // Aquí, s3 sale del scope y se descarta. s2 sale del scope pero se movió,
  // por lo que no sucede nada. s1 sale del scope y se descarta.

fn gives_ownership() -&gt; String {             // gives_ownership moverá su 
                                             // valor de retorno a la función 
                                             // que lo llama.

    let some_string = String::from(&quot;hello&quot;); // some_string entra en el scope

    some_string                              // some_string se devuelve y 
                                             // se mueve a la función de llamada.
}

// takes_and_gives_back tomará un *string* y devolverá uno
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string entra en el scope

    a_string  // a_string se devuelve y se mueve a la función de llamada
}
</code></pre></pre>
<p><span class="caption">Listing 4-4: Transferir la propiedad (<em>ownership</em>) de los valores devueltos</span></p>
<p>La propiedad (<em>ownership</em>) de una variable sigue el mismo patrón cada vez: la asignación de un valor a otra variable mueve la propiedad. Cuando una variable que incluye datos en el Heap queda fuera del scope, el valor se limpiará mediante <code>drop</code> a menos que los datos hayan sido movidos para ser propiedad (<em>ownership</em>) de otra variable.</p>
<p>Tomar posesión y luego devolver la propiedad (<em>ownership</em>) con cada función es un poco tedioso.
¿Qué sucede si queremos permitir que una función use un valor pero no tome posesión?
Es bastante molesto que cualquier cosa que pasemos también deba devolverse si queremos
volver a usarla, además de cualquier dato que provenga del cuerpo de la función que también
deseemos devolver.</p>
<p>Rust nos permite devolver múltiples valores usando una tupla, como se muestra en el Listado 4-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() devuelve la longitud de un String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Listing 4-5: Devolución de la propiedad (<em>ownership</em>) de los parámetros</span></p>
<p>Pero esto es demasiada ceremonia y mucho trabajo para un concepto que debería ser común.
Afortunadamente para nosotros, Rust tiene una característica usar un valor sin transferir la propiedad, llamada <em>referencias</em> (<em>references</em>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
