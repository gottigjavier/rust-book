<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Definiendo un Enum - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introducción</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Comenzando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hola, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hola, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programando un Juego de Adivinanzas</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Conceptos Comunes de Programación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables y Mutabilidad</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Tipos de Datos</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Estructuras de Control</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Comprendiendo la Propiedad (posesión)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Qué es la Propiedad?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencias y Préstamos</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Segmentos (Slices)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Usando Structs para Estructurar Datos Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Definiendo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Un Programa Ejemplo Usando Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Sintáxis del Método</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums y Patrones de Concordancia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html" class="active"><strong aria-hidden="true">6.1.</strong> Definiendo un Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Estructura de Control match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Estructura de Control concisa con if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Gestión de Proyectos en Crecimiento con Packages, Crates y Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages y Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Definiendo Módulos para Controlar el Scope y la Privacidad</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Rutas para hacer Referencia a un Elemento en el Árbol de Módulos</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Colecciones Comunes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Almacenamiento de listas de valores con Vectores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Almacenamiento de texto codificado en UTF-8 con Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Mapas Hash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Manejo de Errores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Errores Irrecuperables con panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Errores Recuperables con Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Con panic! o Sin panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Tipos genéricos, Traits y Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Tipos de Datos Genéricos</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Definición del Comportamiento Compartido</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validando Referencias con Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Escribiendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Corriendo Tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Organización de los Tests</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Un Proyecto I/O: Creando un Programa de Línea de Comandos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Aceptando Argumentos de Línea de Comandos</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Leyendo un Archivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactorizando para mejorar la Modularidad y el Manejo de Errores</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Desarrollando la Funcionalidad de la Biblioteca con Desarrollo Basado en Pruebas (Test-driven development (TDD))</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Trabajando con Variables de Entorno</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Escribiendo Mensajes de Error en "Standard Error" en lugar de "Standard Output"</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Características del Lenguaje Funcional: Iterators y Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Funciones Anónimas que pueden Capturar su Entorno</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Procesando una Serie de Elementos con Iteradores</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Mejorando Nuestro Proyecto de I/O</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparación de Rendimiento: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Más Acerca de Cargo y Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Personalizando Compilaciones con Perfiles de Lanzamiento</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publicando un Crate en Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Espacios de Trabajo de Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Instalando Binarios desde Crates.io con cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Ampliando Cargo con Comandos Personalizados</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Punteros Inteligentes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt; apunta a datos en el Heap y tiene un tamaño conocido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Tratamiento de Punteros Inteligentes como Referencias Regulares con el trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> El Drop Trait Ejecuta el Código durante la Limpieza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Puntero Inteligente con Conteo de Referencias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; y el Patrón de Mutabilidad Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creación de Ciclos de Referencia y la Seguridad en la Fuga de Memoria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrencia sin Miedo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Hilos (Threads)</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Paso de Mensajes</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Estado Compartido</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Concurrencia Extensible: Sync and Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Características de Programación Orientada a Objetos de Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Características de los Lenguajes Orientados a Objetos</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Uso de Objetos Trait que permiten Valores de Diferentes Tipos</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementación de un Patrón de Diseño Orientado a Objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patrones y Coincidencias</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Todos los patrones de lugares pueden ser utilizados</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutabilidad: si un Patrón podría No Coincidir</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Toda la Sintaxis de Patrones</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Características Avanzadas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Rust en Modo Inseguro</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Traits Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Tipos Avanzados</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Funciones Avanzadas y Closures</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Proyecto Final: Construcción de un Servidor web Multiprocesos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Un Servidor Web de un solo Proceso</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Transformando nuestro Servidor de un solo Proceso a un Servidor Multiprocesos</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Apagado y Limpieza Elegantes</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Apéndice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Palabras Claves</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operadores y Símbolos</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Traits Derivables</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Herramientas Útiles de Desarrollo</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ediciones</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Traducciones</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Cómo se hace Rust y “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-advanced-lifetimes.html"><strong aria-hidden="true">21.8.</strong> H - Lifetimes Avanzados</a></li><li class="chapter-item expanded "><a href="appendix-09-newest-features.html"><strong aria-hidden="true">21.9.</strong> I - Características más Recientes (previous version)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="definiendo-un-enum"><a class="header" href="#definiendo-un-enum">Definiendo un <em>Enum</em></a></h2>
<p>Donde los structs le brindan una forma de agrupar campos y datos relacionados, como un <code>Rectangle</code> con su <code>width</code> y <code>height</code>, los enums le brindan una forma de decir que un valor es uno de un posible conjunto de valores. Por ejemplo, podemos querer decir que <code>Rectangle</code> es una de un conjunto de formas posibles que también incluye <code>Circle</code> y <code>Triangle</code>. Para hacer esto, Rust nos permite codificar estas posibilidades como un enum.</p>
<p>Veamos una situación que querríamos expresar en código y veamos por qué los enums son útiles y más apropiados que los structs en este caso. Digamos que necesitamos trabajar con direcciones IP. Actualmente, se utilizan dos estándares principales para las direcciones IP: la versión cuatro y la versión seis. Debido a que estas son las únicas posibilidades para una dirección IP con las que se encontrará nuestro programa, podemos <em>enumerar</em> todas las variantes posibles, que es donde la enumeración (<em>enum</em>) recibe su nombre.</p>
<p>Cualquier dirección IP puede ser una dirección versión cuatro o seis, pero no ambas al mismo tiempo. Esa propiedad de las direcciones IP hace que la estructura de datos enum sea adecuada, porque un valor de enum solo puede ser una de sus variantes. Tanto las direcciones de la versión cuatro como las de la versión seis siguen siendo fundamentalmente direcciones IP, por lo que deben tratarse como del mismo tipo cuando el código maneja situaciones que se aplican a cualquier tipo de dirección IP.</p>
<p>Podemos expresar este concepto en código definiendo un enum <code>IpAddrKind</code> y listando los tipos posibles que una dirección IP puede ser, <code>V4</code> y <code>V6</code>. Estas son las <em>variantes</em> del enum:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> ahora es un tipo de datos personalizado que podemos usar en cualquier parte de nuestro código.</p>
<h3 id="valores-enum"><a class="header" href="#valores-enum">Valores <em>Enum</em></a></h3>
<p>Podemos crear instancias de cada una de las dos variantes de <code>IpAddrKind</code> de esta manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Tenga en cuenta que las variantes del enum son <em>espacios de nombre</em> bajo su identificador, y usamos dos puntos dobles para separar los dos. Esto es útil porque ahora ambos valores <code>IpAddrKind::V4</code> y <code>IpAddrKind::V6</code> son del mismo tipo: <code>IpAddrKind</code>. Entonces podemos, por ejemplo, definir una función que tome cualquier <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Y podemos llamar a esta función con cualquiera de las variantes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>El uso de enums tiene aún más ventajas. Pensando más en nuestro tipo de dirección IP, en este momento no tenemos una forma de almacenar <em>los datos</em> reales de la dirección IP; sólo sabemos de qué clase es. Dado que acaba de aprender acerca de structs en el Capítulo 5, es posible que tenga la tentación de abordar este problema con structs como se muestra en el Listado 6-1.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-1: Almacenar los datos y la variante <code>IpAddrKind</code> de una dirección IP usando un <code>struct</code></span></p>
<p>Aquí, hemos definido un struct <code>IpAddr</code> que tiene dos campos: un campo <code>kind</code> que es de tipo <code>IpAddrKind</code> (el enum que definimos previamente) y un campo <code>address</code> de tipo <code>String</code>. Tenemos dos instancias de este struct. El primero, <code>home</code>, tiene el valor <code>IpAddrKind::V4</code> como su valor <code>kind</code> con los datos de dirección asociados de <code>127.0.0.1</code>. La segunda instancia es <code>loopback</code>. Esta tiene la otra variante de <code>IpAddrKind</code> como su valor <code>kind</code>,<code>V6</code>, y tiene la dirección <code>::1</code> asociada a ella. Hemos utilizado un struct para agrupar los valores <code>kind</code> y <code>address</code> juntos,por lo que ahora la variante está asociada con el valor.</p>
<p>Sin embargo, representar el mismo concepto usando solo un enum es más conciso: en lugar de un enum dentro de un struct, podemos colocar los datos directamente en cada variante del <em>enum</em>. Esta nueva definición del enum <code>IpAddr</code> dice que las variantes<code> V4</code> y <code>V6</code> tendrán valores<code> String</code> asociados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Adjuntamos datos a cada variante del enum directamente, por lo que no hay necesidad de un struct adicional. Aquí también es más fácil ver otro detalle de cómo funcionan los enums: el nombre de cada variante del enum que definimos también se convierte en una función que construye una instancia del enum. Es decir, <code>IpAddr::V4()</code> es una llamada de función que toma un argumento <code>String</code> y devuelve una instancia del tipo <code>IpAddr</code>. Obtenemos automáticamente esta función constructora definida como un resultado de definir el enum.</p>
<p>Hay otra ventaja de usar un enum en lugar de un struct: cada variante puede tener diferentes tipos y cantidades de datos asociados. Las direcciones IP de tipo versión cuatro siempre tendrán cuatro componentes numéricos que tendrán valores entre 0 y 255. Si quisiéramos almacenar direcciones <code>V4</code> como cuatro valores <code>u8</code> pero aún expresar direcciones <code>V6</code> como un valor <code>String</code>, no podríamos con un struct. Los enums manejan este caso con facilidad:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Hemos mostrado varias formas diferentes de definir estructuras de datos para almacenar la versión cuatro y la versión seis de las direcciones IP. Sin embargo, resulta que querer almacenar direcciones IP y codificar de qué clase son es tan común que <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">la biblioteca estándar tiene una definición que podemos usar!</a> <!-- ignore --> Veamos cómo la biblioteca estándar define <code>IpAddr</code>: tiene el enum exacto y las variantes que hemos definido y utilizado, pero incorpora los datos de dirección dentro de las variantes en forma de dos structs diferentes,
que se definen de manera diferente para cada variante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Este código ilustra que puede poner cualquier tipo de datos dentro de una variante <em>enum</em>: strings, tipos numéricos o structs, por ejemplo. ¡Incluso puede incluir otro enum! Además, los tipos de la biblioteca estándar a menudo no son mucho más complicados de lo que se le podría ocurrir.</p>
<p>Tenga en cuenta que, aunque la biblioteca estándar contiene una definición para <code>IpAddr</code>,
aún podemos crear y usar nuestra propia definición sin conflicto porque no hemos incorporado
la definición de la biblioteca estándar a nuestro scope. Hablaremos más sobre incluir tipos en el scope en el Capítulo 7.</p>
<p>Veamos otro ejemplo de un enum en el Listado 6-2: este tiene una amplia variedad de tipos incrustados en sus variantes.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 6-2: El <em>enum</em> <code>Message</code> cuyas variantes almacenan diferentes cantidades y tipos de valores</span></p>
<p>Este enum tiene cuatro variantes con diferentes tipos:</p>
<ul>
<li><code>Quit</code> no tiene datos asociados a ella en absoluto.</li>
<li><code>Move</code> tiene campos con nombre como lo hace un struct.</li>
<li><code>Write</code> incluye solo un <code>String</code>.</li>
<li><code>ChangeColor</code> incluye tres valores <code>i32</code>.</li>
</ul>
<p>Definir un enum con variantes como las del Listado 6-2 es similar a
definir diferentes tipos de definiciones de struct, excepto que <em>enum</em> no usa
la palabra clave <code>struct</code> y todas las variantes se agrupan bajo el tipo <code>Mensaje</code>. Los
siguientes structs podrían contener los mismos datos que contienen las variantes
<em>enum</em> anteriores:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Pero si usáramos los diferentes structs, cada uno de los cuales tiene su propio tipo, no podríamos definir tan fácilmente una función para tomar cualquiera de estas clases de mensajes como lo haríamos con el enum <code>Message</code> definido en el Listado 6-2, que es un solo tipo.</p>
<p>Hay una similitud más entre enums y structs: del mismo modo que podemos definir métodos en los structs usando <code>impl</code>, también podemos definir métodos en los enums. Aquí hay un método llamado <code>call</code> que podríamos definir en nuestro enum <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    Write(String),
</span><span class="boring">    ChangeColor(i32, i32, i32),
</span><span class="boring">}
</span><span class="boring">
</span>impl Message {
    fn call(&amp;self) {
        // el cuerpo del método se definiría aquí
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
<span class="boring">}
</span></code></pre></pre>
<p>El cuerpo del método usaría <code>self</code> para obtener el valor que llamamos en el método. En este ejemplo, hemos creado una variable <code>m</code> que tiene el valor <code>Message::Write(String::from(&quot;hello&quot;))</code>, y eso es lo que será <code>self</code> en el cuerpo del método <code>call</code> cuando <code>m.call()</code> se ejecuta.</p>
<p>Veamos otro enum en la biblioteca estándar que es muy común y útil: <code>Option</code>.</p>
<h3 id="el-enum-option-y-sus-ventajas-sobre-valores-nulos"><a class="header" href="#el-enum-option-y-sus-ventajas-sobre-valores-nulos">El <em>Enum</em> <code>Option</code> y sus Ventajas Sobre Valores Nulos</a></h3>
<p>Esta sección explora un caso de estudio de <code>Option</code>, que es otro enum definido por la biblioteca estándar. El tipo <code>Option</code> codifica el escenario muy común en el que un valor podría ser algo o podría no ser nada.</p>
<p>Por ejemplo, si solicita el primero de una lista que contiene elementos, obtendrá un valor. Si solicita el primer elemento de una lista vacía, no obtendría nada. Expresar este concepto en términos del sistema de tipos significa que el compilador puede verificar si ha manejado todos los casos que debería manejar; esta funcionalidad puede prevenir errores que son extremadamente comunes en otros lenguajes de programación.</p>
<p>El diseño del lenguaje de programación a menudo se piensa en términos de las características que incluye, pero las características que excluye también son importantes. Rust no tiene la característica null que tienen muchos otros lenguajes. <em>Null</em> es un valor que significa que no hay ningún valor allí. En lenguajes con null, las variables siempre pueden estar en uno de dos estados: null o not-null.</p>
<p>En su presentación de 2009 “Null References: The Billion Dollar Mistake”, Tony Hoare, el inventor de null, dice lo siguiente:</p>
<blockquote>
<p>Yo lo llamo mi error de mil millones de dólares. En ese momento, estaba diseñando el primer sistema completo de tipos para referencias en un lenguaje orientado a objetos. Mi objetivo era garantizar que todos los usos de las referencias fueran absolutamente seguros, con la verificación realizada automáticamente por el compilador. Pero no pude resistir la tentación de poner una referencia nula, simplemente porque era muy fácil de implementar. Esto ha llevado a innumerables errores, vulnerabilidades y bloqueos del sistema, que probablemente han causado mil millones de dólares en dolor y daños en los últimos cuarenta años.</p>
</blockquote>
<p>El problema con los valores nulos es que si intenta usar un valor nulo como un valor no nulo, obtendrá algún tipo de error. Debido a que esta propiedad nula o no nula es generalizada, es extremadamente fácil cometer este tipo de error.</p>
<p>Sin embargo, el concepto que <em>null</em> intenta expresar sigue siendo útil: un valor nulo es un valor que actualmente no es válido o está ausente por algún motivo.</p>
<p>El problema no es realmente con el concepto sino con la implementación particular.
Como tal, Rust no tiene <em>null</em>, pero tiene un enum que puede codificar el
concepto de un valor presente o ausente. Este enum es <code>Opción&lt;T&gt;</code>, y está
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">definido por la biblioteca estándar</a> <!-- ignore --> de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p>El enum <code>Option&lt;T&gt;</code> es tan útil que incluso está incluido en el <em>prelude</em>; no es necesario que lo incluya explícitamente en el scope. Sus variantes también se incluyen en el <em>prelude</em>: puede usar <code>Some</code> y <code>None</code> directamente sin el prefijo <code>Option::</code>. El enum <code>Option&lt;T&gt;</code> sigue siendo solo un enum regular, y <code>Some(T)</code> y <code>None</code> siguen siendo variantes del tipo <code>Option&lt;T&gt;</code>.</p>
<p>La sintaxis <code>&lt;T&gt;</code> es una característica de Rust de la que aún no hemos hablado. Es un parámetro
de tipo genérico, y trataremos los genéricos más detalladamente en el Capítulo 10. Por ahora,
todo lo que necesita saber es que <code>&lt;T&gt;</code> significa que la variante <code>Some</code> del enum <code>Option</code> puede contener una pieza de datos de cualquier tipo, y que cada tipo concreto que se usa en lugar de <code>T</code> hace que el tipo general <code>Option&lt;T&gt;</code> sea un tipo diferente. Estos son algunos ejemplos del uso de valores de <code>Option</code> para contener tipos numéricos y tipos string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>El tipo de <code>some_number</code> es <code>Option&lt;i32&gt;</code>. El tipo de <code>some_char</code> es <code>Option&lt;char&gt;</code>, que es un tipo diferente. Rust puede inferir estos tipos porque hemos especificado un valor dentro de la variante <code>Some</code>. Para <code>absent_number</code>, Rust requiere que anotemos el tipo general de <code>Option</code>: el compilador no puede inferir el tipo que tendrá la variante <code>Some</code> correspondiente mirando solo un valor <code>None</code>. Aquí, le decimos a Rust que queremos que <code>absent_number</code> sea del tipo <code>Option&lt;i32&gt;</code>.</p>
<p>Cuando tenemos un valor <code>Some</code>, sabemos que un valor está presente y el valor se mantiene dentro de <code>Some</code>. Cuando tenemos un valor <code>None</code>, en cierto sentido, significa lo mismo que null: no tenemos un valor válido. Entonces, ¿por qué es mejor tener <code>Option&lt;T&gt;</code> que tener null?</p>
<p>En resumen, debido a que <code>Option&lt;T&gt;</code> y <code>T</code> (donde <code>T</code> puede ser de cualquier tipo) son tipos diferentes, el compilador no nos permitirá usar un valor de <code>Option&lt;T&gt;</code> como si definitivamente fuera un valor válido. Por ejemplo, este código no se compilará porque está intentando sumar un <code>i8</code> a un <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>Si ejecutamos este código, recibimos un mensaje de error como este:</p>
<pre><code class="language-text">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;&amp;'a f32 as Add&lt;f32&gt;&gt;
            &lt;&amp;'a f64 as Add&lt;f64&gt;&gt;
            &lt;&amp;'a i128 as Add&lt;i128&gt;&gt;
            &lt;&amp;'a i16 as Add&lt;i16&gt;&gt;
            &lt;&amp;'a i32 as Add&lt;i32&gt;&gt;
            &lt;&amp;'a i64 as Add&lt;i64&gt;&gt;
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;'a isize as Add&lt;isize&gt;&gt;
          and 48 others

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>¡Intenso! En efecto, este mensaje de error significa que Rust no entiende cómo
sumar un <code>i8</code> y un <code>Opción&lt;i8&gt;</code>, porque son tipos diferentes. Cuando tenemos
un valor de un tipo como <code>i8</code> en Rust, el compilador se asegurará de que siempre tengamos
un valor válido. Podemos proceder con confianza sin tener que verificar el valor
nulo antes de usar ese valor. Solo cuando tenemos un <code>Opción&lt;i8&gt;</code>
(o el tipo de valor con el que estemos trabajando) tenemos que preocuparnos por
la posibilidad de no tener un valor, y el compilador se asegurará de que manejemos ese
caso antes de usar el valor.</p>
<p>En otras palabras, debe convertir un <code>Opción&lt;T&gt;</code> a un <code>T</code> antes de poder realizar operaciones de <code>T</code> con él. Generalmente, esto ayuda a detectar uno de los problemas más comunes con <em>null</em>: asumir que algo no es nulo cuando en realidad lo es.</p>
<p>Eliminar el riesgo de asumir incorrectamente un valor no nulo lo ayuda a tener más confianza en su código. Para tener un valor que posiblemente sea nulo, debe optar explícitamente haciendo que el tipo de ese valor sea <code>Option&lt;T&gt;</code>. Luego, cuando usa ese valor, debe manejar explícitamente el caso cuando el valor es nulo. Siempre que un valor tenga un tipo que no sea <code>Option&lt;T&gt;</code>, puede suponer con seguridad que el valor no es nulo. Esta fue una decisión de diseño deliberada de Rust para limitar la omnipresencia de <em>null</em> y aumentar la seguridad del código Rust.</p>
<p>Entonces, ¿cómo se obtiene el valor <code>T</code> de una variante <code>Some</code> cuando tiene un valor de tipo <code>Opción&lt;T&gt;</code> para que pueda usar ese valor? El enum <code>Option&lt;T&gt;</code> tiene una gran cantidad de métodos que son útiles en una variedad de situaciones; puede verlos en <a href="https://doc.rust-lang.org/std/option/enum.Option.html">su documentación</a> <!-- ignore -->. Familiarizarse con los métodos en <code>Option&lt;T&gt;</code> será extremadamente útil en su
viaje con Rust.</p>
<p>En general, para usar un valor <code>Option&lt;T&gt;</code>, desea tener un código que maneje cada variante. Desea un código que se ejecutará solo cuando tenga un valor <code>Some(T)</code>, y este código podrá usar el <code>T</code> interno. Desea que se ejecute algún otro código si tiene un valor <code>None</code> y ese código no tiene un valor <code>T</code> disponible. La expresión <code>match</code> es una <em>estructura de control</em> que hace justamente esto cuando se usa con <em>enums</em>: ejecutará un código diferente dependiendo de la variante del enum que tenga, y ese código puede usar los datos dentro del valor coincidente.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
